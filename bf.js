(self["webpackChunkclient"] = self["webpackChunkclient"] || [])["push"]([
    [0x35c],
    {
        0x156cd: function (r, E, R) {
            r["exports"] = R(0x8b52);
        },
        0xc8d9: function (E, R, T) {
            "use strict";
            T["d"](R, {
                omb: function () {
                    return C;
                },
                neY: function () {
                    return d;
                },
                xYR: function () {
                    return Y;
                },
                zsw: function () {
                    return B;
                },
                z0T: function () {
                    return F;
                },
                mdU: function () {
                    return b;
                },
                opf: function () {
                    return Z;
                },
            });
            var C = {
                    prefix: "fab",
                    iconName: "discord",
                    icon: [
                        0x280,
                        0x200,
                        [],
                        "f392",
                        "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z",
                    ],
                },
                d = {
                    prefix: "fab",
                    iconName: "facebook",
                    icon: [
                        0x200,
                        0x200,
                        [],
                        "f09a",
                        "M504\x20256C504\x20119\x20393\x208\x20256\x208S8\x20119\x208\x20256c0\x20123.78\x2090.69\x20226.38\x20209.25\x20245V327.69h-63V256h63v-54.64c0-62.15\x2037-96.48\x2093.67-96.48\x2027.14\x200\x2055.52\x204.84\x2055.52\x204.84v61h-31.28c-30.8\x200-40.41\x2019.12-40.41\x2038.73V256h68.78l-11\x2071.69h-57.78V501C413.31\x20482.38\x20504\x20379.78\x20504\x20256z",
                    ],
                },
                Y = {
                    prefix: "fab",
                    iconName: "google",
                    icon: [
                        0x1e8,
                        0x200,
                        [],
                        "f1a0",
                        "M488\x20261.8C488\x20403.3\x20391.1\x20504\x20248\x20504\x20110.8\x20504\x200\x20393.2\x200\x20256S110.8\x208\x20248\x208c66.8\x200\x20123\x2024.5\x20166.3\x2064.9l-67.5\x2064.9C258.5\x2052.6\x2094.3\x20116.6\x2094.3\x20256c0\x2086.5\x2069.1\x20156.6\x20153.7\x20156.6\x2098.2\x200\x20135-70.4\x20140.8-106.9H248v-85.3h236.1c2.3\x2012.7\x203.9\x2024.9\x203.9\x2041.4z",
                    ],
                },
                B = {
                    prefix: "fab",
                    iconName: "reddit-square",
                    icon: [
                        0x1c0,
                        0x200,
                        [],
                        "f1a2",
                        "M283.2\x20345.5c2.7\x202.7\x202.7\x206.8\x200\x209.2-24.5\x2024.5-93.8\x2024.6-118.4\x200-2.7-2.4-2.7-6.5\x200-9.2\x202.4-2.4\x206.5-2.4\x208.9\x200\x2018.7\x2019.2\x2081\x2019.6\x20100.5\x200\x202.4-2.3\x206.6-2.3\x209\x200zm-91.3-53.8c0-14.9-11.9-26.8-26.5-26.8-14.9\x200-26.8\x2011.9-26.8\x2026.8\x200\x2014.6\x2011.9\x2026.5\x2026.8\x2026.5\x2014.6\x200\x2026.5-11.9\x2026.5-26.5zm90.7-26.8c-14.6\x200-26.5\x2011.9-26.5\x2026.8\x200\x2014.6\x2011.9\x2026.5\x2026.5\x2026.5\x2014.9\x200\x2026.8-11.9\x2026.8-26.5\x200-14.9-11.9-26.8-26.8-26.8zM448\x2080v352c0\x2026.5-21.5\x2048-48\x2048H48c-26.5\x200-48-21.5-48-48V80c0-26.5\x2021.5-48\x2048-48h352c26.5\x200\x2048\x2021.5\x2048\x2048zm-99.7\x20140.6c-10.1\x200-19\x204.2-25.6\x2010.7-24.1-16.7-56.5-27.4-92.5-28.6l18.7-84.2\x2059.5\x2013.4c0\x2014.6\x2011.9\x2026.5\x2026.5\x2026.5\x2014.9\x200\x2026.8-12.2\x2026.8-26.8\x200-14.6-11.9-26.8-26.8-26.8-10.4\x200-19.3\x206.2-23.8\x2014.9l-65.7-14.6c-3.3-.9-6.5\x201.5-7.4\x204.8l-20.5\x2092.8c-35.7\x201.5-67.8\x2012.2-91.9\x2028.9-6.5-6.8-15.8-11-25.9-11-37.5\x200-49.8\x2050.4-15.5\x2067.5-1.2\x205.4-1.8\x2011-1.8\x2016.7\x200\x2056.5\x2063.7\x20102.3\x20141.9\x20102.3\x2078.5\x200\x20142.2-45.8\x20142.2-102.3\x200-5.7-.6-11.6-2.1-17\x2033.6-17.2\x2021.2-67.2-16.1-67.2z",
                    ],
                },
                F = {
                    prefix: "fab",
                    iconName: "twitch",
                    icon: [
                        0x200,
                        0x200,
                        [],
                        "f1e8",
                        "M391.17,103.47H352.54v109.7h38.63ZM285,103H246.37V212.75H285ZM120.83,0,24.31,91.42V420.58H140.14V512l96.53-91.42h77.25L487.69,256V0ZM449.07,237.75l-77.22,73.12H294.61l-67.6,64v-64H140.14V36.58H449.07Z",
                    ],
                },
                b = {
                    prefix: "fab",
                    iconName: "twitter",
                    icon: [
                        0x200,
                        0x200,
                        [],
                        "f099",
                        "M459.37\x20151.716c.325\x204.548.325\x209.097.325\x2013.645\x200\x20138.72-105.583\x20298.558-298.558\x20298.558-59.452\x200-114.68-17.219-161.137-47.106\x208.447.974\x2016.568\x201.299\x2025.34\x201.299\x2049.055\x200\x2094.213-16.568\x20130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772\x206.498.974\x2012.995\x201.624\x2019.818\x201.624\x209.421\x200\x2018.843-1.3\x2027.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969\x207.797\x2030.214\x2012.67\x2047.431\x2013.319-28.264-18.843-46.781-51.005-46.781-87.391\x200-19.492\x205.197-37.36\x2014.294-52.954\x2051.655\x2063.675\x20129.3\x20105.258\x20216.365\x20109.807-1.624-7.797-2.599-15.918-2.599-24.04\x200-57.828\x2046.782-104.934\x20104.934-104.934\x2030.213\x200\x2057.502\x2012.67\x2076.67\x2033.137\x2023.715-4.548\x2046.456-13.32\x2066.599-25.34-7.798\x2024.366-24.366\x2044.833-46.132\x2057.827\x2021.117-2.273\x2041.584-8.122\x2060.426-16.243-14.292\x2020.791-32.161\x2039.308-52.628\x2054.253z",
                    ],
                },
                Z = {
                    prefix: "fab",
                    iconName: "youtube",
                    icon: [
                        0x240,
                        0x200,
                        [],
                        "f167",
                        "M549.655\x20124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781\x2064\x20288\x2064\x20288\x2064S117.22\x2064\x2074.629\x2075.486c-23.497\x206.322-42.003\x2024.947-48.284\x2048.597-11.412\x2042.867-11.412\x20132.305-11.412\x20132.305s0\x2089.438\x2011.412\x20132.305c6.281\x2023.65\x2024.787\x2041.5\x2048.284\x2047.821C117.22\x20448\x20288\x20448\x20288\x20448s170.78\x200\x20213.371-11.486c23.497-6.321\x2042.003-24.171\x2048.284-47.821\x2011.412-42.867\x2011.412-132.305\x2011.412-132.305s0-89.438-11.412-132.305zm-317.51\x20213.508V175.185l142.739\x2081.205-142.739\x2081.201z",
                    ],
                };
        },
        0x2f31: function (E, R, T) {
            "use strict";
            T["d"](R, {
                aQp: function () {
                    return C;
                },
                AX7: function () {
                    return d;
                },
            });
            var C = {
                    prefix: "fad",
                    iconName: "play-circle",
                    icon: [
                        0x200,
                        0x200,
                        [],
                        "f144",
                        [
                            "M256\x208C119\x208\x208\x20119\x208\x20256s111\x20248\x20248\x20248\x20248-111\x20248-248S393\x208\x20256\x208zm115.7\x20272l-176\x20101c-15.8\x208.8-35.7-2.5-35.7-21V152c0-18.4\x2019.8-29.8\x2035.7-21l176\x20107c16.4\x209.2\x2016.4\x2032.9\x200\x2042z",
                            "M371.7\x20280l-176\x20101c-15.8\x208.8-35.7-2.5-35.7-21V152c0-18.4\x2019.8-29.8\x2035.7-21l176\x20107c16.4\x209.2\x2016.4\x2032.9\x200\x2042z",
                        ],
                    ],
                },
                d = {
                    prefix: "fad",
                    iconName: "spinner-third",
                    icon: [
                        0x200,
                        0x200,
                        [],
                        "f3f4",
                        [
                            "M478.71\x20364.58zm-22\x206.11l-27.83-15.9a15.92\x2015.92\x200\x200\x201-6.94-19.2A184\x20184\x200\x201\x201\x20256\x2072c5.89\x200\x2011.71.29\x2017.46.83-.74-.07-1.48-.15-2.23-.21-8.49-.69-15.23-7.31-15.23-15.83v-32a16\x2016\x200\x200\x201\x2015.34-16C266.24\x208.46\x20261.18\x208\x20256\x208\x20119\x208\x208\x20119\x208\x20256s111\x20248\x20248\x20248c98\x200\x20182.42-56.95\x20222.71-139.42-4.13\x207.86-14.23\x2010.55-22\x206.11z",
                            "M271.23\x2072.62c-8.49-.69-15.23-7.31-15.23-15.83V24.73c0-9.11\x207.67-16.78\x2016.77-16.17C401.92\x2017.18\x20504\x20124.67\x20504\x20256a246\x20246\x200\x200\x201-25\x20108.24c-4\x208.17-14.37\x2011-22.26\x206.45l-27.84-15.9c-7.41-4.23-9.83-13.35-6.2-21.07A182.53\x20182.53\x200\x200\x200\x20440\x20256c0-96.49-74.27-175.63-168.77-183.38z",
                        ],
                    ],
                };
        },
        0x44d9: function (r0, r1, r2) {
            "use strict";
            function r3(Eq) {
                return (
                    (r3 =
                        "function" == typeof Symbol && "symbol" == typeof Symbol["iterator"]
                            ? function (Ew) {
                                  return typeof Ew;
                              }
                            : function (Ew) {
                                  return Ew && "function" == typeof Symbol && Ew["constructor"] === Symbol && Ew !== Symbol["prototype"] ? "symbol" : typeof Ew;
                              }),
                    r3(Eq)
                );
            }
            function r4(Eq, Ew) {
                for (var EO = 0x0; EO < Ew["length"]; EO++) {
                    var Ej = Ew[EO];
                    (Ej["enumerable"] = Ej["enumerable"] || !0x1), (Ej["configurable"] = !0x0), "value" in Ej && (Ej["writable"] = !0x0), Object["defineProperty"](Eq, Ej["key"], Ej);
                }
            }
            function r5(Eq, Ew, EO) {
                return Ew in Eq ? Object["defineProperty"](Eq, Ew, { value: EO, enumerable: !0x0, configurable: !0x0, writable: !0x0 }) : (Eq[Ew] = EO), Eq;
            }
            function r6(Eq) {
                for (var Ew = 0x1; Ew < arguments["length"]; Ew++) {
                    var EO = null != arguments[Ew] ? arguments[Ew] : {},
                        Ej = Object["keys"](EO);
                    "function" == typeof Object["getOwnPropertySymbols"] &&
                        (Ej = Ej["concat"](
                            Object["getOwnPropertySymbols"](EO)["filter"](function (Ei) {
                                return Object["getOwnPropertyDescriptor"](EO, Ei)["enumerable"];
                            })
                        )),
                        Ej["forEach"](function (Ei) {
                            r5(Eq, Ei, EO[Ei]);
                        });
                }
                return Eq;
            }
            function r7(Eq, Ew) {
                return (
                    (function (EO) {
                        if (Array["isArray"](EO)) return EO;
                    })(Eq) ||
                    (function (EO, Ej) {
                        var Ei = [],
                            Eh = !0x0,
                            Ea = !0x1,
                            Ec = void 0x0;
                        try {
                            for (var ES, Eg = EO[Symbol["iterator"]](); !(Eh = (ES = Eg["next"]())["done"]) && (Ei["push"](ES["value"]), !Ej || Ei["length"] !== Ej); Eh = !0x0);
                        } catch (EW) {
                            (Ea = !0x0), (Ec = EW);
                        } finally {
                            try {
                                Eh || null == Eg["return"] || Eg["return"]();
                            } finally {
                                if (Ea) throw Ec;
                            }
                        }
                        return Ei;
                    })(Eq, Ew) ||
                    (function () {
                        throw new TypeError("Invalid\x20attempt\x20to\x20destructure\x20non-iterable\x20instance");
                    })()
                );
            }
            r2["d"](r1, {
                G: function () {
                    return El;
                },
            });
            var r8 = function () {},
                r9 = {},
                rr = {},
                rE = { mark: r8, measure: r8 };
            try {
                "undefined" != typeof window && (r9 = window), "undefined" != typeof document && (rr = document), "undefined" != typeof MutationObserver && MutationObserver, "undefined" != typeof performance && (rE = performance);
            } catch (Eq) {}
            var rR = (r9["navigator"] || {})["userAgent"],
                rT = void 0x0 === rR ? "" : rR,
                rC = r9,
                rd = rr,
                rY = rE,
                rn = (rC["document"], !!rd["documentElement"] && !!rd["head"] && "function" == typeof rd["addEventListener"] && "function" == typeof rd["createElement"]),
                rB = (~rT["indexOf"]("MSIE") || rT["indexOf"]("Trident/"), "svg-inline--fa"),
                rF = "data-fa-i2svg",
                rb =
                    ((function () {
                        try {
                        } catch (Ew) {
                            return !0x1;
                        }
                    })(),
                    [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa]),
                rZ = rb["concat"]([0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14]),
                rm = { GROUP: "group", SWAP_OPACITY: "swap-opacity", PRIMARY: "primary", SECONDARY: "secondary" },
                rv =
                    ([
                        "xs",
                        "sm",
                        "lg",
                        "fw",
                        "ul",
                        "li",
                        "border",
                        "pull-left",
                        "pull-right",
                        "spin",
                        "pulse",
                        "rotate-90",
                        "rotate-180",
                        "rotate-270",
                        "flip-horizontal",
                        "flip-vertical",
                        "flip-both",
                        "stack",
                        "stack-1x",
                        "stack-2x",
                        "inverse",
                        "layers",
                        "layers-text",
                        "layers-counter",
                        rm["GROUP"],
                        rm["SWAP_OPACITY"],
                        rm["PRIMARY"],
                        rm["SECONDARY"],
                    ]
                        ["concat"](
                            rb["map"](function (Ew) {
                                return ""["concat"](Ew, "x");
                            })
                        )
                        ["concat"](
                            rZ["map"](function (Ew) {
                                return "w-"["concat"](Ew);
                            })
                        ),
                    rC["FontAwesomeConfig"] || {});
            rd &&
                "function" == typeof rd["querySelector"] &&
                [
                    ["data-family-prefix", "familyPrefix"],
                    ["data-replacement-class", "replacementClass"],
                    ["data-auto-replace-svg", "autoReplaceSvg"],
                    ["data-auto-add-css", "autoAddCss"],
                    ["data-auto-a11y", "autoA11y"],
                    ["data-search-pseudo-elements", "searchPseudoElements"],
                    ["data-observe-mutations", "observeMutations"],
                    ["data-mutate-approach", "mutateApproach"],
                    ["data-keep-original-source", "keepOriginalSource"],
                    ["data-measure-performance", "measurePerformance"],
                    ["data-show-missing-icons", "showMissingIcons"],
                ]["forEach"](function (Ew) {
                    var EO = r7(Ew, 0x2),
                        Ej = EO[0x0],
                        Ei = EO[0x1],
                        Eh = (function (Ea) {
                            return "" === Ea || ("false" !== Ea && ("true" === Ea || Ea));
                        })(
                            (function (Ea) {
                                var Ec = rd["querySelector"]("script[" + Ea + "]");
                                if (Ec) return Ec["getAttribute"](Ea);
                            })(Ej)
                        );
                    null != Eh && (rv[Ei] = Eh);
                });
            var ru = r6(
                {},
                {
                    familyPrefix: "fa",
                    replacementClass: rB,
                    autoReplaceSvg: !0x0,
                    autoAddCss: !0x0,
                    autoA11y: !0x0,
                    searchPseudoElements: !0x1,
                    observeMutations: !0x0,
                    mutateApproach: "async",
                    keepOriginalSource: !0x0,
                    measurePerformance: !0x1,
                    showMissingIcons: !0x0,
                },
                rv
            );
            ru["autoReplaceSvg"] || (ru["observeMutations"] = !0x1);
            var ry = r6({}, ru);
            rC["FontAwesomeConfig"] = ry;
            var rD = rC || {};
            rD["___FONT_AWESOME___"] || (rD["___FONT_AWESOME___"] = {}),
                rD["___FONT_AWESOME___"]["styles"] || (rD["___FONT_AWESOME___"]["styles"] = {}),
                rD["___FONT_AWESOME___"]["hooks"] || (rD["___FONT_AWESOME___"]["hooks"] = {}),
                rD["___FONT_AWESOME___"]["shims"] || (rD["___FONT_AWESOME___"]["shims"] = []);
            var rN = rD["___FONT_AWESOME___"],
                rX = [];
            rn &&
                ((rd["documentElement"]["doScroll"] ? /^loaded|^c/ : /^loaded|^i|^c/)["test"](rd["readyState"]) ||
                    rd["addEventListener"]("DOMContentLoaded", function Ew() {
                        rd["removeEventListener"]("DOMContentLoaded", Ew),
                            0x1,
                            rX["map"](function (EO) {
                                return EO();
                            });
                    }));
            var rf,
                rP = "pending",
                rI = "settled",
                rA = "fulfilled",
                rM = "rejected",
                ro = function () {},
                rp = void 0x0 !== r2["g"] && void 0x0 !== r2["g"]["process"] && "function" == typeof r2["g"]["process"]["emit"],
                rk = "undefined" == typeof setImmediate ? setTimeout : setImmediate,
                re = [];
            function rl() {
                for (var EO = 0x0; EO < re["length"]; EO++) re[EO][0x0](re[EO][0x1]);
                (re = []), (rf = !0x1);
            }
            function rU(EO, Ej) {
                re["push"]([EO, Ej]), rf || ((rf = !0x0), rk(rl, 0x0));
            }
            function rq(EO) {
                var Ej = EO["owner"],
                    Ei = Ej["_state"],
                    Eh = Ej["_data"],
                    Ea = EO[Ei],
                    Ec = EO["then"];
                if ("function" == typeof Ea) {
                    Ei = rA;
                    try {
                        Eh = Ea(Eh);
                    } catch (ES) {
                        ri(Ec, ES);
                    }
                }
                rw(Ec, Eh) || (Ei === rA && rO(Ec, Eh), Ei === rM && ri(Ec, Eh));
            }
            function rw(EO, Ej) {
                var Ei;
                try {
                    if (EO === Ej) throw new TypeError("A\x20promises\x20callback\x20cannot\x20return\x20that\x20same\x20promise.");
                    if (Ej && ("function" == typeof Ej || "object" === r3(Ej))) {
                        var Eh = Ej["then"];
                        if ("function" == typeof Eh)
                            return (
                                Eh["call"](
                                    Ej,
                                    function (Ea) {
                                        Ei || ((Ei = !0x0), Ej === Ea ? rj(EO, Ea) : rO(EO, Ea));
                                    },
                                    function (Ea) {
                                        Ei || ((Ei = !0x0), ri(EO, Ea));
                                    }
                                ),
                                !0x0
                            );
                    }
                } catch (Ea) {
                    return Ei || ri(EO, Ea), !0x0;
                }
                return !0x1;
            }
            function rO(EO, Ej) {
                (EO !== Ej && rw(EO, Ej)) || rj(EO, Ej);
            }
            function rj(EO, Ej) {
                EO["_state"] === rP && ((EO["_state"] = rI), (EO["_data"] = Ej), rU(ra, EO));
            }
            function ri(EO, Ej) {
                EO["_state"] === rP && ((EO["_state"] = rI), (EO["_data"] = Ej), rU(rc, EO));
            }
            function rh(EO) {
                EO["_then"] = EO["_then"]["forEach"](rq);
            }
            function ra(EO) {
                (EO["_state"] = rA), rh(EO);
            }
            function rc(EO) {
                (EO["_state"] = rM), rh(EO), !EO["_handled"] && rp && r2["g"]["process"]["emit"]("unhandledRejection", EO["_data"], EO);
            }
            function rS(EO) {
                r2["g"]["process"]["emit"]("rejectionHandled", EO);
            }
            function rg(EO) {
                if ("function" != typeof EO) throw new TypeError("Promise\x20resolver\x20" + EO + "\x20is\x20not\x20a\x20function");
                if (this instanceof rg == !0x1)
                    throw new TypeError("Failed\x20to\x20construct\x20\x27Promise\x27:\x20Please\x20use\x20the\x20\x27new\x27\x20operator,\x20this\x20object\x20constructor\x20cannot\x20be\x20called\x20as\x20a\x20function.");
                (this["_then"] = []),
                    (function (Ej, Ei) {
                        function Eh(Ea) {
                            ri(Ei, Ea);
                        }
                        try {
                            Ej(function (Ea) {
                                rO(Ei, Ea);
                            }, Eh);
                        } catch (Ea) {
                            Eh(Ea);
                        }
                    })(EO, this);
            }
            (rg["prototype"] = {
                constructor: rg,
                _state: rP,
                _then: null,
                _data: void 0x0,
                _handled: !0x1,
                then: function (EO, Ej) {
                    var Ei = { owner: this, then: new this["constructor"](ro), fulfilled: EO, rejected: Ej };
                    return (!Ej && !EO) || this["_handled"] || ((this["_handled"] = !0x0), this["_state"] === rM && rp && rU(rS, this)), this["_state"] === rA || this["_state"] === rM ? rU(rq, Ei) : this["_then"]["push"](Ei), Ei["then"];
                },
                catch: function (EO) {
                    return this["then"](null, EO);
                },
            }),
                (rg["all"] = function (EO) {
                    if (!Array["isArray"](EO)) throw new TypeError("You\x20must\x20pass\x20an\x20array\x20to\x20Promise.all().");
                    return new rg(function (Ej, Ei) {
                        var Eh = [],
                            Ea = 0x0;
                        function Ec(EW) {
                            return (
                                Ea++,
                                function (EH) {
                                    (Eh[EW] = EH), --Ea || Ej(Eh);
                                }
                            );
                        }
                        for (var ES, Eg = 0x0; Eg < EO["length"]; Eg++) (ES = EO[Eg]) && "function" == typeof ES["then"] ? ES["then"](Ec(Eg), Ei) : (Eh[Eg] = ES);
                        Ea || Ej(Eh);
                    });
                }),
                (rg["race"] = function (EO) {
                    if (!Array["isArray"](EO)) throw new TypeError("You\x20must\x20pass\x20an\x20array\x20to\x20Promise.race().");
                    return new rg(function (Ej, Ei) {
                        for (var Eh, Ea = 0x0; Ea < EO["length"]; Ea++) (Eh = EO[Ea]) && "function" == typeof Eh["then"] ? Eh["then"](Ej, Ei) : Ej(Eh);
                    });
                }),
                (rg["resolve"] = function (EO) {
                    return EO && "object" === r3(EO) && EO["constructor"] === rg
                        ? EO
                        : new rg(function (Ej) {
                              Ej(EO);
                          });
                }),
                (rg["reject"] = function (EO) {
                    return new rg(function (Ej, Ei) {
                        Ei(EO);
                    });
                });
            var rW = { size: 0x10, x: 0x0, y: 0x0, rotate: 0x0, flipX: !0x1, flipY: !0x1 };
            function rH(EO) {
                if (EO && rn) {
                    var Ej = rd["createElement"]("style");
                    Ej["setAttribute"]("type", "text/css"), (Ej["innerHTML"] = EO);
                    for (var Ei = rd["head"]["childNodes"], Eh = null, Ea = Ei["length"] - 0x1; Ea > -0x1; Ea--) {
                        var Ec = Ei[Ea],
                            ES = (Ec["tagName"] || "")["toUpperCase"]();
                        ["STYLE", "LINK"]["indexOf"](ES) > -0x1 && (Eh = Ec);
                    }
                    return rd["head"]["insertBefore"](Ej, Eh), EO;
                }
            }
            function rx() {
                for (var EO = 0xc, Ej = ""; EO-- > 0x0; ) Ej += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[(0x3e * Math["random"]()) | 0x0];
                return Ej;
            }
            function rK(EO) {
                return ""["concat"](EO)["replace"](/&/g, "&amp;")["replace"](/"/g, "&quot;")["replace"](/'/g, "&#39;")["replace"](/</g, "&lt;")["replace"](/>/g, "&gt;");
            }
            function rV(EO) {
                return Object["keys"](EO || {})["reduce"](function (Ej, Ei) {
                    return Ej + ""["concat"](Ei, ":\x20")["concat"](EO[Ei], ";");
                }, "");
            }
            function rs(EO) {
                return EO["size"] !== rW["size"] || EO["x"] !== rW["x"] || EO["y"] !== rW["y"] || EO["rotate"] !== rW["rotate"] || EO["flipX"] || EO["flipY"];
            }
            function rJ(EO) {
                var Ej = EO["transform"],
                    Ei = EO["containerWidth"],
                    Eh = EO["iconWidth"],
                    Ea = { transform: "translate("["concat"](Ei / 0x2, "\x20256)") },
                    Ec = "translate("["concat"](0x20 * Ej["x"], ",\x20")["concat"](0x20 * Ej["y"], ")\x20"),
                    ES = "scale("["concat"]((Ej["size"] / 0x10) * (Ej["flipX"] ? -0x1 : 0x1), ",\x20")["concat"]((Ej["size"] / 0x10) * (Ej["flipY"] ? -0x1 : 0x1), ")\x20"),
                    Eg = "rotate("["concat"](Ej["rotate"], "\x200\x200)");
                return { outer: Ea, inner: { transform: ""["concat"](Ec, "\x20")["concat"](ES, "\x20")["concat"](Eg) }, path: { transform: "translate("["concat"]((Eh / 0x2) * -0x1, "\x20-256)") } };
            }
            var rG = { x: 0x0, y: 0x0, width: "100%", height: "100%" };
            function rL(EO) {
                var Ej = !(arguments["length"] > 0x1 && void 0x0 !== arguments[0x1]) || arguments[0x1];
                return EO["attributes"] && (EO["attributes"]["fill"] || Ej) && (EO["attributes"]["fill"] = "black"), EO;
            }
            function rQ(EO) {
                var Ej = EO["icons"],
                    Ei = Ej["main"],
                    Eh = Ej["mask"],
                    Ea = EO["prefix"],
                    Ec = EO["iconName"],
                    ES = EO["transform"],
                    Eg = EO["symbol"],
                    EW = EO["title"],
                    EH = EO["maskId"],
                    Ex = EO["titleId"],
                    EK = EO["extra"],
                    EV = EO["watchable"],
                    Es = void 0x0 !== EV && EV,
                    EJ = Eh["found"] ? Eh : Ei,
                    EG = EJ["width"],
                    EL = EJ["height"],
                    EQ = "fak" === Ea,
                    Ez = EQ ? "" : "fa-w-"["concat"](Math["ceil"]((EG / EL) * 0x10)),
                    R0 = [ry["replacementClass"], Ec ? ""["concat"](ry["familyPrefix"], "-")["concat"](Ec) : "", Ez]
                        ["filter"](function (R7) {
                            return -0x1 === EK["classes"]["indexOf"](R7);
                        })
                        ["filter"](function (R7) {
                            return "" !== R7 || !!R7;
                        })
                        ["concat"](EK["classes"])
                        ["join"]("\x20"),
                    R1 = {
                        children: [],
                        attributes: r6({}, EK["attributes"], {
                            "data-prefix": Ea,
                            "data-icon": Ec,
                            class: R0,
                            role: EK["attributes"]["role"] || "img",
                            xmlns: "http://www.w3.org/2000/svg",
                            viewBox: "0\x200\x20"["concat"](EG, "\x20")["concat"](EL),
                        }),
                    },
                    R2 = EQ && !~EK["classes"]["indexOf"]("fa-fw") ? { width: ""["concat"]((EG / EL) * 0x10 * 0.0625, "em") } : {};
                Es && (R1["attributes"][rF] = ""), EW && R1["children"]["push"]({ tag: "title", attributes: { id: R1["attributes"]["aria-labelledby"] || "title-"["concat"](Ex || rx()) }, children: [EW] });
                var R3 = r6({}, R1, { prefix: Ea, iconName: Ec, main: Ei, mask: Eh, maskId: EH, transform: ES, symbol: Eg, styles: r6({}, R2, EK["styles"]) }),
                    R4 =
                        Eh["found"] && Ei["found"]
                            ? (function (R7) {
                                  var R8,
                                      R9 = R7["children"],
                                      Rr = R7["attributes"],
                                      RE = R7["main"],
                                      RR = R7["mask"],
                                      RT = R7["maskId"],
                                      RC = R7["transform"],
                                      Rd = RE["width"],
                                      RY = RE["icon"],
                                      Rn = RR["width"],
                                      RB = RR["icon"],
                                      RF = rJ({ transform: RC, containerWidth: Rn, iconWidth: Rd }),
                                      Rb = { tag: "rect", attributes: r6({}, rG, { fill: "white" }) },
                                      RZ = RY["children"] ? { children: RY["children"]["map"](rL) } : {},
                                      Rm = { tag: "g", attributes: r6({}, RF["inner"]), children: [rL(r6({ tag: RY["tag"], attributes: r6({}, RY["attributes"], RF["path"]) }, RZ))] },
                                      Rv = { tag: "g", attributes: r6({}, RF["outer"]), children: [Rm] },
                                      Ru = "mask-"["concat"](RT || rx()),
                                      Ry = "clip-"["concat"](RT || rx()),
                                      RD = { tag: "mask", attributes: r6({}, rG, { id: Ru, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [Rb, Rv] },
                                      RN = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: Ry }, children: ((R8 = RB), "g" === R8["tag"] ? R8["children"] : [R8]) }, RD] };
                                  return R9["push"](RN, { tag: "rect", attributes: r6({ fill: "currentColor", "clip-path": "url(#"["concat"](Ry, ")"), mask: "url(#"["concat"](Ru, ")") }, rG) }), { children: R9, attributes: Rr };
                              })(R3)
                            : (function (R7) {
                                  var R8 = R7["children"],
                                      R9 = R7["attributes"],
                                      Rr = R7["main"],
                                      RE = R7["transform"],
                                      RR = rV(R7["styles"]);
                                  if ((RR["length"] > 0x0 && (R9["style"] = RR), rs(RE))) {
                                      var RT = rJ({ transform: RE, containerWidth: Rr["width"], iconWidth: Rr["width"] });
                                      R8["push"]({
                                          tag: "g",
                                          attributes: r6({}, RT["outer"]),
                                          children: [{ tag: "g", attributes: r6({}, RT["inner"]), children: [{ tag: Rr["icon"]["tag"], children: Rr["icon"]["children"], attributes: r6({}, Rr["icon"]["attributes"], RT["path"]) }] }],
                                      });
                                  } else R8["push"](Rr["icon"]);
                                  return { children: R8, attributes: R9 };
                              })(R3),
                    R5 = R4["children"],
                    R6 = R4["attributes"];
                return (
                    (R3["children"] = R5),
                    (R3["attributes"] = R6),
                    Eg
                        ? (function (R7) {
                              var R8 = R7["prefix"],
                                  R9 = R7["iconName"],
                                  Rr = R7["children"],
                                  RE = R7["attributes"],
                                  RR = R7["symbol"];
                              return [
                                  {
                                      tag: "svg",
                                      attributes: { style: "display:\x20none;" },
                                      children: [{ tag: "symbol", attributes: r6({}, RE, { id: !0x0 === RR ? ""["concat"](R8, "-")["concat"](ry["familyPrefix"], "-")["concat"](R9) : RR }), children: Rr }],
                                  },
                              ];
                          })(R3)
                        : (function (R7) {
                              var R8 = R7["children"],
                                  R9 = R7["main"],
                                  Rr = R7["mask"],
                                  RE = R7["attributes"],
                                  RR = R7["styles"],
                                  RT = R7["transform"];
                              if (rs(RT) && R9["found"] && !Rr["found"]) {
                                  var RC = { x: R9["width"] / R9["height"] / 0x2, y: 0.5 };
                                  RE["style"] = rV(r6({}, RR, { "transform-origin": ""["concat"](RC["x"] + RT["x"] / 0x10, "em\x20")["concat"](RC["y"] + RT["y"] / 0x10, "em") }));
                              }
                              return [{ tag: "svg", attributes: RE, children: R8 }];
                          })(R3)
                );
            }
            var rz = function () {},
                E0 =
                    (ry["measurePerformance"] && rY && rY["mark"] && rY["measure"],
                    function (EO, Ej, Ei, Eh) {
                        var Ea,
                            Ec,
                            ES,
                            Eg = Object["keys"](EO),
                            EW = Eg["length"],
                            EH =
                                void 0x0 !== Eh
                                    ? (function (Ex, EK) {
                                          return function (EV, Es, EJ, EG) {
                                              return Ex["call"](EK, EV, Es, EJ, EG);
                                          };
                                      })(Ej, Eh)
                                    : Ej;
                        for (void 0x0 === Ei ? ((Ea = 0x1), (ES = EO[Eg[0x0]])) : ((Ea = 0x0), (ES = Ei)); Ea < EW; Ea++) ES = EH(ES, EO[(Ec = Eg[Ea])], Ec, EO);
                        return ES;
                    });
            function E1(EO, Ej) {
                var Ei = arguments["length"] > 0x2 && void 0x0 !== arguments[0x2] ? arguments[0x2] : {},
                    Eh = Ei["skipHooks"],
                    Ea = void 0x0 !== Eh && Eh,
                    Ec = Object["keys"](Ej)["reduce"](function (ES, Eg) {
                        var EW = Ej[Eg];
                        return !!EW["icon"] ? (ES[EW["iconName"]] = EW["icon"]) : (ES[Eg] = EW), ES;
                    }, {});
                "function" != typeof rN["hooks"]["addPack"] || Ea ? (rN["styles"][EO] = r6({}, rN["styles"][EO] || {}, Ec)) : rN["hooks"]["addPack"](EO, Ec), "fas" === EO && E1("fa", Ej);
            }
            var E2 = rN["styles"],
                E3 = rN["shims"],
                E4 = function () {
                    var EO = function (Ei) {
                        return E0(
                            E2,
                            function (Eh, Ea, Ec) {
                                return (Eh[Ec] = E0(Ea, Ei, {})), Eh;
                            },
                            {}
                        );
                    };
                    EO(function (Ei, Eh, Ea) {
                        return Eh[0x3] && (Ei[Eh[0x3]] = Ea), Ei;
                    }),
                        EO(function (Ei, Eh, Ea) {
                            var Ec = Eh[0x2];
                            return (
                                (Ei[Ea] = Ea),
                                Ec["forEach"](function (ES) {
                                    Ei[ES] = Ea;
                                }),
                                Ei
                            );
                        });
                    var Ej = "far" in E2;
                    E0(
                        E3,
                        function (Ei, Eh) {
                            var Ea = Eh[0x0],
                                Ec = Eh[0x1],
                                ES = Eh[0x2];
                            return "far" !== Ec || Ej || (Ec = "fas"), (Ei[Ea] = { prefix: Ec, iconName: ES }), Ei;
                        },
                        {}
                    );
                };
            E4(), rN["styles"];
            function E5(EO, Ej, Ei) {
                if (EO && EO[Ej] && EO[Ej][Ei]) return { prefix: Ej, iconName: Ei, icon: EO[Ej][Ei] };
            }
            function E6(EO) {
                var Ej = EO["tag"],
                    Ei = EO["attributes"],
                    Eh = void 0x0 === Ei ? {} : Ei,
                    Ea = EO["children"],
                    Ec = void 0x0 === Ea ? [] : Ea;
                return "string" == typeof EO
                    ? rK(EO)
                    : "<"
                          ["concat"](Ej, "\x20")
                          ["concat"](
                              (function (ES) {
                                  return Object["keys"](ES || {})
                                      ["reduce"](function (Eg, EW) {
                                          return Eg + ""["concat"](EW, "=\x22")["concat"](rK(ES[EW]), "\x22\x20");
                                      }, "")
                                      ["trim"]();
                              })(Eh),
                              ">"
                          )
                          ["concat"](Ec["map"](E6)["join"](""), "</")
                          ["concat"](Ej, ">");
            }
            var E7 = function (EO) {
                var Ej = { size: 0x10, x: 0x0, y: 0x0, flipX: !0x1, flipY: !0x1, rotate: 0x0 };
                return EO
                    ? EO["toLowerCase"]()
                          ["split"]("\x20")
                          ["reduce"](function (Ei, Eh) {
                              var Ea = Eh["toLowerCase"]()["split"]("-"),
                                  Ec = Ea[0x0],
                                  ES = Ea["slice"](0x1)["join"]("-");
                              if (Ec && "h" === ES) return (Ei["flipX"] = !0x0), Ei;
                              if (Ec && "v" === ES) return (Ei["flipY"] = !0x0), Ei;
                              if (((ES = parseFloat(ES)), isNaN(ES))) return Ei;
                              switch (Ec) {
                                  case "grow":
                                      Ei["size"] = Ei["size"] + ES;
                                      break;
                                  case "shrink":
                                      Ei["size"] = Ei["size"] - ES;
                                      break;
                                  case "left":
                                      Ei["x"] = Ei["x"] - ES;
                                      break;
                                  case "right":
                                      Ei["x"] = Ei["x"] + ES;
                                      break;
                                  case "up":
                                      Ei["y"] = Ei["y"] - ES;
                                      break;
                                  case "down":
                                      Ei["y"] = Ei["y"] + ES;
                                      break;
                                  case "rotate":
                                      Ei["rotate"] = Ei["rotate"] + ES;
                              }
                              return Ei;
                          }, Ej)
                    : Ej;
            };
            function E8(EO) {
                (this["name"] = "MissingIcon"), (this["message"] = EO || "Icon\x20unavailable"), (this["stack"] = new Error()["stack"]);
            }
            (E8["prototype"] = Object["create"](Error["prototype"])), (E8["prototype"]["constructor"] = E8);
            var E9 = { fill: "currentColor" },
                Er = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" },
                EE = {
                    tag: "path",
                    attributes: r6({}, E9, {
                        d:
                            "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z\x20M40.6,272H8.5\x20c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z\x20M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6\x20C14.7,194.3,10,216.7,8.5,240H40.6z\x20M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5\x20L64.3,156.5z\x20M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z\x20M115,92.4\x20c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z\x20M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5\x20l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z\x20M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6\x20c7.5-21.1,12.2-43.5,13.6-66.8H471.4z\x20M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z\x20M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z\x20M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1\x20c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z\x20M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9\x20L92.4,397z\x20M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z\x20M190.8,50\x20c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z\x20M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1\x20l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z\x20M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5\x20C370.4,72.1,384.4,81.5,397,92.4z",
                    }),
                },
                ER = r6({}, Er, { attributeName: "opacity" });
            r6({}, E9, { cx: "256", cy: "364", r: "28" }),
                r6({}, Er, { attributeName: "r", values: "28;14;28;28;14;28;" }),
                r6({}, ER, { values: "1;0;1;1;0;1;" }),
                r6({}, E9, {
                    opacity: "1",
                    d:
                        "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7\x20c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2\x20c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z",
                }),
                r6({}, ER, { values: "1;0;0;0;0;1;" }),
                r6({}, E9, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23\x20C237.7,122,232.2,127.7,232.5,134.5z" }),
                r6({}, ER, { values: "0;0;1;1;0;0;" }),
                rN["styles"];
            function ET(EO) {
                var Ej = EO[0x0],
                    Ei = EO[0x1],
                    Eh = r7(EO["slice"](0x4), 0x1)[0x0];
                return {
                    found: !0x0,
                    width: Ej,
                    height: Ei,
                    icon: Array["isArray"](Eh)
                        ? {
                              tag: "g",
                              attributes: { class: ""["concat"](ry["familyPrefix"], "-")["concat"](rm["GROUP"]) },
                              children: [
                                  { tag: "path", attributes: { class: ""["concat"](ry["familyPrefix"], "-")["concat"](rm["SECONDARY"]), fill: "currentColor", d: Eh[0x0] } },
                                  { tag: "path", attributes: { class: ""["concat"](ry["familyPrefix"], "-")["concat"](rm["PRIMARY"]), fill: "currentColor", d: Eh[0x1] } },
                              ],
                          }
                        : { tag: "path", attributes: { fill: "currentColor", d: Eh } },
                };
            }
            rN["styles"];
            function EC() {
                var EO = "fa",
                    Ej = rB,
                    Ei = ry["familyPrefix"],
                    Eh = ry["replacementClass"],
                    Ea =
                        "svg:not(:root).svg-inline--fa\x20{\x0a\x20\x20overflow:\x20visible;\x0a}\x0a\x0a.svg-inline--fa\x20{\x0a\x20\x20display:\x20inline-block;\x0a\x20\x20font-size:\x20inherit;\x0a\x20\x20height:\x201em;\x0a\x20\x20overflow:\x20visible;\x0a\x20\x20vertical-align:\x20-0.125em;\x0a}\x0a.svg-inline--fa.fa-lg\x20{\x0a\x20\x20vertical-align:\x20-0.225em;\x0a}\x0a.svg-inline--fa.fa-w-1\x20{\x0a\x20\x20width:\x200.0625em;\x0a}\x0a.svg-inline--fa.fa-w-2\x20{\x0a\x20\x20width:\x200.125em;\x0a}\x0a.svg-inline--fa.fa-w-3\x20{\x0a\x20\x20width:\x200.1875em;\x0a}\x0a.svg-inline--fa.fa-w-4\x20{\x0a\x20\x20width:\x200.25em;\x0a}\x0a.svg-inline--fa.fa-w-5\x20{\x0a\x20\x20width:\x200.3125em;\x0a}\x0a.svg-inline--fa.fa-w-6\x20{\x0a\x20\x20width:\x200.375em;\x0a}\x0a.svg-inline--fa.fa-w-7\x20{\x0a\x20\x20width:\x200.4375em;\x0a}\x0a.svg-inline--fa.fa-w-8\x20{\x0a\x20\x20width:\x200.5em;\x0a}\x0a.svg-inline--fa.fa-w-9\x20{\x0a\x20\x20width:\x200.5625em;\x0a}\x0a.svg-inline--fa.fa-w-10\x20{\x0a\x20\x20width:\x200.625em;\x0a}\x0a.svg-inline--fa.fa-w-11\x20{\x0a\x20\x20width:\x200.6875em;\x0a}\x0a.svg-inline--fa.fa-w-12\x20{\x0a\x20\x20width:\x200.75em;\x0a}\x0a.svg-inline--fa.fa-w-13\x20{\x0a\x20\x20width:\x200.8125em;\x0a}\x0a.svg-inline--fa.fa-w-14\x20{\x0a\x20\x20width:\x200.875em;\x0a}\x0a.svg-inline--fa.fa-w-15\x20{\x0a\x20\x20width:\x200.9375em;\x0a}\x0a.svg-inline--fa.fa-w-16\x20{\x0a\x20\x20width:\x201em;\x0a}\x0a.svg-inline--fa.fa-w-17\x20{\x0a\x20\x20width:\x201.0625em;\x0a}\x0a.svg-inline--fa.fa-w-18\x20{\x0a\x20\x20width:\x201.125em;\x0a}\x0a.svg-inline--fa.fa-w-19\x20{\x0a\x20\x20width:\x201.1875em;\x0a}\x0a.svg-inline--fa.fa-w-20\x20{\x0a\x20\x20width:\x201.25em;\x0a}\x0a.svg-inline--fa.fa-pull-left\x20{\x0a\x20\x20margin-right:\x200.3em;\x0a\x20\x20width:\x20auto;\x0a}\x0a.svg-inline--fa.fa-pull-right\x20{\x0a\x20\x20margin-left:\x200.3em;\x0a\x20\x20width:\x20auto;\x0a}\x0a.svg-inline--fa.fa-border\x20{\x0a\x20\x20height:\x201.5em;\x0a}\x0a.svg-inline--fa.fa-li\x20{\x0a\x20\x20width:\x202em;\x0a}\x0a.svg-inline--fa.fa-fw\x20{\x0a\x20\x20width:\x201.25em;\x0a}\x0a\x0a.fa-layers\x20svg.svg-inline--fa\x20{\x0a\x20\x20bottom:\x200;\x0a\x20\x20left:\x200;\x0a\x20\x20margin:\x20auto;\x0a\x20\x20position:\x20absolute;\x0a\x20\x20right:\x200;\x0a\x20\x20top:\x200;\x0a}\x0a\x0a.fa-layers\x20{\x0a\x20\x20display:\x20inline-block;\x0a\x20\x20height:\x201em;\x0a\x20\x20position:\x20relative;\x0a\x20\x20text-align:\x20center;\x0a\x20\x20vertical-align:\x20-0.125em;\x0a\x20\x20width:\x201em;\x0a}\x0a.fa-layers\x20svg.svg-inline--fa\x20{\x0a\x20\x20-webkit-transform-origin:\x20center\x20center;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20center\x20center;\x0a}\x0a\x0a.fa-layers-counter,\x20.fa-layers-text\x20{\x0a\x20\x20display:\x20inline-block;\x0a\x20\x20position:\x20absolute;\x0a\x20\x20text-align:\x20center;\x0a}\x0a\x0a.fa-layers-text\x20{\x0a\x20\x20left:\x2050%;\x0a\x20\x20top:\x2050%;\x0a\x20\x20-webkit-transform:\x20translate(-50%,\x20-50%);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20translate(-50%,\x20-50%);\x0a\x20\x20-webkit-transform-origin:\x20center\x20center;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20center\x20center;\x0a}\x0a\x0a.fa-layers-counter\x20{\x0a\x20\x20background-color:\x20#ff253a;\x0a\x20\x20border-radius:\x201em;\x0a\x20\x20-webkit-box-sizing:\x20border-box;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20box-sizing:\x20border-box;\x0a\x20\x20color:\x20#fff;\x0a\x20\x20height:\x201.5em;\x0a\x20\x20line-height:\x201;\x0a\x20\x20max-width:\x205em;\x0a\x20\x20min-width:\x201.5em;\x0a\x20\x20overflow:\x20hidden;\x0a\x20\x20padding:\x200.25em;\x0a\x20\x20right:\x200;\x0a\x20\x20text-overflow:\x20ellipsis;\x0a\x20\x20top:\x200;\x0a\x20\x20-webkit-transform:\x20scale(0.25);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(0.25);\x0a\x20\x20-webkit-transform-origin:\x20top\x20right;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20top\x20right;\x0a}\x0a\x0a.fa-layers-bottom-right\x20{\x0a\x20\x20bottom:\x200;\x0a\x20\x20right:\x200;\x0a\x20\x20top:\x20auto;\x0a\x20\x20-webkit-transform:\x20scale(0.25);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(0.25);\x0a\x20\x20-webkit-transform-origin:\x20bottom\x20right;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20bottom\x20right;\x0a}\x0a\x0a.fa-layers-bottom-left\x20{\x0a\x20\x20bottom:\x200;\x0a\x20\x20left:\x200;\x0a\x20\x20right:\x20auto;\x0a\x20\x20top:\x20auto;\x0a\x20\x20-webkit-transform:\x20scale(0.25);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(0.25);\x0a\x20\x20-webkit-transform-origin:\x20bottom\x20left;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20bottom\x20left;\x0a}\x0a\x0a.fa-layers-top-right\x20{\x0a\x20\x20right:\x200;\x0a\x20\x20top:\x200;\x0a\x20\x20-webkit-transform:\x20scale(0.25);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(0.25);\x0a\x20\x20-webkit-transform-origin:\x20top\x20right;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20top\x20right;\x0a}\x0a\x0a.fa-layers-top-left\x20{\x0a\x20\x20left:\x200;\x0a\x20\x20right:\x20auto;\x0a\x20\x20top:\x200;\x0a\x20\x20-webkit-transform:\x20scale(0.25);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(0.25);\x0a\x20\x20-webkit-transform-origin:\x20top\x20left;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform-origin:\x20top\x20left;\x0a}\x0a\x0a.fa-lg\x20{\x0a\x20\x20font-size:\x201.3333333333em;\x0a\x20\x20line-height:\x200.75em;\x0a\x20\x20vertical-align:\x20-0.0667em;\x0a}\x0a\x0a.fa-xs\x20{\x0a\x20\x20font-size:\x200.75em;\x0a}\x0a\x0a.fa-sm\x20{\x0a\x20\x20font-size:\x200.875em;\x0a}\x0a\x0a.fa-1x\x20{\x0a\x20\x20font-size:\x201em;\x0a}\x0a\x0a.fa-2x\x20{\x0a\x20\x20font-size:\x202em;\x0a}\x0a\x0a.fa-3x\x20{\x0a\x20\x20font-size:\x203em;\x0a}\x0a\x0a.fa-4x\x20{\x0a\x20\x20font-size:\x204em;\x0a}\x0a\x0a.fa-5x\x20{\x0a\x20\x20font-size:\x205em;\x0a}\x0a\x0a.fa-6x\x20{\x0a\x20\x20font-size:\x206em;\x0a}\x0a\x0a.fa-7x\x20{\x0a\x20\x20font-size:\x207em;\x0a}\x0a\x0a.fa-8x\x20{\x0a\x20\x20font-size:\x208em;\x0a}\x0a\x0a.fa-9x\x20{\x0a\x20\x20font-size:\x209em;\x0a}\x0a\x0a.fa-10x\x20{\x0a\x20\x20font-size:\x2010em;\x0a}\x0a\x0a.fa-fw\x20{\x0a\x20\x20text-align:\x20center;\x0a\x20\x20width:\x201.25em;\x0a}\x0a\x0a.fa-ul\x20{\x0a\x20\x20list-style-type:\x20none;\x0a\x20\x20margin-left:\x202.5em;\x0a\x20\x20padding-left:\x200;\x0a}\x0a.fa-ul\x20>\x20li\x20{\x0a\x20\x20position:\x20relative;\x0a}\x0a\x0a.fa-li\x20{\x0a\x20\x20left:\x20-2em;\x0a\x20\x20position:\x20absolute;\x0a\x20\x20text-align:\x20center;\x0a\x20\x20width:\x202em;\x0a\x20\x20line-height:\x20inherit;\x0a}\x0a\x0a.fa-border\x20{\x0a\x20\x20border:\x20solid\x200.08em\x20#eee;\x0a\x20\x20border-radius:\x200.1em;\x0a\x20\x20padding:\x200.2em\x200.25em\x200.15em;\x0a}\x0a\x0a.fa-pull-left\x20{\x0a\x20\x20float:\x20left;\x0a}\x0a\x0a.fa-pull-right\x20{\x0a\x20\x20float:\x20right;\x0a}\x0a\x0a.fa.fa-pull-left,\x0a.fas.fa-pull-left,\x0a.far.fa-pull-left,\x0a.fal.fa-pull-left,\x0a.fab.fa-pull-left\x20{\x0a\x20\x20margin-right:\x200.3em;\x0a}\x0a.fa.fa-pull-right,\x0a.fas.fa-pull-right,\x0a.far.fa-pull-right,\x0a.fal.fa-pull-right,\x0a.fab.fa-pull-right\x20{\x0a\x20\x20margin-left:\x200.3em;\x0a}\x0a\x0a.fa-spin\x20{\x0a\x20\x20-webkit-animation:\x20fa-spin\x202s\x20infinite\x20linear;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20animation:\x20fa-spin\x202s\x20infinite\x20linear;\x0a}\x0a\x0a.fa-pulse\x20{\x0a\x20\x20-webkit-animation:\x20fa-spin\x201s\x20infinite\x20steps(8);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20animation:\x20fa-spin\x201s\x20infinite\x20steps(8);\x0a}\x0a\x0a@-webkit-keyframes\x20fa-spin\x20{\x0a\x20\x200%\x20{\x0a\x20\x20\x20\x20-webkit-transform:\x20rotate(0deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(0deg);\x0a\x20\x20}\x0a\x20\x20100%\x20{\x0a\x20\x20\x20\x20-webkit-transform:\x20rotate(360deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(360deg);\x0a\x20\x20}\x0a}\x0a\x0a@keyframes\x20fa-spin\x20{\x0a\x20\x200%\x20{\x0a\x20\x20\x20\x20-webkit-transform:\x20rotate(0deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(0deg);\x0a\x20\x20}\x0a\x20\x20100%\x20{\x0a\x20\x20\x20\x20-webkit-transform:\x20rotate(360deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(360deg);\x0a\x20\x20}\x0a}\x0a.fa-rotate-90\x20{\x0a\x20\x20-ms-filter:\x20\x22progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\x22;\x0a\x20\x20-webkit-transform:\x20rotate(90deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(90deg);\x0a}\x0a\x0a.fa-rotate-180\x20{\x0a\x20\x20-ms-filter:\x20\x22progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\x22;\x0a\x20\x20-webkit-transform:\x20rotate(180deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(180deg);\x0a}\x0a\x0a.fa-rotate-270\x20{\x0a\x20\x20-ms-filter:\x20\x22progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\x22;\x0a\x20\x20-webkit-transform:\x20rotate(270deg);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20rotate(270deg);\x0a}\x0a\x0a.fa-flip-horizontal\x20{\x0a\x20\x20-ms-filter:\x20\x22progid:DXImageTransform.Microsoft.BasicImage(rotation=0,\x20mirror=1)\x22;\x0a\x20\x20-webkit-transform:\x20scale(-1,\x201);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(-1,\x201);\x0a}\x0a\x0a.fa-flip-vertical\x20{\x0a\x20\x20-ms-filter:\x20\x22progid:DXImageTransform.Microsoft.BasicImage(rotation=2,\x20mirror=1)\x22;\x0a\x20\x20-webkit-transform:\x20scale(1,\x20-1);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(1,\x20-1);\x0a}\x0a\x0a.fa-flip-both,\x20.fa-flip-horizontal.fa-flip-vertical\x20{\x0a\x20\x20-ms-filter:\x20\x22progid:DXImageTransform.Microsoft.BasicImage(rotation=2,\x20mirror=1)\x22;\x0a\x20\x20-webkit-transform:\x20scale(-1,\x20-1);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20transform:\x20scale(-1,\x20-1);\x0a}\x0a\x0a:root\x20.fa-rotate-90,\x0a:root\x20.fa-rotate-180,\x0a:root\x20.fa-rotate-270,\x0a:root\x20.fa-flip-horizontal,\x0a:root\x20.fa-flip-vertical,\x0a:root\x20.fa-flip-both\x20{\x0a\x20\x20-webkit-filter:\x20none;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20filter:\x20none;\x0a}\x0a\x0a.fa-stack\x20{\x0a\x20\x20display:\x20inline-block;\x0a\x20\x20height:\x202em;\x0a\x20\x20position:\x20relative;\x0a\x20\x20width:\x202.5em;\x0a}\x0a\x0a.fa-stack-1x,\x0a.fa-stack-2x\x20{\x0a\x20\x20bottom:\x200;\x0a\x20\x20left:\x200;\x0a\x20\x20margin:\x20auto;\x0a\x20\x20position:\x20absolute;\x0a\x20\x20right:\x200;\x0a\x20\x20top:\x200;\x0a}\x0a\x0a.svg-inline--fa.fa-stack-1x\x20{\x0a\x20\x20height:\x201em;\x0a\x20\x20width:\x201.25em;\x0a}\x0a.svg-inline--fa.fa-stack-2x\x20{\x0a\x20\x20height:\x202em;\x0a\x20\x20width:\x202.5em;\x0a}\x0a\x0a.fa-inverse\x20{\x0a\x20\x20color:\x20#fff;\x0a}\x0a\x0a.sr-only\x20{\x0a\x20\x20border:\x200;\x0a\x20\x20clip:\x20rect(0,\x200,\x200,\x200);\x0a\x20\x20height:\x201px;\x0a\x20\x20margin:\x20-1px;\x0a\x20\x20overflow:\x20hidden;\x0a\x20\x20padding:\x200;\x0a\x20\x20position:\x20absolute;\x0a\x20\x20width:\x201px;\x0a}\x0a\x0a.sr-only-focusable:active,\x20.sr-only-focusable:focus\x20{\x0a\x20\x20clip:\x20auto;\x0a\x20\x20height:\x20auto;\x0a\x20\x20margin:\x200;\x0a\x20\x20overflow:\x20visible;\x0a\x20\x20position:\x20static;\x0a\x20\x20width:\x20auto;\x0a}\x0a\x0a.svg-inline--fa\x20.fa-primary\x20{\x0a\x20\x20fill:\x20var(--fa-primary-color,\x20currentColor);\x0a\x20\x20opacity:\x201;\x0a\x20\x20opacity:\x20var(--fa-primary-opacity,\x201);\x0a}\x0a\x0a.svg-inline--fa\x20.fa-secondary\x20{\x0a\x20\x20fill:\x20var(--fa-secondary-color,\x20currentColor);\x0a\x20\x20opacity:\x200.4;\x0a\x20\x20opacity:\x20var(--fa-secondary-opacity,\x200.4);\x0a}\x0a\x0a.svg-inline--fa.fa-swap-opacity\x20.fa-primary\x20{\x0a\x20\x20opacity:\x200.4;\x0a\x20\x20opacity:\x20var(--fa-secondary-opacity,\x200.4);\x0a}\x0a\x0a.svg-inline--fa.fa-swap-opacity\x20.fa-secondary\x20{\x0a\x20\x20opacity:\x201;\x0a\x20\x20opacity:\x20var(--fa-primary-opacity,\x201);\x0a}\x0a\x0a.svg-inline--fa\x20mask\x20.fa-primary,\x0a.svg-inline--fa\x20mask\x20.fa-secondary\x20{\x0a\x20\x20fill:\x20black;\x0a}\x0a\x0a.fad.fa-inverse\x20{\x0a\x20\x20color:\x20#fff;\x0a}";
                if (Ei !== EO || Eh !== Ej) {
                    var Ec = new RegExp("\x5c."["concat"](EO, "\x5c-"), "g"),
                        ES = new RegExp("\x5c--"["concat"](EO, "\x5c-"), "g"),
                        Eg = new RegExp("\x5c."["concat"](Ej), "g");
                    Ea = Ea["replace"](Ec, "."["concat"](Ei, "-"))["replace"](ES, "--"["concat"](Ei, "-"))["replace"](Eg, "."["concat"](Eh));
                }
                return Ea;
            }
            var Ed = (function () {
                function EO() {
                    !(function (Ea, Ec) {
                        if (!(Ea instanceof Ec)) throw new TypeError("Cannot\x20call\x20a\x20class\x20as\x20a\x20function");
                    })(this, EO),
                        (this["definitions"] = {});
                }
                var Ej, Ei, Eh;
                return (
                    (Ej = EO),
                    (Ei = [
                        {
                            key: "add",
                            value: function () {
                                for (var Ea = this, Ec = arguments["length"], ES = new Array(Ec), Eg = 0x0; Eg < Ec; Eg++) ES[Eg] = arguments[Eg];
                                var EW = ES["reduce"](this["_pullDefinitions"], {});
                                Object["keys"](EW)["forEach"](function (EH) {
                                    (Ea["definitions"][EH] = r6({}, Ea["definitions"][EH] || {}, EW[EH])), E1(EH, EW[EH]), E4();
                                });
                            },
                        },
                        {
                            key: "reset",
                            value: function () {
                                this["definitions"] = {};
                            },
                        },
                        {
                            key: "_pullDefinitions",
                            value: function (Ea, Ec) {
                                var ES = Ec["prefix"] && Ec["iconName"] && Ec["icon"] ? { 0x0: Ec } : Ec;
                                return (
                                    Object["keys"](ES)["map"](function (Eg) {
                                        var EW = ES[Eg],
                                            EH = EW["prefix"],
                                            Ex = EW["iconName"],
                                            EK = EW["icon"];
                                        Ea[EH] || (Ea[EH] = {}), (Ea[EH][Ex] = EK);
                                    }),
                                    Ea
                                );
                            },
                        },
                    ]),
                    Ei && r4(Ej["prototype"], Ei),
                    Eh && r4(Ej, Eh),
                    EO
                );
            })();
            function EY() {
                ry["autoAddCss"] && !EZ && (rH(EC()), (EZ = !0x0));
            }
            function En(EO, Ej) {
                return (
                    Object["defineProperty"](EO, "abstract", { get: Ej }),
                    Object["defineProperty"](EO, "html", {
                        get: function () {
                            return EO["abstract"]["map"](function (Ei) {
                                return E6(Ei);
                            });
                        },
                    }),
                    Object["defineProperty"](EO, "node", {
                        get: function () {
                            if (rn) {
                                var Ei = rd["createElement"]("div");
                                return (Ei["innerHTML"] = EO["html"]), Ei["children"];
                            }
                        },
                    }),
                    EO
                );
            }
            function EB(EO) {
                var Ej = EO["prefix"],
                    Ei = void 0x0 === Ej ? "fa" : Ej,
                    Eh = EO["iconName"];
                if (Eh) return E5(Eb["definitions"], Ei, Eh) || E5(rN["styles"], Ei, Eh);
            }
            var EF,
                Eb = new Ed(),
                EZ = !0x1,
                Em = {
                    transform: function (EO) {
                        return E7(EO);
                    },
                },
                Ev =
                    ((EF = function (EO) {
                        var Ej = arguments["length"] > 0x1 && void 0x0 !== arguments[0x1] ? arguments[0x1] : {},
                            Ei = Ej["transform"],
                            Eh = void 0x0 === Ei ? rW : Ei,
                            Ea = Ej["symbol"],
                            Ec = void 0x0 !== Ea && Ea,
                            ES = Ej["mask"],
                            Eg = void 0x0 === ES ? null : ES,
                            EW = Ej["maskId"],
                            EH = void 0x0 === EW ? null : EW,
                            Ex = Ej["title"],
                            EK = void 0x0 === Ex ? null : Ex,
                            EV = Ej["titleId"],
                            Es = void 0x0 === EV ? null : EV,
                            EJ = Ej["classes"],
                            EG = void 0x0 === EJ ? [] : EJ,
                            EL = Ej["attributes"],
                            EQ = void 0x0 === EL ? {} : EL,
                            Ez = Ej["styles"],
                            R0 = void 0x0 === Ez ? {} : Ez;
                        if (EO) {
                            var R1 = EO["prefix"],
                                R2 = EO["iconName"],
                                R3 = EO["icon"];
                            return En(r6({ type: "icon" }, EO), function () {
                                return (
                                    EY(),
                                    ry["autoA11y"] && (EK ? (EQ["aria-labelledby"] = ""["concat"](ry["replacementClass"], "-title-")["concat"](Es || rx())) : ((EQ["aria-hidden"] = "true"), (EQ["focusable"] = "false"))),
                                    rQ({
                                        icons: { main: ET(R3), mask: Eg ? ET(Eg["icon"]) : { found: !0x1, width: null, height: null, icon: {} } },
                                        prefix: R1,
                                        iconName: R2,
                                        transform: r6({}, rW, Eh),
                                        symbol: Ec,
                                        title: EK,
                                        maskId: EH,
                                        titleId: Es,
                                        extra: { attributes: EQ, styles: R0, classes: EG },
                                    })
                                );
                            });
                        }
                    }),
                    function (EO) {
                        var Ej = arguments["length"] > 0x1 && void 0x0 !== arguments[0x1] ? arguments[0x1] : {},
                            Ei = (EO || {})["icon"] ? EO : EB(EO || {}),
                            Eh = Ej["mask"];
                        return Eh && (Eh = (Eh || {})["icon"] ? Eh : EB(Eh || {})), EF(Ei, r6({}, Ej, { mask: Eh }));
                    }),
                Eu = r2(0xb281),
                Ey = r2["n"](Eu),
                ED = r2(0x106de);
            function EN(EO) {
                return (
                    (EN =
                        "function" == typeof Symbol && "symbol" == typeof Symbol["iterator"]
                            ? function (Ej) {
                                  return typeof Ej;
                              }
                            : function (Ej) {
                                  return Ej && "function" == typeof Symbol && Ej["constructor"] === Symbol && Ej !== Symbol["prototype"] ? "symbol" : typeof Ej;
                              }),
                    EN(EO)
                );
            }
            function EX(EO, Ej, Ei) {
                return Ej in EO ? Object["defineProperty"](EO, Ej, { value: Ei, enumerable: !0x0, configurable: !0x0, writable: !0x0 }) : (EO[Ej] = Ei), EO;
            }
            function Ef(EO, Ej) {
                var Ei = Object["keys"](EO);
                if (Object["getOwnPropertySymbols"]) {
                    var Eh = Object["getOwnPropertySymbols"](EO);
                    Ej &&
                        (Eh = Eh["filter"](function (Ea) {
                            return Object["getOwnPropertyDescriptor"](EO, Ea)["enumerable"];
                        })),
                        Ei["push"]["apply"](Ei, Eh);
                }
                return Ei;
            }
            function EP(EO) {
                for (var Ej = 0x1; Ej < arguments["length"]; Ej++) {
                    var Ei = null != arguments[Ej] ? arguments[Ej] : {};
                    Ej % 0x2
                        ? Ef(Object(Ei), !0x0)["forEach"](function (Eh) {
                              EX(EO, Eh, Ei[Eh]);
                          })
                        : Object["getOwnPropertyDescriptors"]
                        ? Object["defineProperties"](EO, Object["getOwnPropertyDescriptors"](Ei))
                        : Ef(Object(Ei))["forEach"](function (Eh) {
                              Object["defineProperty"](EO, Eh, Object["getOwnPropertyDescriptor"](Ei, Eh));
                          });
                }
                return EO;
            }
            function EI(EO, Ej) {
                if (null == EO) return {};
                var Ei,
                    Eh,
                    Ea = (function (ES, Eg) {
                        if (null == ES) return {};
                        var EW,
                            EH,
                            Ex = {},
                            EK = Object["keys"](ES);
                        for (EH = 0x0; EH < EK["length"]; EH++) (EW = EK[EH]), Eg["indexOf"](EW) >= 0x0 || (Ex[EW] = ES[EW]);
                        return Ex;
                    })(EO, Ej);
                if (Object["getOwnPropertySymbols"]) {
                    var Ec = Object["getOwnPropertySymbols"](EO);
                    for (Eh = 0x0; Eh < Ec["length"]; Eh++) (Ei = Ec[Eh]), Ej["indexOf"](Ei) >= 0x0 || (Object["prototype"]["propertyIsEnumerable"]["call"](EO, Ei) && (Ea[Ei] = EO[Ei]));
                }
                return Ea;
            }
            function EA(EO) {
                return (
                    (function (Ej) {
                        if (Array["isArray"](Ej)) {
                            for (var Ei = 0x0, Eh = new Array(Ej["length"]); Ei < Ej["length"]; Ei++) Eh[Ei] = Ej[Ei];
                            return Eh;
                        }
                    })(EO) ||
                    (function (Ej) {
                        if (Symbol["iterator"] in Object(Ej) || "[object\x20Arguments]" === Object["prototype"]["toString"]["call"](Ej)) return Array["from"](Ej);
                    })(EO) ||
                    (function () {
                        throw new TypeError("Invalid\x20attempt\x20to\x20spread\x20non-iterable\x20instance");
                    })()
                );
            }
            function EM(EO) {
                return (
                    (Ej = EO),
                    (Ej -= 0x0) == Ej
                        ? EO
                        : (EO = EO["replace"](/[\-_\s]+(.)?/g, function (Ei, Eh) {
                              return Eh ? Eh["toUpperCase"]() : "";
                          }))
                              ["substr"](0x0, 0x1)
                              ["toLowerCase"]() + EO["substr"](0x1)
                );
                var Ej;
            }
            function Eo(EO) {
                return EO["split"](";")
                    ["map"](function (Ej) {
                        return Ej["trim"]();
                    })
                    ["filter"](function (Ej) {
                        return Ej;
                    })
                    ["reduce"](function (Ej, Ei) {
                        var Eh,
                            Ea = Ei["indexOf"](":"),
                            Ec = EM(Ei["slice"](0x0, Ea)),
                            ES = Ei["slice"](Ea + 0x1)["trim"]();
                        return Ec["startsWith"]("webkit") ? (Ej[((Eh = Ec), Eh["charAt"](0x0)["toUpperCase"]() + Eh["slice"](0x1))] = ES) : (Ej[Ec] = ES), Ej;
                    }, {});
            }
            var Ep = !0x1;
            try {
                Ep = !0x0;
            } catch (EO) {}
            function Ek(Ej) {
                return Ej && "object" === EN(Ej) && Ej["prefix"] && Ej["iconName"] && Ej["icon"]
                    ? Ej
                    : Em["icon"]
                    ? Em["icon"](Ej)
                    : null === Ej
                    ? null
                    : Ej && "object" === EN(Ej) && Ej["prefix"] && Ej["iconName"]
                    ? Ej
                    : Array["isArray"](Ej) && 0x2 === Ej["length"]
                    ? { prefix: Ej[0x0], iconName: Ej[0x1] }
                    : "string" == typeof Ej
                    ? { prefix: "fas", iconName: Ej }
                    : void 0x0;
            }
            function Ee(Ej, Ei) {
                return (Array["isArray"](Ei) && Ei["length"] > 0x0) || (!Array["isArray"](Ei) && Ei) ? EX({}, Ej, Ei) : {};
            }
            function El(Ej) {
                var Ei = Ej["forwardedRef"],
                    Eh = EI(Ej, ["forwardedRef"]),
                    Ea = Eh["icon"],
                    Ec = Eh["mask"],
                    ES = Eh["symbol"],
                    Eg = Eh["className"],
                    EW = Eh["title"],
                    EH = Eh["titleId"],
                    Ex = Ek(Ea),
                    EK = Ee(
                        "classes",
                        []["concat"](
                            EA(
                                (function (EQ) {
                                    var Ez,
                                        R0 = EQ["spin"],
                                        R1 = EQ["pulse"],
                                        R2 = EQ["fixedWidth"],
                                        R3 = EQ["inverse"],
                                        R4 = EQ["border"],
                                        R5 = EQ["listItem"],
                                        R6 = EQ["flip"],
                                        R7 = EQ["size"],
                                        R8 = EQ["rotation"],
                                        R9 = EQ["pull"],
                                        Rr =
                                            (EX(
                                                (Ez = {
                                                    "fa-spin": R0,
                                                    "fa-pulse": R1,
                                                    "fa-fw": R2,
                                                    "fa-inverse": R3,
                                                    "fa-border": R4,
                                                    "fa-li": R5,
                                                    "fa-flip-horizontal": "horizontal" === R6 || "both" === R6,
                                                    "fa-flip-vertical": "vertical" === R6 || "both" === R6,
                                                }),
                                                "fa-"["concat"](R7),
                                                null != R7
                                            ),
                                            EX(Ez, "fa-rotate-"["concat"](R8), null != R8 && 0x0 !== R8),
                                            EX(Ez, "fa-pull-"["concat"](R9), null != R9),
                                            EX(Ez, "fa-swap-opacity", EQ["swapOpacity"]),
                                            Ez);
                                    return Object["keys"](Rr)
                                        ["map"](function (RE) {
                                            return Rr[RE] ? RE : null;
                                        })
                                        ["filter"](function (RE) {
                                            return RE;
                                        });
                                })(Eh)
                            ),
                            EA(Eg["split"]("\x20"))
                        )
                    ),
                    EV = Ee("transform", "string" == typeof Eh["transform"] ? Em["transform"](Eh["transform"]) : Eh["transform"]),
                    Es = Ee("mask", Ek(Ec)),
                    EJ = Ev(Ex, EP({}, EK, {}, EV, {}, Es, { symbol: ES, title: EW, titleId: EH }));
                if (!EJ)
                    return (
                        (function () {
                            var EQ;
                            !Ep && console && "function" == typeof console["error"] && (EQ = console)["error"]["apply"](EQ, arguments);
                        })("Could\x20not\x20find\x20icon", Ex),
                        null
                    );
                var EG = EJ["abstract"],
                    EL = { ref: Ei };
                return (
                    Object["keys"](Eh)["forEach"](function (EQ) {
                        El["defaultProps"]["hasOwnProperty"](EQ) || (EL[EQ] = Eh[EQ]);
                    }),
                    EU(EG[0x0], EL)
                );
            }
            (El["displayName"] = "FontAwesomeIcon"),
                (El["propTypes"] = {
                    border: Ey()["bool"],
                    className: Ey()["string"],
                    mask: Ey()["oneOfType"]([Ey()["object"], Ey()["array"], Ey()["string"]]),
                    fixedWidth: Ey()["bool"],
                    inverse: Ey()["bool"],
                    flip: Ey()["oneOf"](["horizontal", "vertical", "both"]),
                    icon: Ey()["oneOfType"]([Ey()["object"], Ey()["array"], Ey()["string"]]),
                    listItem: Ey()["bool"],
                    pull: Ey()["oneOf"](["right", "left"]),
                    pulse: Ey()["bool"],
                    rotation: Ey()["oneOf"]([0x0, 0x5a, 0xb4, 0x10e]),
                    size: Ey()["oneOf"](["lg", "xs", "sm", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
                    spin: Ey()["bool"],
                    symbol: Ey()["oneOfType"]([Ey()["bool"], Ey()["string"]]),
                    title: Ey()["string"],
                    transform: Ey()["oneOfType"]([Ey()["string"], Ey()["object"]]),
                    swapOpacity: Ey()["bool"],
                }),
                (El["defaultProps"] = {
                    border: !0x1,
                    className: "",
                    mask: null,
                    fixedWidth: !0x1,
                    inverse: !0x1,
                    flip: null,
                    icon: null,
                    listItem: !0x1,
                    pull: null,
                    pulse: !0x1,
                    rotation: null,
                    size: null,
                    spin: !0x1,
                    symbol: !0x1,
                    title: "",
                    transform: null,
                    swapOpacity: !0x1,
                });
            var EU = function Ej(Ei, Eh) {
                var Ea = arguments["length"] > 0x2 && void 0x0 !== arguments[0x2] ? arguments[0x2] : {};
                if ("string" == typeof Eh) return Eh;
                var Ec = (Eh["children"] || [])["map"](function (Ex) {
                        return Ej(Ei, Ex);
                    }),
                    ES = Object["keys"](Eh["attributes"] || {})["reduce"](
                        function (Ex, EK) {
                            var EV = Eh["attributes"][EK];
                            switch (EK) {
                                case "class":
                                    (Ex["attrs"]["className"] = EV), delete Eh["attributes"]["class"];
                                    break;
                                case "style":
                                    Ex["attrs"]["style"] = Eo(EV);
                                    break;
                                default:
                                    0x0 === EK["indexOf"]("aria-") || 0x0 === EK["indexOf"]("data-") ? (Ex["attrs"][EK["toLowerCase"]()] = EV) : (Ex["attrs"][EM(EK)] = EV);
                            }
                            return Ex;
                        },
                        { attrs: {} }
                    ),
                    Eg = Ea["style"],
                    EW = void 0x0 === Eg ? {} : Eg,
                    EH = EI(Ea, ["style"]);
                return (ES["attrs"]["style"] = EP({}, ES["attrs"]["style"], {}, EW)), Ei["apply"](void 0x0, [Eh["tag"], EP({}, ES["attrs"], {}, EH)]["concat"](EA(Ec)));
            }["bind"](null, ED["createElement"]);
        },
        0x12a73: function (r0, r1, r2) {
            "use strict";
            function r3(Ef) {
                for (var EP = arguments["length"], EI = Array(EP > 0x1 ? EP - 0x1 : 0x0), EA = 0x1; EA < EP; EA++) EI[EA - 0x1] = arguments[EA];
                throw Error(
                    "[Immer]\x20minified\x20error\x20nr:\x20" +
                        Ef +
                        (EI["length"]
                            ? "\x20" +
                              EI["map"](function (EM) {
                                  return "\x27" + EM + "\x27";
                              })["join"](",")
                            : "") +
                        ".\x20Find\x20the\x20full\x20error\x20at:\x20https://bit.ly/3cXEKWf"
                );
            }
            function r4(Ef) {
                return !!Ef && !!Ef[rc];
            }
            function r5(Ef) {
                return (
                    !!Ef &&
                    ((function (EP) {
                        if (!EP || "object" != typeof EP) return !0x1;
                        var EI = Object["getPrototypeOf"](EP);
                        if (null === EI) return !0x0;
                        var EA = Object["hasOwnProperty"]["call"](EI, "constructor") && EI["constructor"];
                        return EA === Object || ("function" == typeof EA && Function["toString"]["call"](EA) === rS);
                    })(Ef) ||
                        Array["isArray"](Ef) ||
                        !!Ef[ra] ||
                        !!Ef["constructor"][ra] ||
                        rR(Ef) ||
                        rT(Ef))
                );
            }
            function r6(Ef, EP, EI) {
                void 0x0 === EI && (EI = !0x1),
                    0x0 === r7(Ef)
                        ? (EI ? Object["keys"] : rg)(Ef)["forEach"](function (EA) {
                              (EI && "symbol" == typeof EA) || EP(EA, Ef[EA], Ef);
                          })
                        : Ef["forEach"](function (EA, EM) {
                              return EP(EM, EA, Ef);
                          });
            }
            function r7(Ef) {
                var EP = Ef[rc];
                return EP ? (EP["i"] > 0x3 ? EP["i"] - 0x4 : EP["i"]) : Array["isArray"](Ef) ? 0x1 : rR(Ef) ? 0x2 : rT(Ef) ? 0x3 : 0x0;
            }
            function r8(Ef, EP) {
                return 0x2 === r7(Ef) ? Ef["has"](EP) : Object["prototype"]["hasOwnProperty"]["call"](Ef, EP);
            }
            function r9(Ef, EP) {
                return 0x2 === r7(Ef) ? Ef["get"](EP) : Ef[EP];
            }
            function rr(Ef, EP, EI) {
                var EA = r7(Ef);
                0x2 === EA ? Ef["set"](EP, EI) : 0x3 === EA ? (Ef["delete"](EP), Ef["add"](EI)) : (Ef[EP] = EI);
            }
            function rE(Ef, EP) {
                return Ef === EP ? 0x0 !== Ef || 0x1 / Ef == 0x1 / EP : Ef != Ef && EP != EP;
            }
            function rR(Ef) {
                return rO && Ef instanceof Map;
            }
            function rT(Ef) {
                return rj && Ef instanceof Set;
            }
            function rC(Ef) {
                return Ef["o"] || Ef["t"];
            }
            function rd(Ef) {
                if (Array["isArray"](Ef)) return Array["prototype"]["slice"]["call"](Ef);
                var EP = rW(Ef);
                delete EP[rc];
                for (var EI = rg(EP), EA = 0x0; EA < EI["length"]; EA++) {
                    var EM = EI[EA],
                        Eo = EP[EM];
                    !0x1 === Eo["writable"] && ((Eo["writable"] = !0x0), (Eo["configurable"] = !0x0)), (Eo["get"] || Eo["set"]) && (EP[EM] = { configurable: !0x0, writable: !0x0, enumerable: Eo["enumerable"], value: Ef[EM] });
                }
                return Object["create"](Object["getPrototypeOf"](Ef), EP);
            }
            function rY(Ef, EP) {
                return (
                    void 0x0 === EP && (EP = !0x1),
                    rB(Ef) ||
                        r4(Ef) ||
                        !r5(Ef) ||
                        (r7(Ef) > 0x1 && (Ef["set"] = Ef["add"] = Ef["clear"] = Ef["delete"] = rn),
                        Object["freeze"](Ef),
                        EP &&
                            r6(
                                Ef,
                                function (EI, EA) {
                                    return rY(EA, !0x0);
                                },
                                !0x0
                            )),
                    Ef
                );
            }
            function rn() {
                r3(0x2);
            }
            function rB(Ef) {
                return null == Ef || "object" != typeof Ef || Object["isFrozen"](Ef);
            }
            function rF(Ef) {
                var EP = rH[Ef];
                return EP || r3(0x12, Ef), EP;
            }
            function rb(Ef, EP) {
                rH[Ef] || (rH[Ef] = EP);
            }
            function rZ() {
                return rq;
            }
            function rm(Ef, EP) {
                EP && (rF("Patches"), (Ef["u"] = []), (Ef["s"] = []), (Ef["v"] = EP));
            }
            function rv(Ef) {
                ru(Ef), Ef["p"]["forEach"](rD), (Ef["p"] = null);
            }
            function ru(Ef) {
                Ef === rq && (rq = Ef["l"]);
            }
            function ry(Ef) {
                return (rq = { p: [], l: rq, h: Ef, m: !0x0, _: 0x0 });
            }
            function rD(Ef) {
                var EP = Ef[rc];
                0x0 === EP["i"] || 0x1 === EP["i"] ? EP["j"]() : (EP["O"] = !0x0);
            }
            function rN(Ef, EP) {
                EP["_"] = EP["p"]["length"];
                var EI = EP["p"][0x0],
                    EA = void 0x0 !== Ef && Ef !== EI;
                return (
                    EP["h"]["g"] || rF("ES5")["S"](EP, Ef, EA),
                    EA ? (EI[rc]["P"] && (rv(EP), r3(0x4)), r5(Ef) && ((Ef = rX(EP, Ef)), EP["l"] || rP(EP, Ef)), EP["u"] && rF("Patches")["M"](EI[rc], Ef, EP["u"], EP["s"])) : (Ef = rX(EP, EI, [])),
                    rv(EP),
                    EP["u"] && EP["v"](EP["u"], EP["s"]),
                    Ef !== rh ? Ef : void 0x0
                );
            }
            function rX(Ef, EP, EI) {
                if (rB(EP)) return EP;
                var EA = EP[rc];
                if (!EA)
                    return (
                        r6(
                            EP,
                            function (Eo, Ep) {
                                return rf(Ef, EA, EP, Eo, Ep, EI);
                            },
                            !0x0
                        ),
                        EP
                    );
                if (EA["A"] !== Ef) return EP;
                if (!EA["P"]) return rP(Ef, EA["t"], !0x0), EA["t"];
                if (!EA["I"]) {
                    (EA["I"] = !0x0), EA["A"]["_"]--;
                    var EM = 0x4 === EA["i"] || 0x5 === EA["i"] ? (EA["o"] = rd(EA["k"])) : EA["o"];
                    r6(0x3 === EA["i"] ? new Set(EM) : EM, function (Eo, Ep) {
                        return rf(Ef, EA, EM, Eo, Ep, EI);
                    }),
                        rP(Ef, EM, !0x1),
                        EI && Ef["u"] && rF("Patches")["R"](EA, EI, Ef["u"], Ef["s"]);
                }
                return EA["o"];
            }
            function rf(Ef, EP, EI, EA, EM, Eo) {
                if (r4(EM)) {
                    var Ep = rX(Ef, EM, Eo && EP && 0x3 !== EP["i"] && !r8(EP["D"], EA) ? Eo["concat"](EA) : void 0x0);
                    if ((rr(EI, EA, Ep), !r4(Ep))) return;
                    Ef["m"] = !0x1;
                }
                if (r5(EM) && !rB(EM)) {
                    if (!Ef["h"]["F"] && Ef["_"] < 0x1) return;
                    rX(Ef, EM), (EP && EP["A"]["l"]) || rP(Ef, EM);
                }
            }
            function rP(Ef, EP, EI) {
                void 0x0 === EI && (EI = !0x1), Ef["h"]["F"] && Ef["m"] && rY(EP, EI);
            }
            function rI(Ef, EP) {
                var EI = Ef[rc];
                return (EI ? rC(EI) : Ef)[EP];
            }
            function rA(Ef, EP) {
                if (EP in Ef)
                    for (var EI = Object["getPrototypeOf"](Ef); EI; ) {
                        var EA = Object["getOwnPropertyDescriptor"](EI, EP);
                        if (EA) return EA;
                        EI = Object["getPrototypeOf"](EI);
                    }
            }
            function rM(Ef) {
                Ef["P"] || ((Ef["P"] = !0x0), Ef["l"] && rM(Ef["l"]));
            }
            function ro(Ef) {
                Ef["o"] || (Ef["o"] = rd(Ef["t"]));
            }
            function rp(Ef, EP, EI) {
                var EA = rR(EP)
                    ? rF("MapSet")["N"](EP, EI)
                    : rT(EP)
                    ? rF("MapSet")["T"](EP, EI)
                    : Ef["g"]
                    ? (function (EM, Eo) {
                          var Ep = Array["isArray"](EM),
                              Ek = { i: Ep ? 0x1 : 0x0, A: Eo ? Eo["A"] : rZ(), P: !0x1, I: !0x1, D: {}, l: Eo, t: EM, k: null, o: null, j: null, C: !0x1 },
                              Ee = Ek,
                              El = rx;
                          Ep && ((Ee = [Ek]), (El = rK));
                          var EU = Proxy["revocable"](Ee, El),
                              Eq = EU["revoke"],
                              Ew = EU["proxy"];
                          return (Ek["k"] = Ew), (Ek["j"] = Eq), Ew;
                      })(EP, EI)
                    : rF("ES5")["J"](EP, EI);
                return (EI ? EI["A"] : rZ())["p"]["push"](EA), EA;
            }
            function rk(Ef) {
                return (
                    r4(Ef) || r3(0x16, Ef),
                    (function EP(EI) {
                        if (!r5(EI)) return EI;
                        var EA,
                            EM = EI[rc],
                            Eo = r7(EI);
                        if (EM) {
                            if (!EM["P"] && (EM["i"] < 0x4 || !rF("ES5")["K"](EM))) return EM["t"];
                            (EM["I"] = !0x0), (EA = re(EI, Eo)), (EM["I"] = !0x1);
                        } else EA = re(EI, Eo);
                        return (
                            r6(EA, function (Ep, Ek) {
                                (EM && r9(EM["t"], Ep) === Ek) || rr(EA, Ep, EP(Ek));
                            }),
                            0x3 === Eo ? new Set(EA) : EA
                        );
                    })(Ef)
                );
            }
            function re(Ef, EP) {
                switch (EP) {
                    case 0x2:
                        return new Map(Ef);
                    case 0x3:
                        return Array["from"](Ef);
                }
                return rd(Ef);
            }
            function rl() {
                function Ef(Eo, Ep) {
                    var Ek = EM[Eo];
                    return (
                        Ek
                            ? (Ek["enumerable"] = Ep)
                            : (EM[Eo] = Ek = {
                                  configurable: !0x0,
                                  enumerable: Ep,
                                  get: function () {
                                      var Ee = this[rc];
                                      return rx["get"](Ee, Eo);
                                  },
                                  set: function (Ee) {
                                      var El = this[rc];
                                      rx["set"](El, Eo, Ee);
                                  },
                              }),
                        Ek
                    );
                }
                function EP(Eo) {
                    for (var Ep = Eo["length"] - 0x1; Ep >= 0x0; Ep--) {
                        var Ek = Eo[Ep][rc];
                        if (!Ek["P"])
                            switch (Ek["i"]) {
                                case 0x5:
                                    EA(Ek) && rM(Ek);
                                    break;
                                case 0x4:
                                    EI(Ek) && rM(Ek);
                            }
                    }
                }
                function EI(Eo) {
                    for (var Ep = Eo["t"], Ek = Eo["k"], Ee = rg(Ek), El = Ee["length"] - 0x1; El >= 0x0; El--) {
                        var EU = Ee[El];
                        if (EU !== rc) {
                            var Eq = Ep[EU];
                            if (void 0x0 === Eq && !r8(Ep, EU)) return !0x0;
                            var Ew = Ek[EU],
                                EO = Ew && Ew[rc];
                            if (EO ? EO["t"] !== Eq : !rE(Ew, Eq)) return !0x0;
                        }
                    }
                    var Ej = !!Ep[rc];
                    return Ee["length"] !== rg(Ep)["length"] + (Ej ? 0x0 : 0x1);
                }
                function EA(Eo) {
                    var Ep = Eo["k"];
                    if (Ep["length"] !== Eo["t"]["length"]) return !0x0;
                    var Ek = Object["getOwnPropertyDescriptor"](Ep, Ep["length"] - 0x1);
                    return !(!Ek || Ek["get"]);
                }
                var EM = {};
                rb("ES5", {
                    J: function (Eo, Ep) {
                        var Ek = Array["isArray"](Eo),
                            Ee = (function (EU, Eq) {
                                if (EU) {
                                    for (var Ew = Array(Eq["length"]), EO = 0x0; EO < Eq["length"]; EO++) Object["defineProperty"](Ew, "" + EO, Ef(EO, !0x0));
                                    return Ew;
                                }
                                var Ej = rW(Eq);
                                delete Ej[rc];
                                for (var Ei = rg(Ej), Eh = 0x0; Eh < Ei["length"]; Eh++) {
                                    var Ea = Ei[Eh];
                                    Ej[Ea] = Ef(Ea, EU || !!Ej[Ea]["enumerable"]);
                                }
                                return Object["create"](Object["getPrototypeOf"](Eq), Ej);
                            })(Ek, Eo),
                            El = { i: Ek ? 0x5 : 0x4, A: Ep ? Ep["A"] : rZ(), P: !0x1, I: !0x1, D: {}, l: Ep, t: Eo, k: Ee, o: null, O: !0x1, C: !0x1 };
                        return Object["defineProperty"](Ee, rc, { value: El, writable: !0x0 }), Ee;
                    },
                    S: function (Eo, Ep, Ek) {
                        Ek
                            ? r4(Ep) && Ep[rc]["A"] === Eo && EP(Eo["p"])
                            : (Eo["u"] &&
                                  (function Ee(El) {
                                      if (El && "object" == typeof El) {
                                          var EU = El[rc];
                                          if (EU) {
                                              var Eq = EU["t"],
                                                  Ew = EU["k"],
                                                  EO = EU["D"],
                                                  Ej = EU["i"];
                                              if (0x4 === Ej)
                                                  r6(Ew, function (ES) {
                                                      ES !== rc && (void 0x0 !== Eq[ES] || r8(Eq, ES) ? EO[ES] || Ee(Ew[ES]) : ((EO[ES] = !0x0), rM(EU)));
                                                  }),
                                                      r6(Eq, function (ES) {
                                                          void 0x0 !== Ew[ES] || r8(Ew, ES) || ((EO[ES] = !0x1), rM(EU));
                                                      });
                                              else {
                                                  if (0x5 === Ej) {
                                                      if ((EA(EU) && (rM(EU), (EO["length"] = !0x0)), Ew["length"] < Eq["length"])) {
                                                          for (var Ei = Ew["length"]; Ei < Eq["length"]; Ei++) EO[Ei] = !0x1;
                                                      } else {
                                                          for (var Eh = Eq["length"]; Eh < Ew["length"]; Eh++) EO[Eh] = !0x0;
                                                      }
                                                      for (var Ea = Math["min"](Ew["length"], Eq["length"]), Ec = 0x0; Ec < Ea; Ec++) void 0x0 === EO[Ec] && Ee(Ew[Ec]);
                                                  }
                                              }
                                          }
                                      }
                                  })(Eo["p"][0x0]),
                              EP(Eo["p"]));
                    },
                    K: function (Eo) {
                        return 0x4 === Eo["i"] ? EI(Eo) : EA(Eo);
                    },
                });
            }
            r2["d"](r1, {
                xC: function () {
                    return EB;
                },
                hg: function () {
                    return EN;
                },
                oM: function () {
                    return EZ;
                },
            });
            var rU,
                rq,
                rw = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"),
                rO = "undefined" != typeof Map,
                rj = "undefined" != typeof Set,
                ri = "undefined" != typeof Proxy && void 0x0 !== Proxy["revocable"] && "undefined" != typeof Reflect,
                rh = rw ? Symbol["for"]("immer-nothing") : (((rU = {})["immer-nothing"] = !0x0), rU),
                ra = rw ? Symbol["for"]("immer-draftable") : "__$immer_draftable",
                rc = rw ? Symbol["for"]("immer-state") : "__$immer_state",
                rS = ("undefined" != typeof Symbol && Symbol["iterator"], "" + Object["prototype"]["constructor"]),
                rg =
                    "undefined" != typeof Reflect && Reflect["ownKeys"]
                        ? Reflect["ownKeys"]
                        : void 0x0 !== Object["getOwnPropertySymbols"]
                        ? function (Ef) {
                              return Object["getOwnPropertyNames"](Ef)["concat"](Object["getOwnPropertySymbols"](Ef));
                          }
                        : Object["getOwnPropertyNames"],
                rW =
                    Object["getOwnPropertyDescriptors"] ||
                    function (Ef) {
                        var EP = {};
                        return (
                            rg(Ef)["forEach"](function (EI) {
                                EP[EI] = Object["getOwnPropertyDescriptor"](Ef, EI);
                            }),
                            EP
                        );
                    },
                rH = {},
                rx = {
                    get: function (Ef, EP) {
                        if (EP === rc) return Ef;
                        var EI = rC(Ef);
                        if (!r8(EI, EP))
                            return (function (EM, Eo, Ep) {
                                var Ek,
                                    Ee = rA(Eo, Ep);
                                return Ee ? ("value" in Ee ? Ee["value"] : null === (Ek = Ee["get"]) || void 0x0 === Ek ? void 0x0 : Ek["call"](EM["k"])) : void 0x0;
                            })(Ef, EI, EP);
                        var EA = EI[EP];
                        return Ef["I"] || !r5(EA) ? EA : EA === rI(Ef["t"], EP) ? (ro(Ef), (Ef["o"][EP] = rp(Ef["A"]["h"], EA, Ef))) : EA;
                    },
                    has: function (Ef, EP) {
                        return EP in rC(Ef);
                    },
                    ownKeys: function (Ef) {
                        return Reflect["ownKeys"](rC(Ef));
                    },
                    set: function (Ef, EP, EI) {
                        var EA = rA(rC(Ef), EP);
                        if (null == EA ? void 0x0 : EA["set"]) return EA["set"]["call"](Ef["k"], EI), !0x0;
                        if (!Ef["P"]) {
                            var EM = rI(rC(Ef), EP),
                                Eo = null == EM ? void 0x0 : EM[rc];
                            if (Eo && Eo["t"] === EI) return (Ef["o"][EP] = EI), (Ef["D"][EP] = !0x1), !0x0;
                            if (rE(EI, EM) && (void 0x0 !== EI || r8(Ef["t"], EP))) return !0x0;
                            ro(Ef), rM(Ef);
                        }
                        return (Ef["o"][EP] === EI && "number" != typeof EI && (void 0x0 !== EI || EP in Ef["o"])) || ((Ef["o"][EP] = EI), (Ef["D"][EP] = !0x0), !0x0);
                    },
                    deleteProperty: function (Ef, EP) {
                        return void 0x0 !== rI(Ef["t"], EP) || EP in Ef["t"] ? ((Ef["D"][EP] = !0x1), ro(Ef), rM(Ef)) : delete Ef["D"][EP], Ef["o"] && delete Ef["o"][EP], !0x0;
                    },
                    getOwnPropertyDescriptor: function (Ef, EP) {
                        var EI = rC(Ef),
                            EA = Reflect["getOwnPropertyDescriptor"](EI, EP);
                        return EA ? { writable: !0x0, configurable: 0x1 !== Ef["i"] || "length" !== EP, enumerable: EA["enumerable"], value: EI[EP] } : EA;
                    },
                    defineProperty: function () {
                        r3(0xb);
                    },
                    getPrototypeOf: function (Ef) {
                        return Object["getPrototypeOf"](Ef["t"]);
                    },
                    setPrototypeOf: function () {
                        r3(0xc);
                    },
                },
                rK = {};
            r6(rx, function (Ef, EP) {
                rK[Ef] = function () {
                    return (arguments[0x0] = arguments[0x0][0x0]), EP["apply"](this, arguments);
                };
            }),
                (rK["deleteProperty"] = function (Ef, EP) {
                    return rx["deleteProperty"]["call"](this, Ef[0x0], EP);
                }),
                (rK["set"] = function (Ef, EP, EI) {
                    return rx["set"]["call"](this, Ef[0x0], EP, EI, Ef[0x0]);
                });
            var rV = (function () {
                    function Ef(EI) {
                        var EA = this;
                        (this["g"] = ri),
                            (this["F"] = !0x0),
                            (this["produce"] = function (EM, Eo, Ep) {
                                if ("function" == typeof EM && "function" != typeof Eo) {
                                    var Ek = Eo;
                                    Eo = EM;
                                    var Ee = EA;
                                    return function (EO) {
                                        var Ej = this;
                                        void 0x0 === EO && (EO = Ek);
                                        for (var Ei = arguments["length"], Eh = Array(Ei > 0x1 ? Ei - 0x1 : 0x0), Ea = 0x1; Ea < Ei; Ea++) Eh[Ea - 0x1] = arguments[Ea];
                                        return Ee["produce"](EO, function (Ec) {
                                            var ES;
                                            return (ES = Eo)["call"]["apply"](ES, [Ej, Ec]["concat"](Eh));
                                        });
                                    };
                                }
                                var El;
                                if (("function" != typeof Eo && r3(0x6), void 0x0 !== Ep && "function" != typeof Ep && r3(0x7), r5(EM))) {
                                    var EU = ry(EA),
                                        Eq = rp(EA, EM, void 0x0),
                                        Ew = !0x0;
                                    try {
                                        (El = Eo(Eq)), (Ew = !0x1);
                                    } finally {
                                        Ew ? rv(EU) : ru(EU);
                                    }
                                    return "undefined" != typeof Promise && El instanceof Promise
                                        ? El["then"](
                                              function (EO) {
                                                  return rm(EU, Ep), rN(EO, EU);
                                              },
                                              function (EO) {
                                                  throw (rv(EU), EO);
                                              }
                                          )
                                        : (rm(EU, Ep), rN(El, EU));
                                }
                                if (!EM || "object" != typeof EM) {
                                    if ((El = Eo(EM)) === rh) return;
                                    return void 0x0 === El && (El = EM), EA["F"] && rY(El, !0x0), El;
                                }
                                r3(0x15, EM);
                            }),
                            (this["produceWithPatches"] = function (EM, Eo) {
                                return "function" == typeof EM
                                    ? function (Ee) {
                                          for (var El = arguments["length"], EU = Array(El > 0x1 ? El - 0x1 : 0x0), Eq = 0x1; Eq < El; Eq++) EU[Eq - 0x1] = arguments[Eq];
                                          return EA["produceWithPatches"](Ee, function (Ew) {
                                              return EM["apply"](void 0x0, [Ew]["concat"](EU));
                                          });
                                      }
                                    : [
                                          EA["produce"](EM, Eo, function (Ee, El) {
                                              (Ep = Ee), (Ek = El);
                                          }),
                                          Ep,
                                          Ek,
                                      ];
                                var Ep, Ek;
                            }),
                            "boolean" == typeof (null == EI ? void 0x0 : EI["useProxies"]) && this["setUseProxies"](EI["useProxies"]),
                            "boolean" == typeof (null == EI ? void 0x0 : EI["autoFreeze"]) && this["setAutoFreeze"](EI["autoFreeze"]);
                    }
                    var EP = Ef["prototype"];
                    return (
                        (EP["createDraft"] = function (EI) {
                            r5(EI) || r3(0x8), r4(EI) && (EI = rk(EI));
                            var EA = ry(this),
                                EM = rp(this, EI, void 0x0);
                            return (EM[rc]["C"] = !0x0), ru(EA), EM;
                        }),
                        (EP["finishDraft"] = function (EI, EA) {
                            var EM = (EI && EI[rc])["A"];
                            return rm(EM, EA), rN(void 0x0, EM);
                        }),
                        (EP["setAutoFreeze"] = function (EI) {
                            this["F"] = EI;
                        }),
                        (EP["setUseProxies"] = function (EI) {
                            EI && !ri && r3(0x14), (this["g"] = EI);
                        }),
                        (EP["applyPatches"] = function (EI, EA) {
                            var EM;
                            for (EM = EA["length"] - 0x1; EM >= 0x0; EM--) {
                                var Eo = EA[EM];
                                if (0x0 === Eo["path"]["length"] && "replace" === Eo["op"]) {
                                    EI = Eo["value"];
                                    break;
                                }
                            }
                            EM > -0x1 && (EA = EA["slice"](EM + 0x1));
                            var Ep = rF("Patches")["$"];
                            return r4(EI)
                                ? Ep(EI, EA)
                                : this["produce"](EI, function (Ek) {
                                      return Ep(Ek, EA);
                                  });
                        }),
                        Ef
                    );
                })(),
                rs = new rV(),
                rJ = rs["produce"],
                rG = (rs["produceWithPatches"]["bind"](rs), rs["setAutoFreeze"]["bind"](rs), rs["setUseProxies"]["bind"](rs), rs["applyPatches"]["bind"](rs), rs["createDraft"]["bind"](rs), rs["finishDraft"]["bind"](rs), rJ),
                rL = r2(0x3df1);
            function rQ(Ef) {
                return function (EP) {
                    var EI = EP["dispatch"],
                        EA = EP["getState"];
                    return function (EM) {
                        return function (Eo) {
                            return "function" == typeof Eo ? Eo(EI, EA, Ef) : EM(Eo);
                        };
                    };
                };
            }
            var rz = rQ();
            rz["withExtraArgument"] = rQ;
            var E0,
                E1 = rz,
                E2 =
                    ((E0 = function (Ef, EP) {
                        return (
                            (E0 =
                                Object["setPrototypeOf"] ||
                                ({ __proto__: [] } instanceof Array &&
                                    function (EI, EA) {
                                        EI["__proto__"] = EA;
                                    }) ||
                                function (EI, EA) {
                                    for (var EM in EA) Object["prototype"]["hasOwnProperty"]["call"](EA, EM) && (EI[EM] = EA[EM]);
                                }),
                            E0(Ef, EP)
                        );
                    }),
                    function (Ef, EP) {
                        if ("function" != typeof EP && null !== EP) throw new TypeError("Class\x20extends\x20value\x20" + String(EP) + "\x20is\x20not\x20a\x20constructor\x20or\x20null");
                        function EI() {
                            this["constructor"] = Ef;
                        }
                        E0(Ef, EP), (Ef["prototype"] = null === EP ? Object["create"](EP) : ((EI["prototype"] = EP["prototype"]), new EI()));
                    }),
                E3 = function (Ef, EP) {
                    var EI,
                        EA,
                        EM,
                        Eo,
                        Ep = {
                            label: 0x0,
                            sent: function () {
                                if (0x1 & EM[0x0]) throw EM[0x1];
                                return EM[0x1];
                            },
                            trys: [],
                            ops: [],
                        };
                    return (
                        (Eo = { next: Ek(0x0), throw: Ek(0x1), return: Ek(0x2) }),
                        "function" == typeof Symbol &&
                            (Eo[Symbol["iterator"]] = function () {
                                return this;
                            }),
                        Eo
                    );
                    function Ek(Ee) {
                        return function (El) {
                            return (function (EU) {
                                if (EI) throw new TypeError("Generator\x20is\x20already\x20executing.");
                                for (; Ep; )
                                    try {
                                        if (((EI = 0x1), EA && (EM = 0x2 & EU[0x0] ? EA["return"] : EU[0x0] ? EA["throw"] || ((EM = EA["return"]) && EM["call"](EA), 0x0) : EA["next"]) && !(EM = EM["call"](EA, EU[0x1]))["done"])) return EM;
                                        switch (((EA = 0x0), EM && (EU = [0x2 & EU[0x0], EM["value"]]), EU[0x0])) {
                                            case 0x0:
                                            case 0x1:
                                                EM = EU;
                                                break;
                                            case 0x4:
                                                return Ep["label"]++, { value: EU[0x1], done: !0x1 };
                                            case 0x5:
                                                Ep["label"]++, (EA = EU[0x1]), (EU = [0x0]);
                                                continue;
                                            case 0x7:
                                                (EU = Ep["ops"]["pop"]()), Ep["trys"]["pop"]();
                                                continue;
                                            default:
                                                if (!((EM = Ep["trys"]), (EM = EM["length"] > 0x0 && EM[EM["length"] - 0x1]) || (0x6 !== EU[0x0] && 0x2 !== EU[0x0]))) {
                                                    Ep = 0x0;
                                                    continue;
                                                }
                                                if (0x3 === EU[0x0] && (!EM || (EU[0x1] > EM[0x0] && EU[0x1] < EM[0x3]))) {
                                                    Ep["label"] = EU[0x1];
                                                    break;
                                                }
                                                if (0x6 === EU[0x0] && Ep["label"] < EM[0x1]) {
                                                    (Ep["label"] = EM[0x1]), (EM = EU);
                                                    break;
                                                }
                                                if (EM && Ep["label"] < EM[0x2]) {
                                                    (Ep["label"] = EM[0x2]), Ep["ops"]["push"](EU);
                                                    break;
                                                }
                                                EM[0x2] && Ep["ops"]["pop"](), Ep["trys"]["pop"]();
                                                continue;
                                        }
                                        EU = EP["call"](Ef, Ep);
                                    } catch (Eq) {
                                        (EU = [0x6, Eq]), (EA = 0x0);
                                    } finally {
                                        EI = EM = 0x0;
                                    }
                                if (0x5 & EU[0x0]) throw EU[0x1];
                                return { value: EU[0x0] ? EU[0x1] : void 0x0, done: !0x0 };
                            })([Ee, El]);
                        };
                    }
                },
                E4 = function (Ef, EP) {
                    for (var EI = 0x0, EA = EP["length"], EM = Ef["length"]; EI < EA; EI++, EM++) Ef[EM] = EP[EI];
                    return Ef;
                },
                E5 = Object["defineProperty"],
                E6 = Object["defineProperties"],
                E7 = Object["getOwnPropertyDescriptors"],
                E8 = Object["getOwnPropertySymbols"],
                E9 = Object["prototype"]["hasOwnProperty"],
                Er = Object["prototype"]["propertyIsEnumerable"],
                EE = function (Ef, EP, EI) {
                    return EP in Ef ? E5(Ef, EP, { enumerable: !0x0, configurable: !0x0, writable: !0x0, value: EI }) : (Ef[EP] = EI);
                },
                ER = function (Ef, EP) {
                    for (var EI in EP || (EP = {})) E9["call"](EP, EI) && EE(Ef, EI, EP[EI]);
                    if (E8)
                        for (var EA = 0x0, EM = E8(EP); EA < EM["length"]; EA++) {
                            (EI = EM[EA]), Er["call"](EP, EI) && EE(Ef, EI, EP[EI]);
                        }
                    return Ef;
                },
                ET = function (Ef, EP) {
                    return E6(Ef, E7(EP));
                },
                EC =
                    "undefined" != typeof window && window["__REDUX_DEVTOOLS_EXTENSION_COMPOSE__"]
                        ? window["__REDUX_DEVTOOLS_EXTENSION_COMPOSE__"]
                        : function () {
                              if (0x0 !== arguments["length"]) return "object" == typeof arguments[0x0] ? rL["qC"] : rL["qC"]["apply"](null, arguments);
                          };
            "undefined" != typeof window && window["__REDUX_DEVTOOLS_EXTENSION__"] && window["__REDUX_DEVTOOLS_EXTENSION__"];
            function Ed(Ef) {
                if ("object" != typeof Ef || null === Ef) return !0x1;
                for (var EP = Ef; null !== Object["getPrototypeOf"](EP); ) EP = Object["getPrototypeOf"](EP);
                return Object["getPrototypeOf"](Ef) === EP;
            }
            var EY = (function (Ef) {
                function EP() {
                    for (var EI = [], EA = 0x0; EA < arguments["length"]; EA++) EI[EA] = arguments[EA];
                    var EM = Ef["apply"](this, EI) || this;
                    return Object["setPrototypeOf"](EM, EP["prototype"]), EM;
                }
                return (
                    E2(EP, Ef),
                    Object["defineProperty"](EP, Symbol["species"], {
                        get: function () {
                            return EP;
                        },
                        enumerable: !0x1,
                        configurable: !0x0,
                    }),
                    (EP["prototype"]["concat"] = function () {
                        for (var EI = [], EA = 0x0; EA < arguments["length"]; EA++) EI[EA] = arguments[EA];
                        return Ef["prototype"]["concat"]["apply"](this, EI);
                    }),
                    (EP["prototype"]["prepend"] = function () {
                        for (var EI = [], EA = 0x0; EA < arguments["length"]; EA++) EI[EA] = arguments[EA];
                        return 0x1 === EI["length"] && Array["isArray"](EI[0x0]) ? new (EP["bind"]["apply"](EP, E4([void 0x0], EI[0x0]["concat"](this))))() : new (EP["bind"]["apply"](EP, E4([void 0x0], EI["concat"](this))))();
                    }),
                    EP
                );
            })(Array);
            function En() {
                return function (Ef) {
                    return (function (EP) {
                        void 0x0 === EP && (EP = {});
                        var EI = EP["thunk"],
                            EA = void 0x0 === EI || EI,
                            EM = (EP["immutableCheck"], EP["serializableCheck"], new EY());
                        return (
                            EA &&
                                (!(function (Eo) {
                                    return "boolean" == typeof Eo;
                                })(EA)
                                    ? EM["push"](E1["withExtraArgument"](EA["extraArgument"]))
                                    : EM["push"](E1)),
                            0x0,
                            EM
                        );
                    })(Ef);
                };
            }
            function EB(Ef) {
                var EP,
                    EI = En(),
                    EA = Ef || {},
                    EM = EA["reducer"],
                    Eo = void 0x0 === EM ? void 0x0 : EM,
                    Ep = EA["middleware"],
                    Ek = void 0x0 === Ep ? EI() : Ep,
                    Ee = EA["devTools"],
                    El = void 0x0 === Ee || Ee,
                    EU = EA["preloadedState"],
                    Eq = void 0x0 === EU ? void 0x0 : EU,
                    Ew = EA["enhancers"],
                    EO = void 0x0 === Ew ? void 0x0 : Ew;
                if ("function" == typeof Eo) EP = Eo;
                else {
                    if (!Ed(Eo)) throw new Error("\x22reducer\x22\x20is\x20a\x20required\x20argument,\x20and\x20must\x20be\x20a\x20function\x20or\x20an\x20object\x20of\x20functions\x20that\x20can\x20be\x20passed\x20to\x20combineReducers");
                    EP = (0x0, rL["UY"])(Eo);
                }
                var Ej = Ek;
                "function" == typeof Ej && (Ej = Ej(EI));
                var Ei = rL["md"]["apply"](void 0x0, Ej),
                    Eh = rL["qC"];
                El && (Eh = EC(ER({ trace: !0x1 }, "object" == typeof El && El)));
                var Ea = [Ei];
                Array["isArray"](EO) ? (Ea = E4([Ei], EO)) : "function" == typeof EO && (Ea = EO(Ea));
                var Ec = Eh["apply"](void 0x0, Ea);
                return (0x0, rL["MT"])(EP, Eq, Ec);
            }
            function EF(Ef, EP) {
                function EI() {
                    for (var EA = [], EM = 0x0; EM < arguments["length"]; EM++) EA[EM] = arguments[EM];
                    if (EP) {
                        var Eo = EP["apply"](void 0x0, EA);
                        if (!Eo) throw new Error("prepareAction\x20did\x20not\x20return\x20an\x20object");
                        return ER(ER({ type: Ef, payload: Eo["payload"] }, "meta" in Eo && { meta: Eo["meta"] }), "error" in Eo && { error: Eo["error"] });
                    }
                    return { type: Ef, payload: EA[0x0] };
                }
                return (
                    (EI["toString"] = function () {
                        return "" + Ef;
                    }),
                    (EI["type"] = Ef),
                    (EI["match"] = function (EA) {
                        return EA["type"] === Ef;
                    }),
                    EI
                );
            }
            function Eb(Ef) {
                var EP,
                    EI = {},
                    EA = [],
                    EM = {
                        addCase: function (Eo, Ep) {
                            var Ek = "string" == typeof Eo ? Eo : Eo["type"];
                            if (Ek in EI) throw new Error("addCase\x20cannot\x20be\x20called\x20with\x20two\x20reducers\x20for\x20the\x20same\x20action\x20type");
                            return (EI[Ek] = Ep), EM;
                        },
                        addMatcher: function (Eo, Ep) {
                            return EA["push"]({ matcher: Eo, reducer: Ep }), EM;
                        },
                        addDefaultCase: function (Eo) {
                            return (EP = Eo), EM;
                        },
                    };
                return Ef(EM), [EI, EA, EP];
            }
            function EZ(Ef) {
                var EP = Ef["name"],
                    EI = Ef["initialState"];
                if (!EP) throw new Error("`name`\x20is\x20a\x20required\x20option\x20for\x20createSlice");
                var EA = Ef["reducers"] || {},
                    EM = "function" == typeof Ef["extraReducers"] ? Eb(Ef["extraReducers"]) : [Ef["extraReducers"]],
                    Eo = EM[0x0],
                    Ep = void 0x0 === Eo ? {} : Eo,
                    Ek = EM[0x1],
                    Ee = void 0x0 === Ek ? [] : Ek,
                    El = EM[0x2],
                    EU = void 0x0 === El ? void 0x0 : El,
                    Eq = Object["keys"](EA),
                    Ew = {},
                    EO = {},
                    Ej = {};
                Eq["forEach"](function (Eh) {
                    var Ea,
                        Ec,
                        ES = EA[Eh],
                        Eg = EP + "/" + Eh;
                    "reducer" in ES ? ((Ea = ES["reducer"]), (Ec = ES["prepare"])) : (Ea = ES), (Ew[Eh] = Ea), (EO[Eg] = Ea), (Ej[Eh] = Ec ? EF(Eg, Ec) : EF(Eg));
                });
                var Ei = (function (Eh, Ea, Ec, ES) {
                    void 0x0 === Ec && (Ec = []);
                    var Eg = "function" == typeof Ea ? Eb(Ea) : [Ea, Ec, ES],
                        EW = Eg[0x0],
                        EH = Eg[0x1],
                        Ex = Eg[0x2],
                        EK = rG(Eh, function () {});
                    return function (EV, Es) {
                        void 0x0 === EV && (EV = EK);
                        var EJ = E4(
                            [EW[Es["type"]]],
                            EH["filter"](function (EG) {
                                return (0x0, EG["matcher"])(Es);
                            })["map"](function (EG) {
                                return EG["reducer"];
                            })
                        );
                        return (
                            0x0 ===
                                EJ["filter"](function (EG) {
                                    return !!EG;
                                })["length"] && (EJ = [Ex]),
                            EJ["reduce"](function (EG, EL) {
                                if (EL) {
                                    var EQ;
                                    if (r4(EG)) return void 0x0 === (EQ = EL(EG, Es)) ? EG : EQ;
                                    if (r5(EG))
                                        return rG(EG, function (Ez) {
                                            return EL(Ez, Es);
                                        });
                                    if (void 0x0 === (EQ = EL(EG, Es))) {
                                        if (null === EG) return EG;
                                        throw Error("A\x20case\x20reducer\x20on\x20a\x20non-draftable\x20value\x20must\x20not\x20return\x20undefined");
                                    }
                                    return EQ;
                                }
                                return EG;
                            }, EV)
                        );
                    };
                })(EI, ER(ER({}, Ep), EO), Ee, EU);
                return { name: EP, reducer: Ei, actions: Ej, caseReducers: Ew };
            }
            var Em = function (Ef) {
                    void 0x0 === Ef && (Ef = 0x15);
                    for (var EP = "", EI = Ef; EI--; ) EP += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[(0x40 * Math["random"]()) | 0x0];
                    return EP;
                },
                Ev = ["name", "message", "stack", "code"],
                Eu = function (Ef, EP) {
                    (this["payload"] = Ef), (this["meta"] = EP);
                },
                Ey = function (Ef, EP) {
                    (this["payload"] = Ef), (this["meta"] = EP);
                },
                ED = function (Ef) {
                    if ("object" == typeof Ef && null !== Ef) {
                        for (var EP = {}, EI = 0x0, EA = Ev; EI < EA["length"]; EI++) {
                            var EM = EA[EI];
                            "string" == typeof Ef[EM] && (EP[EM] = Ef[EM]);
                        }
                        return EP;
                    }
                    return { message: String(Ef) };
                };
            function EN(Ef, EP, EI) {
                var EA = EF(Ef + "/fulfilled", function (Ek, Ee, El, EU) {
                        return { payload: Ek, meta: ET(ER({}, EU || {}), { arg: El, requestId: Ee, requestStatus: "fulfilled" }) };
                    }),
                    EM = EF(Ef + "/pending", function (Ek, Ee, El) {
                        return { payload: void 0x0, meta: ET(ER({}, El || {}), { arg: Ee, requestId: Ek, requestStatus: "pending" }) };
                    }),
                    Eo = EF(Ef + "/rejected", function (Ek, Ee, El, EU, Eq) {
                        return {
                            payload: EU,
                            error: ((EI && EI["serializeError"]) || ED)(Ek || "Rejected"),
                            meta: ET(ER({}, Eq || {}), {
                                arg: El,
                                requestId: Ee,
                                rejectedWithValue: !!EU,
                                requestStatus: "rejected",
                                aborted: "AbortError" === (null == Ek ? void 0x0 : Ek["name"]),
                                condition: "ConditionError" === (null == Ek ? void 0x0 : Ek["name"]),
                            }),
                        };
                    }),
                    Ep =
                        "undefined" != typeof AbortController
                            ? AbortController
                            : (function () {
                                  function Ek() {
                                      this["signal"] = {
                                          aborted: !0x1,
                                          addEventListener: function () {},
                                          dispatchEvent: function () {
                                              return !0x1;
                                          },
                                          onabort: function () {},
                                          removeEventListener: function () {},
                                      };
                                  }
                                  return (
                                      (Ek["prototype"]["abort"] = function () {
                                          0x0;
                                      }),
                                      Ek
                                  );
                              })();
                return Object["assign"](
                    function (Ek) {
                        return function (Ee, El, EU) {
                            var Eq,
                                Ew,
                                EO = (null != (Eq = null == EI ? void 0x0 : EI["idGenerator"]) ? Eq : Em)(),
                                Ej = new Ep(),
                                Ei = new Promise(function (Ec, ES) {
                                    return Ej["signal"]["addEventListener"]("abort", function () {
                                        return ES({ name: "AbortError", message: Ew || "Aborted" });
                                    });
                                }),
                                Eh = !0x1,
                                Ea = (function () {
                                    return (
                                        (Ec = this),
                                        (ES = null),
                                        (Eg = function () {
                                            var EW, EH, Ex;
                                            return E3(this, function (EK) {
                                                switch (EK["label"]) {
                                                    case 0x0:
                                                        if ((EK["trys"]["push"]([0x0, 0x2, , 0x3]), EI && EI["condition"] && !0x1 === EI["condition"](Ek, { getState: El, extra: EU })))
                                                            throw { name: "ConditionError", message: "Aborted\x20due\x20to\x20condition\x20callback\x20returning\x20false." };
                                                        return (
                                                            (Eh = !0x0),
                                                            Ee(EM(EO, Ek, null == (EW = null == EI ? void 0x0 : EI["getPendingMeta"]) ? void 0x0 : EW["call"](EI, { requestId: EO, arg: Ek }, { getState: El, extra: EU }))),
                                                            [
                                                                0x4,
                                                                Promise["race"]([
                                                                    Ei,
                                                                    Promise["resolve"](
                                                                        EP(Ek, {
                                                                            dispatch: Ee,
                                                                            getState: El,
                                                                            extra: EU,
                                                                            requestId: EO,
                                                                            signal: Ej["signal"],
                                                                            rejectWithValue: function (EV, Es) {
                                                                                return new Eu(EV, Es);
                                                                            },
                                                                            fulfillWithValue: function (EV, Es) {
                                                                                return new Ey(EV, Es);
                                                                            },
                                                                        })
                                                                    )["then"](function (EV) {
                                                                        if (EV instanceof Eu) throw EV;
                                                                        return EV instanceof Ey ? EA(EV["payload"], EO, Ek, EV["meta"]) : EA(EV, EO, Ek);
                                                                    }),
                                                                ]),
                                                            ]
                                                        );
                                                    case 0x1:
                                                        return (EH = EK["sent"]()), [0x3, 0x3];
                                                    case 0x2:
                                                        return (Ex = EK["sent"]()), (EH = Ex instanceof Eu ? Eo(null, EO, Ek, Ex["payload"], Ex["meta"]) : Eo(Ex, EO, Ek)), [0x3, 0x3];
                                                    case 0x3:
                                                        return (EI && !EI["dispatchConditionRejection"] && Eo["match"](EH) && EH["meta"]["condition"]) || Ee(EH), [0x2, EH];
                                                }
                                            });
                                        }),
                                        new Promise(function (EW, EH) {
                                            var Ex = function (Es) {
                                                    try {
                                                        EV(Eg["next"](Es));
                                                    } catch (EJ) {
                                                        EH(EJ);
                                                    }
                                                },
                                                EK = function (Es) {
                                                    try {
                                                        EV(Eg["throw"](Es));
                                                    } catch (EJ) {
                                                        EH(EJ);
                                                    }
                                                },
                                                EV = function (Es) {
                                                    return Es["done"] ? EW(Es["value"]) : Promise["resolve"](Es["value"])["then"](Ex, EK);
                                                };
                                            EV((Eg = Eg["apply"](Ec, ES))["next"]());
                                        })
                                    );
                                    var Ec, ES, Eg;
                                })();
                            return Object["assign"](Ea, {
                                abort: function (Ec) {
                                    Eh && ((Ew = Ec), Ej["abort"]());
                                },
                                requestId: EO,
                                arg: Ek,
                                unwrap: function () {
                                    return Ea["then"](EX);
                                },
                            });
                        };
                    },
                    { pending: EM, rejected: Eo, fulfilled: EA, typePrefix: Ef }
                );
            }
            function EX(Ef) {
                if (Ef["meta"] && Ef["meta"]["rejectedWithValue"]) throw Ef["payload"];
                if (Ef["error"]) throw Ef["error"];
                return Ef["payload"];
            }
            rl();
        },
        0xa837: function (r, E) {
            function R(T) {
                if (T)
                    return (function (C) {
                        for (var d in R["prototype"]) C[d] = R["prototype"][d];
                        return C;
                    })(T);
            }
            (E["Q"] = R),
                (R["prototype"]["on"] = R["prototype"]["addEventListener"] = function (T, C) {
                    return (this["_callbacks"] = this["_callbacks"] || {}), (this["_callbacks"]["$" + T] = this["_callbacks"]["$" + T] || [])["push"](C), this;
                }),
                (R["prototype"]["once"] = function (T, C) {
                    function d() {
                        this["off"](T, d), C["apply"](this, arguments);
                    }
                    return (d["fn"] = C), this["on"](T, d), this;
                }),
                (R["prototype"]["off"] = R["prototype"]["removeListener"] = R["prototype"]["removeAllListeners"] = R["prototype"]["removeEventListener"] = function (T, C) {
                    if (((this["_callbacks"] = this["_callbacks"] || {}), 0x0 == arguments["length"])) return (this["_callbacks"] = {}), this;
                    var d,
                        Y = this["_callbacks"]["$" + T];
                    if (!Y) return this;
                    if (0x1 == arguments["length"]) return delete this["_callbacks"]["$" + T], this;
                    for (var B = 0x0; B < Y["length"]; B++)
                        if ((d = Y[B]) === C || d["fn"] === C) {
                            Y["splice"](B, 0x1);
                            break;
                        }
                    return 0x0 === Y["length"] && delete this["_callbacks"]["$" + T], this;
                }),
                (R["prototype"]["emit"] = function (T) {
                    this["_callbacks"] = this["_callbacks"] || {};
                    for (var C = new Array(arguments["length"] - 0x1), d = this["_callbacks"]["$" + T], Y = 0x1; Y < arguments["length"]; Y++) C[Y - 0x1] = arguments[Y];
                    if (d) {
                        Y = 0x0;
                        for (var B = (d = d["slice"](0x0))["length"]; Y < B; ++Y) d[Y]["apply"](this, C);
                    }
                    return this;
                }),
                (R["prototype"]["emitReserved"] = R["prototype"]["emit"]),
                (R["prototype"]["listeners"] = function (T) {
                    return (this["_callbacks"] = this["_callbacks"] || {}), this["_callbacks"]["$" + T] || [];
                }),
                (R["prototype"]["hasListeners"] = function (T) {
                    return !!this["listeners"](T)["length"];
                });
        },
        0xa802: function (r) {
            function E(R) {
                (R = R || {}),
                    (this["ms"] = R["min"] || 0x64),
                    (this["max"] = R["max"] || 0x2710),
                    (this["factor"] = R["factor"] || 0x2),
                    (this["jitter"] = R["jitter"] > 0x0 && R["jitter"] <= 0x1 ? R["jitter"] : 0x0),
                    (this["attempts"] = 0x0);
            }
            (r["exports"] = E),
                (E["prototype"]["duration"] = function () {
                    var R = this["ms"] * Math["pow"](this["factor"], this["attempts"]++);
                    if (this["jitter"]) {
                        var T = Math["random"](),
                            C = Math["floor"](T * this["jitter"] * R);
                        R = 0x0 == (0x1 & Math["floor"](0xa * T)) ? R - C : R + C;
                    }
                    return 0x0 | Math["min"](R, this["max"]);
                }),
                (E["prototype"]["reset"] = function () {
                    this["attempts"] = 0x0;
                }),
                (E["prototype"]["setMin"] = function (R) {
                    this["ms"] = R;
                }),
                (E["prototype"]["setMax"] = function (R) {
                    this["max"] = R;
                }),
                (E["prototype"]["setJitter"] = function (R) {
                    this["jitter"] = R;
                });
        },
        0x94aa: function (r) {
            try {
                r["exports"] = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
            } catch (E) {
                r["exports"] = !0x1;
            }
        },
        0x15fd7: function (Y, B, F) {
            "use strict";
            F["d"](B, {
                lX: function () {
                    return r2;
                },
                q_: function () {
                    return r8;
                },
                ob: function () {
                    return K;
                },
                PP: function () {
                    return rr;
                },
                Ep: function () {
                    return H;
                },
                Hp: function () {
                    return V;
                },
            });
            var Z = F(0x155a6);
            function D(rE) {
                return "/" === rE["charAt"](0x0);
            }
            function N(rE, rR) {
                for (var rT = rR, rC = rT + 0x1, rd = rE["length"]; rC < rd; rT += 0x1, rC += 0x1) rE[rT] = rE[rC];
                rE["pop"]();
            }
            var X = function (rE, rR) {
                void 0x0 === rR && (rR = "");
                var rT,
                    rC = (rE && rE["split"]("/")) || [],
                    rd = (rR && rR["split"]("/")) || [],
                    rY = rE && D(rE),
                    rn = rR && D(rR),
                    rB = rY || rn;
                if ((rE && D(rE) ? (rd = rC) : rC["length"] && (rd["pop"](), (rd = rd["concat"](rC))), !rd["length"])) return "/";
                if (rd["length"]) {
                    var rF = rd[rd["length"] - 0x1];
                    rT = "." === rF || ".." === rF || "" === rF;
                } else rT = !0x1;
                for (var rb = 0x0, rZ = rd["length"]; rZ >= 0x0; rZ--) {
                    var rm = rd[rZ];
                    "." === rm ? N(rd, rZ) : ".." === rm ? (N(rd, rZ), rb++) : rb && (N(rd, rZ), rb--);
                }
                if (!rB) {
                    for (; rb--; rb) rd["unshift"]("..");
                }
                !rB || "" === rd[0x0] || (rd[0x0] && D(rd[0x0])) || rd["unshift"]("");
                var rv = rd["join"]("/");
                return rT && "/" !== rv["substr"](-0x1) && (rv += "/"), rv;
            };
            function P(rE) {
                return rE["valueOf"] ? rE["valueOf"]() : Object["prototype"]["valueOf"]["call"](rE);
            }
            var I = function rE(rR, rT) {
                    if (rR === rT) return !0x0;
                    if (null == rR || null == rT) return !0x1;
                    if (Array["isArray"](rR))
                        return (
                            Array["isArray"](rT) &&
                            rR["length"] === rT["length"] &&
                            rR["every"](function (rY, rn) {
                                return rE(rY, rT[rn]);
                            })
                        );
                    if ("object" == typeof rR || "object" == typeof rT) {
                        var rC = P(rR),
                            rd = P(rT);
                        return rC !== rR || rd !== rT
                            ? rE(rC, rd)
                            : Object["keys"](Object["assign"]({}, rR, rT))["every"](function (rY) {
                                  return rE(rR[rY], rT[rY]);
                              });
                    }
                    return !0x1;
                },
                k = F(0x881);
            function U(rR) {
                return "/" === rR["charAt"](0x0) ? rR : "/" + rR;
            }
            function q(rR) {
                return "/" === rR["charAt"](0x0) ? rR["substr"](0x1) : rR;
            }
            function j(rR, rT) {
                return (function (rC, rd) {
                    return 0x0 === rC["toLowerCase"]()["indexOf"](rd["toLowerCase"]()) && -0x1 !== "/?#"["indexOf"](rC["charAt"](rd["length"]));
                })(rR, rT)
                    ? rR["substr"](rT["length"])
                    : rR;
            }
            function W(rR) {
                return "/" === rR["charAt"](rR["length"] - 0x1) ? rR["slice"](0x0, -0x1) : rR;
            }
            function H(rR) {
                var rT = rR["pathname"],
                    rC = rR["search"],
                    rd = rR["hash"],
                    rY = rT || "/";
                return rC && "?" !== rC && (rY += "?" === rC["charAt"](0x0) ? rC : "?" + rC), rd && "#" !== rd && (rY += "#" === rd["charAt"](0x0) ? rd : "#" + rd), rY;
            }
            function K(rR, rT, rC, rd) {
                var rY;
                "string" == typeof rR
                    ? ((rY = (function (rn) {
                          var rB = rn || "/",
                              rF = "",
                              rb = "",
                              rZ = rB["indexOf"]("#");
                          -0x1 !== rZ && ((rb = rB["substr"](rZ)), (rB = rB["substr"](0x0, rZ)));
                          var rm = rB["indexOf"]("?");
                          return -0x1 !== rm && ((rF = rB["substr"](rm)), (rB = rB["substr"](0x0, rm))), { pathname: rB, search: "?" === rF ? "" : rF, hash: "#" === rb ? "" : rb };
                      })(rR)),
                      (rY["state"] = rT))
                    : (void 0x0 === (rY = (0x0, Z["Z"])({}, rR))["pathname"] && (rY["pathname"] = ""),
                      rY["search"] ? "?" !== rY["search"]["charAt"](0x0) && (rY["search"] = "?" + rY["search"]) : (rY["search"] = ""),
                      rY["hash"] ? "#" !== rY["hash"]["charAt"](0x0) && (rY["hash"] = "#" + rY["hash"]) : (rY["hash"] = ""),
                      void 0x0 !== rT && void 0x0 === rY["state"] && (rY["state"] = rT));
                try {
                    rY["pathname"] = decodeURI(rY["pathname"]);
                } catch (rn) {
                    throw rn instanceof URIError ? new URIError("Pathname\x20\x22" + rY["pathname"] + "\x22\x20could\x20not\x20be\x20decoded.\x20This\x20is\x20likely\x20caused\x20by\x20an\x20invalid\x20percent-encoding.") : rn;
                }
                return (
                    rC && (rY["key"] = rC),
                    rd ? (rY["pathname"] ? "/" !== rY["pathname"]["charAt"](0x0) && (rY["pathname"] = X(rY["pathname"], rd["pathname"])) : (rY["pathname"] = rd["pathname"])) : rY["pathname"] || (rY["pathname"] = "/"),
                    rY
                );
            }
            function V(rR, rT) {
                return rR["pathname"] === rT["pathname"] && rR["search"] === rT["search"] && rR["hash"] === rT["hash"] && rR["key"] === rT["key"] && I(rR["state"], rT["state"]);
            }
            function J() {
                var rR = null,
                    rT = [];
                return {
                    setPrompt: function (rC) {
                        return (
                            (rR = rC),
                            function () {
                                rR === rC && (rR = null);
                            }
                        );
                    },
                    confirmTransitionTo: function (rC, rd, rY, rn) {
                        if (null != rR) {
                            var rB = "function" == typeof rR ? rR(rC, rd) : rR;
                            "string" == typeof rB ? ("function" == typeof rY ? rY(rB, rn) : rn(!0x0)) : rn(!0x1 !== rB);
                        } else rn(!0x0);
                    },
                    appendListener: function (rC) {
                        var rd = !0x0;
                        function rY() {
                            rd && rC["apply"](void 0x0, arguments);
                        }
                        return (
                            rT["push"](rY),
                            function () {
                                (rd = !0x1),
                                    (rT = rT["filter"](function (rn) {
                                        return rn !== rY;
                                    }));
                            }
                        );
                    },
                    notifyListeners: function () {
                        for (var rC = arguments["length"], rd = new Array(rC), rY = 0x0; rY < rC; rY++) rd[rY] = arguments[rY];
                        rT["forEach"](function (rn) {
                            return rn["apply"](void 0x0, rd);
                        });
                    },
                };
            }
            var G = !("undefined" == typeof window || !window["document"] || !window["document"]["createElement"]);
            function Q(rR, rT) {
                rT(window["confirm"](rR));
            }
            var z = "popstate",
                r0 = "hashchange";
            function r1() {
                try {
                    return window["history"]["state"] || {};
                } catch (rR) {
                    return {};
                }
            }
            function r2(rR) {
                void 0x0 === rR && (rR = {}), G || (0x0, k["Z"])(!0x1);
                var rT,
                    rC = window["history"],
                    rd =
                        ((-0x1 === (rT = window["navigator"]["userAgent"])["indexOf"]("Android\x202.") && -0x1 === rT["indexOf"]("Android\x204.0")) ||
                            -0x1 === rT["indexOf"]("Mobile\x20Safari") ||
                            -0x1 !== rT["indexOf"]("Chrome") ||
                            -0x1 !== rT["indexOf"]("Windows\x20Phone")) &&
                        window["history"] &&
                        "pushState" in window["history"],
                    rY = !(-0x1 === window["navigator"]["userAgent"]["indexOf"]("Trident")),
                    rn = rR,
                    rB = rn["forceRefresh"],
                    rF = void 0x0 !== rB && rB,
                    rb = rn["getUserConfirmation"],
                    rZ = void 0x0 === rb ? Q : rb,
                    rm = rn["keyLength"],
                    rv = void 0x0 === rm ? 0x6 : rm,
                    ru = rR["basename"] ? W(U(rR["basename"])) : "";
                function ry(rq) {
                    var rw = rq || {},
                        rO = rw["key"],
                        rj = rw["state"],
                        ri = window["location"],
                        rh = ri["pathname"] + ri["search"] + ri["hash"];
                    return ru && (rh = j(rh, ru)), K(rh, rj, rO);
                }
                function rD() {
                    return Math["random"]()["toString"](0x24)["substr"](0x2, rv);
                }
                var rN = J();
                function rX(rq) {
                    (0x0, Z["Z"])(rU, rq), (rU["length"] = rC["length"]), rN["notifyListeners"](rU["location"], rU["action"]);
                }
                function rf(rq) {
                    (function (rw) {
                        return void 0x0 === rw["state"] && -0x1 === navigator["userAgent"]["indexOf"]("CriOS");
                    })(rq) || rA(ry(rq["state"]));
                }
                function rP() {
                    rA(ry(r1()));
                }
                var rI = !0x1;
                function rA(rq) {
                    if (rI) (rI = !0x1), rX();
                    else
                        rN["confirmTransitionTo"](rq, "POP", rZ, function (rw) {
                            rw
                                ? rX({ action: "POP", location: rq })
                                : (function (rO) {
                                      var rj = rU["location"],
                                          ri = ro["indexOf"](rj["key"]);
                                      -0x1 === ri && (ri = 0x0);
                                      var rh = ro["indexOf"](rO["key"]);
                                      -0x1 === rh && (rh = 0x0);
                                      var ra = ri - rh;
                                      ra && ((rI = !0x0), rp(ra));
                                  })(rq);
                        });
                }
                var rM = ry(r1()),
                    ro = [rM["key"]];
                function rt(rq) {
                    return ru + H(rq);
                }
                function rp(rq) {
                    rC["go"](rq);
                }
                var rk = 0x0;
                function re(rq) {
                    0x1 === (rk += rq) && 0x1 === rq ? (window["addEventListener"](z, rf), rY && window["addEventListener"](r0, rP)) : 0x0 === rk && (window["removeEventListener"](z, rf), rY && window["removeEventListener"](r0, rP));
                }
                var rl = !0x1,
                    rU = {
                        length: rC["length"],
                        action: "POP",
                        location: rM,
                        createHref: rt,
                        push: function (rq, rw) {
                            var rO = "PUSH",
                                rj = K(rq, rw, rD(), rU["location"]);
                            rN["confirmTransitionTo"](rj, rO, rZ, function (ri) {
                                if (ri) {
                                    var rh = rt(rj),
                                        ra = rj["key"],
                                        rc = rj["state"];
                                    if (rd) {
                                        if ((rC["pushState"]({ key: ra, state: rc }, null, rh), rF)) window["location"]["href"] = rh;
                                        else {
                                            var rS = ro["indexOf"](rU["location"]["key"]),
                                                rg = ro["slice"](0x0, rS + 0x1);
                                            rg["push"](rj["key"]), (ro = rg), rX({ action: rO, location: rj });
                                        }
                                    } else window["location"]["href"] = rh;
                                }
                            });
                        },
                        replace: function (rq, rw) {
                            var rO = "REPLACE",
                                rj = K(rq, rw, rD(), rU["location"]);
                            rN["confirmTransitionTo"](rj, rO, rZ, function (ri) {
                                if (ri) {
                                    var rh = rt(rj),
                                        ra = rj["key"],
                                        rc = rj["state"];
                                    if (rd) {
                                        if ((rC["replaceState"]({ key: ra, state: rc }, null, rh), rF)) window["location"]["replace"](rh);
                                        else {
                                            var rS = ro["indexOf"](rU["location"]["key"]);
                                            -0x1 !== rS && (ro[rS] = rj["key"]), rX({ action: rO, location: rj });
                                        }
                                    } else window["location"]["replace"](rh);
                                }
                            });
                        },
                        go: rp,
                        goBack: function () {
                            rp(-0x1);
                        },
                        goForward: function () {
                            rp(0x1);
                        },
                        block: function (rq) {
                            void 0x0 === rq && (rq = !0x1);
                            var rw = rN["setPrompt"](rq);
                            return (
                                rl || (re(0x1), (rl = !0x0)),
                                function () {
                                    return rl && ((rl = !0x1), re(-0x1)), rw();
                                }
                            );
                        },
                        listen: function (rq) {
                            var rw = rN["appendListener"](rq);
                            return (
                                re(0x1),
                                function () {
                                    re(-0x1), rw();
                                }
                            );
                        },
                    };
                return rU;
            }
            var r3 = "hashchange",
                r4 = {
                    hashbang: {
                        encodePath: function (rR) {
                            return "!" === rR["charAt"](0x0) ? rR : "!/" + q(rR);
                        },
                        decodePath: function (rR) {
                            return "!" === rR["charAt"](0x0) ? rR["substr"](0x1) : rR;
                        },
                    },
                    noslash: { encodePath: q, decodePath: U },
                    slash: { encodePath: U, decodePath: U },
                };
            function r5(rR) {
                var rT = rR["indexOf"]("#");
                return -0x1 === rT ? rR : rR["slice"](0x0, rT);
            }
            function r6() {
                var rR = window["location"]["href"],
                    rT = rR["indexOf"]("#");
                return -0x1 === rT ? "" : rR["substring"](rT + 0x1);
            }
            function r7(rR) {
                window["location"]["replace"](r5(window["location"]["href"]) + "#" + rR);
            }
            function r8(rR) {
                void 0x0 === rR && (rR = {}), G || (0x0, k["Z"])(!0x1);
                var rT = window["history"],
                    rC = (window["navigator"]["userAgent"]["indexOf"]("Firefox"), rR),
                    rd = rC["getUserConfirmation"],
                    rY = void 0x0 === rd ? Q : rd,
                    rn = rC["hashType"],
                    rB = void 0x0 === rn ? "slash" : rn,
                    rF = rR["basename"] ? W(U(rR["basename"])) : "",
                    rb = r4[rB],
                    rZ = rb["encodePath"],
                    rm = rb["decodePath"];
                function rv() {
                    var re = rm(r6());
                    return rF && (re = j(re, rF)), K(re);
                }
                var ru = J();
                function ry(re) {
                    (0x0, Z["Z"])(rk, re), (rk["length"] = rT["length"]), ru["notifyListeners"](rk["location"], rk["action"]);
                }
                var rD = !0x1,
                    rN = null;
                function rX() {
                    var re,
                        rl,
                        rU = r6(),
                        rq = rZ(rU);
                    if (rU !== rq) r7(rq);
                    else {
                        var rw = rv(),
                            rO = rk["location"];
                        if (!rD && ((rl = rw), (re = rO)["pathname"] === rl["pathname"] && re["search"] === rl["search"] && re["hash"] === rl["hash"])) return;
                        if (rN === H(rw)) return;
                        (rN = null),
                            (function (rj) {
                                if (rD) (rD = !0x1), ry();
                                else {
                                    var ri = "POP";
                                    ru["confirmTransitionTo"](rj, ri, rY, function (rh) {
                                        rh
                                            ? ry({ action: ri, location: rj })
                                            : (function (ra) {
                                                  var rc = rk["location"],
                                                      rS = rA["lastIndexOf"](H(rc));
                                                  -0x1 === rS && (rS = 0x0);
                                                  var rg = rA["lastIndexOf"](H(ra));
                                                  -0x1 === rg && (rg = 0x0);
                                                  var rW = rS - rg;
                                                  rW && ((rD = !0x0), rM(rW));
                                              })(rj);
                                    });
                                }
                            })(rw);
                    }
                }
                var rf = r6(),
                    rP = rZ(rf);
                rf !== rP && r7(rP);
                var rI = rv(),
                    rA = [H(rI)];
                function rM(re) {
                    rT["go"](re);
                }
                var ro = 0x0;
                function rt(re) {
                    0x1 === (ro += re) && 0x1 === re ? window["addEventListener"](r3, rX) : 0x0 === ro && window["removeEventListener"](r3, rX);
                }
                var rp = !0x1,
                    rk = {
                        length: rT["length"],
                        action: "POP",
                        location: rI,
                        createHref: function (re) {
                            var rl = document["querySelector"]("base"),
                                rU = "";
                            return rl && rl["getAttribute"]("href") && (rU = r5(window["location"]["href"])), rU + "#" + rZ(rF + H(re));
                        },
                        push: function (re, rl) {
                            var rU = "PUSH",
                                rq = K(re, void 0x0, void 0x0, rk["location"]);
                            ru["confirmTransitionTo"](rq, rU, rY, function (rw) {
                                if (rw) {
                                    var rO = H(rq),
                                        rj = rZ(rF + rO);
                                    if (r6() !== rj) {
                                        (rN = rO),
                                            (function (ra) {
                                                window["location"]["hash"] = ra;
                                            })(rj);
                                        var ri = rA["lastIndexOf"](H(rk["location"])),
                                            rh = rA["slice"](0x0, ri + 0x1);
                                        rh["push"](rO), (rA = rh), ry({ action: rU, location: rq });
                                    } else ry();
                                }
                            });
                        },
                        replace: function (re, rl) {
                            var rU = "REPLACE",
                                rq = K(re, void 0x0, void 0x0, rk["location"]);
                            ru["confirmTransitionTo"](rq, rU, rY, function (rw) {
                                if (rw) {
                                    var rO = H(rq),
                                        rj = rZ(rF + rO);
                                    r6() !== rj && ((rN = rO), r7(rj));
                                    var ri = rA["indexOf"](H(rk["location"]));
                                    -0x1 !== ri && (rA[ri] = rO), ry({ action: rU, location: rq });
                                }
                            });
                        },
                        go: rM,
                        goBack: function () {
                            rM(-0x1);
                        },
                        goForward: function () {
                            rM(0x1);
                        },
                        block: function (re) {
                            void 0x0 === re && (re = !0x1);
                            var rl = ru["setPrompt"](re);
                            return (
                                rp || (rt(0x1), (rp = !0x0)),
                                function () {
                                    return rp && ((rp = !0x1), rt(-0x1)), rl();
                                }
                            );
                        },
                        listen: function (re) {
                            var rl = ru["appendListener"](re);
                            return (
                                rt(0x1),
                                function () {
                                    rt(-0x1), rl();
                                }
                            );
                        },
                    };
                return rk;
            }
            function r9(rR, rT, rC) {
                return Math["min"](Math["max"](rR, rT), rC);
            }
            function rr(rR) {
                void 0x0 === rR && (rR = {});
                var rT = rR,
                    rC = rT["getUserConfirmation"],
                    rd = rT["initialEntries"],
                    rY = void 0x0 === rd ? ["/"] : rd,
                    rn = rT["initialIndex"],
                    rB = void 0x0 === rn ? 0x0 : rn,
                    rF = rT["keyLength"],
                    rb = void 0x0 === rF ? 0x6 : rF,
                    rZ = J();
                function rm(rf) {
                    (0x0, Z["Z"])(rX, rf), (rX["length"] = rX["entries"]["length"]), rZ["notifyListeners"](rX["location"], rX["action"]);
                }
                function rv() {
                    return Math["random"]()["toString"](0x24)["substr"](0x2, rb);
                }
                var ru = r9(rB, 0x0, rY["length"] - 0x1),
                    ry = rY["map"](function (rf) {
                        return K(rf, void 0x0, "string" == typeof rf ? rv() : rf["key"] || rv());
                    }),
                    rD = H;
                function rN(rf) {
                    var rP = r9(rX["index"] + rf, 0x0, rX["entries"]["length"] - 0x1),
                        rI = rX["entries"][rP];
                    rZ["confirmTransitionTo"](rI, "POP", rC, function (rA) {
                        rA ? rm({ action: "POP", location: rI, index: rP }) : rm();
                    });
                }
                var rX = {
                    length: ry["length"],
                    action: "POP",
                    location: ry[ru],
                    index: ru,
                    entries: ry,
                    createHref: rD,
                    push: function (rf, rP) {
                        var rI = "PUSH",
                            rA = K(rf, rP, rv(), rX["location"]);
                        rZ["confirmTransitionTo"](rA, rI, rC, function (rM) {
                            if (rM) {
                                var ro = rX["index"] + 0x1,
                                    rt = rX["entries"]["slice"](0x0);
                                rt["length"] > ro ? rt["splice"](ro, rt["length"] - ro, rA) : rt["push"](rA), rm({ action: rI, location: rA, index: ro, entries: rt });
                            }
                        });
                    },
                    replace: function (rf, rP) {
                        var rI = "REPLACE",
                            rA = K(rf, rP, rv(), rX["location"]);
                        rZ["confirmTransitionTo"](rA, rI, rC, function (rM) {
                            rM && ((rX["entries"][rX["index"]] = rA), rm({ action: rI, location: rA }));
                        });
                    },
                    go: rN,
                    goBack: function () {
                        rN(-0x1);
                    },
                    goForward: function () {
                        rN(0x1);
                    },
                    canGo: function (rf) {
                        var rP = rX["index"] + rf;
                        return rP >= 0x0 && rP < rX["entries"]["length"];
                    },
                    block: function (rf) {
                        return void 0x0 === rf && (rf = !0x1), rZ["setPrompt"](rf);
                    },
                    listen: function (rf) {
                        return rZ["appendListener"](rf);
                    },
                };
                return rX;
            }
        },
        0x21e7: function (E, R, T) {
            "use strict";
            var C = T(0x5330),
                Y = {
                    childContextTypes: !0x0,
                    contextType: !0x0,
                    contextTypes: !0x0,
                    defaultProps: !0x0,
                    displayName: !0x0,
                    getDefaultProps: !0x0,
                    getDerivedStateFromError: !0x0,
                    getDerivedStateFromProps: !0x0,
                    mixins: !0x0,
                    propTypes: !0x0,
                    type: !0x0,
                },
                B = { name: !0x0, length: !0x0, prototype: !0x0, caller: !0x0, callee: !0x0, arguments: !0x0, arity: !0x0 },
                F = { $$typeof: !0x0, compare: !0x0, defaultProps: !0x0, displayName: !0x0, propTypes: !0x0, type: !0x0 },
                b = {};
            function Z(I) {
                return C["isMemo"](I) ? F : b[I["$$typeof"]] || Y;
            }
            (b[C["ForwardRef"]] = { $$typeof: !0x0, render: !0x0, defaultProps: !0x0, displayName: !0x0, propTypes: !0x0 }), (b[C["Memo"]] = F);
            var m = Object["defineProperty"],
                y = Object["getOwnPropertyNames"],
                D = Object["getOwnPropertySymbols"],
                N = Object["getOwnPropertyDescriptor"],
                X = Object["getPrototypeOf"],
                P = Object["prototype"];
            E["exports"] = function I(A, M, k) {
                if ("string" != typeof M) {
                    if (P) {
                        var U = X(M);
                        U && U !== P && I(A, U, k);
                    }
                    var q = y(M);
                    D && (q = q["concat"](D(M)));
                    for (var w = Z(A), O = Z(M), j = 0x0; j < q["length"]; ++j) {
                        var S = q[j];
                        if (!(B[S] || (k && k[S]) || (O && O[S]) || (w && w[S]))) {
                            var W = N(M, S);
                            try {
                                m(A, S, W);
                            } catch (H) {}
                        }
                    }
                }
                return A;
            };
        },
        0x17767: function (R, T) {
            "use strict";
            var C = "function" == typeof Symbol && Symbol["for"],
                Y = C ? Symbol["for"]("react.element") : 0xeac7,
                B = C ? Symbol["for"]("react.portal") : 0xeaca,
                F = C ? Symbol["for"]("react.fragment") : 0xeacb,
                Z = C ? Symbol["for"]("react.strict_mode") : 0xeacc,
                D = C ? Symbol["for"]("react.profiler") : 0xead2,
                N = C ? Symbol["for"]("react.provider") : 0xeacd,
                X = C ? Symbol["for"]("react.context") : 0xeace,
                P = C ? Symbol["for"]("react.async_mode") : 0xeacf,
                I = C ? Symbol["for"]("react.concurrent_mode") : 0xeacf,
                A = C ? Symbol["for"]("react.forward_ref") : 0xead0,
                M = C ? Symbol["for"]("react.suspense") : 0xead1,
                k = C ? Symbol["for"]("react.suspense_list") : 0xead8,
                U = C ? Symbol["for"]("react.memo") : 0xead3,
                q = C ? Symbol["for"]("react.lazy") : 0xead4,
                O = C ? Symbol["for"]("react.block") : 0xead9,
                j = C ? Symbol["for"]("react.fundamental") : 0xead5,
                S = C ? Symbol["for"]("react.responder") : 0xead6,
                W = C ? Symbol["for"]("react.scope") : 0xead7;
            function H(K) {
                if ("object" == typeof K && null !== K) {
                    var V = K["$$typeof"];
                    switch (V) {
                        case Y:
                            switch ((K = K["type"])) {
                                case P:
                                case I:
                                case F:
                                case D:
                                case Z:
                                case M:
                                    return K;
                                default:
                                    switch ((K = K && K["$$typeof"])) {
                                        case X:
                                        case A:
                                        case q:
                                        case U:
                                        case N:
                                            return K;
                                        default:
                                            return V;
                                    }
                            }
                        case B:
                            return V;
                    }
                }
            }
            function x(K) {
                return H(K) === I;
            }
            (T["AsyncMode"] = P),
                (T["ConcurrentMode"] = I),
                (T["ContextConsumer"] = X),
                (T["ContextProvider"] = N),
                (T["Element"] = Y),
                (T["ForwardRef"] = A),
                (T["Fragment"] = F),
                (T["Lazy"] = q),
                (T["Memo"] = U),
                (T["Portal"] = B),
                (T["Profiler"] = D),
                (T["StrictMode"] = Z),
                (T["Suspense"] = M),
                (T["isAsyncMode"] = function (K) {
                    return x(K) || H(K) === P;
                }),
                (T["isConcurrentMode"] = x),
                (T["isContextConsumer"] = function (K) {
                    return H(K) === X;
                }),
                (T["isContextProvider"] = function (K) {
                    return H(K) === N;
                }),
                (T["isElement"] = function (K) {
                    return "object" == typeof K && null !== K && K["$$typeof"] === Y;
                }),
                (T["isForwardRef"] = function (K) {
                    return H(K) === A;
                }),
                (T["isFragment"] = function (K) {
                    return H(K) === F;
                }),
                (T["isLazy"] = function (K) {
                    return H(K) === q;
                }),
                (T["isMemo"] = function (K) {
                    return H(K) === U;
                }),
                (T["isPortal"] = function (K) {
                    return H(K) === B;
                }),
                (T["isProfiler"] = function (K) {
                    return H(K) === D;
                }),
                (T["isStrictMode"] = function (K) {
                    return H(K) === Z;
                }),
                (T["isSuspense"] = function (K) {
                    return H(K) === M;
                }),
                (T["isValidElementType"] = function (K) {
                    return (
                        "string" == typeof K ||
                        "function" == typeof K ||
                        K === F ||
                        K === I ||
                        K === D ||
                        K === Z ||
                        K === M ||
                        K === k ||
                        ("object" == typeof K &&
                            null !== K &&
                            (K["$$typeof"] === q || K["$$typeof"] === U || K["$$typeof"] === N || K["$$typeof"] === X || K["$$typeof"] === A || K["$$typeof"] === j || K["$$typeof"] === S || K["$$typeof"] === W || K["$$typeof"] === O))
                    );
                }),
                (T["typeOf"] = H);
        },
        0x5330: function (r, E, R) {
            "use strict";
            r["exports"] = R(0x17767);
        },
        0x6b1a: function (E) {
            "use strict";
            var R = Object["getOwnPropertySymbols"],
                T = Object["prototype"]["hasOwnProperty"],
                C = Object["prototype"]["propertyIsEnumerable"];
            function d(Y) {
                if (null == Y) throw new TypeError("Object.assign\x20cannot\x20be\x20called\x20with\x20null\x20or\x20undefined");
                return Object(Y);
            }
            E["exports"] = (function () {
                try {
                    if (!Object["assign"]) return !0x1;
                    var Y = new String("abc");
                    if (((Y[0x5] = "de"), "5" === Object["getOwnPropertyNames"](Y)[0x0])) return !0x1;
                    for (var B = {}, F = 0x0; F < 0xa; F++) B["_" + String["fromCharCode"](F)] = F;
                    if (
                        "0123456789" !==
                        Object["getOwnPropertyNames"](B)
                            ["map"](function (Z) {
                                return B[Z];
                            })
                            ["join"]("")
                    )
                        return !0x1;
                    var b = {};
                    return (
                        "abcdefghijklmnopqrst"["split"]("")["forEach"](function (Z) {
                            b[Z] = Z;
                        }),
                        "abcdefghijklmnopqrst" === Object["keys"](Object["assign"]({}, b))["join"]("")
                    );
                } catch (Z) {
                    return !0x1;
                }
            })()
                ? Object["assign"]
                : function (Y, B) {
                      for (var F, b, Z = d(Y), m = 0x1; m < arguments["length"]; m++) {
                          for (var v in (F = Object(arguments[m]))) T["call"](F, v) && (Z[v] = F[v]);
                          if (R) {
                              b = R(F);
                              for (var y = 0x0; y < b["length"]; y++) C["call"](F, b[y]) && (Z[b[y]] = F[b[y]]);
                          }
                      }
                      return Z;
                  };
        },
        0x13fa6: function (r, E) {
            (E["encode"] = function (R) {
                var T = "";
                for (var C in R) R["hasOwnProperty"](C) && (T["length"] && (T += "&"), (T += encodeURIComponent(C) + "=" + encodeURIComponent(R[C])));
                return T;
            }),
                (E["decode"] = function (R) {
                    for (var T = {}, C = R["split"]("&"), d = 0x0, Y = C["length"]; d < Y; d++) {
                        var B = C[d]["split"]("=");
                        T[decodeURIComponent(B[0x0])] = decodeURIComponent(B[0x1]);
                    }
                    return T;
                });
        },
        0xfabb: function (r) {
            var E = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                R = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
            r["exports"] = function (T) {
                var C = T,
                    d = T["indexOf"]("["),
                    Y = T["indexOf"]("]");
                -0x1 != d && -0x1 != Y && (T = T["substring"](0x0, d) + T["substring"](d, Y)["replace"](/:/g, ";") + T["substring"](Y, T["length"]));
                for (var B, F, b = E["exec"](T || ""), Z = {}, m = 0xe; m--; ) Z[R[m]] = b[m] || "";
                return (
                    -0x1 != d &&
                        -0x1 != Y &&
                        ((Z["source"] = C),
                        (Z["host"] = Z["host"]["substring"](0x1, Z["host"]["length"] - 0x1)["replace"](/;/g, ":")),
                        (Z["authority"] = Z["authority"]["replace"]("[", "")["replace"]("]", "")["replace"](/;/g, ":")),
                        (Z["ipv6uri"] = !0x0)),
                    (Z["pathNames"] = (function (v, y) {
                        var D = /\/{2,9}/g,
                            N = y["replace"](D, "/")["split"]("/");
                        return ("/" != y["substr"](0x0, 0x1) && 0x0 !== y["length"]) || N["splice"](0x0, 0x1), "/" == y["substr"](y["length"] - 0x1, 0x1) && N["splice"](N["length"] - 0x1, 0x1), N;
                    })(0x0, Z["path"])),
                    (Z["queryKey"] =
                        ((B = Z["query"]),
                        (F = {}),
                        B["replace"](/(?:^|&)([^&=]*)=?([^&]*)/g, function (v, y, D) {
                            y && (F[y] = D);
                        }),
                        F)),
                    Z
                );
            };
        },
        0x16a1f: function (E, R, T) {
            "use strict";
            var C = T(0xc4ee);
            function d() {}
            function Y() {}
            (Y["resetWarningCache"] = d),
                (E["exports"] = function () {
                    function B(Z, m, v, u, y, D) {
                        if (D !== C) {
                            var N = new Error(
                                "Calling\x20PropTypes\x20validators\x20directly\x20is\x20not\x20supported\x20by\x20the\x20`prop-types`\x20package.\x20Use\x20PropTypes.checkPropTypes()\x20to\x20call\x20them.\x20Read\x20more\x20at\x20http://fb.me/use-check-prop-types"
                            );
                            throw ((N["name"] = "Invariant\x20Violation"), N);
                        }
                    }
                    function F() {
                        return B;
                    }
                    B["isRequired"] = B;
                    var b = {
                        array: B,
                        bool: B,
                        func: B,
                        number: B,
                        object: B,
                        string: B,
                        symbol: B,
                        any: B,
                        arrayOf: F,
                        element: B,
                        elementType: B,
                        instanceOf: F,
                        node: B,
                        objectOf: F,
                        oneOf: F,
                        oneOfType: F,
                        shape: F,
                        exact: F,
                        checkPropTypes: Y,
                        resetWarningCache: d,
                    };
                    return (b["PropTypes"] = b), b;
                });
        },
        0xb281: function (r, E, R) {
            r["exports"] = R(0x16a1f)();
        },
        0xc4ee: function (r) {
            "use strict";
            r["exports"] = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        },
        0xfbc0: function (r0, r1, r2) {
            "use strict";
            var r3 = r2(0x106de),
                r4 = r2(0x6b1a),
                r5 = r2(0xf960);
            function r6(b8) {
                for (var b9 = "https://reactjs.org/docs/error-decoder.html?invariant=" + b8, bE = 0x1; bE < arguments["length"]; bE++) b9 += "&args[]=" + encodeURIComponent(arguments[bE]);
                return (
                    "Minified\x20React\x20error\x20#" +
                    b8 +
                    ";\x20visit\x20" +
                    b9 +
                    "\x20for\x20the\x20full\x20message\x20or\x20use\x20the\x20non-minified\x20dev\x20environment\x20for\x20full\x20errors\x20and\x20additional\x20helpful\x20warnings."
                );
            }
            if (!r3) throw Error(r6(0xe3));
            function r7(b8, b9, bE, bR, bT, bC, bd, bY, bB) {
                var bF = Array["prototype"]["slice"]["call"](arguments, 0x3);
                try {
                    b9["apply"](bE, bF);
                } catch (bb) {
                    this["onError"](bb);
                }
            }
            var r8 = !0x1,
                r9 = null,
                rE = !0x1,
                rR = null,
                rT = {
                    onError: function (b8) {
                        (r8 = !0x0), (r9 = b8);
                    },
                };
            function rC(b8, b9, bE, bR, bT, bC, bd, bY, bB) {
                (r8 = !0x1), (r9 = null), r7["apply"](rT, arguments);
            }
            var rd = null,
                rY = null,
                rB = null;
            function rF(b8, b9, bE) {
                var bR = b8["type"] || "unknown-event";
                (b8["currentTarget"] = rB(bE)),
                    (function (bT, bC, bd, bY, bB, bF, bb, bZ, bm) {
                        if ((rC["apply"](this, arguments), r8)) {
                            if (!r8) throw Error(r6(0xc6));
                            var bv = r9;
                            (r8 = !0x1), (r9 = null), rE || ((rE = !0x0), (rR = bv));
                        }
                    })(bR, b9, void 0x0, b8),
                    (b8["currentTarget"] = null);
            }
            var rb = null,
                rZ = {};
            function rm() {
                if (rb)
                    for (var b8 in rZ) {
                        var b9 = rZ[b8],
                            bE = rb["indexOf"](b8);
                        if (!(-0x1 < bE)) throw Error(r6(0x60, b8));
                        if (!ry[bE]) {
                            if (!b9["extractEvents"]) throw Error(r6(0x61, b8));
                            for (var bR in ((ry[bE] = b9), (bE = b9["eventTypes"]))) {
                                var bT = void 0x0,
                                    bC = bE[bR],
                                    bd = b9,
                                    bY = bR;
                                if (rD["hasOwnProperty"](bY)) throw Error(r6(0x63, bY));
                                rD[bY] = bC;
                                var bB = bC["phasedRegistrationNames"];
                                if (bB) {
                                    for (bT in bB) bB["hasOwnProperty"](bT) && rv(bB[bT], bd, bY);
                                    bT = !0x0;
                                } else bC["registrationName"] ? (rv(bC["registrationName"], bd, bY), (bT = !0x0)) : (bT = !0x1);
                                if (!bT) throw Error(r6(0x62, bR, b8));
                            }
                        }
                    }
            }
            function rv(b8, b9, bE) {
                if (rN[b8]) throw Error(r6(0x64, b8));
                (rN[b8] = b9), (rX[b8] = b9["eventTypes"][bE]["dependencies"]);
            }
            var ry = [],
                rD = {},
                rN = {},
                rX = {};
            function rf(b8) {
                var b9,
                    bE = !0x1;
                for (b9 in b8)
                    if (b8["hasOwnProperty"](b9)) {
                        var bR = b8[b9];
                        if (!rZ["hasOwnProperty"](b9) || rZ[b9] !== bR) {
                            if (rZ[b9]) throw Error(r6(0x66, b9));
                            (rZ[b9] = bR), (bE = !0x0);
                        }
                    }
                bE && rm();
            }
            var rP = !("undefined" == typeof window || void 0x0 === window["document"] || void 0x0 === window["document"]["createElement"]),
                rI = null,
                rA = null,
                rM = null;
            function rp(b8) {
                if ((b8 = rY(b8))) {
                    if ("function" != typeof rI) throw Error(r6(0x118));
                    var b9 = b8["stateNode"];
                    b9 && ((b9 = rd(b9)), rI(b8["stateNode"], b8["type"], b9));
                }
            }
            function rk(b8) {
                rA ? (rM ? rM["push"](b8) : (rM = [b8])) : (rA = b8);
            }
            function rl() {
                if (rA) {
                    var b8 = rA,
                        b9 = rM;
                    if (((rM = rA = null), rp(b8), b9)) {
                        for (b8 = 0x0; b8 < b9["length"]; b8++) rp(b9[b8]);
                    }
                }
            }
            function rU(b8, b9) {
                return b8(b9);
            }
            function rq(b8, b9, bE, bR, bT) {
                return b8(b9, bE, bR, bT);
            }
            function rw() {}
            var rO = rU,
                rj = !0x1,
                rh = !0x1;
            function rc() {
                (null === rA && null === rM) || (rw(), rl());
            }
            function rS(b8, b9, bE) {
                if (rh) return b8(b9, bE);
                rh = !0x0;
                try {
                    return rO(b8, b9, bE);
                } finally {
                    (rh = !0x1), rc();
                }
            }
            var rg = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                rW = Object["prototype"]["hasOwnProperty"],
                rH = {},
                rx = {};
            function rK(b8, b9, bE, bR, bT, bC) {
                (this["acceptsBooleans"] = 0x2 === b9 || 0x3 === b9 || 0x4 === b9),
                    (this["attributeName"] = bR),
                    (this["attributeNamespace"] = bT),
                    (this["mustUseProperty"] = bE),
                    (this["propertyName"] = b8),
                    (this["type"] = b9),
                    (this["sanitizeURL"] = bC);
            }
            var rV = {};
            "children\x20dangerouslySetInnerHTML\x20defaultValue\x20defaultChecked\x20innerHTML\x20suppressContentEditableWarning\x20suppressHydrationWarning\x20style"["split"]("\x20")["forEach"](function (b8) {
                rV[b8] = new rK(b8, 0x0, !0x1, b8, null, !0x1);
            }),
                [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"],
                ]["forEach"](function (b8) {
                    var b9 = b8[0x0];
                    rV[b9] = new rK(b9, 0x1, !0x1, b8[0x1], null, !0x1);
                }),
                ["contentEditable", "draggable", "spellCheck", "value"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x2, !0x1, b8["toLowerCase"](), null, !0x1);
                }),
                ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x2, !0x1, b8, null, !0x1);
                }),
                "allowFullScreen\x20async\x20autoFocus\x20autoPlay\x20controls\x20default\x20defer\x20disabled\x20disablePictureInPicture\x20formNoValidate\x20hidden\x20loop\x20noModule\x20noValidate\x20open\x20playsInline\x20readOnly\x20required\x20reversed\x20scoped\x20seamless\x20itemScope"
                    ["split"]("\x20")
                    ["forEach"](function (b8) {
                        rV[b8] = new rK(b8, 0x3, !0x1, b8["toLowerCase"](), null, !0x1);
                    }),
                ["checked", "multiple", "muted", "selected"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x3, !0x0, b8, null, !0x1);
                }),
                ["capture", "download"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x4, !0x1, b8, null, !0x1);
                }),
                ["cols", "rows", "size", "span"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x6, !0x1, b8, null, !0x1);
                }),
                ["rowSpan", "start"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x5, !0x1, b8["toLowerCase"](), null, !0x1);
                });
            var rJ = /[\-:]([a-z])/g;
            function rG(b8) {
                return b8[0x1]["toUpperCase"]();
            }
            "accent-height\x20alignment-baseline\x20arabic-form\x20baseline-shift\x20cap-height\x20clip-path\x20clip-rule\x20color-interpolation\x20color-interpolation-filters\x20color-profile\x20color-rendering\x20dominant-baseline\x20enable-background\x20fill-opacity\x20fill-rule\x20flood-color\x20flood-opacity\x20font-family\x20font-size\x20font-size-adjust\x20font-stretch\x20font-style\x20font-variant\x20font-weight\x20glyph-name\x20glyph-orientation-horizontal\x20glyph-orientation-vertical\x20horiz-adv-x\x20horiz-origin-x\x20image-rendering\x20letter-spacing\x20lighting-color\x20marker-end\x20marker-mid\x20marker-start\x20overline-position\x20overline-thickness\x20paint-order\x20panose-1\x20pointer-events\x20rendering-intent\x20shape-rendering\x20stop-color\x20stop-opacity\x20strikethrough-position\x20strikethrough-thickness\x20stroke-dasharray\x20stroke-dashoffset\x20stroke-linecap\x20stroke-linejoin\x20stroke-miterlimit\x20stroke-opacity\x20stroke-width\x20text-anchor\x20text-decoration\x20text-rendering\x20underline-position\x20underline-thickness\x20unicode-bidi\x20unicode-range\x20units-per-em\x20v-alphabetic\x20v-hanging\x20v-ideographic\x20v-mathematical\x20vector-effect\x20vert-adv-y\x20vert-origin-x\x20vert-origin-y\x20word-spacing\x20writing-mode\x20xmlns:xlink\x20x-height"
                ["split"]("\x20")
                ["forEach"](function (b8) {
                    var b9 = b8["replace"](rJ, rG);
                    rV[b9] = new rK(b9, 0x1, !0x1, b8, null, !0x1);
                }),
                "xlink:actuate\x20xlink:arcrole\x20xlink:role\x20xlink:show\x20xlink:title\x20xlink:type"["split"]("\x20")["forEach"](function (b8) {
                    var b9 = b8["replace"](rJ, rG);
                    rV[b9] = new rK(b9, 0x1, !0x1, b8, "http://www.w3.org/1999/xlink", !0x1);
                }),
                ["xml:base", "xml:lang", "xml:space"]["forEach"](function (b8) {
                    var b9 = b8["replace"](rJ, rG);
                    rV[b9] = new rK(b9, 0x1, !0x1, b8, "http://www.w3.org/XML/1998/namespace", !0x1);
                }),
                ["tabIndex", "crossOrigin"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x1, !0x1, b8["toLowerCase"](), null, !0x1);
                }),
                (rV["xlinkHref"] = new rK("xlinkHref", 0x1, !0x1, "xlink:href", "http://www.w3.org/1999/xlink", !0x0)),
                ["src", "href", "action", "formAction"]["forEach"](function (b8) {
                    rV[b8] = new rK(b8, 0x1, !0x1, b8["toLowerCase"](), null, !0x0);
                });
            var rL = r3["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"];
            function rQ(b8, b9, bE, bR) {
                var bT = rV["hasOwnProperty"](b9) ? rV[b9] : null;
                (null !== bT ? 0x0 === bT["type"] : !bR && 0x2 < b9["length"] && ("o" === b9[0x0] || "O" === b9[0x0]) && ("n" === b9[0x1] || "N" === b9[0x1])) ||
                    ((function (bC, bd, bY, bB) {
                        if (
                            null == bd ||
                            (function (bF, bb, bZ, bm) {
                                if (null !== bZ && 0x0 === bZ["type"]) return !0x1;
                                switch (typeof bb) {
                                    case "function":
                                    case "symbol":
                                        return !0x0;
                                    case "boolean":
                                        return !bm && (null !== bZ ? !bZ["acceptsBooleans"] : "data-" !== (bF = bF["toLowerCase"]()["slice"](0x0, 0x5)) && "aria-" !== bF);
                                    default:
                                        return !0x1;
                                }
                            })(bC, bd, bY, bB)
                        )
                            return !0x0;
                        if (bB) return !0x1;
                        if (null !== bY)
                            switch (bY["type"]) {
                                case 0x3:
                                    return !bd;
                                case 0x4:
                                    return !0x1 === bd;
                                case 0x5:
                                    return isNaN(bd);
                                case 0x6:
                                    return isNaN(bd) || 0x1 > bd;
                            }
                        return !0x1;
                    })(b9, bE, bT, bR) && (bE = null),
                    bR || null === bT
                        ? (function (bC) {
                              return !!rW["call"](rx, bC) || (!rW["call"](rH, bC) && (rg["test"](bC) ? (rx[bC] = !0x0) : ((rH[bC] = !0x0), !0x1)));
                          })(b9) && (null === bE ? b8["removeAttribute"](b9) : b8["setAttribute"](b9, "" + bE))
                        : bT["mustUseProperty"]
                        ? (b8[bT["propertyName"]] = null === bE ? 0x3 !== bT["type"] && "" : bE)
                        : ((b9 = bT["attributeName"]),
                          (bR = bT["attributeNamespace"]),
                          null === bE ? b8["removeAttribute"](b9) : ((bE = 0x3 === (bT = bT["type"]) || (0x4 === bT && !0x0 === bE) ? "" : "" + bE), bR ? b8["setAttributeNS"](bR, b9, bE) : b8["setAttribute"](b9, bE))));
            }
            rL["hasOwnProperty"]("ReactCurrentDispatcher") || (rL["ReactCurrentDispatcher"] = { current: null }), rL["hasOwnProperty"]("ReactCurrentBatchConfig") || (rL["ReactCurrentBatchConfig"] = { suspense: null });
            var rz = /^(.*)[\\\/]/,
                E0 = "function" == typeof Symbol && Symbol["for"],
                E1 = E0 ? Symbol["for"]("react.element") : 0xeac7,
                E2 = E0 ? Symbol["for"]("react.portal") : 0xeaca,
                E3 = E0 ? Symbol["for"]("react.fragment") : 0xeacb,
                E4 = E0 ? Symbol["for"]("react.strict_mode") : 0xeacc,
                E5 = E0 ? Symbol["for"]("react.profiler") : 0xead2,
                E6 = E0 ? Symbol["for"]("react.provider") : 0xeacd,
                E7 = E0 ? Symbol["for"]("react.context") : 0xeace,
                E8 = E0 ? Symbol["for"]("react.concurrent_mode") : 0xeacf,
                E9 = E0 ? Symbol["for"]("react.forward_ref") : 0xead0,
                EE = E0 ? Symbol["for"]("react.suspense") : 0xead1,
                ER = E0 ? Symbol["for"]("react.suspense_list") : 0xead8,
                ET = E0 ? Symbol["for"]("react.memo") : 0xead3,
                EC = E0 ? Symbol["for"]("react.lazy") : 0xead4,
                Ed = E0 ? Symbol["for"]("react.block") : 0xead9,
                EY = "function" == typeof Symbol && Symbol["iterator"];
            function EB(b8) {
                return null === b8 || "object" != typeof b8 ? null : "function" == typeof (b8 = (EY && b8[EY]) || b8["@@iterator"]) ? b8 : null;
            }
            function EF(b8) {
                if (null == b8) return null;
                if ("function" == typeof b8) return b8["displayName"] || b8["name"] || null;
                if ("string" == typeof b8) return b8;
                switch (b8) {
                    case E3:
                        return "Fragment";
                    case E2:
                        return "Portal";
                    case E5:
                        return "Profiler";
                    case E4:
                        return "StrictMode";
                    case EE:
                        return "Suspense";
                    case ER:
                        return "SuspenseList";
                }
                if ("object" == typeof b8)
                    switch (b8["$$typeof"]) {
                        case E7:
                            return "Context.Consumer";
                        case E6:
                            return "Context.Provider";
                        case E9:
                            var b9 = b8["render"];
                            return (b9 = b9["displayName"] || b9["name"] || ""), b8["displayName"] || ("" !== b9 ? "ForwardRef(" + b9 + ")" : "ForwardRef");
                        case ET:
                            return EF(b8["type"]);
                        case Ed:
                            return EF(b8["render"]);
                        case EC:
                            if ((b8 = 0x1 === b8["_status"] ? b8["_result"] : null)) return EF(b8);
                    }
                return null;
            }
            function Eb(b8) {
                var b9 = "";
                do {
                    bd: switch (b8["tag"]) {
                        case 0x3:
                        case 0x4:
                        case 0x6:
                        case 0x7:
                        case 0xa:
                        case 0x9:
                            var bE = "";
                            break bd;
                        default:
                            var bR = b8["_debugOwner"],
                                bT = b8["_debugSource"],
                                bC = EF(b8["type"]);
                            (bE = null),
                                bR && (bE = EF(bR["type"])),
                                (bR = bC),
                                (bC = ""),
                                bT ? (bC = "\x20(at\x20" + bT["fileName"]["replace"](rz, "") + ":" + bT["lineNumber"] + ")") : bE && (bC = "\x20(created\x20by\x20" + bE + ")"),
                                (bE = "\x0a\x20\x20\x20\x20in\x20" + (bR || "Unknown") + bC);
                    }
                    (b9 += bE), (b8 = b8["return"]);
                } while (b8);
                return b9;
            }
            function EZ(b8) {
                switch (typeof b8) {
                    case "boolean":
                    case "number":
                    case "object":
                    case "string":
                    case "undefined":
                        return b8;
                    default:
                        return "";
                }
            }
            function Em(b8) {
                var b9 = b8["type"];
                return (b8 = b8["nodeName"]) && "input" === b8["toLowerCase"]() && ("checkbox" === b9 || "radio" === b9);
            }
            function Ev(b8) {
                b8["_valueTracker"] ||
                    (b8["_valueTracker"] = (function (b9) {
                        var bE = Em(b9) ? "checked" : "value",
                            bR = Object["getOwnPropertyDescriptor"](b9["constructor"]["prototype"], bE),
                            bT = "" + b9[bE];
                        if (!b9["hasOwnProperty"](bE) && void 0x0 !== bR && "function" == typeof bR["get"] && "function" == typeof bR["set"]) {
                            var bC = bR["get"],
                                bd = bR["set"];
                            return (
                                Object["defineProperty"](b9, bE, {
                                    configurable: !0x0,
                                    get: function () {
                                        return bC["call"](this);
                                    },
                                    set: function (bY) {
                                        (bT = "" + bY), bd["call"](this, bY);
                                    },
                                }),
                                Object["defineProperty"](b9, bE, { enumerable: bR["enumerable"] }),
                                {
                                    getValue: function () {
                                        return bT;
                                    },
                                    setValue: function (bY) {
                                        bT = "" + bY;
                                    },
                                    stopTracking: function () {
                                        (b9["_valueTracker"] = null), delete b9[bE];
                                    },
                                }
                            );
                        }
                    })(b8));
            }
            function Ey(b8) {
                if (!b8) return !0x1;
                var b9 = b8["_valueTracker"];
                if (!b9) return !0x0;
                var bE = b9["getValue"](),
                    bR = "";
                return b8 && (bR = Em(b8) ? (b8["checked"] ? "true" : "false") : b8["value"]), (b8 = bR) !== bE && (b9["setValue"](b8), !0x0);
            }
            function ED(b8, b9) {
                var bE = b9["checked"];
                return r4({}, b9, { defaultChecked: void 0x0, defaultValue: void 0x0, value: void 0x0, checked: null != bE ? bE : b8["_wrapperState"]["initialChecked"] });
            }
            function EN(b8, b9) {
                var bE = null == b9["defaultValue"] ? "" : b9["defaultValue"],
                    bR = null != b9["checked"] ? b9["checked"] : b9["defaultChecked"];
                (bE = EZ(null != b9["value"] ? b9["value"] : bE)),
                    (b8["_wrapperState"] = { initialChecked: bR, initialValue: bE, controlled: "checkbox" === b9["type"] || "radio" === b9["type"] ? null != b9["checked"] : null != b9["value"] });
            }
            function EX(b8, b9) {
                null != (b9 = b9["checked"]) && rQ(b8, "checked", b9, !0x1);
            }
            function Ef(b8, b9) {
                EX(b8, b9);
                var bE = EZ(b9["value"]),
                    bR = b9["type"];
                if (null != bE) "number" === bR ? ((0x0 === bE && "" === b8["value"]) || b8["value"] != bE) && (b8["value"] = "" + bE) : b8["value"] !== "" + bE && (b8["value"] = "" + bE);
                else {
                    if ("submit" === bR || "reset" === bR) return void b8["removeAttribute"]("value");
                }
                b9["hasOwnProperty"]("value") ? EI(b8, b9["type"], bE) : b9["hasOwnProperty"]("defaultValue") && EI(b8, b9["type"], EZ(b9["defaultValue"])),
                    null == b9["checked"] && null != b9["defaultChecked"] && (b8["defaultChecked"] = !!b9["defaultChecked"]);
            }
            function EP(b8, b9, bE) {
                if (b9["hasOwnProperty"]("value") || b9["hasOwnProperty"]("defaultValue")) {
                    var bR = b9["type"];
                    if (!(("submit" !== bR && "reset" !== bR) || (void 0x0 !== b9["value"] && null !== b9["value"]))) return;
                    (b9 = "" + b8["_wrapperState"]["initialValue"]), bE || b9 === b8["value"] || (b8["value"] = b9), (b8["defaultValue"] = b9);
                }
                "" !== (bE = b8["name"]) && (b8["name"] = ""), (b8["defaultChecked"] = !!b8["_wrapperState"]["initialChecked"]), "" !== bE && (b8["name"] = bE);
            }
            function EI(b8, b9, bE) {
                ("number" === b9 && b8["ownerDocument"]["activeElement"] === b8) || (null == bE ? (b8["defaultValue"] = "" + b8["_wrapperState"]["initialValue"]) : b8["defaultValue"] !== "" + bE && (b8["defaultValue"] = "" + bE));
            }
            function EA(b8, b9) {
                return (
                    (b8 = r4({ children: void 0x0 }, b9)),
                    (b9 = (function (bE) {
                        var bR = "";
                        return (
                            r3["Children"]["forEach"](bE, function (bT) {
                                null != bT && (bR += bT);
                            }),
                            bR
                        );
                    })(b9["children"])) && (b8["children"] = b9),
                    b8
                );
            }
            function EM(b8, b9, bE, bR) {
                if (((b8 = b8["options"]), b9)) {
                    b9 = {};
                    for (var bT = 0x0; bT < bE["length"]; bT++) b9["$" + bE[bT]] = !0x0;
                    for (bE = 0x0; bE < b8["length"]; bE++) (bT = b9["hasOwnProperty"]("$" + b8[bE]["value"])), b8[bE]["selected"] !== bT && (b8[bE]["selected"] = bT), bT && bR && (b8[bE]["defaultSelected"] = !0x0);
                } else {
                    for (bE = "" + EZ(bE), b9 = null, bT = 0x0; bT < b8["length"]; bT++) {
                        if (b8[bT]["value"] === bE) return (b8[bT]["selected"] = !0x0), void (bR && (b8[bT]["defaultSelected"] = !0x0));
                        null !== b9 || b8[bT]["disabled"] || (b9 = b8[bT]);
                    }
                    null !== b9 && (b9["selected"] = !0x0);
                }
            }
            function Ep(b8, b9) {
                if (null != b9["dangerouslySetInnerHTML"]) throw Error(r6(0x5b));
                return r4({}, b9, { value: void 0x0, defaultValue: void 0x0, children: "" + b8["_wrapperState"]["initialValue"] });
            }
            function Ek(b8, b9) {
                var bE = b9["value"];
                if (null == bE) {
                    if (((bE = b9["children"]), (b9 = b9["defaultValue"]), null != bE)) {
                        if (null != b9) throw Error(r6(0x5c));
                        if (Array["isArray"](bE)) {
                            if (!(0x1 >= bE["length"])) throw Error(r6(0x5d));
                            bE = bE[0x0];
                        }
                        b9 = bE;
                    }
                    null == b9 && (b9 = ""), (bE = b9);
                }
                b8["_wrapperState"] = { initialValue: EZ(bE) };
            }
            function El(b8, b9) {
                var bE = EZ(b9["value"]),
                    bR = EZ(b9["defaultValue"]);
                null != bE && ((bE = "" + bE) !== b8["value"] && (b8["value"] = bE), null == b9["defaultValue"] && b8["defaultValue"] !== bE && (b8["defaultValue"] = bE)), null != bR && (b8["defaultValue"] = "" + bR);
            }
            function EU(b8) {
                var b9 = b8["textContent"];
                b9 === b8["_wrapperState"]["initialValue"] && "" !== b9 && null !== b9 && (b8["value"] = b9);
            }
            var Eq = "http://www.w3.org/1999/xhtml",
                Ew = "http://www.w3.org/2000/svg";
            function EO(b8) {
                switch (b8) {
                    case "svg":
                        return "http://www.w3.org/2000/svg";
                    case "math":
                        return "http://www.w3.org/1998/Math/MathML";
                    default:
                        return "http://www.w3.org/1999/xhtml";
                }
            }
            function Ej(b8, b9) {
                return null == b8 || "http://www.w3.org/1999/xhtml" === b8 ? EO(b9) : "http://www.w3.org/2000/svg" === b8 && "foreignObject" === b9 ? "http://www.w3.org/1999/xhtml" : b8;
            }
            var Eh,
                Ec,
                ES =
                    ((Ec = function (b8, b9) {
                        if (b8["namespaceURI"] !== Ew || "innerHTML" in b8) b8["innerHTML"] = b9;
                        else {
                            for ((Eh = Eh || document["createElement"]("div"))["innerHTML"] = "<svg>" + b9["valueOf"]()["toString"]() + "</svg>", b9 = Eh["firstChild"]; b8["firstChild"]; ) b8["removeChild"](b8["firstChild"]);
                            for (; b9["firstChild"]; ) b8["appendChild"](b9["firstChild"]);
                        }
                    }),
                    "undefined" != typeof MSApp && MSApp["execUnsafeLocalFunction"]
                        ? function (b8, b9, bE, bR) {
                              MSApp["execUnsafeLocalFunction"](function () {
                                  return Ec(b8, b9);
                              });
                          }
                        : Ec);
            function Eg(b8, b9) {
                if (b9) {
                    var bE = b8["firstChild"];
                    if (bE && bE === b8["lastChild"] && 0x3 === bE["nodeType"]) return void (bE["nodeValue"] = b9);
                }
                b8["textContent"] = b9;
            }
            function EW(b8, b9) {
                var bE = {};
                return (bE[b8["toLowerCase"]()] = b9["toLowerCase"]()), (bE["Webkit" + b8] = "webkit" + b9), (bE["Moz" + b8] = "moz" + b9), bE;
            }
            var EH = { animationend: EW("Animation", "AnimationEnd"), animationiteration: EW("Animation", "AnimationIteration"), animationstart: EW("Animation", "AnimationStart"), transitionend: EW("Transition", "TransitionEnd") },
                Ex = {},
                EK = {};
            function EV(b8) {
                if (Ex[b8]) return Ex[b8];
                if (!EH[b8]) return b8;
                var b9,
                    bE = EH[b8];
                for (b9 in bE) if (bE["hasOwnProperty"](b9) && b9 in EK) return (Ex[b8] = bE[b9]);
                return b8;
            }
            rP &&
                ((EK = document["createElement"]("div")["style"]),
                "AnimationEvent" in window || (delete EH["animationend"]["animation"], delete EH["animationiteration"]["animation"], delete EH["animationstart"]["animation"]),
                "TransitionEvent" in window || delete EH["transitionend"]["transition"]);
            var EJ = EV("animationend"),
                EG = EV("animationiteration"),
                EL = EV("animationstart"),
                EQ = EV("transitionend"),
                Ez = "abort\x20canplay\x20canplaythrough\x20durationchange\x20emptied\x20encrypted\x20ended\x20error\x20loadeddata\x20loadedmetadata\x20loadstart\x20pause\x20play\x20playing\x20progress\x20ratechange\x20seeked\x20seeking\x20stalled\x20suspend\x20timeupdate\x20volumechange\x20waiting"[
                    "split"
                ]("\x20"),
                R0 = new ("function" == typeof WeakMap ? WeakMap : Map)();
            function R1(b8) {
                var b9 = R0["get"](b8);
                return void 0x0 === b9 && ((b9 = new Map()), R0["set"](b8, b9)), b9;
            }
            function R2(b8) {
                var b9 = b8,
                    bE = b8;
                if (b8["alternate"]) {
                    for (; b9["return"]; ) b9 = b9["return"];
                } else {
                    b8 = b9;
                    do {
                        0x0 != (0x402 & (b9 = b8)["effectTag"]) && (bE = b9["return"]), (b8 = b9["return"]);
                    } while (b8);
                }
                return 0x3 === b9["tag"] ? bE : null;
            }
            function R3(b8) {
                if (0xd === b8["tag"]) {
                    var b9 = b8["memoizedState"];
                    if ((null === b9 && null !== (b8 = b8["alternate"]) && (b9 = b8["memoizedState"]), null !== b9)) return b9["dehydrated"];
                }
                return null;
            }
            function R4(b8) {
                if (R2(b8) !== b8) throw Error(r6(0xbc));
            }
            function R5(b8) {
                if (
                    ((b8 = (function (bE) {
                        var bR = bE["alternate"];
                        if (!bR) {
                            if (null === (bR = R2(bE))) throw Error(r6(0xbc));
                            return bR !== bE ? null : bE;
                        }
                        for (var bT = bE, bC = bR; ; ) {
                            var bd = bT["return"];
                            if (null === bd) break;
                            var bY = bd["alternate"];
                            if (null === bY) {
                                if (null !== (bC = bd["return"])) {
                                    bT = bC;
                                    continue;
                                }
                                break;
                            }
                            if (bd["child"] === bY["child"]) {
                                for (bY = bd["child"]; bY; ) {
                                    if (bY === bT) return R4(bd), bE;
                                    if (bY === bC) return R4(bd), bR;
                                    bY = bY["sibling"];
                                }
                                throw Error(r6(0xbc));
                            }
                            if (bT["return"] !== bC["return"]) (bT = bd), (bC = bY);
                            else {
                                for (var bB = !0x1, bF = bd["child"]; bF; ) {
                                    if (bF === bT) {
                                        (bB = !0x0), (bT = bd), (bC = bY);
                                        break;
                                    }
                                    if (bF === bC) {
                                        (bB = !0x0), (bC = bd), (bT = bY);
                                        break;
                                    }
                                    bF = bF["sibling"];
                                }
                                if (!bB) {
                                    for (bF = bY["child"]; bF; ) {
                                        if (bF === bT) {
                                            (bB = !0x0), (bT = bY), (bC = bd);
                                            break;
                                        }
                                        if (bF === bC) {
                                            (bB = !0x0), (bC = bY), (bT = bd);
                                            break;
                                        }
                                        bF = bF["sibling"];
                                    }
                                    if (!bB) throw Error(r6(0xbd));
                                }
                            }
                            if (bT["alternate"] !== bC) throw Error(r6(0xbe));
                        }
                        if (0x3 !== bT["tag"]) throw Error(r6(0xbc));
                        return bT["stateNode"]["current"] === bT ? bE : bR;
                    })(b8)),
                    !b8)
                )
                    return null;
                for (var b9 = b8; ; ) {
                    if (0x5 === b9["tag"] || 0x6 === b9["tag"]) return b9;
                    if (b9["child"]) (b9["child"]["return"] = b9), (b9 = b9["child"]);
                    else {
                        if (b9 === b8) break;
                        for (; !b9["sibling"]; ) {
                            if (!b9["return"] || b9["return"] === b8) return null;
                            b9 = b9["return"];
                        }
                        (b9["sibling"]["return"] = b9["return"]), (b9 = b9["sibling"]);
                    }
                }
                return null;
            }
            function R6(b8, b9) {
                if (null == b9) throw Error(r6(0x1e));
                return null == b8 ? b9 : Array["isArray"](b8) ? (Array["isArray"](b9) ? (b8["push"]["apply"](b8, b9), b8) : (b8["push"](b9), b8)) : Array["isArray"](b9) ? [b8]["concat"](b9) : [b8, b9];
            }
            function R7(b8, b9, bE) {
                Array["isArray"](b8) ? b8["forEach"](b9, bE) : b8 && b9["call"](bE, b8);
            }
            var R8 = null;
            function R9(b8) {
                if (b8) {
                    var b9 = b8["_dispatchListeners"],
                        bE = b8["_dispatchInstances"];
                    if (Array["isArray"](b9)) {
                        for (var bR = 0x0; bR < b9["length"] && !b8["isPropagationStopped"](); bR++) rF(b8, b9[bR], bE[bR]);
                    } else b9 && rF(b8, b9, bE);
                    (b8["_dispatchListeners"] = null), (b8["_dispatchInstances"] = null), b8["isPersistent"]() || b8["constructor"]["release"](b8);
                }
            }
            function RE(b8) {
                if ((null !== b8 && (R8 = R6(R8, b8)), (b8 = R8), (R8 = null), b8)) {
                    if ((R7(b8, R9), R8)) throw Error(r6(0x5f));
                    if (rE) throw ((b8 = rR), (rE = !0x1), (rR = null), b8);
                }
            }
            function RR(b8) {
                return (b8 = b8["target"] || b8["srcElement"] || window)["correspondingUseElement"] && (b8 = b8["correspondingUseElement"]), 0x3 === b8["nodeType"] ? b8["parentNode"] : b8;
            }
            function RT(b8) {
                if (!rP) return !0x1;
                var b9 = (b8 = "on" + b8) in document;
                return b9 || ((b9 = document["createElement"]("div"))["setAttribute"](b8, "return;"), (b9 = "function" == typeof b9[b8])), b9;
            }
            var RC = [];
            function Rd(b8) {
                (b8["topLevelType"] = null), (b8["nativeEvent"] = null), (b8["targetInst"] = null), (b8["ancestors"]["length"] = 0x0), 0xa > RC["length"] && RC["push"](b8);
            }
            function RY(b8, b9, bE, bR) {
                if (RC["length"]) {
                    var bT = RC["pop"]();
                    return (bT["topLevelType"] = b8), (bT["eventSystemFlags"] = bR), (bT["nativeEvent"] = b9), (bT["targetInst"] = bE), bT;
                }
                return { topLevelType: b8, eventSystemFlags: bR, nativeEvent: b9, targetInst: bE, ancestors: [] };
            }
            function RB(b8) {
                var b9 = b8["targetInst"],
                    bE = b9;
                do {
                    if (!bE) {
                        b8["ancestors"]["push"](bE);
                        break;
                    }
                    var bR = bE;
                    if (0x3 === bR["tag"]) bR = bR["stateNode"]["containerInfo"];
                    else {
                        for (; bR["return"]; ) bR = bR["return"];
                        bR = 0x3 !== bR["tag"] ? null : bR["stateNode"]["containerInfo"];
                    }
                    if (!bR) break;
                    (0x5 !== (b9 = bE["tag"]) && 0x6 !== b9) || b8["ancestors"]["push"](bE), (bE = Tl(bR));
                } while (bE);
                for (bE = 0x0; bE < b8["ancestors"]["length"]; bE++) {
                    b9 = b8["ancestors"][bE];
                    var bT = RR(b8["nativeEvent"]);
                    bR = b8["topLevelType"];
                    var bC = b8["nativeEvent"],
                        bd = b8["eventSystemFlags"];
                    0x0 === bE && (bd |= 0x40);
                    for (var bY = null, bB = 0x0; bB < ry["length"]; bB++) {
                        var bF = ry[bB];
                        bF && (bF = bF["extractEvents"](bR, b9, bC, bT, bd)) && (bY = R6(bY, bF));
                    }
                    RE(bY);
                }
            }
            function RF(b8, b9, bE) {
                if (!bE["has"](b8)) {
                    switch (b8) {
                        case "scroll":
                            RQ(b9, "scroll", !0x0);
                            break;
                        case "focus":
                        case "blur":
                            RQ(b9, "focus", !0x0), RQ(b9, "blur", !0x0), bE["set"]("blur", null), bE["set"]("focus", null);
                            break;
                        case "cancel":
                        case "close":
                            RT(b8) && RQ(b9, b8, !0x0);
                            break;
                        case "invalid":
                        case "submit":
                        case "reset":
                            break;
                        default:
                            -0x1 === Ez["indexOf"](b8) && RL(b8, b9);
                    }
                    bE["set"](b8, null);
                }
            }
            var Rb,
                RZ,
                Rm,
                Rv = !0x1,
                Ry = [],
                RD = null,
                RN = null,
                RX = null,
                Rf = new Map(),
                RP = new Map(),
                RI = [],
                RA = "mousedown\x20mouseup\x20touchcancel\x20touchend\x20touchstart\x20auxclick\x20dblclick\x20pointercancel\x20pointerdown\x20pointerup\x20dragend\x20dragstart\x20drop\x20compositionend\x20compositionstart\x20keydown\x20keypress\x20keyup\x20input\x20textInput\x20close\x20cancel\x20copy\x20cut\x20paste\x20click\x20change\x20contextmenu\x20reset\x20submit"[
                    "split"
                ]("\x20"),
                RM = "focus\x20blur\x20dragenter\x20dragleave\x20mouseover\x20mouseout\x20pointerover\x20pointerout\x20gotpointercapture\x20lostpointercapture"["split"]("\x20");
            function Rp(b8, b9, bE, bR, bT) {
                return { blockedOn: b8, topLevelType: b9, eventSystemFlags: 0x20 | bE, nativeEvent: bT, container: bR };
            }
            function Rk(b8, b9) {
                switch (b8) {
                    case "focus":
                    case "blur":
                        RD = null;
                        break;
                    case "dragenter":
                    case "dragleave":
                        RN = null;
                        break;
                    case "mouseover":
                    case "mouseout":
                        RX = null;
                        break;
                    case "pointerover":
                    case "pointerout":
                        Rf["delete"](b9["pointerId"]);
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                        RP["delete"](b9["pointerId"]);
                }
            }
            function Rl(b8, b9, bE, bR, bT, bC) {
                return null === b8 || b8["nativeEvent"] !== bC ? ((b8 = Rp(b9, bE, bR, bT, bC)), null !== b9 && null !== (b9 = TU(b9)) && RZ(b9), b8) : ((b8["eventSystemFlags"] |= bR), b8);
            }
            function RU(b8) {
                var b9 = Tl(b8["target"]);
                if (null !== b9) {
                    var bE = R2(b9);
                    if (null !== bE) {
                        if (0xd === (b9 = bE["tag"])) {
                            if (null !== (b9 = R3(bE)))
                                return (
                                    (b8["blockedOn"] = b9),
                                    void r5["unstable_runWithPriority"](b8["priority"], function () {
                                        Rm(bE);
                                    })
                                );
                        } else {
                            if (0x3 === b9 && bE["stateNode"]["hydrate"]) return void (b8["blockedOn"] = 0x3 === bE["tag"] ? bE["stateNode"]["containerInfo"] : null);
                        }
                    }
                }
                b8["blockedOn"] = null;
            }
            function Rq(b8) {
                if (null !== b8["blockedOn"]) return !0x1;
                var b9 = T2(b8["topLevelType"], b8["eventSystemFlags"], b8["container"], b8["nativeEvent"]);
                if (null !== b9) {
                    var bE = TU(b9);
                    return null !== bE && RZ(bE), (b8["blockedOn"] = b9), !0x1;
                }
                return !0x0;
            }
            function Rw(b8, b9, bE) {
                Rq(b8) && bE["delete"](b9);
            }
            function RO() {
                for (Rv = !0x1; 0x0 < Ry["length"]; ) {
                    var b8 = Ry[0x0];
                    if (null !== b8["blockedOn"]) {
                        null !== (b8 = TU(b8["blockedOn"])) && Rb(b8);
                        break;
                    }
                    var b9 = T2(b8["topLevelType"], b8["eventSystemFlags"], b8["container"], b8["nativeEvent"]);
                    null !== b9 ? (b8["blockedOn"] = b9) : Ry["shift"]();
                }
                null !== RD && Rq(RD) && (RD = null), null !== RN && Rq(RN) && (RN = null), null !== RX && Rq(RX) && (RX = null), Rf["forEach"](Rw), RP["forEach"](Rw);
            }
            function Rj(b8, b9) {
                b8["blockedOn"] === b9 && ((b8["blockedOn"] = null), Rv || ((Rv = !0x0), r5["unstable_scheduleCallback"](r5["unstable_NormalPriority"], RO)));
            }
            function Rh(b8) {
                function b9(bT) {
                    return Rj(bT, b8);
                }
                if (0x0 < Ry["length"]) {
                    Rj(Ry[0x0], b8);
                    for (var bE = 0x1; bE < Ry["length"]; bE++) {
                        var bR = Ry[bE];
                        bR["blockedOn"] === b8 && (bR["blockedOn"] = null);
                    }
                }
                for (null !== RD && Rj(RD, b8), null !== RN && Rj(RN, b8), null !== RX && Rj(RX, b8), Rf["forEach"](b9), RP["forEach"](b9), bE = 0x0; bE < RI["length"]; bE++) (bR = RI[bE])["blockedOn"] === b8 && (bR["blockedOn"] = null);
                for (; 0x0 < RI["length"] && null === (bE = RI[0x0])["blockedOn"]; ) RU(bE), null === bE["blockedOn"] && RI["shift"]();
            }
            var Rc = {},
                RS = new Map(),
                Rg = new Map(),
                RW = [
                    "abort",
                    "abort",
                    EJ,
                    "animationEnd",
                    EG,
                    "animationIteration",
                    EL,
                    "animationStart",
                    "canplay",
                    "canPlay",
                    "canplaythrough",
                    "canPlayThrough",
                    "durationchange",
                    "durationChange",
                    "emptied",
                    "emptied",
                    "encrypted",
                    "encrypted",
                    "ended",
                    "ended",
                    "error",
                    "error",
                    "gotpointercapture",
                    "gotPointerCapture",
                    "load",
                    "load",
                    "loadeddata",
                    "loadedData",
                    "loadedmetadata",
                    "loadedMetadata",
                    "loadstart",
                    "loadStart",
                    "lostpointercapture",
                    "lostPointerCapture",
                    "playing",
                    "playing",
                    "progress",
                    "progress",
                    "seeking",
                    "seeking",
                    "stalled",
                    "stalled",
                    "suspend",
                    "suspend",
                    "timeupdate",
                    "timeUpdate",
                    EQ,
                    "transitionEnd",
                    "waiting",
                    "waiting",
                ];
            function RH(b8, b9) {
                for (var bE = 0x0; bE < b8["length"]; bE += 0x2) {
                    var bR = b8[bE],
                        bT = b8[bE + 0x1],
                        bC = "on" + (bT[0x0]["toUpperCase"]() + bT["slice"](0x1));
                    (bC = { phasedRegistrationNames: { bubbled: bC, captured: bC + "Capture" }, dependencies: [bR], eventPriority: b9 }), Rg["set"](bR, b9), RS["set"](bR, bC), (Rc[bT] = bC);
                }
            }
            RH(
                "blur\x20blur\x20cancel\x20cancel\x20click\x20click\x20close\x20close\x20contextmenu\x20contextMenu\x20copy\x20copy\x20cut\x20cut\x20auxclick\x20auxClick\x20dblclick\x20doubleClick\x20dragend\x20dragEnd\x20dragstart\x20dragStart\x20drop\x20drop\x20focus\x20focus\x20input\x20input\x20invalid\x20invalid\x20keydown\x20keyDown\x20keypress\x20keyPress\x20keyup\x20keyUp\x20mousedown\x20mouseDown\x20mouseup\x20mouseUp\x20paste\x20paste\x20pause\x20pause\x20play\x20play\x20pointercancel\x20pointerCancel\x20pointerdown\x20pointerDown\x20pointerup\x20pointerUp\x20ratechange\x20rateChange\x20reset\x20reset\x20seeked\x20seeked\x20submit\x20submit\x20touchcancel\x20touchCancel\x20touchend\x20touchEnd\x20touchstart\x20touchStart\x20volumechange\x20volumeChange"[
                    "split"
                ]("\x20"),
                0x0
            ),
                RH(
                    "drag\x20drag\x20dragenter\x20dragEnter\x20dragexit\x20dragExit\x20dragleave\x20dragLeave\x20dragover\x20dragOver\x20mousemove\x20mouseMove\x20mouseout\x20mouseOut\x20mouseover\x20mouseOver\x20pointermove\x20pointerMove\x20pointerout\x20pointerOut\x20pointerover\x20pointerOver\x20scroll\x20scroll\x20toggle\x20toggle\x20touchmove\x20touchMove\x20wheel\x20wheel"[
                        "split"
                    ]("\x20"),
                    0x1
                ),
                RH(RW, 0x2);
            for (var Rx = "change\x20selectionchange\x20textInput\x20compositionstart\x20compositionend\x20compositionupdate"["split"]("\x20"), RK = 0x0; RK < Rx["length"]; RK++) Rg["set"](Rx[RK], 0x0);
            var RV = r5["unstable_UserBlockingPriority"],
                RJ = r5["unstable_runWithPriority"],
                RG = !0x0;
            function RL(b8, b9) {
                RQ(b9, b8, !0x1);
            }
            function RQ(b8, b9, bE) {
                var bR = Rg["get"](b9);
                switch (void 0x0 === bR ? 0x2 : bR) {
                    case 0x0:
                        bR = Rz["bind"](null, b9, 0x1, b8);
                        break;
                    case 0x1:
                        bR = T0["bind"](null, b9, 0x1, b8);
                        break;
                    default:
                        bR = T1["bind"](null, b9, 0x1, b8);
                }
                bE ? b8["addEventListener"](b9, bR, !0x0) : b8["addEventListener"](b9, bR, !0x1);
            }
            function Rz(b8, b9, bE, bR) {
                rj || rw();
                var bT = T1,
                    bC = rj;
                rj = !0x0;
                try {
                    rq(bT, b8, b9, bE, bR);
                } finally {
                    (rj = bC) || rc();
                }
            }
            function T0(b8, b9, bE, bR) {
                RJ(RV, T1["bind"](null, b8, b9, bE, bR));
            }
            function T1(b8, b9, bE, bR) {
                if (RG) {
                    if (0x0 < Ry["length"] && -0x1 < RA["indexOf"](b8)) (b8 = Rp(null, b8, b9, bE, bR)), Ry["push"](b8);
                    else {
                        var bT = T2(b8, b9, bE, bR);
                        if (null === bT) Rk(b8, bR);
                        else {
                            if (-0x1 < RA["indexOf"](b8)) (b8 = Rp(bT, b8, b9, bE, bR)), Ry["push"](b8);
                            else {
                                if (
                                    !(function (bC, bd, bY, bB, bF) {
                                        switch (bd) {
                                            case "focus":
                                                return (RD = Rl(RD, bC, bd, bY, bB, bF)), !0x0;
                                            case "dragenter":
                                                return (RN = Rl(RN, bC, bd, bY, bB, bF)), !0x0;
                                            case "mouseover":
                                                return (RX = Rl(RX, bC, bd, bY, bB, bF)), !0x0;
                                            case "pointerover":
                                                var bb = bF["pointerId"];
                                                return Rf["set"](bb, Rl(Rf["get"](bb) || null, bC, bd, bY, bB, bF)), !0x0;
                                            case "gotpointercapture":
                                                return (bb = bF["pointerId"]), RP["set"](bb, Rl(RP["get"](bb) || null, bC, bd, bY, bB, bF)), !0x0;
                                        }
                                        return !0x1;
                                    })(bT, b8, b9, bE, bR)
                                ) {
                                    Rk(b8, bR), (b8 = RY(b8, bR, null, b9));
                                    try {
                                        rS(RB, b8);
                                    } finally {
                                        Rd(b8);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            function T2(b8, b9, bE, bR) {
                if (null !== (bE = Tl((bE = RR(bR))))) {
                    var bT = R2(bE);
                    if (null === bT) bE = null;
                    else {
                        var bC = bT["tag"];
                        if (0xd === bC) {
                            if (null !== (bE = R3(bT))) return bE;
                            bE = null;
                        } else {
                            if (0x3 === bC) {
                                if (bT["stateNode"]["hydrate"]) return 0x3 === bT["tag"] ? bT["stateNode"]["containerInfo"] : null;
                                bE = null;
                            } else bT !== bE && (bE = null);
                        }
                    }
                }
                b8 = RY(b8, bR, bE, b9);
                try {
                    rS(RB, b8);
                } finally {
                    Rd(b8);
                }
                return null;
            }
            var T3 = {
                    animationIterationCount: !0x0,
                    borderImageOutset: !0x0,
                    borderImageSlice: !0x0,
                    borderImageWidth: !0x0,
                    boxFlex: !0x0,
                    boxFlexGroup: !0x0,
                    boxOrdinalGroup: !0x0,
                    columnCount: !0x0,
                    columns: !0x0,
                    flex: !0x0,
                    flexGrow: !0x0,
                    flexPositive: !0x0,
                    flexShrink: !0x0,
                    flexNegative: !0x0,
                    flexOrder: !0x0,
                    gridArea: !0x0,
                    gridRow: !0x0,
                    gridRowEnd: !0x0,
                    gridRowSpan: !0x0,
                    gridRowStart: !0x0,
                    gridColumn: !0x0,
                    gridColumnEnd: !0x0,
                    gridColumnSpan: !0x0,
                    gridColumnStart: !0x0,
                    fontWeight: !0x0,
                    lineClamp: !0x0,
                    lineHeight: !0x0,
                    opacity: !0x0,
                    order: !0x0,
                    orphans: !0x0,
                    tabSize: !0x0,
                    widows: !0x0,
                    zIndex: !0x0,
                    zoom: !0x0,
                    fillOpacity: !0x0,
                    floodOpacity: !0x0,
                    stopOpacity: !0x0,
                    strokeDasharray: !0x0,
                    strokeDashoffset: !0x0,
                    strokeMiterlimit: !0x0,
                    strokeOpacity: !0x0,
                    strokeWidth: !0x0,
                },
                T4 = ["Webkit", "ms", "Moz", "O"];
            function T5(b8, b9, bE) {
                return null == b9 || "boolean" == typeof b9 || "" === b9 ? "" : bE || "number" != typeof b9 || 0x0 === b9 || (T3["hasOwnProperty"](b8) && T3[b8]) ? ("" + b9)["trim"]() : b9 + "px";
            }
            function T6(b8, b9) {
                for (var bE in ((b8 = b8["style"]), b9))
                    if (b9["hasOwnProperty"](bE)) {
                        var bR = 0x0 === bE["indexOf"]("--"),
                            bT = T5(bE, b9[bE], bR);
                        "float" === bE && (bE = "cssFloat"), bR ? b8["setProperty"](bE, bT) : (b8[bE] = bT);
                    }
            }
            Object["keys"](T3)["forEach"](function (b8) {
                T4["forEach"](function (b9) {
                    (b9 = b9 + b8["charAt"](0x0)["toUpperCase"]() + b8["substring"](0x1)), (T3[b9] = T3[b8]);
                });
            });
            var T7 = r4({ menuitem: !0x0 }, { area: !0x0, base: !0x0, br: !0x0, col: !0x0, embed: !0x0, hr: !0x0, img: !0x0, input: !0x0, keygen: !0x0, link: !0x0, meta: !0x0, param: !0x0, source: !0x0, track: !0x0, wbr: !0x0 });
            function T8(b8, b9) {
                if (b9) {
                    if (T7[b8] && (null != b9["children"] || null != b9["dangerouslySetInnerHTML"])) throw Error(r6(0x89, b8, ""));
                    if (null != b9["dangerouslySetInnerHTML"]) {
                        if (null != b9["children"]) throw Error(r6(0x3c));
                        if ("object" != typeof b9["dangerouslySetInnerHTML"] || !("__html" in b9["dangerouslySetInnerHTML"])) throw Error(r6(0x3d));
                    }
                    if (null != b9["style"] && "object" != typeof b9["style"]) throw Error(r6(0x3e, ""));
                }
            }
            function T9(b8, b9) {
                if (-0x1 === b8["indexOf"]("-")) return "string" == typeof b9["is"];
                switch (b8) {
                    case "annotation-xml":
                    case "color-profile":
                    case "font-face":
                    case "font-face-src":
                    case "font-face-uri":
                    case "font-face-format":
                    case "font-face-name":
                    case "missing-glyph":
                        return !0x1;
                    default:
                        return !0x0;
                }
            }
            var TE = Eq;
            function TR(b8, b9) {
                var bE = R1((b8 = 0x9 === b8["nodeType"] || 0xb === b8["nodeType"] ? b8 : b8["ownerDocument"]));
                b9 = rX[b9];
                for (var bR = 0x0; bR < b9["length"]; bR++) RF(b9[bR], b8, bE);
            }
            function TT() {}
            function TC(b8) {
                if (void 0x0 === (b8 = b8 || ("undefined" != typeof document ? document : void 0x0))) return null;
                try {
                    return b8["activeElement"] || b8["body"];
                } catch (b9) {
                    return b8["body"];
                }
            }
            function Td(b8) {
                for (; b8 && b8["firstChild"]; ) b8 = b8["firstChild"];
                return b8;
            }
            function TY(b8, b9) {
                var bE,
                    bR = Td(b8);
                for (b8 = 0x0; bR; ) {
                    if (0x3 === bR["nodeType"]) {
                        if (((bE = b8 + bR["textContent"]["length"]), b8 <= b9 && bE >= b9)) return { node: bR, offset: b9 - b8 };
                        b8 = bE;
                    }
                    bT: {
                        for (; bR; ) {
                            if (bR["nextSibling"]) {
                                bR = bR["nextSibling"];
                                break bT;
                            }
                            bR = bR["parentNode"];
                        }
                        bR = void 0x0;
                    }
                    bR = Td(bR);
                }
            }
            function TB(b8, b9) {
                return (
                    !(!b8 || !b9) &&
                    (b8 === b9 ||
                        ((!b8 || 0x3 !== b8["nodeType"]) &&
                            (b9 && 0x3 === b9["nodeType"] ? TB(b8, b9["parentNode"]) : "contains" in b8 ? b8["contains"](b9) : !!b8["compareDocumentPosition"] && !!(0x10 & b8["compareDocumentPosition"](b9)))))
                );
            }
            function TF() {
                for (var b8 = window, b9 = TC(); b9 instanceof b8["HTMLIFrameElement"]; ) {
                    try {
                        var bE = "string" == typeof b9["contentWindow"]["location"]["href"];
                    } catch (bR) {
                        bE = !0x1;
                    }
                    if (!bE) break;
                    b9 = TC((b8 = b9["contentWindow"])["document"]);
                }
                return b9;
            }
            function Tb(b8) {
                var b9 = b8 && b8["nodeName"] && b8["nodeName"]["toLowerCase"]();
                return b9 && (("input" === b9 && ("text" === b8["type"] || "search" === b8["type"] || "tel" === b8["type"] || "url" === b8["type"] || "password" === b8["type"])) || "textarea" === b9 || "true" === b8["contentEditable"]);
            }
            var TZ = "$?",
                Tm = "$!",
                Tv = null,
                Ty = null;
            function TD(b8, b9) {
                switch (b8) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        return !!b9["autoFocus"];
                }
                return !0x1;
            }
            function TN(b8, b9) {
                return (
                    "textarea" === b8 ||
                    "option" === b8 ||
                    "noscript" === b8 ||
                    "string" == typeof b9["children"] ||
                    "number" == typeof b9["children"] ||
                    ("object" == typeof b9["dangerouslySetInnerHTML"] && null !== b9["dangerouslySetInnerHTML"] && null != b9["dangerouslySetInnerHTML"]["__html"])
                );
            }
            var TX = "function" == typeof setTimeout ? setTimeout : void 0x0,
                Tf = "function" == typeof clearTimeout ? clearTimeout : void 0x0;
            function TP(b8) {
                for (; null != b8; b8 = b8["nextSibling"]) {
                    var b9 = b8["nodeType"];
                    if (0x1 === b9 || 0x3 === b9) break;
                }
                return b8;
            }
            function TI(b8) {
                b8 = b8["previousSibling"];
                for (var b9 = 0x0; b8; ) {
                    if (0x8 === b8["nodeType"]) {
                        var bE = b8["data"];
                        if ("$" === bE || bE === Tm || bE === TZ) {
                            if (0x0 === b9) return b8;
                            b9--;
                        } else "/$" === bE && b9++;
                    }
                    b8 = b8["previousSibling"];
                }
                return null;
            }
            var TA = Math["random"]()["toString"](0x24)["slice"](0x2),
                TM = "__reactInternalInstance$" + TA,
                Tp = "__reactEventHandlers$" + TA,
                Tk = "__reactContainere$" + TA;
            function Tl(b8) {
                var b9 = b8[TM];
                if (b9) return b9;
                for (var bE = b8["parentNode"]; bE; ) {
                    if ((b9 = bE[Tk] || bE[TM])) {
                        if (((bE = b9["alternate"]), null !== b9["child"] || (null !== bE && null !== bE["child"])))
                            for (b8 = TI(b8); null !== b8; ) {
                                if ((bE = b8[TM])) return bE;
                                b8 = TI(b8);
                            }
                        return b9;
                    }
                    bE = (b8 = bE)["parentNode"];
                }
                return null;
            }
            function TU(b8) {
                return !(b8 = b8[TM] || b8[Tk]) || (0x5 !== b8["tag"] && 0x6 !== b8["tag"] && 0xd !== b8["tag"] && 0x3 !== b8["tag"]) ? null : b8;
            }
            function Tq(b8) {
                if (0x5 === b8["tag"] || 0x6 === b8["tag"]) return b8["stateNode"];
                throw Error(r6(0x21));
            }
            function Tw(b8) {
                return b8[Tp] || null;
            }
            function TO(b8) {
                do {
                    b8 = b8["return"];
                } while (b8 && 0x5 !== b8["tag"]);
                return b8 || null;
            }
            function Tj(b8, b9) {
                var bE = b8["stateNode"];
                if (!bE) return null;
                var bR = rd(bE);
                if (!bR) return null;
                bE = bR[b9];
                bT: switch (b9) {
                    case "onClick":
                    case "onClickCapture":
                    case "onDoubleClick":
                    case "onDoubleClickCapture":
                    case "onMouseDown":
                    case "onMouseDownCapture":
                    case "onMouseMove":
                    case "onMouseMoveCapture":
                    case "onMouseUp":
                    case "onMouseUpCapture":
                    case "onMouseEnter":
                        (bR = !bR["disabled"]) || (bR = !("button" === (b8 = b8["type"]) || "input" === b8 || "select" === b8 || "textarea" === b8)), (b8 = !bR);
                        break bT;
                    default:
                        b8 = !0x1;
                }
                if (b8) return null;
                if (bE && "function" != typeof bE) throw Error(r6(0xe7, b9, typeof bE));
                return bE;
            }
            function Th(b8, b9, bE) {
                (b9 = Tj(b8, bE["dispatchConfig"]["phasedRegistrationNames"][b9])) && ((bE["_dispatchListeners"] = R6(bE["_dispatchListeners"], b9)), (bE["_dispatchInstances"] = R6(bE["_dispatchInstances"], b8)));
            }
            function Tc(b8) {
                if (b8 && b8["dispatchConfig"]["phasedRegistrationNames"]) {
                    for (var b9 = b8["_targetInst"], bE = []; b9; ) bE["push"](b9), (b9 = TO(b9));
                    for (b9 = bE["length"]; 0x0 < b9--; ) Th(bE[b9], "captured", b8);
                    for (b9 = 0x0; b9 < bE["length"]; b9++) Th(bE[b9], "bubbled", b8);
                }
            }
            function TS(b8, b9, bE) {
                b8 &&
                    bE &&
                    bE["dispatchConfig"]["registrationName"] &&
                    (b9 = Tj(b8, bE["dispatchConfig"]["registrationName"])) &&
                    ((bE["_dispatchListeners"] = R6(bE["_dispatchListeners"], b9)), (bE["_dispatchInstances"] = R6(bE["_dispatchInstances"], b8)));
            }
            function Tg(b8) {
                b8 && b8["dispatchConfig"]["registrationName"] && TS(b8["_targetInst"], null, b8);
            }
            function TW(b8) {
                R7(b8, Tc);
            }
            var TH = null,
                Tx = null,
                TK = null;
            function TV() {
                if (TK) return TK;
                var b8,
                    b9,
                    bE = Tx,
                    bR = bE["length"],
                    bT = "value" in TH ? TH["value"] : TH["textContent"],
                    bC = bT["length"];
                for (b8 = 0x0; b8 < bR && bE[b8] === bT[b8]; b8++);
                var bd = bR - b8;
                for (b9 = 0x1; b9 <= bd && bE[bR - b9] === bT[bC - b9]; b9++);
                return (TK = bT["slice"](b8, 0x1 < b9 ? 0x1 - b9 : void 0x0));
            }
            function TJ() {
                return !0x0;
            }
            function TG() {
                return !0x1;
            }
            function TL(b8, b9, bE, bR) {
                for (var bT in ((this["dispatchConfig"] = b8), (this["_targetInst"] = b9), (this["nativeEvent"] = bE), (b8 = this["constructor"]["Interface"])))
                    b8["hasOwnProperty"](bT) && ((b9 = b8[bT]) ? (this[bT] = b9(bE)) : "target" === bT ? (this["target"] = bR) : (this[bT] = bE[bT]));
                return (this["isDefaultPrevented"] = (null != bE["defaultPrevented"] ? bE["defaultPrevented"] : !0x1 === bE["returnValue"]) ? TJ : TG), (this["isPropagationStopped"] = TG), this;
            }
            function TQ(b8, b9, bE, bR) {
                if (this["eventPool"]["length"]) {
                    var bT = this["eventPool"]["pop"]();
                    return this["call"](bT, b8, b9, bE, bR), bT;
                }
                return new this(b8, b9, bE, bR);
            }
            function Tz(b8) {
                if (!(b8 instanceof this)) throw Error(r6(0x117));
                b8["destructor"](), 0xa > this["eventPool"]["length"] && this["eventPool"]["push"](b8);
            }
            function C0(b8) {
                (b8["eventPool"] = []), (b8["getPooled"] = TQ), (b8["release"] = Tz);
            }
            r4(TL["prototype"], {
                preventDefault: function () {
                    this["defaultPrevented"] = !0x0;
                    var b8 = this["nativeEvent"];
                    b8 && (b8["preventDefault"] ? b8["preventDefault"]() : "unknown" != typeof b8["returnValue"] && (b8["returnValue"] = !0x1), (this["isDefaultPrevented"] = TJ));
                },
                stopPropagation: function () {
                    var b8 = this["nativeEvent"];
                    b8 && (b8["stopPropagation"] ? b8["stopPropagation"]() : "unknown" != typeof b8["cancelBubble"] && (b8["cancelBubble"] = !0x0), (this["isPropagationStopped"] = TJ));
                },
                persist: function () {
                    this["isPersistent"] = TJ;
                },
                isPersistent: TG,
                destructor: function () {
                    var b8,
                        b9 = this["constructor"]["Interface"];
                    for (b8 in b9) this[b8] = null;
                    (this["nativeEvent"] = this["_targetInst"] = this["dispatchConfig"] = null), (this["isPropagationStopped"] = this["isDefaultPrevented"] = TG), (this["_dispatchInstances"] = this["_dispatchListeners"] = null);
                },
            }),
                (TL["Interface"] = {
                    type: null,
                    target: null,
                    currentTarget: function () {
                        return null;
                    },
                    eventPhase: null,
                    bubbles: null,
                    cancelable: null,
                    timeStamp: function (b8) {
                        return b8["timeStamp"] || Date["now"]();
                    },
                    defaultPrevented: null,
                    isTrusted: null,
                }),
                (TL["extend"] = function (b8) {
                    function b9() {}
                    function bE() {
                        return bR["apply"](this, arguments);
                    }
                    var bR = this;
                    b9["prototype"] = bR["prototype"];
                    var bT = new b9();
                    return r4(bT, bE["prototype"]), (bE["prototype"] = bT), (bE["prototype"]["constructor"] = bE), (bE["Interface"] = r4({}, bR["Interface"], b8)), (bE["extend"] = bR["extend"]), C0(bE), bE;
                }),
                C0(TL);
            var C1 = TL["extend"]({ data: null }),
                C2 = TL["extend"]({ data: null }),
                C3 = [0x9, 0xd, 0x1b, 0x20],
                C4 = rP && "CompositionEvent" in window,
                C5 = null;
            rP && "documentMode" in document && (C5 = document["documentMode"]);
            var C6 = rP && "TextEvent" in window && !C5,
                C7 = rP && (!C4 || (C5 && 0x8 < C5 && 0xb >= C5)),
                C8 = String["fromCharCode"](0x20),
                C9 = {
                    beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["compositionend", "keypress", "textInput", "paste"] },
                    compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "blur\x20compositionend\x20keydown\x20keypress\x20keyup\x20mousedown"["split"]("\x20") },
                    compositionStart: {
                        phasedRegistrationNames: { bubbled: "onCompositionStart", captured: "onCompositionStartCapture" },
                        dependencies: "blur\x20compositionstart\x20keydown\x20keypress\x20keyup\x20mousedown"["split"]("\x20"),
                    },
                    compositionUpdate: {
                        phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" },
                        dependencies: "blur\x20compositionupdate\x20keydown\x20keypress\x20keyup\x20mousedown"["split"]("\x20"),
                    },
                },
                CE = !0x1;
            function CR(b8, b9) {
                switch (b8) {
                    case "keyup":
                        return -0x1 !== C3["indexOf"](b9["keyCode"]);
                    case "keydown":
                        return 0xe5 !== b9["keyCode"];
                    case "keypress":
                    case "mousedown":
                    case "blur":
                        return !0x0;
                    default:
                        return !0x1;
                }
            }
            function CT(b8) {
                return "object" == typeof (b8 = b8["detail"]) && "data" in b8 ? b8["data"] : null;
            }
            var CC = !0x1,
                Cd = {
                    eventTypes: C9,
                    extractEvents: function (b8, b9, bE, bR) {
                        var bT;
                        if (C4)
                            bd: {
                                switch (b8) {
                                    case "compositionstart":
                                        var bC = C9["compositionStart"];
                                        break bd;
                                    case "compositionend":
                                        bC = C9["compositionEnd"];
                                        break bd;
                                    case "compositionupdate":
                                        bC = C9["compositionUpdate"];
                                        break bd;
                                }
                                bC = void 0x0;
                            }
                        else CC ? CR(b8, bE) && (bC = C9["compositionEnd"]) : "keydown" === b8 && 0xe5 === bE["keyCode"] && (bC = C9["compositionStart"]);
                        return (
                            bC
                                ? (C7 && "ko" !== bE["locale"] && (CC || bC !== C9["compositionStart"] ? bC === C9["compositionEnd"] && CC && (bT = TV()) : ((Tx = "value" in (TH = bR) ? TH["value"] : TH["textContent"]), (CC = !0x0))),
                                  (bC = C1["getPooled"](bC, b9, bE, bR)),
                                  bT ? (bC["data"] = bT) : null !== (bT = CT(bE)) && (bC["data"] = bT),
                                  TW(bC),
                                  (bT = bC))
                                : (bT = null),
                            (b8 = C6
                                ? (function (bd, bY) {
                                      switch (bd) {
                                          case "compositionend":
                                              return CT(bY);
                                          case "keypress":
                                              return 0x20 !== bY["which"] ? null : ((CE = !0x0), C8);
                                          case "textInput":
                                              return (bd = bY["data"]) === C8 && CE ? null : bd;
                                          default:
                                              return null;
                                      }
                                  })(b8, bE)
                                : (function (bd, bY) {
                                      if (CC) return "compositionend" === bd || (!C4 && CR(bd, bY)) ? ((bd = TV()), (TK = Tx = TH = null), (CC = !0x1), bd) : null;
                                      switch (bd) {
                                          case "paste":
                                          default:
                                              return null;
                                          case "keypress":
                                              if (!(bY["ctrlKey"] || bY["altKey"] || bY["metaKey"]) || (bY["ctrlKey"] && bY["altKey"])) {
                                                  if (bY["char"] && 0x1 < bY["char"]["length"]) return bY["char"];
                                                  if (bY["which"]) return String["fromCharCode"](bY["which"]);
                                              }
                                              return null;
                                          case "compositionend":
                                              return C7 && "ko" !== bY["locale"] ? null : bY["data"];
                                      }
                                  })(b8, bE))
                                ? (((b9 = C2["getPooled"](C9["beforeInput"], b9, bE, bR))["data"] = b8), TW(b9))
                                : (b9 = null),
                            null === bT ? b9 : null === b9 ? bT : [bT, b9]
                        );
                    },
                },
                CY = { color: !0x0, date: !0x0, datetime: !0x0, "datetime-local": !0x0, email: !0x0, month: !0x0, number: !0x0, password: !0x0, range: !0x0, search: !0x0, tel: !0x0, text: !0x0, time: !0x0, url: !0x0, week: !0x0 };
            function CB(b8) {
                var b9 = b8 && b8["nodeName"] && b8["nodeName"]["toLowerCase"]();
                return "input" === b9 ? !!CY[b8["type"]] : "textarea" === b9;
            }
            var CF = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "blur\x20change\x20click\x20focus\x20input\x20keydown\x20keyup\x20selectionchange"["split"]("\x20") } };
            function Cb(b8, b9, bE) {
                return ((b8 = TL["getPooled"](CF["change"], b8, b9, bE))["type"] = "change"), rk(bE), TW(b8), b8;
            }
            var CZ = null,
                Cm = null;
            function Cv(b8) {
                RE(b8);
            }
            function Cy(b8) {
                if (Ey(Tq(b8))) return b8;
            }
            function CD(b8, b9) {
                if ("change" === b8) return b9;
            }
            var CN = !0x1;
            function CX() {
                CZ && (CZ["detachEvent"]("onpropertychange", Cf), (Cm = CZ = null));
            }
            function Cf(b8) {
                if ("value" === b8["propertyName"] && Cy(Cm)) {
                    if (((b8 = Cb(Cm, b8, RR(b8))), rj)) RE(b8);
                    else {
                        rj = !0x0;
                        try {
                            rU(Cv, b8);
                        } finally {
                            (rj = !0x1), rc();
                        }
                    }
                }
            }
            function CP(b8, b9, bE) {
                "focus" === b8 ? (CX(), (Cm = bE), (CZ = b9)["attachEvent"]("onpropertychange", Cf)) : "blur" === b8 && CX();
            }
            function CI(b8) {
                if ("selectionchange" === b8 || "keyup" === b8 || "keydown" === b8) return Cy(Cm);
            }
            function CA(b8, b9) {
                if ("click" === b8) return Cy(b9);
            }
            function CM(b8, b9) {
                if ("input" === b8 || "change" === b8) return Cy(b9);
            }
            rP && (CN = RT("input") && (!document["documentMode"] || 0x9 < document["documentMode"]));
            var Cp = {
                    eventTypes: CF,
                    _isInputEventSupported: CN,
                    extractEvents: function (b8, b9, bE, bR) {
                        var bT = b9 ? Tq(b9) : window,
                            bC = bT["nodeName"] && bT["nodeName"]["toLowerCase"]();
                        if ("select" === bC || ("input" === bC && "file" === bT["type"])) var bd = CD;
                        else {
                            if (CB(bT)) {
                                if (CN) bd = CM;
                                else {
                                    bd = CI;
                                    var bY = CP;
                                }
                            } else (bC = bT["nodeName"]) && "input" === bC["toLowerCase"]() && ("checkbox" === bT["type"] || "radio" === bT["type"]) && (bd = CA);
                        }
                        if (bd && (bd = bd(b8, b9))) return Cb(bd, bE, bR);
                        bY && bY(b8, bT, b9), "blur" === b8 && (b8 = bT["_wrapperState"]) && b8["controlled"] && "number" === bT["type"] && EI(bT, "number", bT["value"]);
                    },
                },
                Ck = TL["extend"]({ view: null, detail: null }),
                Cl = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
            function CU(b8) {
                var b9 = this["nativeEvent"];
                return b9["getModifierState"] ? b9["getModifierState"](b8) : !!(b8 = Cl[b8]) && !!b9[b8];
            }
            function Cq() {
                return CU;
            }
            var Cw = 0x0,
                CO = 0x0,
                Cj = !0x1,
                Ch = !0x1,
                Cc = Ck["extend"]({
                    screenX: null,
                    screenY: null,
                    clientX: null,
                    clientY: null,
                    pageX: null,
                    pageY: null,
                    ctrlKey: null,
                    shiftKey: null,
                    altKey: null,
                    metaKey: null,
                    getModifierState: Cq,
                    button: null,
                    buttons: null,
                    relatedTarget: function (b8) {
                        return b8["relatedTarget"] || (b8["fromElement"] === b8["srcElement"] ? b8["toElement"] : b8["fromElement"]);
                    },
                    movementX: function (b8) {
                        if ("movementX" in b8) return b8["movementX"];
                        var b9 = Cw;
                        return (Cw = b8["screenX"]), Cj ? ("mousemove" === b8["type"] ? b8["screenX"] - b9 : 0x0) : ((Cj = !0x0), 0x0);
                    },
                    movementY: function (b8) {
                        if ("movementY" in b8) return b8["movementY"];
                        var b9 = CO;
                        return (CO = b8["screenY"]), Ch ? ("mousemove" === b8["type"] ? b8["screenY"] - b9 : 0x0) : ((Ch = !0x0), 0x0);
                    },
                }),
                CS = Cc["extend"]({ pointerId: null, width: null, height: null, pressure: null, tangentialPressure: null, tiltX: null, tiltY: null, twist: null, pointerType: null, isPrimary: null }),
                Cg = {
                    mouseEnter: { registrationName: "onMouseEnter", dependencies: ["mouseout", "mouseover"] },
                    mouseLeave: { registrationName: "onMouseLeave", dependencies: ["mouseout", "mouseover"] },
                    pointerEnter: { registrationName: "onPointerEnter", dependencies: ["pointerout", "pointerover"] },
                    pointerLeave: { registrationName: "onPointerLeave", dependencies: ["pointerout", "pointerover"] },
                },
                CW = {
                    eventTypes: Cg,
                    extractEvents: function (b8, b9, bE, bR, bT) {
                        var bC = "mouseover" === b8 || "pointerover" === b8,
                            bd = "mouseout" === b8 || "pointerout" === b8;
                        if ((bC && 0x0 == (0x20 & bT) && (bE["relatedTarget"] || bE["fromElement"])) || (!bd && !bC)) return null;
                        ((bC = bR["window"] === bR ? bR : (bC = bR["ownerDocument"]) ? bC["defaultView"] || bC["parentWindow"] : window), bd)
                            ? ((bd = b9), null !== (b9 = (b9 = bE["relatedTarget"] || bE["toElement"]) ? Tl(b9) : null) && (b9 !== R2(b9) || (0x5 !== b9["tag"] && 0x6 !== b9["tag"])) && (b9 = null))
                            : (bd = null);
                        if (bd === b9) return null;
                        if ("mouseout" === b8 || "mouseover" === b8)
                            var bY = Cc,
                                bB = Cg["mouseLeave"],
                                bF = Cg["mouseEnter"],
                                bb = "mouse";
                        else ("pointerout" !== b8 && "pointerover" !== b8) || ((bY = CS), (bB = Cg["pointerLeave"]), (bF = Cg["pointerEnter"]), (bb = "pointer"));
                        if (
                            ((b8 = null == bd ? bC : Tq(bd)),
                            (bC = null == b9 ? bC : Tq(b9)),
                            ((bB = bY["getPooled"](bB, bd, bE, bR))["type"] = bb + "leave"),
                            (bB["target"] = b8),
                            (bB["relatedTarget"] = bC),
                            ((bE = bY["getPooled"](bF, b9, bE, bR))["type"] = bb + "enter"),
                            (bE["target"] = bC),
                            (bE["relatedTarget"] = b8),
                            (bb = b9),
                            (bR = bd) && bb)
                        )
                            bZ: {
                                for (bF = bb, bd = 0x0, b8 = bY = bR; b8; b8 = TO(b8)) bd++;
                                for (b8 = 0x0, b9 = bF; b9; b9 = TO(b9)) b8++;
                                for (; 0x0 < bd - b8; ) (bY = TO(bY)), bd--;
                                for (; 0x0 < b8 - bd; ) (bF = TO(bF)), b8--;
                                for (; bd--; ) {
                                    if (bY === bF || bY === bF["alternate"]) break bZ;
                                    (bY = TO(bY)), (bF = TO(bF));
                                }
                                bY = null;
                            }
                        else bY = null;
                        for (bF = bY, bY = []; bR && bR !== bF && (null === (bd = bR["alternate"]) || bd !== bF); ) bY["push"](bR), (bR = TO(bR));
                        for (bR = []; bb && bb !== bF && (null === (bd = bb["alternate"]) || bd !== bF); ) bR["push"](bb), (bb = TO(bb));
                        for (bb = 0x0; bb < bY["length"]; bb++) TS(bY[bb], "bubbled", bB);
                        for (bb = bR["length"]; 0x0 < bb--; ) TS(bR[bb], "captured", bE);
                        return 0x0 == (0x40 & bT) ? [bB] : [bB, bE];
                    },
                },
                CH =
                    "function" == typeof Object["is"]
                        ? Object["is"]
                        : function (b8, b9) {
                              return (b8 === b9 && (0x0 !== b8 || 0x1 / b8 == 0x1 / b9)) || (b8 != b8 && b9 != b9);
                          },
                Cx = Object["prototype"]["hasOwnProperty"];
            function CK(b8, b9) {
                if (CH(b8, b9)) return !0x0;
                if ("object" != typeof b8 || null === b8 || "object" != typeof b9 || null === b9) return !0x1;
                var bE = Object["keys"](b8),
                    bR = Object["keys"](b9);
                if (bE["length"] !== bR["length"]) return !0x1;
                for (bR = 0x0; bR < bE["length"]; bR++) if (!Cx["call"](b9, bE[bR]) || !CH(b8[bE[bR]], b9[bE[bR]])) return !0x1;
                return !0x0;
            }
            var CV = rP && "documentMode" in document && 0xb >= document["documentMode"],
                CJ = {
                    select: {
                        phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" },
                        dependencies: "blur\x20contextmenu\x20dragend\x20focus\x20keydown\x20keyup\x20mousedown\x20mouseup\x20selectionchange"["split"]("\x20"),
                    },
                },
                CG = null,
                CL = null,
                CQ = null,
                Cz = !0x1;
            function d0(b8, b9) {
                var bE = b9["window"] === b9 ? b9["document"] : 0x9 === b9["nodeType"] ? b9 : b9["ownerDocument"];
                return Cz || null == CG || CG !== TC(bE)
                    ? null
                    : ("selectionStart" in (bE = CG) && Tb(bE)
                          ? (bE = { start: bE["selectionStart"], end: bE["selectionEnd"] })
                          : (bE = {
                                anchorNode: (bE = ((bE["ownerDocument"] && bE["ownerDocument"]["defaultView"]) || window)["getSelection"]())["anchorNode"],
                                anchorOffset: bE["anchorOffset"],
                                focusNode: bE["focusNode"],
                                focusOffset: bE["focusOffset"],
                            }),
                      CQ && CK(CQ, bE) ? null : ((CQ = bE), ((b8 = TL["getPooled"](CJ["select"], CL, b8, b9))["type"] = "select"), (b8["target"] = CG), TW(b8), b8));
            }
            var d1 = {
                    eventTypes: CJ,
                    extractEvents: function (b8, b9, bE, bR, bT, bC) {
                        if (!(bC = !(bT = bC || (bR["window"] === bR ? bR["document"] : 0x9 === bR["nodeType"] ? bR : bR["ownerDocument"])))) {
                            bY: {
                                (bT = R1(bT)), (bC = rX["onSelect"]);
                                for (var bd = 0x0; bd < bC["length"]; bd++)
                                    if (!bT["has"](bC[bd])) {
                                        bT = !0x1;
                                        break bY;
                                    }
                                bT = !0x0;
                            }
                            bC = !bT;
                        }
                        if (bC) return null;
                        switch (((bT = b9 ? Tq(b9) : window), b8)) {
                            case "focus":
                                (CB(bT) || "true" === bT["contentEditable"]) && ((CG = bT), (CL = b9), (CQ = null));
                                break;
                            case "blur":
                                CQ = CL = CG = null;
                                break;
                            case "mousedown":
                                Cz = !0x0;
                                break;
                            case "contextmenu":
                            case "mouseup":
                            case "dragend":
                                return (Cz = !0x1), d0(bE, bR);
                            case "selectionchange":
                                if (CV) break;
                            case "keydown":
                            case "keyup":
                                return d0(bE, bR);
                        }
                        return null;
                    },
                },
                d2 = TL["extend"]({ animationName: null, elapsedTime: null, pseudoElement: null }),
                d3 = TL["extend"]({
                    clipboardData: function (b8) {
                        return "clipboardData" in b8 ? b8["clipboardData"] : window["clipboardData"];
                    },
                }),
                d4 = Ck["extend"]({ relatedTarget: null });
            function d5(b8) {
                var b9 = b8["keyCode"];
                return "charCode" in b8 ? 0x0 === (b8 = b8["charCode"]) && 0xd === b9 && (b8 = 0xd) : (b8 = b9), 0xa === b8 && (b8 = 0xd), 0x20 <= b8 || 0xd === b8 ? b8 : 0x0;
            }
            var d6 = {
                    Esc: "Escape",
                    Spacebar: "\x20",
                    Left: "ArrowLeft",
                    Up: "ArrowUp",
                    Right: "ArrowRight",
                    Down: "ArrowDown",
                    Del: "Delete",
                    Win: "OS",
                    Menu: "ContextMenu",
                    Apps: "ContextMenu",
                    Scroll: "ScrollLock",
                    MozPrintableKey: "Unidentified",
                },
                d7 = {
                    0x8: "Backspace",
                    0x9: "Tab",
                    0xc: "Clear",
                    0xd: "Enter",
                    0x10: "Shift",
                    0x11: "Control",
                    0x12: "Alt",
                    0x13: "Pause",
                    0x14: "CapsLock",
                    0x1b: "Escape",
                    0x20: "\x20",
                    0x21: "PageUp",
                    0x22: "PageDown",
                    0x23: "End",
                    0x24: "Home",
                    0x25: "ArrowLeft",
                    0x26: "ArrowUp",
                    0x27: "ArrowRight",
                    0x28: "ArrowDown",
                    0x2d: "Insert",
                    0x2e: "Delete",
                    0x70: "F1",
                    0x71: "F2",
                    0x72: "F3",
                    0x73: "F4",
                    0x74: "F5",
                    0x75: "F6",
                    0x76: "F7",
                    0x77: "F8",
                    0x78: "F9",
                    0x79: "F10",
                    0x7a: "F11",
                    0x7b: "F12",
                    0x90: "NumLock",
                    0x91: "ScrollLock",
                    0xe0: "Meta",
                },
                d8 = Ck["extend"]({
                    key: function (b8) {
                        if (b8["key"]) {
                            var b9 = d6[b8["key"]] || b8["key"];
                            if ("Unidentified" !== b9) return b9;
                        }
                        return "keypress" === b8["type"] ? (0xd === (b8 = d5(b8)) ? "Enter" : String["fromCharCode"](b8)) : "keydown" === b8["type"] || "keyup" === b8["type"] ? d7[b8["keyCode"]] || "Unidentified" : "";
                    },
                    location: null,
                    ctrlKey: null,
                    shiftKey: null,
                    altKey: null,
                    metaKey: null,
                    repeat: null,
                    locale: null,
                    getModifierState: Cq,
                    charCode: function (b8) {
                        return "keypress" === b8["type"] ? d5(b8) : 0x0;
                    },
                    keyCode: function (b8) {
                        return "keydown" === b8["type"] || "keyup" === b8["type"] ? b8["keyCode"] : 0x0;
                    },
                    which: function (b8) {
                        return "keypress" === b8["type"] ? d5(b8) : "keydown" === b8["type"] || "keyup" === b8["type"] ? b8["keyCode"] : 0x0;
                    },
                }),
                d9 = Cc["extend"]({ dataTransfer: null }),
                dE = Ck["extend"]({ touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Cq }),
                dR = TL["extend"]({ propertyName: null, elapsedTime: null, pseudoElement: null }),
                dT = Cc["extend"]({
                    deltaX: function (b8) {
                        return "deltaX" in b8 ? b8["deltaX"] : "wheelDeltaX" in b8 ? -b8["wheelDeltaX"] : 0x0;
                    },
                    deltaY: function (b8) {
                        return "deltaY" in b8 ? b8["deltaY"] : "wheelDeltaY" in b8 ? -b8["wheelDeltaY"] : "wheelDelta" in b8 ? -b8["wheelDelta"] : 0x0;
                    },
                    deltaZ: null,
                    deltaMode: null,
                }),
                dC = {
                    eventTypes: Rc,
                    extractEvents: function (b8, b9, bE, bR) {
                        var bT = RS["get"](b8);
                        if (!bT) return null;
                        switch (b8) {
                            case "keypress":
                                if (0x0 === d5(bE)) return null;
                            case "keydown":
                            case "keyup":
                                b8 = d8;
                                break;
                            case "blur":
                            case "focus":
                                b8 = d4;
                                break;
                            case "click":
                                if (0x2 === bE["button"]) return null;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                b8 = Cc;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                b8 = d9;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                b8 = dE;
                                break;
                            case EJ:
                            case EG:
                            case EL:
                                b8 = d2;
                                break;
                            case EQ:
                                b8 = dR;
                                break;
                            case "scroll":
                                b8 = Ck;
                                break;
                            case "wheel":
                                b8 = dT;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                b8 = d3;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                b8 = CS;
                                break;
                            default:
                                b8 = TL;
                        }
                        return TW((b9 = b8["getPooled"](bT, b9, bE, bR))), b9;
                    },
                };
            if (rb) throw Error(r6(0x65));
            (rb = Array["prototype"]["slice"]["call"]("ResponderEventPlugin\x20SimpleEventPlugin\x20EnterLeaveEventPlugin\x20ChangeEventPlugin\x20SelectEventPlugin\x20BeforeInputEventPlugin"["split"]("\x20"))),
                rm(),
                (rd = Tw),
                (rY = TU),
                (rB = Tq),
                rf({ SimpleEventPlugin: dC, EnterLeaveEventPlugin: CW, ChangeEventPlugin: Cp, SelectEventPlugin: d1, BeforeInputEventPlugin: Cd });
            var dd = [],
                dY = -0x1;
            function dB(b8) {
                0x0 > dY || ((b8["current"] = dd[dY]), (dd[dY] = null), dY--);
            }
            function dF(b8, b9) {
                dY++, (dd[dY] = b8["current"]), (b8["current"] = b9);
            }
            var db = {},
                dZ = { current: db },
                dm = { current: !0x1 },
                dv = db;
            function dy(b8, b9) {
                var bE = b8["type"]["contextTypes"];
                if (!bE) return db;
                var bR = b8["stateNode"];
                if (bR && bR["__reactInternalMemoizedUnmaskedChildContext"] === b9) return bR["__reactInternalMemoizedMaskedChildContext"];
                var bT,
                    bC = {};
                for (bT in bE) bC[bT] = b9[bT];
                return bR && (((b8 = b8["stateNode"])["__reactInternalMemoizedUnmaskedChildContext"] = b9), (b8["__reactInternalMemoizedMaskedChildContext"] = bC)), bC;
            }
            function dD(b8) {
                return null != (b8 = b8["childContextTypes"]);
            }
            function dN() {
                dB(dm), dB(dZ);
            }
            function dX(b8, b9, bE) {
                if (dZ["current"] !== db) throw Error(r6(0xa8));
                dF(dZ, b9), dF(dm, bE);
            }
            function df(b8, b9, bE) {
                var bR = b8["stateNode"];
                if (((b8 = b9["childContextTypes"]), "function" != typeof bR["getChildContext"])) return bE;
                for (var bT in (bR = bR["getChildContext"]())) if (!(bT in b8)) throw Error(r6(0x6c, EF(b9) || "Unknown", bT));
                return r4({}, bE, {}, bR);
            }
            function dP(b8) {
                return (b8 = ((b8 = b8["stateNode"]) && b8["__reactInternalMemoizedMergedChildContext"]) || db), (dv = dZ["current"]), dF(dZ, b8), dF(dm, dm["current"]), !0x0;
            }
            function dI(b8, b9, bE) {
                var bR = b8["stateNode"];
                if (!bR) throw Error(r6(0xa9));
                bE ? ((b8 = df(b8, b9, dv)), (bR["__reactInternalMemoizedMergedChildContext"] = b8), dB(dm), dB(dZ), dF(dZ, b8)) : dB(dm), dF(dm, bE);
            }
            var dA = r5["unstable_runWithPriority"],
                dM = r5["unstable_scheduleCallback"],
                dp = r5["unstable_cancelCallback"],
                dk = r5["unstable_requestPaint"],
                dl = r5["unstable_now"],
                dU = r5["unstable_getCurrentPriorityLevel"],
                dq = r5["unstable_ImmediatePriority"],
                dw = r5["unstable_UserBlockingPriority"],
                dO = r5["unstable_NormalPriority"],
                dj = r5["unstable_LowPriority"],
                dh = r5["unstable_IdlePriority"],
                dc = {},
                dS = r5["unstable_shouldYield"],
                dg = void 0x0 !== dk ? dk : function () {},
                dW = null,
                dH = null,
                dx = !0x1,
                dK = dl(),
                dV =
                    0x2710 > dK
                        ? dl
                        : function () {
                              return dl() - dK;
                          };
            function dJ() {
                switch (dU()) {
                    case dq:
                        return 0x63;
                    case dw:
                        return 0x62;
                    case dO:
                        return 0x61;
                    case dj:
                        return 0x60;
                    case dh:
                        return 0x5f;
                    default:
                        throw Error(r6(0x14c));
                }
            }
            function dG(b8) {
                switch (b8) {
                    case 0x63:
                        return dq;
                    case 0x62:
                        return dw;
                    case 0x61:
                        return dO;
                    case 0x60:
                        return dj;
                    case 0x5f:
                        return dh;
                    default:
                        throw Error(r6(0x14c));
                }
            }
            function dL(b8, b9) {
                return (b8 = dG(b8)), dA(b8, b9);
            }
            function dQ(b8, b9, bE) {
                return (b8 = dG(b8)), dM(b8, b9, bE);
            }
            function dz(b8) {
                return null === dW ? ((dW = [b8]), (dH = dM(dq, Y1))) : dW["push"](b8), dc;
            }
            function Y0() {
                if (null !== dH) {
                    var b8 = dH;
                    (dH = null), dp(b8);
                }
                Y1();
            }
            function Y1() {
                if (!dx && null !== dW) {
                    dx = !0x0;
                    var b8 = 0x0;
                    try {
                        var b9 = dW;
                        dL(0x63, function () {
                            for (; b8 < b9["length"]; b8++) {
                                var bE = b9[b8];
                                do {
                                    bE = bE(!0x0);
                                } while (null !== bE);
                            }
                        }),
                            (dW = null);
                    } catch (bE) {
                        throw (null !== dW && (dW = dW["slice"](b8 + 0x1)), dM(dq, Y0), bE);
                    } finally {
                        dx = !0x1;
                    }
                }
            }
            function Y2(b8, b9, bE) {
                return 0x3ffffffd - (0x1 + (((0x3ffffffd - b8 + b9 / 0xa) / (bE /= 0xa)) | 0x0)) * bE;
            }
            function Y3(b8, b9) {
                if (b8 && b8["defaultProps"]) {
                    for (var bE in ((b9 = r4({}, b9)), (b8 = b8["defaultProps"]))) void 0x0 === b9[bE] && (b9[bE] = b8[bE]);
                }
                return b9;
            }
            var Y4 = { current: null },
                Y5 = null,
                Y6 = null,
                Y7 = null;
            function Y8() {
                Y7 = Y6 = Y5 = null;
            }
            function Y9(b8) {
                var b9 = Y4["current"];
                dB(Y4), (b8["type"]["_context"]["_currentValue"] = b9);
            }
            function YE(b8, b9) {
                for (; null !== b8; ) {
                    var bE = b8["alternate"];
                    if (b8["childExpirationTime"] < b9) (b8["childExpirationTime"] = b9), null !== bE && bE["childExpirationTime"] < b9 && (bE["childExpirationTime"] = b9);
                    else {
                        if (!(null !== bE && bE["childExpirationTime"] < b9)) break;
                        bE["childExpirationTime"] = b9;
                    }
                    b8 = b8["return"];
                }
            }
            function YR(b8, b9) {
                (Y5 = b8), (Y7 = Y6 = null), null !== (b8 = b8["dependencies"]) && null !== b8["firstContext"] && (b8["expirationTime"] >= b9 && (nh = !0x0), (b8["firstContext"] = null));
            }
            function YT(b8, b9) {
                if (Y7 !== b8 && !0x1 !== b9 && 0x0 !== b9) {
                    if ((("number" == typeof b9 && 0x3fffffff !== b9) || ((Y7 = b8), (b9 = 0x3fffffff)), (b9 = { context: b8, observedBits: b9, next: null }), null === Y6)) {
                        if (null === Y5) throw Error(r6(0x134));
                        (Y6 = b9), (Y5["dependencies"] = { expirationTime: 0x0, firstContext: b9, responders: null });
                    } else Y6 = Y6["next"] = b9;
                }
                return b8["_currentValue"];
            }
            var YC = !0x1;
            function Yd(b8) {
                b8["updateQueue"] = { baseState: b8["memoizedState"], baseQueue: null, shared: { pending: null }, effects: null };
            }
            function YY(b8, b9) {
                (b8 = b8["updateQueue"]), b9["updateQueue"] === b8 && (b9["updateQueue"] = { baseState: b8["baseState"], baseQueue: b8["baseQueue"], shared: b8["shared"], effects: b8["effects"] });
            }
            function YB(b8, b9) {
                return ((b8 = { expirationTime: b8, suspenseConfig: b9, tag: 0x0, payload: null, callback: null, next: null })["next"] = b8);
            }
            function YF(b8, b9) {
                if (null !== (b8 = b8["updateQueue"])) {
                    var bE = (b8 = b8["shared"])["pending"];
                    null === bE ? (b9["next"] = b9) : ((b9["next"] = bE["next"]), (bE["next"] = b9)), (b8["pending"] = b9);
                }
            }
            function Yb(b8, b9) {
                var bE = b8["alternate"];
                null !== bE && YY(bE, b8), null === (bE = (b8 = b8["updateQueue"])["baseQueue"]) ? ((b8["baseQueue"] = b9["next"] = b9), (b9["next"] = b9)) : ((b9["next"] = bE["next"]), (bE["next"] = b9));
            }
            function YZ(b8, b9, bE, bR) {
                var bT = b8["updateQueue"];
                YC = !0x1;
                var bC = bT["baseQueue"],
                    bd = bT["shared"]["pending"];
                if (null !== bd) {
                    if (null !== bC) {
                        var bY = bC["next"];
                        (bC["next"] = bd["next"]), (bd["next"] = bY);
                    }
                    (bC = bd), (bT["shared"]["pending"] = null), null !== (bY = b8["alternate"]) && null !== (bY = bY["updateQueue"]) && (bY["baseQueue"] = bd);
                }
                if (null !== bC) {
                    bY = bC["next"];
                    var bB = bT["baseState"],
                        bF = 0x0,
                        bb = null,
                        bZ = null,
                        bm = null;
                    if (null !== bY)
                        for (var bv = bY; ; ) {
                            if ((bd = bv["expirationTime"]) < bR) {
                                var by = { expirationTime: bv["expirationTime"], suspenseConfig: bv["suspenseConfig"], tag: bv["tag"], payload: bv["payload"], callback: bv["callback"], next: null };
                                null === bm ? ((bZ = bm = by), (bb = bB)) : (bm = bm["next"] = by), bd > bF && (bF = bd);
                            } else {
                                null !== bm && (bm = bm["next"] = { expirationTime: 0x3fffffff, suspenseConfig: bv["suspenseConfig"], tag: bv["tag"], payload: bv["payload"], callback: bv["callback"], next: null }),
                                    Fm(bd, bv["suspenseConfig"]);
                                bX: {
                                    var bD = b8,
                                        bN = bv;
                                    switch (((bd = b9), (by = bE), bN["tag"])) {
                                        case 0x1:
                                            if ("function" == typeof (bD = bN["payload"])) {
                                                bB = bD["call"](by, bB, bd);
                                                break bX;
                                            }
                                            bB = bD;
                                            break bX;
                                        case 0x3:
                                            bD["effectTag"] = (-0x1001 & bD["effectTag"]) | 0x40;
                                        case 0x0:
                                            if (null == (bd = "function" == typeof (bD = bN["payload"]) ? bD["call"](by, bB, bd) : bD)) break bX;
                                            bB = r4({}, bB, bd);
                                            break bX;
                                        case 0x2:
                                            YC = !0x0;
                                    }
                                }
                                null !== bv["callback"] && ((b8["effectTag"] |= 0x20), null === (bd = bT["effects"]) ? (bT["effects"] = [bv]) : bd["push"](bv));
                            }
                            if (null === (bv = bv["next"]) || bv === bY) {
                                if (null === (bd = bT["shared"]["pending"])) break;
                                (bv = bC["next"] = bd["next"]), (bd["next"] = bY), (bT["baseQueue"] = bC = bd), (bT["shared"]["pending"] = null);
                            }
                        }
                    null === bm ? (bb = bB) : (bm["next"] = bZ), (bT["baseState"] = bb), (bT["baseQueue"] = bm), Fv(bF), (b8["expirationTime"] = bF), (b8["memoizedState"] = bB);
                }
            }
            function Ym(b8, b9, bE) {
                if (((b8 = b9["effects"]), (b9["effects"] = null), null !== b8))
                    for (b9 = 0x0; b9 < b8["length"]; b9++) {
                        var bR = b8[b9],
                            bT = bR["callback"];
                        if (null !== bT) {
                            if (((bR["callback"] = null), (bR = bT), (bT = bE), "function" != typeof bR)) throw Error(r6(0xbf, bR));
                            bR["call"](bT);
                        }
                    }
            }
            var Yv = rL["ReactCurrentBatchConfig"],
                Yy = new r3["Component"]()["refs"];
            function YD(b8, b9, bE, bR) {
                (bE = null == (bE = bE(bR, (b9 = b8["memoizedState"]))) ? b9 : r4({}, b9, bE)), (b8["memoizedState"] = bE), 0x0 === b8["expirationTime"] && (b8["updateQueue"]["baseState"] = bE);
            }
            var YN = {
                isMounted: function (b8) {
                    return !!(b8 = b8["_reactInternalFiber"]) && R2(b8) === b8;
                },
                enqueueSetState: function (b8, b9, bE) {
                    b8 = b8["_reactInternalFiber"];
                    var bR = F7(),
                        bT = Yv["suspense"];
                    ((bT = YB((bR = F8(bR, b8, bT)), bT))["payload"] = b9), null != bE && (bT["callback"] = bE), YF(b8, bT), F9(b8, bR);
                },
                enqueueReplaceState: function (b8, b9, bE) {
                    b8 = b8["_reactInternalFiber"];
                    var bR = F7(),
                        bT = Yv["suspense"];
                    ((bT = YB((bR = F8(bR, b8, bT)), bT))["tag"] = 0x1), (bT["payload"] = b9), null != bE && (bT["callback"] = bE), YF(b8, bT), F9(b8, bR);
                },
                enqueueForceUpdate: function (b8, b9) {
                    b8 = b8["_reactInternalFiber"];
                    var bE = F7(),
                        bR = Yv["suspense"];
                    ((bR = YB((bE = F8(bE, b8, bR)), bR))["tag"] = 0x2), null != b9 && (bR["callback"] = b9), YF(b8, bR), F9(b8, bE);
                },
            };
            function YX(b8, b9, bE, bR, bT, bC, bd) {
                return "function" == typeof (b8 = b8["stateNode"])["shouldComponentUpdate"] ? b8["shouldComponentUpdate"](bR, bC, bd) : !b9["prototype"] || !b9["prototype"]["isPureReactComponent"] || !CK(bE, bR) || !CK(bT, bC);
            }
            function Yf(b8, b9, bE) {
                var bR = !0x1,
                    bT = db,
                    bC = b9["contextType"];
                return (
                    "object" == typeof bC && null !== bC ? (bC = YT(bC)) : ((bT = dD(b9) ? dv : dZ["current"]), (bC = (bR = null != (bR = b9["contextTypes"])) ? dy(b8, bT) : db)),
                    (b9 = new b9(bE, bC)),
                    (b8["memoizedState"] = null !== b9["state"] && void 0x0 !== b9["state"] ? b9["state"] : null),
                    (b9["updater"] = YN),
                    (b8["stateNode"] = b9),
                    (b9["_reactInternalFiber"] = b8),
                    bR && (((b8 = b8["stateNode"])["__reactInternalMemoizedUnmaskedChildContext"] = bT), (b8["__reactInternalMemoizedMaskedChildContext"] = bC)),
                    b9
                );
            }
            function YP(b8, b9, bE, bR) {
                (b8 = b9["state"]),
                    "function" == typeof b9["componentWillReceiveProps"] && b9["componentWillReceiveProps"](bE, bR),
                    "function" == typeof b9["UNSAFE_componentWillReceiveProps"] && b9["UNSAFE_componentWillReceiveProps"](bE, bR),
                    b9["state"] !== b8 && YN["enqueueReplaceState"](b9, b9["state"], null);
            }
            function YI(b8, b9, bE, bR) {
                var bT = b8["stateNode"];
                (bT["props"] = bE), (bT["state"] = b8["memoizedState"]), (bT["refs"] = Yy), Yd(b8);
                var bC = b9["contextType"];
                "object" == typeof bC && null !== bC ? (bT["context"] = YT(bC)) : ((bC = dD(b9) ? dv : dZ["current"]), (bT["context"] = dy(b8, bC))),
                    YZ(b8, bE, bT, bR),
                    (bT["state"] = b8["memoizedState"]),
                    "function" == typeof (bC = b9["getDerivedStateFromProps"]) && (YD(b8, b9, bC, bE), (bT["state"] = b8["memoizedState"])),
                    "function" == typeof b9["getDerivedStateFromProps"] ||
                        "function" == typeof bT["getSnapshotBeforeUpdate"] ||
                        ("function" != typeof bT["UNSAFE_componentWillMount"] && "function" != typeof bT["componentWillMount"]) ||
                        ((b9 = bT["state"]),
                        "function" == typeof bT["componentWillMount"] && bT["componentWillMount"](),
                        "function" == typeof bT["UNSAFE_componentWillMount"] && bT["UNSAFE_componentWillMount"](),
                        b9 !== bT["state"] && YN["enqueueReplaceState"](bT, bT["state"], null),
                        YZ(b8, bE, bT, bR),
                        (bT["state"] = b8["memoizedState"])),
                    "function" == typeof bT["componentDidMount"] && (b8["effectTag"] |= 0x4);
            }
            var YA = Array["isArray"];
            function YM(b8, b9, bE) {
                if (null !== (b8 = bE["ref"]) && "function" != typeof b8 && "object" != typeof b8) {
                    if (bE["_owner"]) {
                        if ((bE = bE["_owner"])) {
                            if (0x1 !== bE["tag"]) throw Error(r6(0x135));
                            var bR = bE["stateNode"];
                        }
                        if (!bR) throw Error(r6(0x93, b8));
                        var bT = "" + b8;
                        return null !== b9 && null !== b9["ref"] && "function" == typeof b9["ref"] && b9["ref"]["_stringRef"] === bT
                            ? b9["ref"]
                            : ((b9 = function (bC) {
                                  var bd = bR["refs"];
                                  bd === Yy && (bd = bR["refs"] = {}), null === bC ? delete bd[bT] : (bd[bT] = bC);
                              }),
                              (b9["_stringRef"] = bT),
                              b9);
                    }
                    if ("string" != typeof b8) throw Error(r6(0x11c));
                    if (!bE["_owner"]) throw Error(r6(0x122, b8));
                }
                return b8;
            }
            function Yp(b8, b9) {
                if ("textarea" !== b8["type"]) throw Error(r6(0x1f, "[object\x20Object]" === Object["prototype"]["toString"]["call"](b9) ? "object\x20with\x20keys\x20{" + Object["keys"](b9)["join"](",\x20") + "}" : b9, ""));
            }
            function Yk(b8) {
                function b9(bN, bX) {
                    if (b8) {
                        var bf = bN["lastEffect"];
                        null !== bf ? ((bf["nextEffect"] = bX), (bN["lastEffect"] = bX)) : (bN["firstEffect"] = bN["lastEffect"] = bX), (bX["nextEffect"] = null), (bX["effectTag"] = 0x8);
                    }
                }
                function bE(bN, bX) {
                    if (!b8) return null;
                    for (; null !== bX; ) b9(bN, bX), (bX = bX["sibling"]);
                    return null;
                }
                function bR(bN, bX) {
                    for (bN = new Map(); null !== bX; ) null !== bX["key"] ? bN["set"](bX["key"], bX) : bN["set"](bX["index"], bX), (bX = bX["sibling"]);
                    return bN;
                }
                function bT(bN, bX) {
                    return ((bN = FS(bN, bX))["index"] = 0x0), (bN["sibling"] = null), bN;
                }
                function bC(bN, bX, bf) {
                    return (bN["index"] = bf), b8 ? (null !== (bf = bN["alternate"]) ? ((bf = bf["index"]) < bX ? ((bN["effectTag"] = 0x2), bX) : bf) : ((bN["effectTag"] = 0x2), bX)) : bX;
                }
                function bd(bN) {
                    return b8 && null === bN["alternate"] && (bN["effectTag"] = 0x2), bN;
                }
                function bY(bN, bX, bf, bP) {
                    return null === bX || 0x6 !== bX["tag"] ? (((bX = FH(bf, bN["mode"], bP))["return"] = bN), bX) : (((bX = bT(bX, bf))["return"] = bN), bX);
                }
                function bB(bN, bX, bf, bP) {
                    return null !== bX && bX["elementType"] === bf["type"]
                        ? (((bP = bT(bX, bf["props"]))["ref"] = YM(bN, bX, bf)), (bP["return"] = bN), bP)
                        : (((bP = Fg(bf["type"], bf["key"], bf["props"], null, bN["mode"], bP))["ref"] = YM(bN, bX, bf)), (bP["return"] = bN), bP);
                }
                function bF(bN, bX, bf, bP) {
                    return null === bX || 0x4 !== bX["tag"] || bX["stateNode"]["containerInfo"] !== bf["containerInfo"] || bX["stateNode"]["implementation"] !== bf["implementation"]
                        ? (((bX = Fx(bf, bN["mode"], bP))["return"] = bN), bX)
                        : (((bX = bT(bX, bf["children"] || []))["return"] = bN), bX);
                }
                function bb(bN, bX, bf, bP, bI) {
                    return null === bX || 0x7 !== bX["tag"] ? (((bX = FW(bf, bN["mode"], bP, bI))["return"] = bN), bX) : (((bX = bT(bX, bf))["return"] = bN), bX);
                }
                function bZ(bN, bX, bf) {
                    if ("string" == typeof bX || "number" == typeof bX) return ((bX = FH("" + bX, bN["mode"], bf))["return"] = bN), bX;
                    if ("object" == typeof bX && null !== bX) {
                        switch (bX["$$typeof"]) {
                            case E1:
                                return ((bf = Fg(bX["type"], bX["key"], bX["props"], null, bN["mode"], bf))["ref"] = YM(bN, null, bX)), (bf["return"] = bN), bf;
                            case E2:
                                return ((bX = Fx(bX, bN["mode"], bf))["return"] = bN), bX;
                        }
                        if (YA(bX) || EB(bX)) return ((bX = FW(bX, bN["mode"], bf, null))["return"] = bN), bX;
                        Yp(bN, bX);
                    }
                    return null;
                }
                function bm(bN, bX, bf, bP) {
                    var bI = null !== bX ? bX["key"] : null;
                    if ("string" == typeof bf || "number" == typeof bf) return null !== bI ? null : bY(bN, bX, "" + bf, bP);
                    if ("object" == typeof bf && null !== bf) {
                        switch (bf["$$typeof"]) {
                            case E1:
                                return bf["key"] === bI ? (bf["type"] === E3 ? bb(bN, bX, bf["props"]["children"], bP, bI) : bB(bN, bX, bf, bP)) : null;
                            case E2:
                                return bf["key"] === bI ? bF(bN, bX, bf, bP) : null;
                        }
                        if (YA(bf) || EB(bf)) return null !== bI ? null : bb(bN, bX, bf, bP, null);
                        Yp(bN, bf);
                    }
                    return null;
                }
                function bv(bN, bX, bf, bP, bI) {
                    if ("string" == typeof bP || "number" == typeof bP) return bY(bX, (bN = bN["get"](bf) || null), "" + bP, bI);
                    if ("object" == typeof bP && null !== bP) {
                        switch (bP["$$typeof"]) {
                            case E1:
                                return (bN = bN["get"](null === bP["key"] ? bf : bP["key"]) || null), bP["type"] === E3 ? bb(bX, bN, bP["props"]["children"], bI, bP["key"]) : bB(bX, bN, bP, bI);
                            case E2:
                                return bF(bX, (bN = bN["get"](null === bP["key"] ? bf : bP["key"]) || null), bP, bI);
                        }
                        if (YA(bP) || EB(bP)) return bb(bX, (bN = bN["get"](bf) || null), bP, bI, null);
                        Yp(bX, bP);
                    }
                    return null;
                }
                function by(bN, bX, bf, bP) {
                    for (var bI = null, bA = null, bM = bX, bp = (bX = 0x0), bk = null; null !== bM && bp < bf["length"]; bp++) {
                        bM["index"] > bp ? ((bk = bM), (bM = null)) : (bk = bM["sibling"]);
                        var bl = bm(bN, bM, bf[bp], bP);
                        if (null === bl) {
                            null === bM && (bM = bk);
                            break;
                        }
                        b8 && bM && null === bl["alternate"] && b9(bN, bM), (bX = bC(bl, bX, bp)), null === bA ? (bI = bl) : (bA["sibling"] = bl), (bA = bl), (bM = bk);
                    }
                    if (bp === bf["length"]) return bE(bN, bM), bI;
                    if (null === bM) {
                        for (; bp < bf["length"]; bp++) null !== (bM = bZ(bN, bf[bp], bP)) && ((bX = bC(bM, bX, bp)), null === bA ? (bI = bM) : (bA["sibling"] = bM), (bA = bM));
                        return bI;
                    }
                    for (bM = bR(bN, bM); bp < bf["length"]; bp++)
                        null !== (bk = bv(bM, bN, bp, bf[bp], bP)) && (b8 && null !== bk["alternate"] && bM["delete"](null === bk["key"] ? bp : bk["key"]), (bX = bC(bk, bX, bp)), null === bA ? (bI = bk) : (bA["sibling"] = bk), (bA = bk));
                    return (
                        b8 &&
                            bM["forEach"](function (bU) {
                                return b9(bN, bU);
                            }),
                        bI
                    );
                }
                function bD(bN, bX, bf, bP) {
                    var bI = EB(bf);
                    if ("function" != typeof bI) throw Error(r6(0x96));
                    if (null == (bf = bI["call"](bf))) throw Error(r6(0x97));
                    for (var bA = (bI = null), bM = bX, bp = (bX = 0x0), bk = null, bl = bf["next"](); null !== bM && !bl["done"]; bp++, bl = bf["next"]()) {
                        bM["index"] > bp ? ((bk = bM), (bM = null)) : (bk = bM["sibling"]);
                        var bU = bm(bN, bM, bl["value"], bP);
                        if (null === bU) {
                            null === bM && (bM = bk);
                            break;
                        }
                        b8 && bM && null === bU["alternate"] && b9(bN, bM), (bX = bC(bU, bX, bp)), null === bA ? (bI = bU) : (bA["sibling"] = bU), (bA = bU), (bM = bk);
                    }
                    if (bl["done"]) return bE(bN, bM), bI;
                    if (null === bM) {
                        for (; !bl["done"]; bp++, bl = bf["next"]()) null !== (bl = bZ(bN, bl["value"], bP)) && ((bX = bC(bl, bX, bp)), null === bA ? (bI = bl) : (bA["sibling"] = bl), (bA = bl));
                        return bI;
                    }
                    for (bM = bR(bN, bM); !bl["done"]; bp++, bl = bf["next"]())
                        null !== (bl = bv(bM, bN, bp, bl["value"], bP)) &&
                            (b8 && null !== bl["alternate"] && bM["delete"](null === bl["key"] ? bp : bl["key"]), (bX = bC(bl, bX, bp)), null === bA ? (bI = bl) : (bA["sibling"] = bl), (bA = bl));
                    return (
                        b8 &&
                            bM["forEach"](function (bq) {
                                return b9(bN, bq);
                            }),
                        bI
                    );
                }
                return function (bN, bX, bf, bP) {
                    var bI = "object" == typeof bf && null !== bf && bf["type"] === E3 && null === bf["key"];
                    bI && (bf = bf["props"]["children"]);
                    var bA = "object" == typeof bf && null !== bf;
                    if (bA)
                        switch (bf["$$typeof"]) {
                            case E1:
                                bM: {
                                    for (bA = bf["key"], bI = bX; null !== bI; ) {
                                        if (bI["key"] === bA) {
                                            if (0x7 === bI["tag"]) {
                                                if (bf["type"] === E3) {
                                                    bE(bN, bI["sibling"]), ((bX = bT(bI, bf["props"]["children"]))["return"] = bN), (bN = bX);
                                                    break bM;
                                                }
                                            } else {
                                                if (bI["elementType"] === bf["type"]) {
                                                    bE(bN, bI["sibling"]), ((bX = bT(bI, bf["props"]))["ref"] = YM(bN, bI, bf)), (bX["return"] = bN), (bN = bX);
                                                    break bM;
                                                }
                                            }
                                            bE(bN, bI);
                                            break;
                                        }
                                        b9(bN, bI), (bI = bI["sibling"]);
                                    }
                                    bf["type"] === E3
                                        ? (((bX = FW(bf["props"]["children"], bN["mode"], bP, bf["key"]))["return"] = bN), (bN = bX))
                                        : (((bP = Fg(bf["type"], bf["key"], bf["props"], null, bN["mode"], bP))["ref"] = YM(bN, bX, bf)), (bP["return"] = bN), (bN = bP));
                                }
                                return bd(bN);
                            case E2:
                                bp: {
                                    for (bI = bf["key"]; null !== bX; ) {
                                        if (bX["key"] === bI) {
                                            if (0x4 === bX["tag"] && bX["stateNode"]["containerInfo"] === bf["containerInfo"] && bX["stateNode"]["implementation"] === bf["implementation"]) {
                                                bE(bN, bX["sibling"]), ((bX = bT(bX, bf["children"] || []))["return"] = bN), (bN = bX);
                                                break bp;
                                            }
                                            bE(bN, bX);
                                            break;
                                        }
                                        b9(bN, bX), (bX = bX["sibling"]);
                                    }
                                    ((bX = Fx(bf, bN["mode"], bP))["return"] = bN), (bN = bX);
                                }
                                return bd(bN);
                        }
                    if ("string" == typeof bf || "number" == typeof bf)
                        return (bf = "" + bf), null !== bX && 0x6 === bX["tag"] ? (bE(bN, bX["sibling"]), ((bX = bT(bX, bf))["return"] = bN), (bN = bX)) : (bE(bN, bX), ((bX = FH(bf, bN["mode"], bP))["return"] = bN), (bN = bX)), bd(bN);
                    if (YA(bf)) return by(bN, bX, bf, bP);
                    if (EB(bf)) return bD(bN, bX, bf, bP);
                    if ((bA && Yp(bN, bf), void 0x0 === bf && !bI))
                        switch (bN["tag"]) {
                            case 0x1:
                            case 0x0:
                                throw ((bN = bN["type"]), Error(r6(0x98, bN["displayName"] || bN["name"] || "Component")));
                        }
                    return bE(bN, bX);
                };
            }
            var Yl = Yk(!0x0),
                YU = Yk(!0x1),
                Yq = {},
                Yw = { current: Yq },
                YO = { current: Yq },
                Yj = { current: Yq };
            function Yh(b8) {
                if (b8 === Yq) throw Error(r6(0xae));
                return b8;
            }
            function Yc(b8, b9) {
                switch ((dF(Yj, b9), dF(YO, b8), dF(Yw, Yq), (b8 = b9["nodeType"]))) {
                    case 0x9:
                    case 0xb:
                        b9 = (b9 = b9["documentElement"]) ? b9["namespaceURI"] : Ej(null, "");
                        break;
                    default:
                        b9 = Ej((b9 = (b8 = 0x8 === b8 ? b9["parentNode"] : b9)["namespaceURI"] || null), (b8 = b8["tagName"]));
                }
                dB(Yw), dF(Yw, b9);
            }
            function YS() {
                dB(Yw), dB(YO), dB(Yj);
            }
            function Yg(b8) {
                Yh(Yj["current"]);
                var b9 = Yh(Yw["current"]),
                    bE = Ej(b9, b8["type"]);
                b9 !== bE && (dF(YO, b8), dF(Yw, bE));
            }
            function YW(b8) {
                YO["current"] === b8 && (dB(Yw), dB(YO));
            }
            var YH = { current: 0x0 };
            function Yx(b8) {
                for (var b9 = b8; null !== b9; ) {
                    if (0xd === b9["tag"]) {
                        var bE = b9["memoizedState"];
                        if (null !== bE && (null === (bE = bE["dehydrated"]) || bE["data"] === TZ || bE["data"] === Tm)) return b9;
                    } else {
                        if (0x13 === b9["tag"] && void 0x0 !== b9["memoizedProps"]["revealOrder"]) {
                            if (0x0 != (0x40 & b9["effectTag"])) return b9;
                        } else {
                            if (null !== b9["child"]) {
                                (b9["child"]["return"] = b9), (b9 = b9["child"]);
                                continue;
                            }
                        }
                    }
                    if (b9 === b8) break;
                    for (; null === b9["sibling"]; ) {
                        if (null === b9["return"] || b9["return"] === b8) return null;
                        b9 = b9["return"];
                    }
                    (b9["sibling"]["return"] = b9["return"]), (b9 = b9["sibling"]);
                }
                return null;
            }
            function YK(b8, b9) {
                return { responder: b8, props: b9 };
            }
            var YV = rL["ReactCurrentDispatcher"],
                YJ = rL["ReactCurrentBatchConfig"],
                YG = 0x0,
                YL = null,
                YQ = null,
                Yz = null,
                n0 = !0x1;
            function n1() {
                throw Error(r6(0x141));
            }
            function n2(b8, b9) {
                if (null === b9) return !0x1;
                for (var bE = 0x0; bE < b9["length"] && bE < b8["length"]; bE++) if (!CH(b8[bE], b9[bE])) return !0x1;
                return !0x0;
            }
            function n3(b8, b9, bE, bR, bT, bC) {
                if (
                    ((YG = bC),
                    (YL = b9),
                    (b9["memoizedState"] = null),
                    (b9["updateQueue"] = null),
                    (b9["expirationTime"] = 0x0),
                    (YV["current"] = null === b8 || null === b8["memoizedState"] ? nf : nP),
                    (b8 = bE(bR, bT)),
                    b9["expirationTime"] === YG)
                ) {
                    bC = 0x0;
                    do {
                        if (((b9["expirationTime"] = 0x0), !(0x19 > bC))) throw Error(r6(0x12d));
                        (bC += 0x1), (Yz = YQ = null), (b9["updateQueue"] = null), (YV["current"] = nI), (b8 = bE(bR, bT));
                    } while (b9["expirationTime"] === YG);
                }
                if (((YV["current"] = nX), (b9 = null !== YQ && null !== YQ["next"]), (YG = 0x0), (Yz = YQ = YL = null), (n0 = !0x1), b9)) throw Error(r6(0x12c));
                return b8;
            }
            function n4() {
                var b8 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
                return null === Yz ? (YL["memoizedState"] = Yz = b8) : (Yz = Yz["next"] = b8), Yz;
            }
            function n5() {
                if (null === YQ) {
                    var b8 = YL["alternate"];
                    b8 = null !== b8 ? b8["memoizedState"] : null;
                } else b8 = YQ["next"];
                var b9 = null === Yz ? YL["memoizedState"] : Yz["next"];
                if (null !== b9) (Yz = b9), (YQ = b8);
                else {
                    if (null === b8) throw Error(r6(0x136));
                    (b8 = { memoizedState: (YQ = b8)["memoizedState"], baseState: YQ["baseState"], baseQueue: YQ["baseQueue"], queue: YQ["queue"], next: null }), null === Yz ? (YL["memoizedState"] = Yz = b8) : (Yz = Yz["next"] = b8);
                }
                return Yz;
            }
            function n6(b8, b9) {
                return "function" == typeof b9 ? b9(b8) : b9;
            }
            function n7(b8) {
                var b9 = n5(),
                    bE = b9["queue"];
                if (null === bE) throw Error(r6(0x137));
                bE["lastRenderedReducer"] = b8;
                var bR = YQ,
                    bT = bR["baseQueue"],
                    bC = bE["pending"];
                if (null !== bC) {
                    if (null !== bT) {
                        var bd = bT["next"];
                        (bT["next"] = bC["next"]), (bC["next"] = bd);
                    }
                    (bR["baseQueue"] = bT = bC), (bE["pending"] = null);
                }
                if (null !== bT) {
                    (bT = bT["next"]), (bR = bR["baseState"]);
                    var bY = (bd = bC = null),
                        bB = bT;
                    do {
                        var bF = bB["expirationTime"];
                        if (bF < YG) {
                            var bb = { expirationTime: bB["expirationTime"], suspenseConfig: bB["suspenseConfig"], action: bB["action"], eagerReducer: bB["eagerReducer"], eagerState: bB["eagerState"], next: null };
                            null === bY ? ((bd = bY = bb), (bC = bR)) : (bY = bY["next"] = bb), bF > YL["expirationTime"] && ((YL["expirationTime"] = bF), Fv(bF));
                        } else
                            null !== bY && (bY = bY["next"] = { expirationTime: 0x3fffffff, suspenseConfig: bB["suspenseConfig"], action: bB["action"], eagerReducer: bB["eagerReducer"], eagerState: bB["eagerState"], next: null }),
                                Fm(bF, bB["suspenseConfig"]),
                                (bR = bB["eagerReducer"] === b8 ? bB["eagerState"] : b8(bR, bB["action"]));
                        bB = bB["next"];
                    } while (null !== bB && bB !== bT);
                    null === bY ? (bC = bR) : (bY["next"] = bd), CH(bR, b9["memoizedState"]) || (nh = !0x0), (b9["memoizedState"] = bR), (b9["baseState"] = bC), (b9["baseQueue"] = bY), (bE["lastRenderedState"] = bR);
                }
                return [b9["memoizedState"], bE["dispatch"]];
            }
            function n8(b8) {
                var b9 = n5(),
                    bE = b9["queue"];
                if (null === bE) throw Error(r6(0x137));
                bE["lastRenderedReducer"] = b8;
                var bR = bE["dispatch"],
                    bT = bE["pending"],
                    bC = b9["memoizedState"];
                if (null !== bT) {
                    bE["pending"] = null;
                    var bd = (bT = bT["next"]);
                    do {
                        (bC = b8(bC, bd["action"])), (bd = bd["next"]);
                    } while (bd !== bT);
                    CH(bC, b9["memoizedState"]) || (nh = !0x0), (b9["memoizedState"] = bC), null === b9["baseQueue"] && (b9["baseState"] = bC), (bE["lastRenderedState"] = bC);
                }
                return [bC, bR];
            }
            function n9(b8) {
                var b9 = n4();
                return (
                    "function" == typeof b8 && (b8 = b8()),
                    (b9["memoizedState"] = b9["baseState"] = b8),
                    (b8 = (b8 = b9["queue"] = { pending: null, dispatch: null, lastRenderedReducer: n6, lastRenderedState: b8 })["dispatch"] = nN["bind"](null, YL, b8)),
                    [b9["memoizedState"], b8]
                );
            }
            function nE(b8, b9, bE, bR) {
                return (
                    (b8 = { tag: b8, create: b9, destroy: bE, deps: bR, next: null }),
                    null === (b9 = YL["updateQueue"])
                        ? ((b9 = { lastEffect: null }), (YL["updateQueue"] = b9), (b9["lastEffect"] = b8["next"] = b8))
                        : null === (bE = b9["lastEffect"])
                        ? (b9["lastEffect"] = b8["next"] = b8)
                        : ((bR = bE["next"]), (bE["next"] = b8), (b8["next"] = bR), (b9["lastEffect"] = b8)),
                    b8
                );
            }
            function nR() {
                return n5()["memoizedState"];
            }
            function nT(b8, b9, bE, bR) {
                var bT = n4();
                (YL["effectTag"] |= b8), (bT["memoizedState"] = nE(0x1 | b9, bE, void 0x0, void 0x0 === bR ? null : bR));
            }
            function nC(b8, b9, bE, bR) {
                var bT = n5();
                bR = void 0x0 === bR ? null : bR;
                var bC = void 0x0;
                if (null !== YQ) {
                    var bd = YQ["memoizedState"];
                    if (((bC = bd["destroy"]), null !== bR && n2(bR, bd["deps"]))) return void nE(b9, bE, bC, bR);
                }
                (YL["effectTag"] |= b8), (bT["memoizedState"] = nE(0x1 | b9, bE, bC, bR));
            }
            function nd(b8, b9) {
                return nT(0x204, 0x4, b8, b9);
            }
            function nY(b8, b9) {
                return nC(0x204, 0x4, b8, b9);
            }
            function nB(b8, b9) {
                return nC(0x4, 0x2, b8, b9);
            }
            function nF(b8, b9) {
                return "function" == typeof b9
                    ? ((b8 = b8()),
                      b9(b8),
                      function () {
                          b9(null);
                      })
                    : null != b9
                    ? ((b8 = b8()),
                      (b9["current"] = b8),
                      function () {
                          b9["current"] = null;
                      })
                    : void 0x0;
            }
            function nb(b8, b9, bE) {
                return (bE = null != bE ? bE["concat"]([b8]) : null), nC(0x4, 0x2, nF["bind"](null, b9, b8), bE);
            }
            function nZ() {}
            function nm(b8, b9) {
                return (n4()["memoizedState"] = [b8, void 0x0 === b9 ? null : b9]), b8;
            }
            function nv(b8, b9) {
                var bE = n5();
                b9 = void 0x0 === b9 ? null : b9;
                var bR = bE["memoizedState"];
                return null !== bR && null !== b9 && n2(b9, bR[0x1]) ? bR[0x0] : ((bE["memoizedState"] = [b8, b9]), b8);
            }
            function ny(b8, b9) {
                var bE = n5();
                b9 = void 0x0 === b9 ? null : b9;
                var bR = bE["memoizedState"];
                return null !== bR && null !== b9 && n2(b9, bR[0x1]) ? bR[0x0] : ((b8 = b8()), (bE["memoizedState"] = [b8, b9]), b8);
            }
            function nD(b8, b9, bE) {
                var bR = dJ();
                dL(0x62 > bR ? 0x62 : bR, function () {
                    b8(!0x0);
                }),
                    dL(0x61 < bR ? 0x61 : bR, function () {
                        var bT = YJ["suspense"];
                        YJ["suspense"] = void 0x0 === b9 ? null : b9;
                        try {
                            b8(!0x1), bE();
                        } finally {
                            YJ["suspense"] = bT;
                        }
                    });
            }
            function nN(b8, b9, bE) {
                var bR = F7(),
                    bT = Yv["suspense"];
                bT = { expirationTime: (bR = F8(bR, b8, bT)), suspenseConfig: bT, action: bE, eagerReducer: null, eagerState: null, next: null };
                var bC = b9["pending"];
                if ((null === bC ? (bT["next"] = bT) : ((bT["next"] = bC["next"]), (bC["next"] = bT)), (b9["pending"] = bT), (bC = b8["alternate"]), b8 === YL || (null !== bC && bC === YL)))
                    (n0 = !0x0), (bT["expirationTime"] = YG), (YL["expirationTime"] = YG);
                else {
                    if (0x0 === b8["expirationTime"] && (null === bC || 0x0 === bC["expirationTime"]) && null !== (bC = b9["lastRenderedReducer"]))
                        try {
                            var bd = b9["lastRenderedState"],
                                bY = bC(bd, bE);
                            if (((bT["eagerReducer"] = bC), (bT["eagerState"] = bY), CH(bY, bd))) return;
                        } catch (bB) {}
                    F9(b8, bR);
                }
            }
            var nX = {
                    readContext: YT,
                    useCallback: n1,
                    useContext: n1,
                    useEffect: n1,
                    useImperativeHandle: n1,
                    useLayoutEffect: n1,
                    useMemo: n1,
                    useReducer: n1,
                    useRef: n1,
                    useState: n1,
                    useDebugValue: n1,
                    useResponder: n1,
                    useDeferredValue: n1,
                    useTransition: n1,
                },
                nf = {
                    readContext: YT,
                    useCallback: nm,
                    useContext: YT,
                    useEffect: nd,
                    useImperativeHandle: function (b8, b9, bE) {
                        return (bE = null != bE ? bE["concat"]([b8]) : null), nT(0x4, 0x2, nF["bind"](null, b9, b8), bE);
                    },
                    useLayoutEffect: function (b8, b9) {
                        return nT(0x4, 0x2, b8, b9);
                    },
                    useMemo: function (b8, b9) {
                        var bE = n4();
                        return (b9 = void 0x0 === b9 ? null : b9), (b8 = b8()), (bE["memoizedState"] = [b8, b9]), b8;
                    },
                    useReducer: function (b8, b9, bE) {
                        var bR = n4();
                        return (
                            (b9 = void 0x0 !== bE ? bE(b9) : b9),
                            (bR["memoizedState"] = bR["baseState"] = b9),
                            (b8 = (b8 = bR["queue"] = { pending: null, dispatch: null, lastRenderedReducer: b8, lastRenderedState: b9 })["dispatch"] = nN["bind"](null, YL, b8)),
                            [bR["memoizedState"], b8]
                        );
                    },
                    useRef: function (b8) {
                        return (b8 = { current: b8 }), (n4()["memoizedState"] = b8);
                    },
                    useState: n9,
                    useDebugValue: nZ,
                    useResponder: YK,
                    useDeferredValue: function (b8, b9) {
                        var bE = n9(b8),
                            bR = bE[0x0],
                            bT = bE[0x1];
                        return (
                            nd(
                                function () {
                                    var bC = YJ["suspense"];
                                    YJ["suspense"] = void 0x0 === b9 ? null : b9;
                                    try {
                                        bT(b8);
                                    } finally {
                                        YJ["suspense"] = bC;
                                    }
                                },
                                [b8, b9]
                            ),
                            bR
                        );
                    },
                    useTransition: function (b8) {
                        var b9 = n9(!0x1),
                            bE = b9[0x0];
                        return (b9 = b9[0x1]), [nm(nD["bind"](null, b9, b8), [b9, b8]), bE];
                    },
                },
                nP = {
                    readContext: YT,
                    useCallback: nv,
                    useContext: YT,
                    useEffect: nY,
                    useImperativeHandle: nb,
                    useLayoutEffect: nB,
                    useMemo: ny,
                    useReducer: n7,
                    useRef: nR,
                    useState: function () {
                        return n7(n6);
                    },
                    useDebugValue: nZ,
                    useResponder: YK,
                    useDeferredValue: function (b8, b9) {
                        var bE = n7(n6),
                            bR = bE[0x0],
                            bT = bE[0x1];
                        return (
                            nY(
                                function () {
                                    var bC = YJ["suspense"];
                                    YJ["suspense"] = void 0x0 === b9 ? null : b9;
                                    try {
                                        bT(b8);
                                    } finally {
                                        YJ["suspense"] = bC;
                                    }
                                },
                                [b8, b9]
                            ),
                            bR
                        );
                    },
                    useTransition: function (b8) {
                        var b9 = n7(n6),
                            bE = b9[0x0];
                        return (b9 = b9[0x1]), [nv(nD["bind"](null, b9, b8), [b9, b8]), bE];
                    },
                },
                nI = {
                    readContext: YT,
                    useCallback: nv,
                    useContext: YT,
                    useEffect: nY,
                    useImperativeHandle: nb,
                    useLayoutEffect: nB,
                    useMemo: ny,
                    useReducer: n8,
                    useRef: nR,
                    useState: function () {
                        return n8(n6);
                    },
                    useDebugValue: nZ,
                    useResponder: YK,
                    useDeferredValue: function (b8, b9) {
                        var bE = n8(n6),
                            bR = bE[0x0],
                            bT = bE[0x1];
                        return (
                            nY(
                                function () {
                                    var bC = YJ["suspense"];
                                    YJ["suspense"] = void 0x0 === b9 ? null : b9;
                                    try {
                                        bT(b8);
                                    } finally {
                                        YJ["suspense"] = bC;
                                    }
                                },
                                [b8, b9]
                            ),
                            bR
                        );
                    },
                    useTransition: function (b8) {
                        var b9 = n8(n6),
                            bE = b9[0x0];
                        return (b9 = b9[0x1]), [nv(nD["bind"](null, b9, b8), [b9, b8]), bE];
                    },
                },
                nA = null,
                nM = null,
                np = !0x1;
            function nk(b8, b9) {
                var bE = Fh(0x5, null, null, 0x0);
                (bE["elementType"] = "DELETED"),
                    (bE["type"] = "DELETED"),
                    (bE["stateNode"] = b9),
                    (bE["return"] = b8),
                    (bE["effectTag"] = 0x8),
                    null !== b8["lastEffect"] ? ((b8["lastEffect"]["nextEffect"] = bE), (b8["lastEffect"] = bE)) : (b8["firstEffect"] = b8["lastEffect"] = bE);
            }
            function nl(b8, b9) {
                switch (b8["tag"]) {
                    case 0x5:
                        var bE = b8["type"];
                        return null !== (b9 = 0x1 !== b9["nodeType"] || bE["toLowerCase"]() !== b9["nodeName"]["toLowerCase"]() ? null : b9) && ((b8["stateNode"] = b9), !0x0);
                    case 0x6:
                        return null !== (b9 = "" === b8["pendingProps"] || 0x3 !== b9["nodeType"] ? null : b9) && ((b8["stateNode"] = b9), !0x0);
                    default:
                        return !0x1;
                }
            }
            function nU(b8) {
                if (np) {
                    var b9 = nM;
                    if (b9) {
                        var bE = b9;
                        if (!nl(b8, b9)) {
                            if (!(b9 = TP(bE["nextSibling"])) || !nl(b8, b9)) return (b8["effectTag"] = (-0x401 & b8["effectTag"]) | 0x2), (np = !0x1), void (nA = b8);
                            nk(nA, bE);
                        }
                        (nA = b8), (nM = TP(b9["firstChild"]));
                    } else (b8["effectTag"] = (-0x401 & b8["effectTag"]) | 0x2), (np = !0x1), (nA = b8);
                }
            }
            function nq(b8) {
                for (b8 = b8["return"]; null !== b8 && 0x5 !== b8["tag"] && 0x3 !== b8["tag"] && 0xd !== b8["tag"]; ) b8 = b8["return"];
                nA = b8;
            }
            function nw(b8) {
                if (b8 !== nA) return !0x1;
                if (!np) return nq(b8), (np = !0x0), !0x1;
                var b9 = b8["type"];
                if (0x5 !== b8["tag"] || ("head" !== b9 && "body" !== b9 && !TN(b9, b8["memoizedProps"]))) {
                    for (b9 = nM; b9; ) nk(b8, b9), (b9 = TP(b9["nextSibling"]));
                }
                if ((nq(b8), 0xd === b8["tag"])) {
                    if (!(b8 = null !== (b8 = b8["memoizedState"]) ? b8["dehydrated"] : null)) throw Error(r6(0x13d));
                    bR: {
                        for (b8 = b8["nextSibling"], b9 = 0x0; b8; ) {
                            if (0x8 === b8["nodeType"]) {
                                var bE = b8["data"];
                                if ("/$" === bE) {
                                    if (0x0 === b9) {
                                        nM = TP(b8["nextSibling"]);
                                        break bR;
                                    }
                                    b9--;
                                } else ("$" !== bE && bE !== Tm && bE !== TZ) || b9++;
                            }
                            b8 = b8["nextSibling"];
                        }
                        nM = null;
                    }
                } else nM = nA ? TP(b8["stateNode"]["nextSibling"]) : null;
                return !0x0;
            }
            function nO() {
                (nM = nA = null), (np = !0x1);
            }
            var nj = rL["ReactCurrentOwner"],
                nh = !0x1;
            function nc(b8, b9, bE, bR) {
                b9["child"] = null === b8 ? YU(b9, null, bE, bR) : Yl(b9, b8["child"], bE, bR);
            }
            function nS(b8, b9, bE, bR, bT) {
                bE = bE["render"];
                var bC = b9["ref"];
                return (
                    YR(b9, bT),
                    (bR = n3(b8, b9, bE, bR, bC, bT)),
                    null === b8 || nh
                        ? ((b9["effectTag"] |= 0x1), nc(b8, b9, bR, bT), b9["child"])
                        : ((b9["updateQueue"] = b8["updateQueue"]), (b9["effectTag"] &= -0x205), b8["expirationTime"] <= bT && (b8["expirationTime"] = 0x0), B4(b8, b9, bT))
                );
            }
            function ng(b8, b9, bE, bR, bT, bC) {
                if (null === b8) {
                    var bd = bE["type"];
                    return "function" != typeof bd || Fc(bd) || void 0x0 !== bd["defaultProps"] || null !== bE["compare"] || void 0x0 !== bE["defaultProps"]
                        ? (((b8 = Fg(bE["type"], null, bR, null, b9["mode"], bC))["ref"] = b9["ref"]), (b8["return"] = b9), (b9["child"] = b8))
                        : ((b9["tag"] = 0xf), (b9["type"] = bd), nW(b8, b9, bd, bR, bT, bC));
                }
                return (
                    (bd = b8["child"]),
                    bT < bC && ((bT = bd["memoizedProps"]), (bE = null !== (bE = bE["compare"]) ? bE : CK)(bT, bR) && b8["ref"] === b9["ref"])
                        ? B4(b8, b9, bC)
                        : ((b9["effectTag"] |= 0x1), ((b8 = FS(bd, bR))["ref"] = b9["ref"]), (b8["return"] = b9), (b9["child"] = b8))
                );
            }
            function nW(b8, b9, bE, bR, bT, bC) {
                return null !== b8 && CK(b8["memoizedProps"], bR) && b8["ref"] === b9["ref"] && ((nh = !0x1), bT < bC) ? ((b9["expirationTime"] = b8["expirationTime"]), B4(b8, b9, bC)) : nx(b8, b9, bE, bR, bC);
            }
            function nH(b8, b9) {
                var bE = b9["ref"];
                ((null === b8 && null !== bE) || (null !== b8 && b8["ref"] !== bE)) && (b9["effectTag"] |= 0x80);
            }
            function nx(b8, b9, bE, bR, bT) {
                var bC = dD(bE) ? dv : dZ["current"];
                return (
                    (bC = dy(b9, bC)),
                    YR(b9, bT),
                    (bE = n3(b8, b9, bE, bR, bC, bT)),
                    null === b8 || nh
                        ? ((b9["effectTag"] |= 0x1), nc(b8, b9, bE, bT), b9["child"])
                        : ((b9["updateQueue"] = b8["updateQueue"]), (b9["effectTag"] &= -0x205), b8["expirationTime"] <= bT && (b8["expirationTime"] = 0x0), B4(b8, b9, bT))
                );
            }
            function nK(b8, b9, bE, bR, bT) {
                if (dD(bE)) {
                    var bC = !0x0;
                    dP(b9);
                } else bC = !0x1;
                if ((YR(b9, bT), null === b9["stateNode"])) null !== b8 && ((b8["alternate"] = null), (b9["alternate"] = null), (b9["effectTag"] |= 0x2)), Yf(b9, bE, bR), YI(b9, bE, bR, bT), (bR = !0x0);
                else {
                    if (null === b8) {
                        var bd = b9["stateNode"],
                            bY = b9["memoizedProps"];
                        bd["props"] = bY;
                        var bB = bd["context"],
                            bF = bE["contextType"];
                        "object" == typeof bF && null !== bF ? (bF = YT(bF)) : (bF = dy(b9, (bF = dD(bE) ? dv : dZ["current"])));
                        var bb = bE["getDerivedStateFromProps"],
                            bZ = "function" == typeof bb || "function" == typeof bd["getSnapshotBeforeUpdate"];
                        bZ || ("function" != typeof bd["UNSAFE_componentWillReceiveProps"] && "function" != typeof bd["componentWillReceiveProps"]) || ((bY !== bR || bB !== bF) && YP(b9, bd, bR, bF)), (YC = !0x1);
                        var bm = b9["memoizedState"];
                        (bd["state"] = bm),
                            YZ(b9, bR, bd, bT),
                            (bB = b9["memoizedState"]),
                            bY !== bR || bm !== bB || dm["current"] || YC
                                ? ("function" == typeof bb && (YD(b9, bE, bb, bR), (bB = b9["memoizedState"])),
                                  (bY = YC || YX(b9, bE, bY, bR, bm, bB, bF))
                                      ? (bZ ||
                                            ("function" != typeof bd["UNSAFE_componentWillMount"] && "function" != typeof bd["componentWillMount"]) ||
                                            ("function" == typeof bd["componentWillMount"] && bd["componentWillMount"](), "function" == typeof bd["UNSAFE_componentWillMount"] && bd["UNSAFE_componentWillMount"]()),
                                        "function" == typeof bd["componentDidMount"] && (b9["effectTag"] |= 0x4))
                                      : ("function" == typeof bd["componentDidMount"] && (b9["effectTag"] |= 0x4), (b9["memoizedProps"] = bR), (b9["memoizedState"] = bB)),
                                  (bd["props"] = bR),
                                  (bd["state"] = bB),
                                  (bd["context"] = bF),
                                  (bR = bY))
                                : ("function" == typeof bd["componentDidMount"] && (b9["effectTag"] |= 0x4), (bR = !0x1));
                    } else
                        (bd = b9["stateNode"]),
                            YY(b8, b9),
                            (bY = b9["memoizedProps"]),
                            (bd["props"] = b9["type"] === b9["elementType"] ? bY : Y3(b9["type"], bY)),
                            (bB = bd["context"]),
                            "object" == typeof (bF = bE["contextType"]) && null !== bF ? (bF = YT(bF)) : (bF = dy(b9, (bF = dD(bE) ? dv : dZ["current"]))),
                            (bZ = "function" == typeof (bb = bE["getDerivedStateFromProps"]) || "function" == typeof bd["getSnapshotBeforeUpdate"]) ||
                                ("function" != typeof bd["UNSAFE_componentWillReceiveProps"] && "function" != typeof bd["componentWillReceiveProps"]) ||
                                ((bY !== bR || bB !== bF) && YP(b9, bd, bR, bF)),
                            (YC = !0x1),
                            (bB = b9["memoizedState"]),
                            (bd["state"] = bB),
                            YZ(b9, bR, bd, bT),
                            (bm = b9["memoizedState"]),
                            bY !== bR || bB !== bm || dm["current"] || YC
                                ? ("function" == typeof bb && (YD(b9, bE, bb, bR), (bm = b9["memoizedState"])),
                                  (bb = YC || YX(b9, bE, bY, bR, bB, bm, bF))
                                      ? (bZ ||
                                            ("function" != typeof bd["UNSAFE_componentWillUpdate"] && "function" != typeof bd["componentWillUpdate"]) ||
                                            ("function" == typeof bd["componentWillUpdate"] && bd["componentWillUpdate"](bR, bm, bF), "function" == typeof bd["UNSAFE_componentWillUpdate"] && bd["UNSAFE_componentWillUpdate"](bR, bm, bF)),
                                        "function" == typeof bd["componentDidUpdate"] && (b9["effectTag"] |= 0x4),
                                        "function" == typeof bd["getSnapshotBeforeUpdate"] && (b9["effectTag"] |= 0x100))
                                      : ("function" != typeof bd["componentDidUpdate"] || (bY === b8["memoizedProps"] && bB === b8["memoizedState"]) || (b9["effectTag"] |= 0x4),
                                        "function" != typeof bd["getSnapshotBeforeUpdate"] || (bY === b8["memoizedProps"] && bB === b8["memoizedState"]) || (b9["effectTag"] |= 0x100),
                                        (b9["memoizedProps"] = bR),
                                        (b9["memoizedState"] = bm)),
                                  (bd["props"] = bR),
                                  (bd["state"] = bm),
                                  (bd["context"] = bF),
                                  (bR = bb))
                                : ("function" != typeof bd["componentDidUpdate"] || (bY === b8["memoizedProps"] && bB === b8["memoizedState"]) || (b9["effectTag"] |= 0x4),
                                  "function" != typeof bd["getSnapshotBeforeUpdate"] || (bY === b8["memoizedProps"] && bB === b8["memoizedState"]) || (b9["effectTag"] |= 0x100),
                                  (bR = !0x1));
                }
                return nV(b8, b9, bE, bR, bC, bT);
            }
            function nV(b8, b9, bE, bR, bT, bC) {
                nH(b8, b9);
                var bd = 0x0 != (0x40 & b9["effectTag"]);
                if (!bR && !bd) return bT && dI(b9, bE, !0x1), B4(b8, b9, bC);
                (bR = b9["stateNode"]), (nj["current"] = b9);
                var bY = bd && "function" != typeof bE["getDerivedStateFromError"] ? null : bR["render"]();
                return (
                    (b9["effectTag"] |= 0x1),
                    null !== b8 && bd ? ((b9["child"] = Yl(b9, b8["child"], null, bC)), (b9["child"] = Yl(b9, null, bY, bC))) : nc(b8, b9, bY, bC),
                    (b9["memoizedState"] = bR["state"]),
                    bT && dI(b9, bE, !0x0),
                    b9["child"]
                );
            }
            function nJ(b8) {
                var b9 = b8["stateNode"];
                b9["pendingContext"] ? dX(0x0, b9["pendingContext"], b9["pendingContext"] !== b9["context"]) : b9["context"] && dX(0x0, b9["context"], !0x1), Yc(b8, b9["containerInfo"]);
            }
            var nG,
                nL,
                nQ,
                nz = { dehydrated: null, retryTime: 0x0 };
            function B0(b8, b9, bE) {
                var bR,
                    bT = b9["mode"],
                    bC = b9["pendingProps"],
                    bd = YH["current"],
                    bY = !0x1;
                if (
                    ((bR = 0x0 != (0x40 & b9["effectTag"])) || (bR = 0x0 != (0x2 & bd) && (null === b8 || null !== b8["memoizedState"])),
                    bR ? ((bY = !0x0), (b9["effectTag"] &= -0x41)) : (null !== b8 && null === b8["memoizedState"]) || void 0x0 === bC["fallback"] || !0x0 === bC["unstable_avoidThisFallback"] || (bd |= 0x1),
                    dF(YH, 0x1 & bd),
                    null === b8)
                ) {
                    if ((void 0x0 !== bC["fallback"] && nU(b9), bY)) {
                        if (((bY = bC["fallback"]), ((bC = FW(null, bT, 0x0, null))["return"] = b9), 0x0 == (0x2 & b9["mode"]))) {
                            for (b8 = null !== b9["memoizedState"] ? b9["child"]["child"] : b9["child"], bC["child"] = b8; null !== b8; ) (b8["return"] = bC), (b8 = b8["sibling"]);
                        }
                        return ((bE = FW(bY, bT, bE, null))["return"] = b9), (bC["sibling"] = bE), (b9["memoizedState"] = nz), (b9["child"] = bC), bE;
                    }
                    return (bT = bC["children"]), (b9["memoizedState"] = null), (b9["child"] = YU(b9, null, bT, bE));
                }
                if (null !== b8["memoizedState"]) {
                    if (((bT = (b8 = b8["child"])["sibling"]), bY)) {
                        if (((bC = bC["fallback"]), ((bE = FS(b8, b8["pendingProps"]))["return"] = b9), 0x0 == (0x2 & b9["mode"]) && (bY = null !== b9["memoizedState"] ? b9["child"]["child"] : b9["child"]) !== b8["child"])) {
                            for (bE["child"] = bY; null !== bY; ) (bY["return"] = bE), (bY = bY["sibling"]);
                        }
                        return ((bT = FS(bT, bC))["return"] = b9), (bE["sibling"] = bT), (bE["childExpirationTime"] = 0x0), (b9["memoizedState"] = nz), (b9["child"] = bE), bT;
                    }
                    return (bE = Yl(b9, b8["child"], bC["children"], bE)), (b9["memoizedState"] = null), (b9["child"] = bE);
                }
                if (((b8 = b8["child"]), bY)) {
                    if (((bY = bC["fallback"]), ((bC = FW(null, bT, 0x0, null))["return"] = b9), (bC["child"] = b8), null !== b8 && (b8["return"] = bC), 0x0 == (0x2 & b9["mode"]))) {
                        for (b8 = null !== b9["memoizedState"] ? b9["child"]["child"] : b9["child"], bC["child"] = b8; null !== b8; ) (b8["return"] = bC), (b8 = b8["sibling"]);
                    }
                    return ((bE = FW(bY, bT, bE, null))["return"] = b9), (bC["sibling"] = bE), (bE["effectTag"] |= 0x2), (bC["childExpirationTime"] = 0x0), (b9["memoizedState"] = nz), (b9["child"] = bC), bE;
                }
                return (b9["memoizedState"] = null), (b9["child"] = Yl(b9, b8, bC["children"], bE));
            }
            function B1(b8, b9) {
                b8["expirationTime"] < b9 && (b8["expirationTime"] = b9);
                var bE = b8["alternate"];
                null !== bE && bE["expirationTime"] < b9 && (bE["expirationTime"] = b9), YE(b8["return"], b9);
            }
            function B2(b8, b9, bE, bR, bT, bC) {
                var bd = b8["memoizedState"];
                null === bd
                    ? (b8["memoizedState"] = { isBackwards: b9, rendering: null, renderingStartTime: 0x0, last: bR, tail: bE, tailExpiration: 0x0, tailMode: bT, lastEffect: bC })
                    : ((bd["isBackwards"] = b9), (bd["rendering"] = null), (bd["renderingStartTime"] = 0x0), (bd["last"] = bR), (bd["tail"] = bE), (bd["tailExpiration"] = 0x0), (bd["tailMode"] = bT), (bd["lastEffect"] = bC));
            }
            function B3(b8, b9, bE) {
                var bR = b9["pendingProps"],
                    bT = bR["revealOrder"],
                    bC = bR["tail"];
                if ((nc(b8, b9, bR["children"], bE), 0x0 != (0x2 & (bR = YH["current"])))) (bR = (0x1 & bR) | 0x2), (b9["effectTag"] |= 0x40);
                else {
                    if (null !== b8 && 0x0 != (0x40 & b8["effectTag"])) {
                        bd: for (b8 = b9["child"]; null !== b8; ) {
                            if (0xd === b8["tag"]) null !== b8["memoizedState"] && B1(b8, bE);
                            else {
                                if (0x13 === b8["tag"]) B1(b8, bE);
                                else {
                                    if (null !== b8["child"]) {
                                        (b8["child"]["return"] = b8), (b8 = b8["child"]);
                                        continue;
                                    }
                                }
                            }
                            if (b8 === b9) break bd;
                            for (; null === b8["sibling"]; ) {
                                if (null === b8["return"] || b8["return"] === b9) break bd;
                                b8 = b8["return"];
                            }
                            (b8["sibling"]["return"] = b8["return"]), (b8 = b8["sibling"]);
                        }
                    }
                    bR &= 0x1;
                }
                if ((dF(YH, bR), 0x0 == (0x2 & b9["mode"]))) b9["memoizedState"] = null;
                else
                    switch (bT) {
                        case "forwards":
                            for (bE = b9["child"], bT = null; null !== bE; ) null !== (b8 = bE["alternate"]) && null === Yx(b8) && (bT = bE), (bE = bE["sibling"]);
                            null === (bE = bT) ? ((bT = b9["child"]), (b9["child"] = null)) : ((bT = bE["sibling"]), (bE["sibling"] = null)), B2(b9, !0x1, bT, bE, bC, b9["lastEffect"]);
                            break;
                        case "backwards":
                            for (bE = null, bT = b9["child"], b9["child"] = null; null !== bT; ) {
                                if (null !== (b8 = bT["alternate"]) && null === Yx(b8)) {
                                    b9["child"] = bT;
                                    break;
                                }
                                (b8 = bT["sibling"]), (bT["sibling"] = bE), (bE = bT), (bT = b8);
                            }
                            B2(b9, !0x0, bE, null, bC, b9["lastEffect"]);
                            break;
                        case "together":
                            B2(b9, !0x1, null, null, void 0x0, b9["lastEffect"]);
                            break;
                        default:
                            b9["memoizedState"] = null;
                    }
                return b9["child"];
            }
            function B4(b8, b9, bE) {
                null !== b8 && (b9["dependencies"] = b8["dependencies"]);
                var bR = b9["expirationTime"];
                if ((0x0 !== bR && Fv(bR), b9["childExpirationTime"] < bE)) return null;
                if (null !== b8 && b9["child"] !== b8["child"]) throw Error(r6(0x99));
                if (null !== b9["child"]) {
                    for (bE = FS((b8 = b9["child"]), b8["pendingProps"]), b9["child"] = bE, bE["return"] = b9; null !== b8["sibling"]; ) (b8 = b8["sibling"]), ((bE = bE["sibling"] = FS(b8, b8["pendingProps"]))["return"] = b9);
                    bE["sibling"] = null;
                }
                return b9["child"];
            }
            function B5(b8, b9) {
                switch (b8["tailMode"]) {
                    case "hidden":
                        b9 = b8["tail"];
                        for (var bE = null; null !== b9; ) null !== b9["alternate"] && (bE = b9), (b9 = b9["sibling"]);
                        null === bE ? (b8["tail"] = null) : (bE["sibling"] = null);
                        break;
                    case "collapsed":
                        bE = b8["tail"];
                        for (var bR = null; null !== bE; ) null !== bE["alternate"] && (bR = bE), (bE = bE["sibling"]);
                        null === bR ? (b9 || null === b8["tail"] ? (b8["tail"] = null) : (b8["tail"]["sibling"] = null)) : (bR["sibling"] = null);
                }
            }
            function B6(b8, b9, bE) {
                var bR = b9["pendingProps"];
                switch (b9["tag"]) {
                    case 0x2:
                    case 0x10:
                    case 0xf:
                    case 0x0:
                    case 0xb:
                    case 0x7:
                    case 0x8:
                    case 0xc:
                    case 0x9:
                    case 0xe:
                        return null;
                    case 0x1:
                    case 0x11:
                        return dD(b9["type"]) && dN(), null;
                    case 0x3:
                        return (
                            YS(),
                            dB(dm),
                            dB(dZ),
                            (bE = b9["stateNode"])["pendingContext"] && ((bE["context"] = bE["pendingContext"]), (bE["pendingContext"] = null)),
                            (null !== b8 && null !== b8["child"]) || !nw(b9) || (b9["effectTag"] |= 0x4),
                            null
                        );
                    case 0x5:
                        YW(b9), (bE = Yh(Yj["current"]));
                        var bT = b9["type"];
                        if (null !== b8 && null != b9["stateNode"]) nL(b8, b9, bT, bR, bE), b8["ref"] !== b9["ref"] && (b9["effectTag"] |= 0x80);
                        else {
                            if (!bR) {
                                if (null === b9["stateNode"]) throw Error(r6(0xa6));
                                return null;
                            }
                            if (((b8 = Yh(Yw["current"])), nw(b9))) {
                                (bR = b9["stateNode"]), (bT = b9["type"]);
                                var bC = b9["memoizedProps"];
                                switch (((bR[TM] = b9), (bR[Tp] = bC), bT)) {
                                    case "iframe":
                                    case "object":
                                    case "embed":
                                        RL("load", bR);
                                        break;
                                    case "video":
                                    case "audio":
                                        for (b8 = 0x0; b8 < Ez["length"]; b8++) RL(Ez[b8], bR);
                                        break;
                                    case "source":
                                        RL("error", bR);
                                        break;
                                    case "img":
                                    case "image":
                                    case "link":
                                        RL("error", bR), RL("load", bR);
                                        break;
                                    case "form":
                                        RL("reset", bR), RL("submit", bR);
                                        break;
                                    case "details":
                                        RL("toggle", bR);
                                        break;
                                    case "input":
                                        EN(bR, bC), RL("invalid", bR), TR(bE, "onChange");
                                        break;
                                    case "select":
                                        (bR["_wrapperState"] = { wasMultiple: !!bC["multiple"] }), RL("invalid", bR), TR(bE, "onChange");
                                        break;
                                    case "textarea":
                                        Ek(bR, bC), RL("invalid", bR), TR(bE, "onChange");
                                }
                                for (var bd in (T8(bT, bC), (b8 = null), bC))
                                    if (bC["hasOwnProperty"](bd)) {
                                        var bY = bC[bd];
                                        "children" === bd
                                            ? "string" == typeof bY
                                                ? bR["textContent"] !== bY && (b8 = ["children", bY])
                                                : "number" == typeof bY && bR["textContent"] !== "" + bY && (b8 = ["children", "" + bY])
                                            : rN["hasOwnProperty"](bd) && null != bY && TR(bE, bd);
                                    }
                                switch (bT) {
                                    case "input":
                                        Ev(bR), EP(bR, bC, !0x0);
                                        break;
                                    case "textarea":
                                        Ev(bR), EU(bR);
                                        break;
                                    case "select":
                                    case "option":
                                        break;
                                    default:
                                        "function" == typeof bC["onClick"] && (bR["onclick"] = TT);
                                }
                                (bE = b8), (b9["updateQueue"] = bE), null !== bE && (b9["effectTag"] |= 0x4);
                            } else {
                                switch (
                                    ((bd = 0x9 === bE["nodeType"] ? bE : bE["ownerDocument"]),
                                    b8 === TE && (b8 = EO(bT)),
                                    b8 === TE
                                        ? "script" === bT
                                            ? (((b8 = bd["createElement"]("div"))["innerHTML"] = "<script></script>"), (b8 = b8["removeChild"](b8["firstChild"])))
                                            : "string" == typeof bR["is"]
                                            ? (b8 = bd["createElement"](bT, { is: bR["is"] }))
                                            : ((b8 = bd["createElement"](bT)), "select" === bT && ((bd = b8), bR["multiple"] ? (bd["multiple"] = !0x0) : bR["size"] && (bd["size"] = bR["size"])))
                                        : (b8 = bd["createElementNS"](b8, bT)),
                                    (b8[TM] = b9),
                                    (b8[Tp] = bR),
                                    nG(b8, b9),
                                    (b9["stateNode"] = b8),
                                    (bd = T9(bT, bR)),
                                    bT)
                                ) {
                                    case "iframe":
                                    case "object":
                                    case "embed":
                                        RL("load", b8), (bY = bR);
                                        break;
                                    case "video":
                                    case "audio":
                                        for (bY = 0x0; bY < Ez["length"]; bY++) RL(Ez[bY], b8);
                                        bY = bR;
                                        break;
                                    case "source":
                                        RL("error", b8), (bY = bR);
                                        break;
                                    case "img":
                                    case "image":
                                    case "link":
                                        RL("error", b8), RL("load", b8), (bY = bR);
                                        break;
                                    case "form":
                                        RL("reset", b8), RL("submit", b8), (bY = bR);
                                        break;
                                    case "details":
                                        RL("toggle", b8), (bY = bR);
                                        break;
                                    case "input":
                                        EN(b8, bR), (bY = ED(b8, bR)), RL("invalid", b8), TR(bE, "onChange");
                                        break;
                                    case "option":
                                        bY = EA(b8, bR);
                                        break;
                                    case "select":
                                        (b8["_wrapperState"] = { wasMultiple: !!bR["multiple"] }), (bY = r4({}, bR, { value: void 0x0 })), RL("invalid", b8), TR(bE, "onChange");
                                        break;
                                    case "textarea":
                                        Ek(b8, bR), (bY = Ep(b8, bR)), RL("invalid", b8), TR(bE, "onChange");
                                        break;
                                    default:
                                        bY = bR;
                                }
                                T8(bT, bY);
                                var bB = bY;
                                for (bC in bB)
                                    if (bB["hasOwnProperty"](bC)) {
                                        var bF = bB[bC];
                                        "style" === bC
                                            ? T6(b8, bF)
                                            : "dangerouslySetInnerHTML" === bC
                                            ? null != (bF = bF ? bF["__html"] : void 0x0) && ES(b8, bF)
                                            : "children" === bC
                                            ? "string" == typeof bF
                                                ? ("textarea" !== bT || "" !== bF) && Eg(b8, bF)
                                                : "number" == typeof bF && Eg(b8, "" + bF)
                                            : "suppressContentEditableWarning" !== bC && "suppressHydrationWarning" !== bC && "autoFocus" !== bC && (rN["hasOwnProperty"](bC) ? null != bF && TR(bE, bC) : null != bF && rQ(b8, bC, bF, bd));
                                    }
                                switch (bT) {
                                    case "input":
                                        Ev(b8), EP(b8, bR, !0x1);
                                        break;
                                    case "textarea":
                                        Ev(b8), EU(b8);
                                        break;
                                    case "option":
                                        null != bR["value"] && b8["setAttribute"]("value", "" + EZ(bR["value"]));
                                        break;
                                    case "select":
                                        (b8["multiple"] = !!bR["multiple"]), null != (bE = bR["value"]) ? EM(b8, !!bR["multiple"], bE, !0x1) : null != bR["defaultValue"] && EM(b8, !!bR["multiple"], bR["defaultValue"], !0x0);
                                        break;
                                    default:
                                        "function" == typeof bY["onClick"] && (b8["onclick"] = TT);
                                }
                                TD(bT, bR) && (b9["effectTag"] |= 0x4);
                            }
                            null !== b9["ref"] && (b9["effectTag"] |= 0x80);
                        }
                        return null;
                    case 0x6:
                        if (b8 && null != b9["stateNode"]) nQ(0x0, b9, b8["memoizedProps"], bR);
                        else {
                            if ("string" != typeof bR && null === b9["stateNode"]) throw Error(r6(0xa6));
                            (bE = Yh(Yj["current"])),
                                Yh(Yw["current"]),
                                nw(b9)
                                    ? ((bE = b9["stateNode"]), (bR = b9["memoizedProps"]), (bE[TM] = b9), bE["nodeValue"] !== bR && (b9["effectTag"] |= 0x4))
                                    : (((bE = (0x9 === bE["nodeType"] ? bE : bE["ownerDocument"])["createTextNode"](bR))[TM] = b9), (b9["stateNode"] = bE));
                        }
                        return null;
                    case 0xd:
                        return (
                            dB(YH),
                            (bR = b9["memoizedState"]),
                            0x0 != (0x40 & b9["effectTag"])
                                ? ((b9["expirationTime"] = bE), b9)
                                : ((bE = null !== bR),
                                  (bR = !0x1),
                                  null === b8
                                      ? void 0x0 !== b9["memoizedProps"]["fallback"] && nw(b9)
                                      : ((bR = null !== (bT = b8["memoizedState"])),
                                        bE ||
                                            null === bT ||
                                            (null !== (bT = b8["child"]["sibling"]) &&
                                                (null !== (bC = b9["firstEffect"]) ? ((b9["firstEffect"] = bT), (bT["nextEffect"] = bC)) : ((b9["firstEffect"] = b9["lastEffect"] = bT), (bT["nextEffect"] = null)), (bT["effectTag"] = 0x8)))),
                                  bE &&
                                      !bR &&
                                      0x0 != (0x2 & b9["mode"]) &&
                                      ((null === b8 && !0x0 !== b9["memoizedProps"]["unstable_avoidThisFallback"]) || 0x0 != (0x1 & YH["current"])
                                          ? BS === BU && (BS = Bq)
                                          : ((BS !== BU && BS !== Bq) || (BS = Bw), 0x0 !== BK && null !== Bj && (FJ(Bj, Bc), FG(Bj, BK)))),
                                  (bE || bR) && (b9["effectTag"] |= 0x4),
                                  null)
                        );
                    case 0x4:
                        return YS(), null;
                    case 0xa:
                        return Y9(b9), null;
                    case 0x13:
                        if ((dB(YH), null === (bR = b9["memoizedState"]))) return null;
                        if (((bT = 0x0 != (0x40 & b9["effectTag"])), null === (bC = bR["rendering"]))) {
                            if (bT) B5(bR, !0x1);
                            else {
                                if (BS !== BU || (null !== b8 && 0x0 != (0x40 & b8["effectTag"])))
                                    for (bC = b9["child"]; null !== bC; ) {
                                        if (null !== (b8 = Yx(bC))) {
                                            for (
                                                b9["effectTag"] |= 0x40,
                                                    B5(bR, !0x1),
                                                    null !== (bT = b8["updateQueue"]) && ((b9["updateQueue"] = bT), (b9["effectTag"] |= 0x4)),
                                                    null === bR["lastEffect"] && (b9["firstEffect"] = null),
                                                    b9["lastEffect"] = bR["lastEffect"],
                                                    bR = b9["child"];
                                                null !== bR;

                                            )
                                                (bC = bE),
                                                    ((bT = bR)["effectTag"] &= 0x2),
                                                    (bT["nextEffect"] = null),
                                                    (bT["firstEffect"] = null),
                                                    (bT["lastEffect"] = null),
                                                    null === (b8 = bT["alternate"])
                                                        ? ((bT["childExpirationTime"] = 0x0),
                                                          (bT["expirationTime"] = bC),
                                                          (bT["child"] = null),
                                                          (bT["memoizedProps"] = null),
                                                          (bT["memoizedState"] = null),
                                                          (bT["updateQueue"] = null),
                                                          (bT["dependencies"] = null))
                                                        : ((bT["childExpirationTime"] = b8["childExpirationTime"]),
                                                          (bT["expirationTime"] = b8["expirationTime"]),
                                                          (bT["child"] = b8["child"]),
                                                          (bT["memoizedProps"] = b8["memoizedProps"]),
                                                          (bT["memoizedState"] = b8["memoizedState"]),
                                                          (bT["updateQueue"] = b8["updateQueue"]),
                                                          (bC = b8["dependencies"]),
                                                          (bT["dependencies"] = null === bC ? null : { expirationTime: bC["expirationTime"], firstContext: bC["firstContext"], responders: bC["responders"] })),
                                                    (bR = bR["sibling"]);
                                            return dF(YH, (0x1 & YH["current"]) | 0x2), b9["child"];
                                        }
                                        bC = bC["sibling"];
                                    }
                            }
                        } else {
                            if (!bT) {
                                if (null !== (b8 = Yx(bC))) {
                                    if (
                                        ((b9["effectTag"] |= 0x40),
                                        (bT = !0x0),
                                        null !== (bE = b8["updateQueue"]) && ((b9["updateQueue"] = bE), (b9["effectTag"] |= 0x4)),
                                        B5(bR, !0x0),
                                        null === bR["tail"] && "hidden" === bR["tailMode"] && !bC["alternate"])
                                    )
                                        return null !== (b9 = b9["lastEffect"] = bR["lastEffect"]) && (b9["nextEffect"] = null), null;
                                } else 0x2 * dV() - bR["renderingStartTime"] > bR["tailExpiration"] && 0x1 < bE && ((b9["effectTag"] |= 0x40), (bT = !0x0), B5(bR, !0x1), (b9["expirationTime"] = b9["childExpirationTime"] = bE - 0x1));
                            }
                            bR["isBackwards"] ? ((bC["sibling"] = b9["child"]), (b9["child"] = bC)) : (null !== (bE = bR["last"]) ? (bE["sibling"] = bC) : (b9["child"] = bC), (bR["last"] = bC));
                        }
                        return null !== bR["tail"]
                            ? (0x0 === bR["tailExpiration"] && (bR["tailExpiration"] = dV() + 0x1f4),
                              (bE = bR["tail"]),
                              (bR["rendering"] = bE),
                              (bR["tail"] = bE["sibling"]),
                              (bR["lastEffect"] = b9["lastEffect"]),
                              (bR["renderingStartTime"] = dV()),
                              (bE["sibling"] = null),
                              (b9 = YH["current"]),
                              dF(YH, bT ? (0x1 & b9) | 0x2 : 0x1 & b9),
                              bE)
                            : null;
                }
                throw Error(r6(0x9c, b9["tag"]));
            }
            function B7(b8) {
                switch (b8["tag"]) {
                    case 0x1:
                        dD(b8["type"]) && dN();
                        var b9 = b8["effectTag"];
                        return 0x1000 & b9 ? ((b8["effectTag"] = (-0x1001 & b9) | 0x40), b8) : null;
                    case 0x3:
                        if ((YS(), dB(dm), dB(dZ), 0x0 != (0x40 & (b9 = b8["effectTag"])))) throw Error(r6(0x11d));
                        return (b8["effectTag"] = (-0x1001 & b9) | 0x40), b8;
                    case 0x5:
                        return YW(b8), null;
                    case 0xd:
                        return dB(YH), 0x1000 & (b9 = b8["effectTag"]) ? ((b8["effectTag"] = (-0x1001 & b9) | 0x40), b8) : null;
                    case 0x13:
                        return dB(YH), null;
                    case 0x4:
                        return YS(), null;
                    case 0xa:
                        return Y9(b8), null;
                    default:
                        return null;
                }
            }
            function B8(b8, b9) {
                return { value: b8, source: b9, stack: Eb(b9) };
            }
            (nG = function (b8, b9) {
                for (var bE = b9["child"]; null !== bE; ) {
                    if (0x5 === bE["tag"] || 0x6 === bE["tag"]) b8["appendChild"](bE["stateNode"]);
                    else {
                        if (0x4 !== bE["tag"] && null !== bE["child"]) {
                            (bE["child"]["return"] = bE), (bE = bE["child"]);
                            continue;
                        }
                    }
                    if (bE === b9) break;
                    for (; null === bE["sibling"]; ) {
                        if (null === bE["return"] || bE["return"] === b9) return;
                        bE = bE["return"];
                    }
                    (bE["sibling"]["return"] = bE["return"]), (bE = bE["sibling"]);
                }
            }),
                (nL = function (b8, b9, bE, bR, bT) {
                    var bC = b8["memoizedProps"];
                    if (bC !== bR) {
                        var bd,
                            bY,
                            bB = b9["stateNode"];
                        switch ((Yh(Yw["current"]), (b8 = null), bE)) {
                            case "input":
                                (bC = ED(bB, bC)), (bR = ED(bB, bR)), (b8 = []);
                                break;
                            case "option":
                                (bC = EA(bB, bC)), (bR = EA(bB, bR)), (b8 = []);
                                break;
                            case "select":
                                (bC = r4({}, bC, { value: void 0x0 })), (bR = r4({}, bR, { value: void 0x0 })), (b8 = []);
                                break;
                            case "textarea":
                                (bC = Ep(bB, bC)), (bR = Ep(bB, bR)), (b8 = []);
                                break;
                            default:
                                "function" != typeof bC["onClick"] && "function" == typeof bR["onClick"] && (bB["onclick"] = TT);
                        }
                        for (bd in (T8(bE, bR), (bE = null), bC))
                            if (!bR["hasOwnProperty"](bd) && bC["hasOwnProperty"](bd) && null != bC[bd]) {
                                if ("style" === bd) {
                                    for (bY in (bB = bC[bd])) bB["hasOwnProperty"](bY) && (bE || (bE = {}), (bE[bY] = ""));
                                } else
                                    "dangerouslySetInnerHTML" !== bd &&
                                        "children" !== bd &&
                                        "suppressContentEditableWarning" !== bd &&
                                        "suppressHydrationWarning" !== bd &&
                                        "autoFocus" !== bd &&
                                        (rN["hasOwnProperty"](bd) ? b8 || (b8 = []) : (b8 = b8 || [])["push"](bd, null));
                            }
                        for (bd in bR) {
                            var bF = bR[bd];
                            if (((bB = null != bC ? bC[bd] : void 0x0), bR["hasOwnProperty"](bd) && bF !== bB && (null != bF || null != bB))) {
                                if ("style" === bd) {
                                    if (bB) {
                                        for (bY in bB) !bB["hasOwnProperty"](bY) || (bF && bF["hasOwnProperty"](bY)) || (bE || (bE = {}), (bE[bY] = ""));
                                        for (bY in bF) bF["hasOwnProperty"](bY) && bB[bY] !== bF[bY] && (bE || (bE = {}), (bE[bY] = bF[bY]));
                                    } else bE || (b8 || (b8 = []), b8["push"](bd, bE)), (bE = bF);
                                } else
                                    "dangerouslySetInnerHTML" === bd
                                        ? ((bF = bF ? bF["__html"] : void 0x0), (bB = bB ? bB["__html"] : void 0x0), null != bF && bB !== bF && (b8 = b8 || [])["push"](bd, bF))
                                        : "children" === bd
                                        ? bB === bF || ("string" != typeof bF && "number" != typeof bF) || (b8 = b8 || [])["push"](bd, "" + bF)
                                        : "suppressContentEditableWarning" !== bd &&
                                          "suppressHydrationWarning" !== bd &&
                                          (rN["hasOwnProperty"](bd) ? (null != bF && TR(bT, bd), b8 || bB === bF || (b8 = [])) : (b8 = b8 || [])["push"](bd, bF));
                            }
                        }
                        bE && (b8 = b8 || [])["push"]("style", bE), (bT = b8), (b9["updateQueue"] = bT) && (b9["effectTag"] |= 0x4);
                    }
                }),
                (nQ = function (b8, b9, bE, bR) {
                    bE !== bR && (b9["effectTag"] |= 0x4);
                });
            var B9 = "function" == typeof WeakSet ? WeakSet : Set;
            function BE(b8, b9) {
                var bE = b9["source"],
                    bR = b9["stack"];
                null === bR && null !== bE && (bR = Eb(bE)), null !== bE && EF(bE["type"]), (b9 = b9["value"]), null !== b8 && 0x1 === b8["tag"] && EF(b8["type"]);
                try {
                    console["error"](b9);
                } catch (bT) {
                    setTimeout(function () {
                        throw bT;
                    });
                }
            }
            function BR(b8) {
                var b9 = b8["ref"];
                if (null !== b9) {
                    if ("function" == typeof b9)
                        try {
                            b9(null);
                        } catch (bE) {
                            Fl(b8, bE);
                        }
                    else b9["current"] = null;
                }
            }
            function BT(b8, b9) {
                switch (b9["tag"]) {
                    case 0x0:
                    case 0xb:
                    case 0xf:
                    case 0x16:
                    case 0x3:
                    case 0x5:
                    case 0x6:
                    case 0x4:
                    case 0x11:
                        return;
                    case 0x1:
                        if (0x100 & b9["effectTag"] && null !== b8) {
                            var bE = b8["memoizedProps"],
                                bR = b8["memoizedState"];
                            (b9 = (b8 = b9["stateNode"])["getSnapshotBeforeUpdate"](b9["elementType"] === b9["type"] ? bE : Y3(b9["type"], bE), bR)), (b8["__reactInternalSnapshotBeforeUpdate"] = b9);
                        }
                        return;
                }
                throw Error(r6(0xa3));
            }
            function BC(b8, b9) {
                if (null !== (b9 = null !== (b9 = b9["updateQueue"]) ? b9["lastEffect"] : null)) {
                    var bE = (b9 = b9["next"]);
                    do {
                        if ((bE["tag"] & b8) === b8) {
                            var bR = bE["destroy"];
                            (bE["destroy"] = void 0x0), void 0x0 !== bR && bR();
                        }
                        bE = bE["next"];
                    } while (bE !== b9);
                }
            }
            function Bd(b8, b9) {
                if (null !== (b9 = null !== (b9 = b9["updateQueue"]) ? b9["lastEffect"] : null)) {
                    var bE = (b9 = b9["next"]);
                    do {
                        if ((bE["tag"] & b8) === b8) {
                            var bR = bE["create"];
                            bE["destroy"] = bR();
                        }
                        bE = bE["next"];
                    } while (bE !== b9);
                }
            }
            function BY(b8, b9, bE) {
                switch (bE["tag"]) {
                    case 0x0:
                    case 0xb:
                    case 0xf:
                    case 0x16:
                        return void Bd(0x3, bE);
                    case 0x1:
                        if (((b8 = bE["stateNode"]), 0x4 & bE["effectTag"])) {
                            if (null === b9) b8["componentDidMount"]();
                            else {
                                var bR = bE["elementType"] === bE["type"] ? b9["memoizedProps"] : Y3(bE["type"], b9["memoizedProps"]);
                                b8["componentDidUpdate"](bR, b9["memoizedState"], b8["__reactInternalSnapshotBeforeUpdate"]);
                            }
                        }
                        return void (null !== (b9 = bE["updateQueue"]) && Ym(bE, b9, b8));
                    case 0x3:
                        if (null !== (b9 = bE["updateQueue"])) {
                            if (((b8 = null), null !== bE["child"]))
                                switch (bE["child"]["tag"]) {
                                    case 0x5:
                                    case 0x1:
                                        b8 = bE["child"]["stateNode"];
                                }
                            Ym(bE, b9, b8);
                        }
                        return;
                    case 0x5:
                        return (b8 = bE["stateNode"]), void (null === b9 && 0x4 & bE["effectTag"] && TD(bE["type"], bE["memoizedProps"]) && b8["focus"]());
                    case 0x6:
                    case 0x4:
                    case 0xc:
                    case 0x13:
                    case 0x11:
                    case 0x14:
                    case 0x15:
                        return;
                    case 0xd:
                        return void (null === bE["memoizedState"] && ((bE = bE["alternate"]), null !== bE && ((bE = bE["memoizedState"]), null !== bE && ((bE = bE["dehydrated"]), null !== bE && Rh(bE)))));
                }
                throw Error(r6(0xa3));
            }
            function BB(b8, b9, bE) {
                switch (("function" == typeof FO && FO(b9), b9["tag"])) {
                    case 0x0:
                    case 0xb:
                    case 0xe:
                    case 0xf:
                    case 0x16:
                        if (null !== (b8 = b9["updateQueue"]) && null !== (b8 = b8["lastEffect"])) {
                            var bR = b8["next"];
                            dL(0x61 < bE ? 0x61 : bE, function () {
                                var bT = bR;
                                do {
                                    var bC = bT["destroy"];
                                    if (void 0x0 !== bC) {
                                        var bd = b9;
                                        try {
                                            bC();
                                        } catch (bY) {
                                            Fl(bd, bY);
                                        }
                                    }
                                    bT = bT["next"];
                                } while (bT !== bR);
                            });
                        }
                        break;
                    case 0x1:
                        BR(b9),
                            "function" == typeof (bE = b9["stateNode"])["componentWillUnmount"] &&
                                (function (bT, bC) {
                                    try {
                                        (bC["props"] = bT["memoizedProps"]), (bC["state"] = bT["memoizedState"]), bC["componentWillUnmount"]();
                                    } catch (bd) {
                                        Fl(bT, bd);
                                    }
                                })(b9, bE);
                        break;
                    case 0x5:
                        BR(b9);
                        break;
                    case 0x4:
                        By(b8, b9, bE);
                }
            }
            function BF(b8) {
                var b9 = b8["alternate"];
                (b8["return"] = null),
                    (b8["child"] = null),
                    (b8["memoizedState"] = null),
                    (b8["updateQueue"] = null),
                    (b8["dependencies"] = null),
                    (b8["alternate"] = null),
                    (b8["firstEffect"] = null),
                    (b8["lastEffect"] = null),
                    (b8["pendingProps"] = null),
                    (b8["memoizedProps"] = null),
                    (b8["stateNode"] = null),
                    null !== b9 && BF(b9);
            }
            function Bb(b8) {
                return 0x5 === b8["tag"] || 0x3 === b8["tag"] || 0x4 === b8["tag"];
            }
            function BZ(b8) {
                bT: {
                    for (var b9 = b8["return"]; null !== b9; ) {
                        if (Bb(b9)) {
                            var bE = b9;
                            break bT;
                        }
                        b9 = b9["return"];
                    }
                    throw Error(r6(0xa0));
                }
                switch (((b9 = bE["stateNode"]), bE["tag"])) {
                    case 0x5:
                        var bR = !0x1;
                        break;
                    case 0x3:
                    case 0x4:
                        (b9 = b9["containerInfo"]), (bR = !0x0);
                        break;
                    default:
                        throw Error(r6(0xa1));
                }
                0x10 & bE["effectTag"] && (Eg(b9, ""), (bE["effectTag"] &= -0x11));
                bC: bd: for (bE = b8; ; ) {
                    for (; null === bE["sibling"]; ) {
                        if (null === bE["return"] || Bb(bE["return"])) {
                            bE = null;
                            break bC;
                        }
                        bE = bE["return"];
                    }
                    for (bE["sibling"]["return"] = bE["return"], bE = bE["sibling"]; 0x5 !== bE["tag"] && 0x6 !== bE["tag"] && 0x12 !== bE["tag"]; ) {
                        if (0x2 & bE["effectTag"]) continue bd;
                        if (null === bE["child"] || 0x4 === bE["tag"]) continue bd;
                        (bE["child"]["return"] = bE), (bE = bE["child"]);
                    }
                    if (!(0x2 & bE["effectTag"])) {
                        bE = bE["stateNode"];
                        break bC;
                    }
                }
                bR ? Bm(b8, bE, b9) : Bv(b8, bE, b9);
            }
            function Bm(b8, b9, bE) {
                var bR = b8["tag"],
                    bT = 0x5 === bR || 0x6 === bR;
                if (bT)
                    (b8 = bT ? b8["stateNode"] : b8["stateNode"]["instance"]),
                        b9
                            ? 0x8 === bE["nodeType"]
                                ? bE["parentNode"]["insertBefore"](b8, b9)
                                : bE["insertBefore"](b8, b9)
                            : (0x8 === bE["nodeType"] ? (b9 = bE["parentNode"])["insertBefore"](b8, bE) : (b9 = bE)["appendChild"](b8), null != (bE = bE["_reactRootContainer"]) || null !== b9["onclick"] || (b9["onclick"] = TT));
                else {
                    if (0x4 !== bR && null !== (b8 = b8["child"])) {
                        for (Bm(b8, b9, bE), b8 = b8["sibling"]; null !== b8; ) Bm(b8, b9, bE), (b8 = b8["sibling"]);
                    }
                }
            }
            function Bv(b8, b9, bE) {
                var bR = b8["tag"],
                    bT = 0x5 === bR || 0x6 === bR;
                if (bT) (b8 = bT ? b8["stateNode"] : b8["stateNode"]["instance"]), b9 ? bE["insertBefore"](b8, b9) : bE["appendChild"](b8);
                else {
                    if (0x4 !== bR && null !== (b8 = b8["child"])) {
                        for (Bv(b8, b9, bE), b8 = b8["sibling"]; null !== b8; ) Bv(b8, b9, bE), (b8 = b8["sibling"]);
                    }
                }
            }
            function By(b8, b9, bE) {
                for (var bR, bT, bC = b9, bd = !0x1; ; ) {
                    if (!bd) {
                        bd = bC["return"];
                        bZ: for (;;) {
                            if (null === bd) throw Error(r6(0xa0));
                            switch (((bR = bd["stateNode"]), bd["tag"])) {
                                case 0x5:
                                    bT = !0x1;
                                    break bZ;
                                case 0x3:
                                case 0x4:
                                    (bR = bR["containerInfo"]), (bT = !0x0);
                                    break bZ;
                            }
                            bd = bd["return"];
                        }
                        bd = !0x0;
                    }
                    if (0x5 === bC["tag"] || 0x6 === bC["tag"]) {
                        bm: for (var bY = b8, bB = bC, bF = bE, bb = bB; ; )
                            if ((BB(bY, bb, bF), null !== bb["child"] && 0x4 !== bb["tag"])) (bb["child"]["return"] = bb), (bb = bb["child"]);
                            else {
                                if (bb === bB) break bm;
                                for (; null === bb["sibling"]; ) {
                                    if (null === bb["return"] || bb["return"] === bB) break bm;
                                    bb = bb["return"];
                                }
                                (bb["sibling"]["return"] = bb["return"]), (bb = bb["sibling"]);
                            }
                        bT ? ((bY = bR), (bB = bC["stateNode"]), 0x8 === bY["nodeType"] ? bY["parentNode"]["removeChild"](bB) : bY["removeChild"](bB)) : bR["removeChild"](bC["stateNode"]);
                    } else {
                        if (0x4 === bC["tag"]) {
                            if (null !== bC["child"]) {
                                (bR = bC["stateNode"]["containerInfo"]), (bT = !0x0), (bC["child"]["return"] = bC), (bC = bC["child"]);
                                continue;
                            }
                        } else {
                            if ((BB(b8, bC, bE), null !== bC["child"])) {
                                (bC["child"]["return"] = bC), (bC = bC["child"]);
                                continue;
                            }
                        }
                    }
                    if (bC === b9) break;
                    for (; null === bC["sibling"]; ) {
                        if (null === bC["return"] || bC["return"] === b9) return;
                        0x4 === (bC = bC["return"])["tag"] && (bd = !0x1);
                    }
                    (bC["sibling"]["return"] = bC["return"]), (bC = bC["sibling"]);
                }
            }
            function BD(b8, b9) {
                switch (b9["tag"]) {
                    case 0x0:
                    case 0xb:
                    case 0xe:
                    case 0xf:
                    case 0x16:
                        return void BC(0x3, b9);
                    case 0x1:
                    case 0xc:
                    case 0x11:
                        return;
                    case 0x5:
                        var bE = b9["stateNode"];
                        if (null != bE) {
                            var bR = b9["memoizedProps"],
                                bT = null !== b8 ? b8["memoizedProps"] : bR;
                            b8 = b9["type"];
                            var bC = b9["updateQueue"];
                            if (((b9["updateQueue"] = null), null !== bC)) {
                                for (bE[Tp] = bR, "input" === b8 && "radio" === bR["type"] && null != bR["name"] && EX(bE, bR), T9(b8, bT), b9 = T9(b8, bR), bT = 0x0; bT < bC["length"]; bT += 0x2) {
                                    var bd = bC[bT],
                                        bY = bC[bT + 0x1];
                                    "style" === bd ? T6(bE, bY) : "dangerouslySetInnerHTML" === bd ? ES(bE, bY) : "children" === bd ? Eg(bE, bY) : rQ(bE, bd, bY, b9);
                                }
                                switch (b8) {
                                    case "input":
                                        Ef(bE, bR);
                                        break;
                                    case "textarea":
                                        El(bE, bR);
                                        break;
                                    case "select":
                                        (b9 = bE["_wrapperState"]["wasMultiple"]),
                                            (bE["_wrapperState"]["wasMultiple"] = !!bR["multiple"]),
                                            null != (b8 = bR["value"])
                                                ? EM(bE, !!bR["multiple"], b8, !0x1)
                                                : b9 !== !!bR["multiple"] && (null != bR["defaultValue"] ? EM(bE, !!bR["multiple"], bR["defaultValue"], !0x0) : EM(bE, !!bR["multiple"], bR["multiple"] ? [] : "", !0x1));
                                }
                            }
                        }
                        return;
                    case 0x6:
                        if (null === b9["stateNode"]) throw Error(r6(0xa2));
                        return void (b9["stateNode"]["nodeValue"] = b9["memoizedProps"]);
                    case 0x3:
                        return void ((b9 = b9["stateNode"])["hydrate"] && ((b9["hydrate"] = !0x1), Rh(b9["containerInfo"])));
                    case 0xd:
                        if (((bE = b9), null === b9["memoizedState"] ? (bR = !0x1) : ((bR = !0x0), (bE = b9["child"]), (BJ = dV())), null !== bE)) {
                            bB: for (b8 = bE; ; ) {
                                if (0x5 === b8["tag"])
                                    (bC = b8["stateNode"]),
                                        bR
                                            ? "function" == typeof (bC = bC["style"])["setProperty"]
                                                ? bC["setProperty"]("display", "none", "important")
                                                : (bC["display"] = "none")
                                            : ((bC = b8["stateNode"]), (bT = null != (bT = b8["memoizedProps"]["style"]) && bT["hasOwnProperty"]("display") ? bT["display"] : null), (bC["style"]["display"] = T5("display", bT)));
                                else {
                                    if (0x6 === b8["tag"]) b8["stateNode"]["nodeValue"] = bR ? "" : b8["memoizedProps"];
                                    else {
                                        if (0xd === b8["tag"] && null !== b8["memoizedState"] && null === b8["memoizedState"]["dehydrated"]) {
                                            ((bC = b8["child"]["sibling"])["return"] = b8), (b8 = bC);
                                            continue;
                                        }
                                        if (null !== b8["child"]) {
                                            (b8["child"]["return"] = b8), (b8 = b8["child"]);
                                            continue;
                                        }
                                    }
                                }
                                if (b8 === bE) break;
                                for (; null === b8["sibling"]; ) {
                                    if (null === b8["return"] || b8["return"] === bE) break bB;
                                    b8 = b8["return"];
                                }
                                (b8["sibling"]["return"] = b8["return"]), (b8 = b8["sibling"]);
                            }
                        }
                        return void BN(b9);
                    case 0x13:
                        return void BN(b9);
                }
                throw Error(r6(0xa3));
            }
            function BN(b8) {
                var b9 = b8["updateQueue"];
                if (null !== b9) {
                    b8["updateQueue"] = null;
                    var bE = b8["stateNode"];
                    null === bE && (bE = b8["stateNode"] = new B9()),
                        b9["forEach"](function (bR) {
                            var bT = Fq["bind"](null, b8, bR);
                            bE["has"](bR) || (bE["add"](bR), bR["then"](bT, bT));
                        });
                }
            }
            var BX = "function" == typeof WeakMap ? WeakMap : Map;
            function Bf(b8, b9, bE) {
                ((bE = YB(bE, null))["tag"] = 0x3), (bE["payload"] = { element: null });
                var bR = b9["value"];
                return (
                    (bE["callback"] = function () {
                        BL || ((BL = !0x0), (BQ = bR)), BE(b8, b9);
                    }),
                    bE
                );
            }
            function BP(b8, b9, bE) {
                (bE = YB(bE, null))["tag"] = 0x3;
                var bR = b8["type"]["getDerivedStateFromError"];
                if ("function" == typeof bR) {
                    var bT = b9["value"];
                    bE["payload"] = function () {
                        return BE(b8, b9), bR(bT);
                    };
                }
                var bC = b8["stateNode"];
                return (
                    null !== bC &&
                        "function" == typeof bC["componentDidCatch"] &&
                        (bE["callback"] = function () {
                            "function" != typeof bR && (null === Bz ? (Bz = new Set([this])) : Bz["add"](this), BE(b8, b9));
                            var bd = b9["stack"];
                            this["componentDidCatch"](b9["value"], { componentStack: null !== bd ? bd : "" });
                        }),
                    bE
                );
            }
            var BI,
                BA = Math["ceil"],
                BM = rL["ReactCurrentDispatcher"],
                Bp = rL["ReactCurrentOwner"],
                Bk = 0x10,
                Bl = 0x20,
                BU = 0x0,
                Bq = 0x3,
                Bw = 0x4,
                BO = 0x0,
                Bj = null,
                Bh = null,
                Bc = 0x0,
                BS = BU,
                Bg = null,
                BW = 0x3fffffff,
                BH = 0x3fffffff,
                Bx = null,
                BK = 0x0,
                BV = !0x1,
                BJ = 0x0,
                BG = null,
                BL = !0x1,
                BQ = null,
                Bz = null,
                F0 = !0x1,
                F1 = null,
                F2 = 0x5a,
                F3 = null,
                F4 = 0x0,
                F5 = null,
                F6 = 0x0;
            function F7() {
                return 0x0 != (0x30 & BO) ? 0x3ffffffd - ((dV() / 0xa) | 0x0) : 0x0 !== F6 ? F6 : (F6 = 0x3ffffffd - ((dV() / 0xa) | 0x0));
            }
            function F8(b8, b9, bE) {
                if (0x0 == (0x2 & (b9 = b9["mode"]))) return 0x3fffffff;
                var bR = dJ();
                if (0x0 == (0x4 & b9)) return 0x63 === bR ? 0x3fffffff : 0x3ffffffe;
                if (0x0 != (BO & Bk)) return Bc;
                if (null !== bE) b8 = Y2(b8, 0x0 | bE["timeoutMs"] || 0x1388, 0xfa);
                else
                    switch (bR) {
                        case 0x63:
                            b8 = 0x3fffffff;
                            break;
                        case 0x62:
                            b8 = Y2(b8, 0x96, 0x64);
                            break;
                        case 0x61:
                        case 0x60:
                            b8 = Y2(b8, 0x1388, 0xfa);
                            break;
                        case 0x5f:
                            b8 = 0x2;
                            break;
                        default:
                            throw Error(r6(0x146));
                    }
                return null !== Bj && b8 === Bc && --b8, b8;
            }
            function F9(b8, b9) {
                if (0x32 < F4) throw ((F4 = 0x0), (F5 = null), Error(r6(0xb9)));
                if (null !== (b8 = FE(b8, b9))) {
                    var bE = dJ();
                    0x3fffffff === b9 ? (0x0 != (0x8 & BO) && 0x0 == (0x30 & BO) ? Fd(b8) : (FT(b8), 0x0 === BO && Y0())) : FT(b8),
                        0x0 == (0x4 & BO) || (0x62 !== bE && 0x63 !== bE) || (null === F3 ? (F3 = new Map([[b8, b9]])) : (void 0x0 === (bE = F3["get"](b8)) || bE > b9) && F3["set"](b8, b9));
                }
            }
            function FE(b8, b9) {
                b8["expirationTime"] < b9 && (b8["expirationTime"] = b9);
                var bE = b8["alternate"];
                null !== bE && bE["expirationTime"] < b9 && (bE["expirationTime"] = b9);
                var bR = b8["return"],
                    bT = null;
                if (null === bR && 0x3 === b8["tag"]) bT = b8["stateNode"];
                else
                    for (; null !== bR; ) {
                        if (
                            ((bE = bR["alternate"]),
                            bR["childExpirationTime"] < b9 && (bR["childExpirationTime"] = b9),
                            null !== bE && bE["childExpirationTime"] < b9 && (bE["childExpirationTime"] = b9),
                            null === bR["return"] && 0x3 === bR["tag"])
                        ) {
                            bT = bR["stateNode"];
                            break;
                        }
                        bR = bR["return"];
                    }
                return null !== bT && (Bj === bT && (Fv(b9), BS === Bw && FJ(bT, Bc)), FG(bT, b9)), bT;
            }
            function FR(b8) {
                var b9 = b8["lastExpiredTime"];
                if (0x0 !== b9) return b9;
                if (!FV(b8, (b9 = b8["firstPendingTime"]))) return b9;
                var bE = b8["lastPingedTime"];
                return 0x2 >= (b8 = bE > (b8 = b8["nextKnownPendingLevel"]) ? bE : b8) && b9 !== b8 ? 0x0 : b8;
            }
            function FT(b8) {
                if (0x0 !== b8["lastExpiredTime"]) (b8["callbackExpirationTime"] = 0x3fffffff), (b8["callbackPriority"] = 0x63), (b8["callbackNode"] = dz(Fd["bind"](null, b8)));
                else {
                    var b9 = FR(b8),
                        bE = b8["callbackNode"];
                    if (0x0 === b9) null !== bE && ((b8["callbackNode"] = null), (b8["callbackExpirationTime"] = 0x0), (b8["callbackPriority"] = 0x5a));
                    else {
                        var bR = F7();
                        if (
                            (0x3fffffff === b9 ? (bR = 0x63) : 0x1 === b9 || 0x2 === b9 ? (bR = 0x5f) : (bR = 0x0 >= (bR = 0xa * (0x3ffffffd - b9) - 0xa * (0x3ffffffd - bR)) ? 0x63 : 0xfa >= bR ? 0x62 : 0x1482 >= bR ? 0x61 : 0x5f),
                            null !== bE)
                        ) {
                            var bT = b8["callbackPriority"];
                            if (b8["callbackExpirationTime"] === b9 && bT >= bR) return;
                            bE !== dc && dp(bE);
                        }
                        (b8["callbackExpirationTime"] = b9),
                            (b8["callbackPriority"] = bR),
                            (b9 = 0x3fffffff === b9 ? dz(Fd["bind"](null, b8)) : dQ(bR, FC["bind"](null, b8), { timeout: 0xa * (0x3ffffffd - b9) - dV() })),
                            (b8["callbackNode"] = b9);
                    }
                }
            }
            function FC(b8, b9) {
                if (((F6 = 0x0), b9)) return FL(b8, (b9 = F7())), FT(b8), null;
                var bE = FR(b8);
                if (0x0 !== bE) {
                    if (((b9 = b8["callbackNode"]), 0x0 != (0x30 & BO))) throw Error(r6(0x147));
                    if ((FM(), (b8 === Bj && bE === Bc) || FF(b8, bE), null !== Bh)) {
                        var bR = BO;
                        BO |= Bk;
                        for (var bT = FZ(); ; )
                            try {
                                FD();
                                break;
                            } catch (bY) {
                                Fb(b8, bY);
                            }
                        if ((Y8(), (BO = bR), (BM["current"] = bT), 0x1 === BS)) throw ((b9 = Bg), FF(b8, bE), FJ(b8, bE), FT(b8), b9);
                        if (null === Bh)
                            switch (((bT = b8["finishedWork"] = b8["current"]["alternate"]), (b8["finishedExpirationTime"] = bE), (bR = BS), (Bj = null), bR)) {
                                case BU:
                                case 0x1:
                                    throw Error(r6(0x159));
                                case 0x2:
                                    FL(b8, 0x2 < bE ? 0x2 : bE);
                                    break;
                                case Bq:
                                    if ((FJ(b8, bE), bE === (bR = b8["lastSuspendedTime"]) && (b8["nextKnownPendingLevel"] = Ff(bT)), 0x3fffffff === BW && 0xa < (bT = BJ + 0x1f4 - dV()))) {
                                        if (BV) {
                                            var bC = b8["lastPingedTime"];
                                            if (0x0 === bC || bC >= bE) {
                                                (b8["lastPingedTime"] = bE), FF(b8, bE);
                                                break;
                                            }
                                        }
                                        if (0x0 !== (bC = FR(b8)) && bC !== bE) break;
                                        if (0x0 !== bR && bR !== bE) {
                                            b8["lastPingedTime"] = bR;
                                            break;
                                        }
                                        b8["timeoutHandle"] = TX(FP["bind"](null, b8), bT);
                                        break;
                                    }
                                    FP(b8);
                                    break;
                                case Bw:
                                    if ((FJ(b8, bE), bE === (bR = b8["lastSuspendedTime"]) && (b8["nextKnownPendingLevel"] = Ff(bT)), BV && (0x0 === (bT = b8["lastPingedTime"]) || bT >= bE))) {
                                        (b8["lastPingedTime"] = bE), FF(b8, bE);
                                        break;
                                    }
                                    if (0x0 !== (bT = FR(b8)) && bT !== bE) break;
                                    if (0x0 !== bR && bR !== bE) {
                                        b8["lastPingedTime"] = bR;
                                        break;
                                    }
                                    if (
                                        (0x3fffffff !== BH
                                            ? (bR = 0xa * (0x3ffffffd - BH) - dV())
                                            : 0x3fffffff === BW
                                            ? (bR = 0x0)
                                            : ((bR = 0xa * (0x3ffffffd - BW) - 0x1388),
                                              0x0 > (bR = (bT = dV()) - bR) && (bR = 0x0),
                                              (bE = 0xa * (0x3ffffffd - bE) - bT) <
                                                  (bR = (0x78 > bR ? 0x78 : 0x1e0 > bR ? 0x1e0 : 0x438 > bR ? 0x438 : 0x780 > bR ? 0x780 : 0xbb8 > bR ? 0xbb8 : 0x10e0 > bR ? 0x10e0 : 0x7a8 * BA(bR / 0x7a8)) - bR) && (bR = bE)),
                                        0xa < bR)
                                    ) {
                                        b8["timeoutHandle"] = TX(FP["bind"](null, b8), bR);
                                        break;
                                    }
                                    FP(b8);
                                    break;
                                case 0x5:
                                    if (0x3fffffff !== BW && null !== Bx) {
                                        bC = BW;
                                        var bd = Bx;
                                        if (
                                            (0x0 >= (bR = 0x0 | bd["busyMinDurationMs"])
                                                ? (bR = 0x0)
                                                : ((bT = 0x0 | bd["busyDelayMs"]), (bR = (bC = dV() - (0xa * (0x3ffffffd - bC) - (0x0 | bd["timeoutMs"] || 0x1388))) <= bT ? 0x0 : bT + bR - bC)),
                                            0xa < bR)
                                        ) {
                                            FJ(b8, bE), (b8["timeoutHandle"] = TX(FP["bind"](null, b8), bR));
                                            break;
                                        }
                                    }
                                    FP(b8);
                                    break;
                                default:
                                    throw Error(r6(0x149));
                            }
                        if ((FT(b8), b8["callbackNode"] === b9)) return FC["bind"](null, b8);
                    }
                }
                return null;
            }
            function Fd(b8) {
                var b9 = b8["lastExpiredTime"];
                if (((b9 = 0x0 !== b9 ? b9 : 0x3fffffff), 0x0 != (0x30 & BO))) throw Error(r6(0x147));
                if ((FM(), (b8 === Bj && b9 === Bc) || FF(b8, b9), null !== Bh)) {
                    var bE = BO;
                    BO |= Bk;
                    for (var bR = FZ(); ; )
                        try {
                            Fy();
                            break;
                        } catch (bT) {
                            Fb(b8, bT);
                        }
                    if ((Y8(), (BO = bE), (BM["current"] = bR), 0x1 === BS)) throw ((bE = Bg), FF(b8, b9), FJ(b8, b9), FT(b8), bE);
                    if (null !== Bh) throw Error(r6(0x105));
                    (b8["finishedWork"] = b8["current"]["alternate"]), (b8["finishedExpirationTime"] = b9), (Bj = null), FP(b8), FT(b8);
                }
                return null;
            }
            function FY(b8, b9) {
                var bE = BO;
                BO |= 0x1;
                try {
                    return b8(b9);
                } finally {
                    0x0 === (BO = bE) && Y0();
                }
            }
            function FB(b8, b9) {
                var bE = BO;
                (BO &= -0x2), (BO |= 0x8);
                try {
                    return b8(b9);
                } finally {
                    0x0 === (BO = bE) && Y0();
                }
            }
            function FF(b8, b9) {
                (b8["finishedWork"] = null), (b8["finishedExpirationTime"] = 0x0);
                var bE = b8["timeoutHandle"];
                if ((-0x1 !== bE && ((b8["timeoutHandle"] = -0x1), Tf(bE)), null !== Bh))
                    for (bE = Bh["return"]; null !== bE; ) {
                        var bR = bE;
                        switch (bR["tag"]) {
                            case 0x1:
                                null != (bR = bR["type"]["childContextTypes"]) && dN();
                                break;
                            case 0x3:
                                YS(), dB(dm), dB(dZ);
                                break;
                            case 0x5:
                                YW(bR);
                                break;
                            case 0x4:
                                YS();
                                break;
                            case 0xd:
                            case 0x13:
                                dB(YH);
                                break;
                            case 0xa:
                                Y9(bR);
                        }
                        bE = bE["return"];
                    }
                (Bj = b8), (Bh = FS(b8["current"], null)), (Bc = b9), (BS = BU), (Bg = null), (BH = BW = 0x3fffffff), (Bx = null), (BK = 0x0), (BV = !0x1);
            }
            function Fb(b8, b9) {
                for (;;) {
                    try {
                        if ((Y8(), (YV["current"] = nX), n0))
                            for (var bE = YL["memoizedState"]; null !== bE; ) {
                                var bR = bE["queue"];
                                null !== bR && (bR["pending"] = null), (bE = bE["next"]);
                            }
                        if (((YG = 0x0), (Yz = YQ = YL = null), (n0 = !0x1), null === Bh || null === Bh["return"])) return (BS = 0x1), (Bg = b9), (Bh = null);
                        bp: {
                            var bT = b8,
                                bC = Bh["return"],
                                bd = Bh,
                                bY = b9;
                            if (((b9 = Bc), (bd["effectTag"] |= 0x800), (bd["firstEffect"] = bd["lastEffect"] = null), null !== bY && "object" == typeof bY && "function" == typeof bY["then"])) {
                                var bB = bY;
                                if (0x0 == (0x2 & bd["mode"])) {
                                    var bF = bd["alternate"];
                                    bF ? ((bd["updateQueue"] = bF["updateQueue"]), (bd["memoizedState"] = bF["memoizedState"]), (bd["expirationTime"] = bF["expirationTime"])) : ((bd["updateQueue"] = null), (bd["memoizedState"] = null));
                                }
                                var bb = 0x0 != (0x1 & YH["current"]),
                                    bZ = bC;
                                do {
                                    var bm;
                                    if ((bm = 0xd === bZ["tag"])) {
                                        var bv = bZ["memoizedState"];
                                        if (null !== bv) bm = null !== bv["dehydrated"];
                                        else {
                                            var by = bZ["memoizedProps"];
                                            bm = void 0x0 !== by["fallback"] && (!0x0 !== by["unstable_avoidThisFallback"] || !bb);
                                        }
                                    }
                                    if (bm) {
                                        var bD = bZ["updateQueue"];
                                        if (null === bD) {
                                            var bN = new Set();
                                            bN["add"](bB), (bZ["updateQueue"] = bN);
                                        } else bD["add"](bB);
                                        if (0x0 == (0x2 & bZ["mode"])) {
                                            if (((bZ["effectTag"] |= 0x40), (bd["effectTag"] &= -0xba5), 0x1 === bd["tag"])) {
                                                if (null === bd["alternate"]) bd["tag"] = 0x11;
                                                else {
                                                    var bX = YB(0x3fffffff, null);
                                                    (bX["tag"] = 0x2), YF(bd, bX);
                                                }
                                            }
                                            bd["expirationTime"] = 0x3fffffff;
                                            break bp;
                                        }
                                        (bY = void 0x0), (bd = b9);
                                        var bf = bT["pingCache"];
                                        if ((null === bf ? ((bf = bT["pingCache"] = new BX()), (bY = new Set()), bf["set"](bB, bY)) : void 0x0 === (bY = bf["get"](bB)) && ((bY = new Set()), bf["set"](bB, bY)), !bY["has"](bd))) {
                                            bY["add"](bd);
                                            var bP = FU["bind"](null, bT, bB, bd);
                                            bB["then"](bP, bP);
                                        }
                                        (bZ["effectTag"] |= 0x1000), (bZ["expirationTime"] = b9);
                                        break bp;
                                    }
                                    bZ = bZ["return"];
                                } while (null !== bZ);
                                bY = Error(
                                    (EF(bd["type"]) || "A\x20React\x20component") +
                                        "\x20suspended\x20while\x20rendering,\x20but\x20no\x20fallback\x20UI\x20was\x20specified.\x0a\x0aAdd\x20a\x20<Suspense\x20fallback=...>\x20component\x20higher\x20in\x20the\x20tree\x20to\x20provide\x20a\x20loading\x20indicator\x20or\x20placeholder\x20to\x20display." +
                                        Eb(bd)
                                );
                            }
                            0x5 !== BS && (BS = 0x2), (bY = B8(bY, bd)), (bZ = bC);
                            do {
                                switch (bZ["tag"]) {
                                    case 0x3:
                                        (bB = bY), (bZ["effectTag"] |= 0x1000), (bZ["expirationTime"] = b9), Yb(bZ, Bf(bZ, bB, b9));
                                        break bp;
                                    case 0x1:
                                        bB = bY;
                                        var bI = bZ["type"],
                                            bA = bZ["stateNode"];
                                        if (0x0 == (0x40 & bZ["effectTag"]) && ("function" == typeof bI["getDerivedStateFromError"] || (null !== bA && "function" == typeof bA["componentDidCatch"] && (null === Bz || !Bz["has"](bA))))) {
                                            (bZ["effectTag"] |= 0x1000), (bZ["expirationTime"] = b9), Yb(bZ, BP(bZ, bB, b9));
                                            break bp;
                                        }
                                }
                                bZ = bZ["return"];
                            } while (null !== bZ);
                        }
                        Bh = FX(Bh);
                    } catch (bM) {
                        b9 = bM;
                        continue;
                    }
                    break;
                }
            }
            function FZ() {
                var b8 = BM["current"];
                return (BM["current"] = nX), null === b8 ? nX : b8;
            }
            function Fm(b8, b9) {
                b8 < BW && 0x2 < b8 && (BW = b8), null !== b9 && b8 < BH && 0x2 < b8 && ((BH = b8), (Bx = b9));
            }
            function Fv(b8) {
                b8 > BK && (BK = b8);
            }
            function Fy() {
                for (; null !== Bh; ) Bh = FN(Bh);
            }
            function FD() {
                for (; null !== Bh && !dS(); ) Bh = FN(Bh);
            }
            function FN(b8) {
                var b9 = BI(b8["alternate"], b8, Bc);
                return (b8["memoizedProps"] = b8["pendingProps"]), null === b9 && (b9 = FX(b8)), (Bp["current"] = null), b9;
            }
            function FX(b8) {
                Bh = b8;
                do {
                    var b9 = Bh["alternate"];
                    if (((b8 = Bh["return"]), 0x0 == (0x800 & Bh["effectTag"]))) {
                        if (((b9 = B6(b9, Bh, Bc)), 0x1 === Bc || 0x1 !== Bh["childExpirationTime"])) {
                            for (var bE = 0x0, bR = Bh["child"]; null !== bR; ) {
                                var bT = bR["expirationTime"],
                                    bC = bR["childExpirationTime"];
                                bT > bE && (bE = bT), bC > bE && (bE = bC), (bR = bR["sibling"]);
                            }
                            Bh["childExpirationTime"] = bE;
                        }
                        if (null !== b9) return b9;
                        null !== b8 &&
                            0x0 == (0x800 & b8["effectTag"]) &&
                            (null === b8["firstEffect"] && (b8["firstEffect"] = Bh["firstEffect"]),
                            null !== Bh["lastEffect"] && (null !== b8["lastEffect"] && (b8["lastEffect"]["nextEffect"] = Bh["firstEffect"]), (b8["lastEffect"] = Bh["lastEffect"])),
                            0x1 < Bh["effectTag"] && (null !== b8["lastEffect"] ? (b8["lastEffect"]["nextEffect"] = Bh) : (b8["firstEffect"] = Bh), (b8["lastEffect"] = Bh)));
                    } else {
                        if (null !== (b9 = B7(Bh))) return (b9["effectTag"] &= 0x7ff), b9;
                        null !== b8 && ((b8["firstEffect"] = b8["lastEffect"] = null), (b8["effectTag"] |= 0x800));
                    }
                    if (null !== (b9 = Bh["sibling"])) return b9;
                    Bh = b8;
                } while (null !== Bh);
                return BS === BU && (BS = 0x5), null;
            }
            function Ff(b8) {
                var b9 = b8["expirationTime"];
                return b9 > (b8 = b8["childExpirationTime"]) ? b9 : b8;
            }
            function FP(b8) {
                var b9 = dJ();
                return dL(0x63, FI["bind"](null, b8, b9)), null;
            }
            function FI(b8, b9) {
                do {
                    FM();
                } while (null !== F1);
                if (0x0 != (0x30 & BO)) throw Error(r6(0x147));
                var bE = b8["finishedWork"],
                    bR = b8["finishedExpirationTime"];
                if (null === bE) return null;
                if (((b8["finishedWork"] = null), (b8["finishedExpirationTime"] = 0x0), bE === b8["current"])) throw Error(r6(0xb1));
                (b8["callbackNode"] = null), (b8["callbackExpirationTime"] = 0x0), (b8["callbackPriority"] = 0x5a), (b8["nextKnownPendingLevel"] = 0x0);
                var bT = Ff(bE);
                if (
                    ((b8["firstPendingTime"] = bT),
                    bR <= b8["lastSuspendedTime"] ? (b8["firstSuspendedTime"] = b8["lastSuspendedTime"] = b8["nextKnownPendingLevel"] = 0x0) : bR <= b8["firstSuspendedTime"] && (b8["firstSuspendedTime"] = bR - 0x1),
                    bR <= b8["lastPingedTime"] && (b8["lastPingedTime"] = 0x0),
                    bR <= b8["lastExpiredTime"] && (b8["lastExpiredTime"] = 0x0),
                    b8 === Bj && ((Bh = Bj = null), (Bc = 0x0)),
                    0x1 < bE["effectTag"] ? (null !== bE["lastEffect"] ? ((bE["lastEffect"]["nextEffect"] = bE), (bT = bE["firstEffect"])) : (bT = bE)) : (bT = bE["firstEffect"]),
                    null !== bT)
                ) {
                    var bC = BO;
                    (BO |= Bl), (Bp["current"] = null), (Tv = RG);
                    var bd = TF();
                    if (Tb(bd)) {
                        if ("selectionStart" in bd) var bY = { start: bd["selectionStart"], end: bd["selectionEnd"] };
                        else
                            bO: {
                                var bB = (bY = ((bY = bd["ownerDocument"]) && bY["defaultView"]) || window)["getSelection"] && bY["getSelection"]();
                                if (bB && 0x0 !== bB["rangeCount"]) {
                                    bY = bB["anchorNode"];
                                    var bF = bB["anchorOffset"],
                                        bb = bB["focusNode"];
                                    bB = bB["focusOffset"];
                                    try {
                                        bY["nodeType"], bb["nodeType"];
                                    } catch (bl) {
                                        bY = null;
                                        break bO;
                                    }
                                    var bZ = 0x0,
                                        bm = -0x1,
                                        bv = -0x1,
                                        by = 0x0,
                                        bD = 0x0,
                                        bN = bd,
                                        bX = null;
                                    bj: for (;;) {
                                        for (
                                            var bf;
                                            bN !== bY || (0x0 !== bF && 0x3 !== bN["nodeType"]) || (bm = bZ + bF),
                                                bN !== bb || (0x0 !== bB && 0x3 !== bN["nodeType"]) || (bv = bZ + bB),
                                                0x3 === bN["nodeType"] && (bZ += bN["nodeValue"]["length"]),
                                                null !== (bf = bN["firstChild"]);

                                        )
                                            (bX = bN), (bN = bf);
                                        for (;;) {
                                            if (bN === bd) break bj;
                                            if ((bX === bY && ++by === bF && (bm = bZ), bX === bb && ++bD === bB && (bv = bZ), null !== (bf = bN["nextSibling"]))) break;
                                            bX = (bN = bX)["parentNode"];
                                        }
                                        bN = bf;
                                    }
                                    bY = -0x1 === bm || -0x1 === bv ? null : { start: bm, end: bv };
                                } else bY = null;
                            }
                        bY = bY || { start: 0x0, end: 0x0 };
                    } else bY = null;
                    (Ty = { activeElementDetached: null, focusedElem: bd, selectionRange: bY }), (RG = !0x1), (BG = bT);
                    do {
                        try {
                            FA();
                        } catch (bU) {
                            if (null === BG) throw Error(r6(0x14a));
                            Fl(BG, bU), (BG = BG["nextEffect"]);
                        }
                    } while (null !== BG);
                    BG = bT;
                    do {
                        try {
                            for (bd = b8, bY = b9; null !== BG; ) {
                                var bP = BG["effectTag"];
                                if ((0x10 & bP && Eg(BG["stateNode"], ""), 0x80 & bP)) {
                                    var bI = BG["alternate"];
                                    if (null !== bI) {
                                        var bA = bI["ref"];
                                        null !== bA && ("function" == typeof bA ? bA(null) : (bA["current"] = null));
                                    }
                                }
                                switch (0x40e & bP) {
                                    case 0x2:
                                        BZ(BG), (BG["effectTag"] &= -0x3);
                                        break;
                                    case 0x6:
                                        BZ(BG), (BG["effectTag"] &= -0x3), BD(BG["alternate"], BG);
                                        break;
                                    case 0x400:
                                        BG["effectTag"] &= -0x401;
                                        break;
                                    case 0x404:
                                        (BG["effectTag"] &= -0x401), BD(BG["alternate"], BG);
                                        break;
                                    case 0x4:
                                        BD(BG["alternate"], BG);
                                        break;
                                    case 0x8:
                                        By(bd, (bF = BG), bY), BF(bF);
                                }
                                BG = BG["nextEffect"];
                            }
                        } catch (bq) {
                            if (null === BG) throw Error(r6(0x14a));
                            Fl(BG, bq), (BG = BG["nextEffect"]);
                        }
                    } while (null !== BG);
                    if (((bA = Ty), (bI = TF()), (bP = bA["focusedElem"]), (bY = bA["selectionRange"]), bI !== bP && bP && bP["ownerDocument"] && TB(bP["ownerDocument"]["documentElement"], bP))) {
                        null !== bY &&
                            Tb(bP) &&
                            ((bI = bY["start"]),
                            void 0x0 === (bA = bY["end"]) && (bA = bI),
                            "selectionStart" in bP
                                ? ((bP["selectionStart"] = bI), (bP["selectionEnd"] = Math["min"](bA, bP["value"]["length"])))
                                : (bA = ((bI = bP["ownerDocument"] || document) && bI["defaultView"]) || window)["getSelection"] &&
                                  ((bA = bA["getSelection"]()),
                                  (bF = bP["textContent"]["length"]),
                                  (bd = Math["min"](bY["start"], bF)),
                                  (bY = void 0x0 === bY["end"] ? bd : Math["min"](bY["end"], bF)),
                                  !bA["extend"] && bd > bY && ((bF = bY), (bY = bd), (bd = bF)),
                                  (bF = TY(bP, bd)),
                                  (bb = TY(bP, bY)),
                                  bF &&
                                      bb &&
                                      (0x1 !== bA["rangeCount"] || bA["anchorNode"] !== bF["node"] || bA["anchorOffset"] !== bF["offset"] || bA["focusNode"] !== bb["node"] || bA["focusOffset"] !== bb["offset"]) &&
                                      ((bI = bI["createRange"]())["setStart"](bF["node"], bF["offset"]),
                                      bA["removeAllRanges"](),
                                      bd > bY ? (bA["addRange"](bI), bA["extend"](bb["node"], bb["offset"])) : (bI["setEnd"](bb["node"], bb["offset"]), bA["addRange"](bI))))),
                            (bI = []);
                        for (bA = bP; (bA = bA["parentNode"]); ) 0x1 === bA["nodeType"] && bI["push"]({ element: bA, left: bA["scrollLeft"], top: bA["scrollTop"] });
                        for ("function" == typeof bP["focus"] && bP["focus"](), bP = 0x0; bP < bI["length"]; bP++) ((bA = bI[bP])["element"]["scrollLeft"] = bA["left"]), (bA["element"]["scrollTop"] = bA["top"]);
                    }
                    (RG = !!Tv), (Ty = Tv = null), (b8["current"] = bE), (BG = bT);
                    do {
                        try {
                            for (bP = b8; null !== BG; ) {
                                var bM = BG["effectTag"];
                                if ((0x24 & bM && BY(bP, BG["alternate"], BG), 0x80 & bM)) {
                                    bI = void 0x0;
                                    var bp = BG["ref"];
                                    if (null !== bp) {
                                        var bk = BG["stateNode"];
                                        BG["tag"], (bI = bk), "function" == typeof bp ? bp(bI) : (bp["current"] = bI);
                                    }
                                }
                                BG = BG["nextEffect"];
                            }
                        } catch (bw) {
                            if (null === BG) throw Error(r6(0x14a));
                            Fl(BG, bw), (BG = BG["nextEffect"]);
                        }
                    } while (null !== BG);
                    (BG = null), dg(), (BO = bC);
                } else b8["current"] = bE;
                if (F0) (F0 = !0x1), (F1 = b8), (F2 = b9);
                else {
                    for (BG = bT; null !== BG; ) (b9 = BG["nextEffect"]), (BG["nextEffect"] = null), (BG = b9);
                }
                if ((0x0 === (b9 = b8["firstPendingTime"]) && (Bz = null), 0x3fffffff === b9 ? (b8 === F5 ? F4++ : ((F4 = 0x0), (F5 = b8))) : (F4 = 0x0), "function" == typeof Fw && Fw(bE["stateNode"], bR), FT(b8), BL))
                    throw ((BL = !0x1), (b8 = BQ), (BQ = null), b8);
                return 0x0 != (0x8 & BO) || Y0(), null;
            }
            function FA() {
                for (; null !== BG; ) {
                    var b8 = BG["effectTag"];
                    0x0 != (0x100 & b8) && BT(BG["alternate"], BG),
                        0x0 == (0x200 & b8) ||
                            F0 ||
                            ((F0 = !0x0),
                            dQ(0x61, function () {
                                return FM(), null;
                            })),
                        (BG = BG["nextEffect"]);
                }
            }
            function FM() {
                if (0x5a !== F2) {
                    var b8 = 0x61 < F2 ? 0x61 : F2;
                    return (F2 = 0x5a), dL(b8, Fp);
                }
            }
            function Fp() {
                if (null === F1) return !0x1;
                var b8 = F1;
                if (((F1 = null), 0x0 != (0x30 & BO))) throw Error(r6(0x14b));
                var b9 = BO;
                for (BO |= Bl, b8 = b8["current"]["firstEffect"]; null !== b8; ) {
                    try {
                        var bE = b8;
                        if (0x0 != (0x200 & bE["effectTag"]))
                            switch (bE["tag"]) {
                                case 0x0:
                                case 0xb:
                                case 0xf:
                                case 0x16:
                                    BC(0x5, bE), Bd(0x5, bE);
                            }
                    } catch (bR) {
                        if (null === b8) throw Error(r6(0x14a));
                        Fl(b8, bR);
                    }
                    (bE = b8["nextEffect"]), (b8["nextEffect"] = null), (b8 = bE);
                }
                return (BO = b9), Y0(), !0x0;
            }
            function Fk(b8, b9, bE) {
                YF(b8, (b9 = Bf(b8, (b9 = B8(bE, b9)), 0x3fffffff))), null !== (b8 = FE(b8, 0x3fffffff)) && FT(b8);
            }
            function Fl(b8, b9) {
                if (0x3 === b8["tag"]) Fk(b8, b8, b9);
                else
                    for (var bE = b8["return"]; null !== bE; ) {
                        if (0x3 === bE["tag"]) {
                            Fk(bE, b8, b9);
                            break;
                        }
                        if (0x1 === bE["tag"]) {
                            var bR = bE["stateNode"];
                            if ("function" == typeof bE["type"]["getDerivedStateFromError"] || ("function" == typeof bR["componentDidCatch"] && (null === Bz || !Bz["has"](bR)))) {
                                YF(bE, (b8 = BP(bE, (b8 = B8(b9, b8)), 0x3fffffff))), null !== (bE = FE(bE, 0x3fffffff)) && FT(bE);
                                break;
                            }
                        }
                        bE = bE["return"];
                    }
            }
            function FU(b8, b9, bE) {
                var bR = b8["pingCache"];
                null !== bR && bR["delete"](b9),
                    Bj === b8 && Bc === bE
                        ? BS === Bw || (BS === Bq && 0x3fffffff === BW && dV() - BJ < 0x1f4)
                            ? FF(b8, Bc)
                            : (BV = !0x0)
                        : FV(b8, bE) && ((0x0 !== (b9 = b8["lastPingedTime"]) && b9 < bE) || ((b8["lastPingedTime"] = bE), FT(b8)));
            }
            function Fq(b8, b9) {
                var bE = b8["stateNode"];
                null !== bE && bE["delete"](b9), 0x0 === (b9 = 0x0) && (b9 = F8((b9 = F7()), b8, null)), null !== (b8 = FE(b8, b9)) && FT(b8);
            }
            BI = function (b8, b9, bE) {
                var bR = b9["expirationTime"];
                if (null !== b8) {
                    var bT = b9["pendingProps"];
                    if (b8["memoizedProps"] !== bT || dm["current"]) nh = !0x0;
                    else {
                        if (bR < bE) {
                            switch (((nh = !0x1), b9["tag"])) {
                                case 0x3:
                                    nJ(b9), nO();
                                    break;
                                case 0x5:
                                    if ((Yg(b9), 0x4 & b9["mode"] && 0x1 !== bE && bT["hidden"])) return (b9["expirationTime"] = b9["childExpirationTime"] = 0x1), null;
                                    break;
                                case 0x1:
                                    dD(b9["type"]) && dP(b9);
                                    break;
                                case 0x4:
                                    Yc(b9, b9["stateNode"]["containerInfo"]);
                                    break;
                                case 0xa:
                                    (bR = b9["memoizedProps"]["value"]), (bT = b9["type"]["_context"]), dF(Y4, bT["_currentValue"]), (bT["_currentValue"] = bR);
                                    break;
                                case 0xd:
                                    if (null !== b9["memoizedState"])
                                        return 0x0 !== (bR = b9["child"]["childExpirationTime"]) && bR >= bE ? B0(b8, b9, bE) : (dF(YH, 0x1 & YH["current"]), null !== (b9 = B4(b8, b9, bE)) ? b9["sibling"] : null);
                                    dF(YH, 0x1 & YH["current"]);
                                    break;
                                case 0x13:
                                    if (((bR = b9["childExpirationTime"] >= bE), 0x0 != (0x40 & b8["effectTag"]))) {
                                        if (bR) return B3(b8, b9, bE);
                                        b9["effectTag"] |= 0x40;
                                    }
                                    if ((null !== (bT = b9["memoizedState"]) && ((bT["rendering"] = null), (bT["tail"] = null)), dF(YH, YH["current"]), !bR)) return null;
                            }
                            return B4(b8, b9, bE);
                        }
                        nh = !0x1;
                    }
                } else nh = !0x1;
                switch (((b9["expirationTime"] = 0x0), b9["tag"])) {
                    case 0x2:
                        if (
                            ((bR = b9["type"]),
                            null !== b8 && ((b8["alternate"] = null), (b9["alternate"] = null), (b9["effectTag"] |= 0x2)),
                            (b8 = b9["pendingProps"]),
                            (bT = dy(b9, dZ["current"])),
                            YR(b9, bE),
                            (bT = n3(null, b9, bR, b8, bT, bE)),
                            (b9["effectTag"] |= 0x1),
                            "object" == typeof bT && null !== bT && "function" == typeof bT["render"] && void 0x0 === bT["$$typeof"])
                        ) {
                            if (((b9["tag"] = 0x1), (b9["memoizedState"] = null), (b9["updateQueue"] = null), dD(bR))) {
                                var bC = !0x0;
                                dP(b9);
                            } else bC = !0x1;
                            (b9["memoizedState"] = null !== bT["state"] && void 0x0 !== bT["state"] ? bT["state"] : null), Yd(b9);
                            var bd = bR["getDerivedStateFromProps"];
                            "function" == typeof bd && YD(b9, bR, bd, b8), (bT["updater"] = YN), (b9["stateNode"] = bT), (bT["_reactInternalFiber"] = b9), YI(b9, bR, b8, bE), (b9 = nV(null, b9, bR, !0x0, bC, bE));
                        } else (b9["tag"] = 0x0), nc(null, b9, bT, bE), (b9 = b9["child"]);
                        return b9;
                    case 0x10:
                        bb: {
                            if (
                                ((bT = b9["elementType"]),
                                null !== b8 && ((b8["alternate"] = null), (b9["alternate"] = null), (b9["effectTag"] |= 0x2)),
                                (b8 = b9["pendingProps"]),
                                (function (bb) {
                                    if (-0x1 === bb["_status"]) {
                                        bb["_status"] = 0x0;
                                        var bZ = bb["_ctor"];
                                        (bZ = bZ()),
                                            (bb["_result"] = bZ),
                                            bZ["then"](
                                                function (bm) {
                                                    0x0 === bb["_status"] && ((bm = bm["default"]), (bb["_status"] = 0x1), (bb["_result"] = bm));
                                                },
                                                function (bm) {
                                                    0x0 === bb["_status"] && ((bb["_status"] = 0x2), (bb["_result"] = bm));
                                                }
                                            );
                                    }
                                })(bT),
                                0x1 !== bT["_status"])
                            )
                                throw bT["_result"];
                            switch (
                                ((bT = bT["_result"]),
                                (b9["type"] = bT),
                                (bC = b9["tag"] = (function (bb) {
                                    if ("function" == typeof bb) return Fc(bb) ? 0x1 : 0x0;
                                    if (null != bb) {
                                        if ((bb = bb["$$typeof"]) === E9) return 0xb;
                                        if (bb === ET) return 0xe;
                                    }
                                    return 0x2;
                                })(bT)),
                                (b8 = Y3(bT, b8)),
                                bC)
                            ) {
                                case 0x0:
                                    b9 = nx(null, b9, bT, b8, bE);
                                    break bb;
                                case 0x1:
                                    b9 = nK(null, b9, bT, b8, bE);
                                    break bb;
                                case 0xb:
                                    b9 = nS(null, b9, bT, b8, bE);
                                    break bb;
                                case 0xe:
                                    b9 = ng(null, b9, bT, Y3(bT["type"], b8), bR, bE);
                                    break bb;
                            }
                            throw Error(r6(0x132, bT, ""));
                        }
                        return b9;
                    case 0x0:
                        return (bR = b9["type"]), (bT = b9["pendingProps"]), nx(b8, b9, bR, (bT = b9["elementType"] === bR ? bT : Y3(bR, bT)), bE);
                    case 0x1:
                        return (bR = b9["type"]), (bT = b9["pendingProps"]), nK(b8, b9, bR, (bT = b9["elementType"] === bR ? bT : Y3(bR, bT)), bE);
                    case 0x3:
                        if ((nJ(b9), (bR = b9["updateQueue"]), null === b8 || null === bR)) throw Error(r6(0x11a));
                        if (((bR = b9["pendingProps"]), (bT = null !== (bT = b9["memoizedState"]) ? bT["element"] : null), YY(b8, b9), YZ(b9, bR, null, bE), (bR = b9["memoizedState"]["element"]) === bT)) nO(), (b9 = B4(b8, b9, bE));
                        else {
                            if (((bT = b9["stateNode"]["hydrate"]) && ((nM = TP(b9["stateNode"]["containerInfo"]["firstChild"])), (nA = b9), (bT = np = !0x0)), bT)) {
                                for (bE = YU(b9, null, bR, bE), b9["child"] = bE; bE; ) (bE["effectTag"] = (-0x3 & bE["effectTag"]) | 0x400), (bE = bE["sibling"]);
                            } else nc(b8, b9, bR, bE), nO();
                            b9 = b9["child"];
                        }
                        return b9;
                    case 0x5:
                        return (
                            Yg(b9),
                            null === b8 && nU(b9),
                            (bR = b9["type"]),
                            (bT = b9["pendingProps"]),
                            (bC = null !== b8 ? b8["memoizedProps"] : null),
                            (bd = bT["children"]),
                            TN(bR, bT) ? (bd = null) : null !== bC && TN(bR, bC) && (b9["effectTag"] |= 0x10),
                            nH(b8, b9),
                            0x4 & b9["mode"] && 0x1 !== bE && bT["hidden"] ? ((b9["expirationTime"] = b9["childExpirationTime"] = 0x1), (b9 = null)) : (nc(b8, b9, bd, bE), (b9 = b9["child"])),
                            b9
                        );
                    case 0x6:
                        return null === b8 && nU(b9), null;
                    case 0xd:
                        return B0(b8, b9, bE);
                    case 0x4:
                        return Yc(b9, b9["stateNode"]["containerInfo"]), (bR = b9["pendingProps"]), null === b8 ? (b9["child"] = Yl(b9, null, bR, bE)) : nc(b8, b9, bR, bE), b9["child"];
                    case 0xb:
                        return (bR = b9["type"]), (bT = b9["pendingProps"]), nS(b8, b9, bR, (bT = b9["elementType"] === bR ? bT : Y3(bR, bT)), bE);
                    case 0x7:
                        return nc(b8, b9, b9["pendingProps"], bE), b9["child"];
                    case 0x8:
                    case 0xc:
                        return nc(b8, b9, b9["pendingProps"]["children"], bE), b9["child"];
                    case 0xa:
                        bZ: {
                            (bR = b9["type"]["_context"]), (bT = b9["pendingProps"]), (bd = b9["memoizedProps"]), (bC = bT["value"]);
                            var bY = b9["type"]["_context"];
                            if ((dF(Y4, bY["_currentValue"]), (bY["_currentValue"] = bC), null !== bd)) {
                                if (((bY = bd["value"]), 0x0 === (bC = CH(bY, bC) ? 0x0 : 0x0 | ("function" == typeof bR["_calculateChangedBits"] ? bR["_calculateChangedBits"](bY, bC) : 0x3fffffff)))) {
                                    if (bd["children"] === bT["children"] && !dm["current"]) {
                                        b9 = B4(b8, b9, bE);
                                        break bZ;
                                    }
                                } else
                                    for (null !== (bY = b9["child"]) && (bY["return"] = b9); null !== bY; ) {
                                        var bB = bY["dependencies"];
                                        if (null !== bB) {
                                            bd = bY["child"];
                                            for (var bF = bB["firstContext"]; null !== bF; ) {
                                                if (bF["context"] === bR && 0x0 != (bF["observedBits"] & bC)) {
                                                    0x1 === bY["tag"] && (((bF = YB(bE, null))["tag"] = 0x2), YF(bY, bF)),
                                                        bY["expirationTime"] < bE && (bY["expirationTime"] = bE),
                                                        null !== (bF = bY["alternate"]) && bF["expirationTime"] < bE && (bF["expirationTime"] = bE),
                                                        YE(bY["return"], bE),
                                                        bB["expirationTime"] < bE && (bB["expirationTime"] = bE);
                                                    break;
                                                }
                                                bF = bF["next"];
                                            }
                                        } else bd = 0xa === bY["tag"] && bY["type"] === b9["type"] ? null : bY["child"];
                                        if (null !== bd) bd["return"] = bY;
                                        else
                                            for (bd = bY; null !== bd; ) {
                                                if (bd === b9) {
                                                    bd = null;
                                                    break;
                                                }
                                                if (null !== (bY = bd["sibling"])) {
                                                    (bY["return"] = bd["return"]), (bd = bY);
                                                    break;
                                                }
                                                bd = bd["return"];
                                            }
                                        bY = bd;
                                    }
                            }
                            nc(b8, b9, bT["children"], bE), (b9 = b9["child"]);
                        }
                        return b9;
                    case 0x9:
                        return (bT = b9["type"]), (bR = (bC = b9["pendingProps"])["children"]), YR(b9, bE), (bR = bR((bT = YT(bT, bC["unstable_observedBits"])))), (b9["effectTag"] |= 0x1), nc(b8, b9, bR, bE), b9["child"];
                    case 0xe:
                        return (bC = Y3((bT = b9["type"]), b9["pendingProps"])), ng(b8, b9, bT, (bC = Y3(bT["type"], bC)), bR, bE);
                    case 0xf:
                        return nW(b8, b9, b9["type"], b9["pendingProps"], bR, bE);
                    case 0x11:
                        return (
                            (bR = b9["type"]),
                            (bT = b9["pendingProps"]),
                            (bT = b9["elementType"] === bR ? bT : Y3(bR, bT)),
                            null !== b8 && ((b8["alternate"] = null), (b9["alternate"] = null), (b9["effectTag"] |= 0x2)),
                            (b9["tag"] = 0x1),
                            dD(bR) ? ((b8 = !0x0), dP(b9)) : (b8 = !0x1),
                            YR(b9, bE),
                            Yf(b9, bR, bT),
                            YI(b9, bR, bT, bE),
                            nV(null, b9, bR, !0x0, b8, bE)
                        );
                    case 0x13:
                        return B3(b8, b9, bE);
                }
                throw Error(r6(0x9c, b9["tag"]));
            };
            var Fw = null,
                FO = null;
            function Fj(b8, b9, bE, bR) {
                (this["tag"] = b8),
                    (this["key"] = bE),
                    (this["sibling"] = this["child"] = this["return"] = this["stateNode"] = this["type"] = this["elementType"] = null),
                    (this["index"] = 0x0),
                    (this["ref"] = null),
                    (this["pendingProps"] = b9),
                    (this["dependencies"] = this["memoizedState"] = this["updateQueue"] = this["memoizedProps"] = null),
                    (this["mode"] = bR),
                    (this["effectTag"] = 0x0),
                    (this["lastEffect"] = this["firstEffect"] = this["nextEffect"] = null),
                    (this["childExpirationTime"] = this["expirationTime"] = 0x0),
                    (this["alternate"] = null);
            }
            function Fh(b8, b9, bE, bR) {
                return new Fj(b8, b9, bE, bR);
            }
            function Fc(b8) {
                return !(!(b8 = b8["prototype"]) || !b8["isReactComponent"]);
            }
            function FS(b8, b9) {
                var bE = b8["alternate"];
                return (
                    null === bE
                        ? (((bE = Fh(b8["tag"], b9, b8["key"], b8["mode"]))["elementType"] = b8["elementType"]), (bE["type"] = b8["type"]), (bE["stateNode"] = b8["stateNode"]), (bE["alternate"] = b8), (b8["alternate"] = bE))
                        : ((bE["pendingProps"] = b9), (bE["effectTag"] = 0x0), (bE["nextEffect"] = null), (bE["firstEffect"] = null), (bE["lastEffect"] = null)),
                    (bE["childExpirationTime"] = b8["childExpirationTime"]),
                    (bE["expirationTime"] = b8["expirationTime"]),
                    (bE["child"] = b8["child"]),
                    (bE["memoizedProps"] = b8["memoizedProps"]),
                    (bE["memoizedState"] = b8["memoizedState"]),
                    (bE["updateQueue"] = b8["updateQueue"]),
                    (b9 = b8["dependencies"]),
                    (bE["dependencies"] = null === b9 ? null : { expirationTime: b9["expirationTime"], firstContext: b9["firstContext"], responders: b9["responders"] }),
                    (bE["sibling"] = b8["sibling"]),
                    (bE["index"] = b8["index"]),
                    (bE["ref"] = b8["ref"]),
                    bE
                );
            }
            function Fg(b8, b9, bE, bR, bT, bC) {
                var bd = 0x2;
                if (((bR = b8), "function" == typeof b8)) Fc(b8) && (bd = 0x1);
                else {
                    if ("string" == typeof b8) bd = 0x5;
                    else {
                        bY: switch (b8) {
                            case E3:
                                return FW(bE["children"], bT, bC, b9);
                            case E8:
                                (bd = 0x8), (bT |= 0x7);
                                break;
                            case E4:
                                (bd = 0x8), (bT |= 0x1);
                                break;
                            case E5:
                                return ((b8 = Fh(0xc, bE, b9, 0x8 | bT))["elementType"] = E5), (b8["type"] = E5), (b8["expirationTime"] = bC), b8;
                            case EE:
                                return ((b8 = Fh(0xd, bE, b9, bT))["type"] = EE), (b8["elementType"] = EE), (b8["expirationTime"] = bC), b8;
                            case ER:
                                return ((b8 = Fh(0x13, bE, b9, bT))["elementType"] = ER), (b8["expirationTime"] = bC), b8;
                            default:
                                if ("object" == typeof b8 && null !== b8)
                                    switch (b8["$$typeof"]) {
                                        case E6:
                                            bd = 0xa;
                                            break bY;
                                        case E7:
                                            bd = 0x9;
                                            break bY;
                                        case E9:
                                            bd = 0xb;
                                            break bY;
                                        case ET:
                                            bd = 0xe;
                                            break bY;
                                        case EC:
                                            (bd = 0x10), (bR = null);
                                            break bY;
                                        case Ed:
                                            bd = 0x16;
                                            break bY;
                                    }
                                throw Error(r6(0x82, null == b8 ? b8 : typeof b8, ""));
                        }
                    }
                }
                return ((b9 = Fh(bd, bE, b9, bT))["elementType"] = b8), (b9["type"] = bR), (b9["expirationTime"] = bC), b9;
            }
            function FW(b8, b9, bE, bR) {
                return ((b8 = Fh(0x7, b8, bR, b9))["expirationTime"] = bE), b8;
            }
            function FH(b8, b9, bE) {
                return ((b8 = Fh(0x6, b8, null, b9))["expirationTime"] = bE), b8;
            }
            function Fx(b8, b9, bE) {
                return (
                    ((b9 = Fh(0x4, null !== b8["children"] ? b8["children"] : [], b8["key"], b9))["expirationTime"] = bE),
                    (b9["stateNode"] = { containerInfo: b8["containerInfo"], pendingChildren: null, implementation: b8["implementation"] }),
                    b9
                );
            }
            function FK(b8, b9, bE) {
                (this["tag"] = b9),
                    (this["current"] = null),
                    (this["containerInfo"] = b8),
                    (this["pingCache"] = this["pendingChildren"] = null),
                    (this["finishedExpirationTime"] = 0x0),
                    (this["finishedWork"] = null),
                    (this["timeoutHandle"] = -0x1),
                    (this["pendingContext"] = this["context"] = null),
                    (this["hydrate"] = bE),
                    (this["callbackNode"] = null),
                    (this["callbackPriority"] = 0x5a),
                    (this["lastExpiredTime"] = this["lastPingedTime"] = this["nextKnownPendingLevel"] = this["lastSuspendedTime"] = this["firstSuspendedTime"] = this["firstPendingTime"] = 0x0);
            }
            function FV(b8, b9) {
                var bE = b8["firstSuspendedTime"];
                return (b8 = b8["lastSuspendedTime"]), 0x0 !== bE && bE >= b9 && b8 <= b9;
            }
            function FJ(b8, b9) {
                var bE = b8["firstSuspendedTime"],
                    bR = b8["lastSuspendedTime"];
                bE < b9 && (b8["firstSuspendedTime"] = b9), (bR > b9 || 0x0 === bE) && (b8["lastSuspendedTime"] = b9), b9 <= b8["lastPingedTime"] && (b8["lastPingedTime"] = 0x0), b9 <= b8["lastExpiredTime"] && (b8["lastExpiredTime"] = 0x0);
            }
            function FG(b8, b9) {
                b9 > b8["firstPendingTime"] && (b8["firstPendingTime"] = b9);
                var bE = b8["firstSuspendedTime"];
                0x0 !== bE &&
                    (b9 >= bE ? (b8["firstSuspendedTime"] = b8["lastSuspendedTime"] = b8["nextKnownPendingLevel"] = 0x0) : b9 >= b8["lastSuspendedTime"] && (b8["lastSuspendedTime"] = b9 + 0x1),
                    b9 > b8["nextKnownPendingLevel"] && (b8["nextKnownPendingLevel"] = b9));
            }
            function FL(b8, b9) {
                var bE = b8["lastExpiredTime"];
                (0x0 === bE || bE > b9) && (b8["lastExpiredTime"] = b9);
            }
            function FQ(b8, b9, bE, bR) {
                var bT = b9["current"],
                    bC = F7(),
                    bd = Yv["suspense"];
                bC = F8(bC, bT, bd);
                bF: if (bE) {
                    bb: {
                        if (R2((bE = bE["_reactInternalFiber"])) !== bE || 0x1 !== bE["tag"]) throw Error(r6(0xaa));
                        var bY = bE;
                        do {
                            switch (bY["tag"]) {
                                case 0x3:
                                    bY = bY["stateNode"]["context"];
                                    break bb;
                                case 0x1:
                                    if (dD(bY["type"])) {
                                        bY = bY["stateNode"]["__reactInternalMemoizedMergedChildContext"];
                                        break bb;
                                    }
                            }
                            bY = bY["return"];
                        } while (null !== bY);
                        throw Error(r6(0xab));
                    }
                    if (0x1 === bE["tag"]) {
                        var bB = bE["type"];
                        if (dD(bB)) {
                            bE = df(bE, bB, bY);
                            break bF;
                        }
                    }
                    bE = bY;
                } else bE = db;
                return (
                    null === b9["context"] ? (b9["context"] = bE) : (b9["pendingContext"] = bE),
                    ((b9 = YB(bC, bd))["payload"] = { element: b8 }),
                    null !== (bR = void 0x0 === bR ? null : bR) && (b9["callback"] = bR),
                    YF(bT, b9),
                    F9(bT, bC),
                    bC
                );
            }
            function Fz(b8) {
                return (b8 = b8["current"])["child"] ? (b8["child"]["tag"], b8["child"]["stateNode"]) : null;
            }
            function b0(b8, b9) {
                null !== (b8 = b8["memoizedState"]) && null !== b8["dehydrated"] && b8["retryTime"] < b9 && (b8["retryTime"] = b9);
            }
            function b1(b8, b9) {
                b0(b8, b9), (b8 = b8["alternate"]) && b0(b8, b9);
            }
            function b2(b8, b9, bE) {
                var bR = new FK(b8, b9, (bE = null != bE && !0x0 === bE["hydrate"])),
                    bT = Fh(0x3, null, null, 0x2 === b9 ? 0x7 : 0x1 === b9 ? 0x3 : 0x0);
                (bR["current"] = bT),
                    (bT["stateNode"] = bR),
                    Yd(bT),
                    (b8[Tk] = bR["current"]),
                    bE &&
                        0x0 !== b9 &&
                        (function (bC, bd) {
                            var bY = R1(bd);
                            RA["forEach"](function (bB) {
                                RF(bB, bd, bY);
                            }),
                                RM["forEach"](function (bB) {
                                    RF(bB, bd, bY);
                                });
                        })(0x0, 0x9 === b8["nodeType"] ? b8 : b8["ownerDocument"]),
                    (this["_internalRoot"] = bR);
            }
            function b3(b8) {
                return !(!b8 || (0x1 !== b8["nodeType"] && 0x9 !== b8["nodeType"] && 0xb !== b8["nodeType"] && (0x8 !== b8["nodeType"] || "\x20react-mount-point-unstable\x20" !== b8["nodeValue"])));
            }
            function b4(b8, b9, bE, bR, bT) {
                var bC = bE["_reactRootContainer"];
                if (bC) {
                    var bd = bC["_internalRoot"];
                    if ("function" == typeof bT) {
                        var bY = bT;
                        bT = function () {
                            var bF = Fz(bd);
                            bY["call"](bF);
                        };
                    }
                    FQ(b9, bd, b8, bT);
                } else {
                    if (
                        ((bC = bE["_reactRootContainer"] = (function (bF, bb) {
                            if ((bb || (bb = !(!(bb = bF ? (0x9 === bF["nodeType"] ? bF["documentElement"] : bF["firstChild"]) : null) || 0x1 !== bb["nodeType"] || !bb["hasAttribute"]("data-reactroot"))), !bb)) {
                                for (var bZ; (bZ = bF["lastChild"]); ) bF["removeChild"](bZ);
                            }
                            return new b2(bF, 0x0, bb ? { hydrate: !0x0 } : void 0x0);
                        })(bE, bR)),
                        (bd = bC["_internalRoot"]),
                        "function" == typeof bT)
                    ) {
                        var bB = bT;
                        bT = function () {
                            var bF = Fz(bd);
                            bB["call"](bF);
                        };
                    }
                    FB(function () {
                        FQ(b9, bd, b8, bT);
                    });
                }
                return Fz(bd);
            }
            function b5(b8, b9, bE) {
                var bR = 0x3 < arguments["length"] && void 0x0 !== arguments[0x3] ? arguments[0x3] : null;
                return { $$typeof: E2, key: null == bR ? null : "" + bR, children: b8, containerInfo: b9, implementation: bE };
            }
            function b6(b8, b9) {
                var bE = 0x2 < arguments["length"] && void 0x0 !== arguments[0x2] ? arguments[0x2] : null;
                if (!b3(b9)) throw Error(r6(0xc8));
                return b5(b8, b9, null, bE);
            }
            (b2["prototype"]["render"] = function (b8) {
                FQ(b8, this["_internalRoot"], null, null);
            }),
                (b2["prototype"]["unmount"] = function () {
                    var b8 = this["_internalRoot"],
                        b9 = b8["containerInfo"];
                    FQ(null, b8, null, function () {
                        b9[Tk] = null;
                    });
                }),
                (Rb = function (b8) {
                    if (0xd === b8["tag"]) {
                        var b9 = Y2(F7(), 0x96, 0x64);
                        F9(b8, b9), b1(b8, b9);
                    }
                }),
                (RZ = function (b8) {
                    0xd === b8["tag"] && (F9(b8, 0x3), b1(b8, 0x3));
                }),
                (Rm = function (b8) {
                    if (0xd === b8["tag"]) {
                        var b9 = F7();
                        F9(b8, (b9 = F8(b9, b8, null))), b1(b8, b9);
                    }
                }),
                (rI = function (b8, b9, bE) {
                    switch (b9) {
                        case "input":
                            if ((Ef(b8, bE), (b9 = bE["name"]), "radio" === bE["type"] && null != b9)) {
                                for (bE = b8; bE["parentNode"]; ) bE = bE["parentNode"];
                                for (bE = bE["querySelectorAll"]("input[name=" + JSON["stringify"]("" + b9) + "][type=\x22radio\x22]"), b9 = 0x0; b9 < bE["length"]; b9++) {
                                    var bR = bE[b9];
                                    if (bR !== b8 && bR["form"] === b8["form"]) {
                                        var bT = Tw(bR);
                                        if (!bT) throw Error(r6(0x5a));
                                        Ey(bR), Ef(bR, bT);
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            El(b8, bE);
                            break;
                        case "select":
                            null != (b9 = bE["value"]) && EM(b8, !!bE["multiple"], b9, !0x1);
                    }
                }),
                (rU = FY),
                (rq = function (b8, b9, bE, bR, bT) {
                    var bC = BO;
                    BO |= 0x4;
                    try {
                        return dL(0x62, b8["bind"](null, b9, bE, bR, bT));
                    } finally {
                        0x0 === (BO = bC) && Y0();
                    }
                }),
                (rw = function () {
                    0x0 == (0x31 & BO) &&
                        ((function () {
                            if (null !== F3) {
                                var b8 = F3;
                                (F3 = null),
                                    b8["forEach"](function (b9, bE) {
                                        FL(bE, b9), FT(bE);
                                    }),
                                    Y0();
                            }
                        })(),
                        FM());
                }),
                (rO = function (b8, b9) {
                    var bE = BO;
                    BO |= 0x2;
                    try {
                        return b8(b9);
                    } finally {
                        0x0 === (BO = bE) && Y0();
                    }
                });
            var b7 = {
                Events: [
                    TU,
                    Tq,
                    Tw,
                    rf,
                    rD,
                    TW,
                    function (b8) {
                        R7(b8, Tg);
                    },
                    rk,
                    rl,
                    T1,
                    RE,
                    FM,
                    { current: !0x1 },
                ],
            };
            !(function (b8) {
                var b9 = b8["findFiberByHostInstance"];
                (function (bE) {
                    if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !0x1;
                    var bR = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (bR["isDisabled"] || !bR["supportsFiber"]) return !0x0;
                    try {
                        var bT = bR["inject"](bE);
                        (Fw = function (bC) {
                            try {
                                bR["onCommitFiberRoot"](bT, bC, void 0x0, 0x40 == (0x40 & bC["current"]["effectTag"]));
                            } catch (bd) {}
                        }),
                            (FO = function (bC) {
                                try {
                                    bR["onCommitFiberUnmount"](bT, bC);
                                } catch (bd) {}
                            });
                    } catch (bC) {}
                })(
                    r4({}, b8, {
                        overrideHookState: null,
                        overrideProps: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: rL["ReactCurrentDispatcher"],
                        findHostInstanceByFiber: function (bE) {
                            return null === (bE = R5(bE)) ? null : bE["stateNode"];
                        },
                        findFiberByHostInstance: function (bE) {
                            return b9 ? b9(bE) : null;
                        },
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                    })
                );
            })({ findFiberByHostInstance: Tl, bundleType: 0x0, version: "16.14.0", rendererPackageName: "react-dom" }),
                (r1["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"] = b7),
                (r1["createPortal"] = b6),
                (r1["findDOMNode"] = function (b8) {
                    if (null == b8) return null;
                    if (0x1 === b8["nodeType"]) return b8;
                    var b9 = b8["_reactInternalFiber"];
                    if (void 0x0 === b9) {
                        if ("function" == typeof b8["render"]) throw Error(r6(0xbc));
                        throw Error(r6(0x10c, Object["keys"](b8)));
                    }
                    return (b8 = null === (b8 = R5(b9)) ? null : b8["stateNode"]);
                }),
                (r1["flushSync"] = function (b8, b9) {
                    if (0x0 != (0x30 & BO)) throw Error(r6(0xbb));
                    var bE = BO;
                    BO |= 0x1;
                    try {
                        return dL(0x63, b8["bind"](null, b9));
                    } finally {
                        (BO = bE), Y0();
                    }
                }),
                (r1["hydrate"] = function (b8, b9, bE) {
                    if (!b3(b9)) throw Error(r6(0xc8));
                    return b4(null, b8, b9, !0x0, bE);
                }),
                (r1["render"] = function (b8, b9, bE) {
                    if (!b3(b9)) throw Error(r6(0xc8));
                    return b4(null, b8, b9, !0x1, bE);
                }),
                (r1["unmountComponentAtNode"] = function (b8) {
                    if (!b3(b8)) throw Error(r6(0x28));
                    return (
                        !!b8["_reactRootContainer"] &&
                        (FB(function () {
                            b4(null, null, b8, !0x1, function () {
                                (b8["_reactRootContainer"] = null), (b8[Tk] = null);
                            });
                        }),
                        !0x0)
                    );
                }),
                (r1["unstable_batchedUpdates"] = FY),
                (r1["unstable_createPortal"] = function (b8, b9) {
                    return b6(b8, b9, 0x2 < arguments["length"] && void 0x0 !== arguments[0x2] ? arguments[0x2] : null);
                }),
                (r1["unstable_renderSubtreeIntoContainer"] = function (b8, b9, bE, bR) {
                    if (!b3(bE)) throw Error(r6(0xc8));
                    if (null == b8 || void 0x0 === b8["_reactInternalFiber"]) throw Error(r6(0x26));
                    return b4(b8, b9, bE, !0x1, bR);
                }),
                (r1["version"] = "16.14.0");
        },
        0x120cf: function (r, E, R) {
            "use strict";
            !(function T() {
                if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__["checkDCE"])
                    try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__["checkDCE"](T);
                    } catch (C) {
                        console["error"](C);
                    }
            })(),
                (r["exports"] = R(0xfbc0));
        },
        0x11121: function (E, R) {
            "use strict";
            var T = 0xeac7,
                C = 0xeaca,
                Y = 0xeacb,
                B = 0xeacc,
                F = 0xead2,
                Z = 0xeacd,
                D = 0xeace,
                N = 0xead0,
                X = 0xead1,
                P = 0xead8,
                I = 0xead3,
                A = 0xead4,
                M = 0xead9,
                k = 0xeada,
                U = 0xead5,
                q = 0xeae1,
                O = 0xeae3;
            if ("function" == typeof Symbol && Symbol["for"]) {
                var j = Symbol["for"];
                (T = j("react.element")),
                    (C = j("react.portal")),
                    (Y = j("react.fragment")),
                    (B = j("react.strict_mode")),
                    (F = j("react.profiler")),
                    (Z = j("react.provider")),
                    (D = j("react.context")),
                    (N = j("react.forward_ref")),
                    (X = j("react.suspense")),
                    (P = j("react.suspense_list")),
                    (I = j("react.memo")),
                    (A = j("react.lazy")),
                    (M = j("react.block")),
                    (k = j("react.server.block")),
                    (U = j("react.fundamental")),
                    (q = j("react.debug_trace_mode")),
                    (O = j("react.legacy_hidden"));
            }
            function S(W) {
                if ("object" == typeof W && null !== W) {
                    var H = W["$$typeof"];
                    switch (H) {
                        case T:
                            switch ((W = W["type"])) {
                                case Y:
                                case F:
                                case B:
                                case X:
                                case P:
                                    return W;
                                default:
                                    switch ((W = W && W["$$typeof"])) {
                                        case D:
                                        case N:
                                        case A:
                                        case I:
                                        case Z:
                                            return W;
                                        default:
                                            return H;
                                    }
                            }
                        case C:
                            return H;
                    }
                }
            }
            (R["isValidElementType"] = function (W) {
                return (
                    "string" == typeof W ||
                    "function" == typeof W ||
                    W === Y ||
                    W === F ||
                    W === q ||
                    W === B ||
                    W === X ||
                    W === P ||
                    W === O ||
                    ("object" == typeof W && null !== W && (W["$$typeof"] === A || W["$$typeof"] === I || W["$$typeof"] === Z || W["$$typeof"] === D || W["$$typeof"] === N || W["$$typeof"] === U || W["$$typeof"] === M || W[0x0] === k))
                );
            }),
                (R["typeOf"] = S);
        },
        0xe9d8: function (r, E, R) {
            "use strict";
            r["exports"] = R(0x11121);
        },
        0x9b18: function (E, R, T) {
            "use strict";
            T["d"](R, {
                zt: function () {
                    return X;
                },
                I0: function () {
                    return k;
                },
                v9: function () {
                    return j;
                },
            });
            var C = T(0x106de),
                Y = (T(0xb281), C["createContext"](null)),
                B = function (W) {
                    W();
                },
                F = function () {
                    return B;
                },
                Z = {
                    notify: function () {},
                    get: function () {
                        return [];
                    },
                };
            function D(W, H) {
                var x,
                    K = Z;
                function V() {
                    G["onStateChange"] && G["onStateChange"]();
                }
                function J() {
                    x ||
                        ((x = H ? H["addNestedSub"](V) : W["subscribe"](V)),
                        (K = (function () {
                            var L = F(),
                                Q = null,
                                z = null;
                            return {
                                clear: function () {
                                    (Q = null), (z = null);
                                },
                                notify: function () {
                                    L(function () {
                                        for (var r0 = Q; r0; ) r0["callback"](), (r0 = r0["next"]);
                                    });
                                },
                                get: function () {
                                    for (var r0 = [], r1 = Q; r1; ) r0["push"](r1), (r1 = r1["next"]);
                                    return r0;
                                },
                                subscribe: function (r0) {
                                    var r1 = !0x0,
                                        r2 = (z = { callback: r0, next: null, prev: z });
                                    return (
                                        r2["prev"] ? (r2["prev"]["next"] = r2) : (Q = r2),
                                        function () {
                                            r1 && null !== Q && ((r1 = !0x1), r2["next"] ? (r2["next"]["prev"] = r2["prev"]) : (z = r2["prev"]), r2["prev"] ? (r2["prev"]["next"] = r2["next"]) : (Q = r2["next"]));
                                        }
                                    );
                                },
                            };
                        })()));
                }
                var G = {
                    addNestedSub: function (L) {
                        return J(), K["subscribe"](L);
                    },
                    notifyNestedSubs: function () {
                        K["notify"]();
                    },
                    handleChangeWrapper: V,
                    isSubscribed: function () {
                        return Boolean(x);
                    },
                    trySubscribe: J,
                    tryUnsubscribe: function () {
                        x && (x(), (x = void 0x0), K["clear"](), (K = Z));
                    },
                    getListeners: function () {
                        return K;
                    },
                };
                return G;
            }
            var N = "undefined" != typeof window && void 0x0 !== window["document"] && void 0x0 !== window["document"]["createElement"] ? C["useLayoutEffect"] : C["useEffect"],
                X = function (W) {
                    var H = W["store"],
                        x = W["context"],
                        K = W["children"],
                        V = (0x0, C["useMemo"])(
                            function () {
                                var L = D(H);
                                return (L["onStateChange"] = L["notifyNestedSubs"]), { store: H, subscription: L };
                            },
                            [H]
                        ),
                        J = (0x0, C["useMemo"])(
                            function () {
                                return H["getState"]();
                            },
                            [H]
                        );
                    N(
                        function () {
                            var L = V["subscription"];
                            return (
                                L["trySubscribe"](),
                                J !== H["getState"]() && L["notifyNestedSubs"](),
                                function () {
                                    L["tryUnsubscribe"](), (L["onStateChange"] = null);
                                }
                            );
                        },
                        [V, J]
                    );
                    var G = x || Y;
                    return C["createElement"](G["Provider"], { value: V }, K);
                };
            T(0x21e7), T(0xe9d8), T(0x155a6);
            function P() {
                return (0x0, C["useContext"])(Y);
            }
            function I(W) {
                void 0x0 === W && (W = Y);
                var H =
                    W === Y
                        ? P
                        : function () {
                              return (0x0, C["useContext"])(W);
                          };
                return function () {
                    return H()["store"];
                };
            }
            var A = I();
            function M(W) {
                void 0x0 === W && (W = Y);
                var H = W === Y ? A : I(W);
                return function () {
                    return H()["dispatch"];
                };
            }
            var k = M(),
                U = function (W, H) {
                    return W === H;
                };
            function q(W) {
                void 0x0 === W && (W = Y);
                var H =
                    W === Y
                        ? P
                        : function () {
                              return (0x0, C["useContext"])(W);
                          };
                return function (x, K) {
                    void 0x0 === K && (K = U);
                    var V = H(),
                        J = (function (G, L, Q, z) {
                            var r0,
                                r1 = (0x0, C["useReducer"])(function (r9) {
                                    return r9 + 0x1;
                                }, 0x0)[0x1],
                                r2 = (0x0, C["useMemo"])(
                                    function () {
                                        return D(Q, z);
                                    },
                                    [Q, z]
                                ),
                                r3 = (0x0, C["useRef"])(),
                                r4 = (0x0, C["useRef"])(),
                                r5 = (0x0, C["useRef"])(),
                                r6 = (0x0, C["useRef"])(),
                                r7 = Q["getState"]();
                            try {
                                if (G !== r4["current"] || r7 !== r5["current"] || r3["current"]) {
                                    var r8 = G(r7);
                                    r0 = void 0x0 !== r6["current"] && L(r8, r6["current"]) ? r6["current"] : r8;
                                } else r0 = r6["current"];
                            } catch (r9) {
                                throw (r3["current"] && (r9["message"] += "\x0aThe\x20error\x20may\x20be\x20correlated\x20with\x20this\x20previous\x20error:\x0a" + r3["current"]["stack"] + "\x0a\x0a"), r9);
                            }
                            return (
                                N(function () {
                                    (r4["current"] = G), (r5["current"] = r7), (r6["current"] = r0), (r3["current"] = void 0x0);
                                }),
                                N(
                                    function () {
                                        function rr() {
                                            try {
                                                var rE = Q["getState"]();
                                                if (rE === r5["current"]) return;
                                                var rR = r4["current"](rE);
                                                if (L(rR, r6["current"])) return;
                                                (r6["current"] = rR), (r5["current"] = rE);
                                            } catch (rT) {
                                                r3["current"] = rT;
                                            }
                                            r1();
                                        }
                                        return (
                                            (r2["onStateChange"] = rr),
                                            r2["trySubscribe"](),
                                            rr(),
                                            function () {
                                                return r2["tryUnsubscribe"]();
                                            }
                                        );
                                    },
                                    [Q, r2]
                                ),
                                r0
                            );
                        })(x, K, V["store"], V["subscription"]);
                    return (0x0, C["useDebugValue"])(J), J;
                };
            }
            var O,
                j = q(),
                S = T(0x120cf);
            (O = S["unstable_batchedUpdates"]), (B = O);
        },
        0x11fff: function (E, R, T) {
            "use strict";
            T["d"](R, {
                VK: function () {
                    return N;
                },
                rU: function () {
                    return k;
                },
                OL: function () {
                    return O;
                },
            });
            var C = T(0xc99f),
                Y = T(0xca09),
                B = T(0x106de),
                F = T(0x15fd7),
                Z = (T(0xb281), T(0x155a6)),
                y = T(0xf786),
                D = T(0x881),
                N = (function (j) {
                    function S() {
                        for (var W, H = arguments["length"], x = new Array(H), K = 0x0; K < H; K++) x[K] = arguments[K];
                        return ((W = j["call"]["apply"](j, [this]["concat"](x)) || this)["history"] = (0x0, F["lX"])(W["props"])), W;
                    }
                    return (
                        (0x0, Y["Z"])(S, j),
                        (S["prototype"]["render"] = function () {
                            return B["createElement"](C["F0"], { history: this["history"], children: this["props"]["children"] });
                        }),
                        S
                    );
                })(B["Component"]);
            B["Component"];
            var X = function (j, S) {
                    return "function" == typeof j ? j(S) : j;
                },
                P = function (j, S) {
                    return "string" == typeof j ? (0x0, F["ob"])(j, null, null, S) : j;
                },
                I = function (j) {
                    return j;
                },
                A = B["forwardRef"];
            void 0x0 === A && (A = I);
            var M = A(function (j, S) {
                    var W = j["innerRef"],
                        H = j["navigate"],
                        x = j["onClick"],
                        K = (0x0, y["Z"])(j, ["innerRef", "navigate", "onClick"]),
                        V = K["target"],
                        J = (0x0, Z["Z"])({}, K, {
                            onClick: function (G) {
                                try {
                                    x && x(G);
                                } catch (L) {
                                    throw (G["preventDefault"](), L);
                                }
                                G["defaultPrevented"] ||
                                    0x0 !== G["button"] ||
                                    (V && "_self" !== V) ||
                                    (function (Q) {
                                        return !!(Q["metaKey"] || Q["altKey"] || Q["ctrlKey"] || Q["shiftKey"]);
                                    })(G) ||
                                    (G["preventDefault"](), H());
                            },
                        });
                    return (J["ref"] = (I !== A && S) || W), B["createElement"]("a", J);
                }),
                k = A(function (j, S) {
                    var W = j["component"],
                        H = void 0x0 === W ? M : W,
                        x = j["replace"],
                        K = j["to"],
                        V = j["innerRef"],
                        J = (0x0, y["Z"])(j, ["component", "replace", "to", "innerRef"]);
                    return B["createElement"](C["s6"]["Consumer"], null, function (G) {
                        G || (0x0, D["Z"])(!0x1);
                        var L = G["history"],
                            Q = P(X(K, G["location"]), G["location"]),
                            z = Q ? L["createHref"](Q) : "",
                            r0 = (0x0, Z["Z"])({}, J, {
                                href: z,
                                navigate: function () {
                                    var r1 = X(K, G["location"]),
                                        r2 = (0x0, F["Ep"])(G["location"]) === (0x0, F["Ep"])(P(r1));
                                    (x || r2 ? L["replace"] : L["push"])(r1);
                                },
                            });
                        return I !== A ? (r0["ref"] = S || V) : (r0["innerRef"] = V), B["createElement"](H, r0);
                    });
                }),
                U = function (j) {
                    return j;
                },
                q = B["forwardRef"];
            void 0x0 === q && (q = U);
            var O = q(function (j, W) {
                var H = j["aria-current"],
                    K = void 0x0 === H ? "page" : H,
                    V = j["activeClassName"],
                    J = void 0x0 === V ? "active" : V,
                    G = j["activeStyle"],
                    L = j["className"],
                    Q = j["exact"],
                    z = j["isActive"],
                    r0 = j["location"],
                    r1 = j["sensitive"],
                    r2 = j["strict"],
                    r3 = j["style"],
                    r4 = j["to"],
                    r5 = j["innerRef"],
                    r6 = (0x0, y["Z"])(j, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
                return B["createElement"](C["s6"]["Consumer"], null, function (r7) {
                    r7 || (0x0, D["Z"])(!0x1);
                    var r8 = r0 || r7["location"],
                        r9 = P(X(r4, r8), r8),
                        rr = r9["pathname"],
                        rE = rr && rr["replace"](/([.+*?=^!:${}()[\]|/\\])/g, "\x5c$1"),
                        rR = rE ? (0x0, C["LX"])(r8["pathname"], { path: rE, exact: Q, sensitive: r1, strict: r2 }) : null,
                        rT = !!(z ? z(rR, r8) : rR),
                        rC = "function" == typeof L ? L(rT) : L,
                        rd = "function" == typeof r3 ? r3(rT) : r3;
                    rT &&
                        ((rC = (function () {
                            for (var rn = arguments["length"], rB = new Array(rn), rF = 0x0; rF < rn; rF++) rB[rF] = arguments[rF];
                            return rB["filter"](function (rb) {
                                return rb;
                            })["join"]("\x20");
                        })(rC, J)),
                        (rd = (0x0, Z["Z"])({}, rd, G)));
                    var rY = (0x0, Z["Z"])({ "aria-current": (rT && K) || null, className: rC, style: rd, to: r9 }, r6);
                    return U !== q ? (rY["ref"] = W || r5) : (rY["innerRef"] = r5), B["createElement"](k, rY);
                });
            });
        },
        0xc99f: function (Y, B, F) {
            "use strict";
            F["d"](B, {
                l_: function () {
                    return rT;
                },
                AW: function () {
                    return rn;
                },
                F0: function () {
                    return r8;
                },
                rs: function () {
                    return rv;
                },
                s6: function () {
                    return r7;
                },
                LX: function () {
                    return rY;
                },
                k6: function () {
                    return ry;
                },
                UO: function () {
                    return rD;
                },
            });
            var Z = F(0xca09),
                X = F(0x106de),
                U = F(0xb281),
                q = F["n"](U),
                W = F(0x15fd7),
                K = 0x3fffffff,
                V = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0x0 !== F["g"] ? F["g"] : {};
            function J(rN) {
                var rX = [];
                return {
                    on: function (rf) {
                        rX["push"](rf);
                    },
                    off: function (rf) {
                        rX = rX["filter"](function (rP) {
                            return rP !== rf;
                        });
                    },
                    get: function () {
                        return rN;
                    },
                    set: function (rf, rP) {
                        (rN = rf),
                            rX["forEach"](function (rI) {
                                return rI(rN, rP);
                            });
                    },
                };
            }
            var Q =
                    X["createContext"] ||
                    function (rN, rX) {
                        var rf,
                            rP,
                            rI =
                                "__create-react-context-" +
                                (function () {
                                    var ro = "__global_unique_id__";
                                    return (V[ro] = (V[ro] || 0x0) + 0x1);
                                })() +
                                "__",
                            rA = (function (ro) {
                                function rt() {
                                    var rk;
                                    return ((rk = ro["apply"](this, arguments) || this)["emitter"] = J(rk["props"]["value"])), rk;
                                }
                                (0x0, Z["Z"])(rt, ro);
                                var rp = rt["prototype"];
                                return (
                                    (rp["getChildContext"] = function () {
                                        var rk;
                                        return ((rk = {})[rI] = this["emitter"]), rk;
                                    }),
                                    (rp["componentWillReceiveProps"] = function (rk) {
                                        if (this["props"]["value"] !== rk["value"]) {
                                            var re,
                                                rl = this["props"]["value"],
                                                rU = rk["value"];
                                            !(function (rq, rw) {
                                                return rq === rw ? 0x0 !== rq || 0x1 / rq == 0x1 / rw : rq != rq && rw != rw;
                                            })(rl, rU)
                                                ? ((re = "function" == typeof rX ? rX(rl, rU) : K), 0x0 !== (re |= 0x0) && this["emitter"]["set"](rk["value"], re))
                                                : (re = 0x0);
                                        }
                                    }),
                                    (rp["render"] = function () {
                                        return this["props"]["children"];
                                    }),
                                    rt
                                );
                            })(X["Component"]);
                        rA["childContextTypes"] = (((rf = {})[rI] = q()["object"]["isRequired"]), rf);
                        var rM = (function (ro) {
                            function rt() {
                                var rk;
                                return (
                                    ((rk = ro["apply"](this, arguments) || this)["state"] = { value: rk["getValue"]() }),
                                    (rk["onUpdate"] = function (re, rl) {
                                        0x0 != ((0x0 | rk["observedBits"]) & rl) && rk["setState"]({ value: rk["getValue"]() });
                                    }),
                                    rk
                                );
                            }
                            (0x0, Z["Z"])(rt, ro);
                            var rp = rt["prototype"];
                            return (
                                (rp["componentWillReceiveProps"] = function (rk) {
                                    var re = rk["observedBits"];
                                    this["observedBits"] = null == re ? K : re;
                                }),
                                (rp["componentDidMount"] = function () {
                                    this["context"][rI] && this["context"][rI]["on"](this["onUpdate"]);
                                    var rk = this["props"]["observedBits"];
                                    this["observedBits"] = null == rk ? K : rk;
                                }),
                                (rp["componentWillUnmount"] = function () {
                                    this["context"][rI] && this["context"][rI]["off"](this["onUpdate"]);
                                }),
                                (rp["getValue"] = function () {
                                    return this["context"][rI] ? this["context"][rI]["get"]() : rN;
                                }),
                                (rp["render"] = function () {
                                    return ((rk = this["props"]["children"]), Array["isArray"](rk) ? rk[0x0] : rk)(this["state"]["value"]);
                                    var rk;
                                }),
                                rt
                            );
                        })(X["Component"]);
                        return (rM["contextTypes"] = (((rP = {})[rI] = q()["object"]), rP)), { Provider: rA, Consumer: rM };
                    },
                z = Q,
                r0 = F(0x881),
                r1 = F(0x155a6),
                r2 = F(0x9aea),
                r3 = F["n"](r2),
                r4 = (F(0xc5e7), F(0xf786)),
                r5 =
                    (F(0x21e7),
                    function (rN) {
                        var rX = z();
                        return (rX["displayName"] = rN), rX;
                    }),
                r6 = r5("Router-History"),
                r7 = r5("Router"),
                r8 = (function (rN) {
                    function rX(rP) {
                        var rI;
                        return (
                            ((rI = rN["call"](this, rP) || this)["state"] = { location: rP["history"]["location"] }),
                            (rI["_isMounted"] = !0x1),
                            (rI["_pendingLocation"] = null),
                            rP["staticContext"] ||
                                (rI["unlisten"] = rP["history"]["listen"](function (rA) {
                                    rI["_isMounted"] ? rI["setState"]({ location: rA }) : (rI["_pendingLocation"] = rA);
                                })),
                            rI
                        );
                    }
                    (0x0, Z["Z"])(rX, rN),
                        (rX["computeRootMatch"] = function (rP) {
                            return { path: "/", url: "/", params: {}, isExact: "/" === rP };
                        });
                    var rf = rX["prototype"];
                    return (
                        (rf["componentDidMount"] = function () {
                            (this["_isMounted"] = !0x0), this["_pendingLocation"] && this["setState"]({ location: this["_pendingLocation"] });
                        }),
                        (rf["componentWillUnmount"] = function () {
                            this["unlisten"] && (this["unlisten"](), (this["_isMounted"] = !0x1), (this["_pendingLocation"] = null));
                        }),
                        (rf["render"] = function () {
                            return X["createElement"](
                                r7["Provider"],
                                { value: { history: this["props"]["history"], location: this["state"]["location"], match: rX["computeRootMatch"](this["state"]["location"]["pathname"]), staticContext: this["props"]["staticContext"] } },
                                X["createElement"](r6["Provider"], { children: this["props"]["children"] || null, value: this["props"]["history"] })
                            );
                        }),
                        rX
                    );
                })(X["Component"]);
            X["Component"];
            var r9 = (function (rN) {
                    function rX() {
                        return rN["apply"](this, arguments) || this;
                    }
                    (0x0, Z["Z"])(rX, rN);
                    var rf = rX["prototype"];
                    return (
                        (rf["componentDidMount"] = function () {
                            this["props"]["onMount"] && this["props"]["onMount"]["call"](this, this);
                        }),
                        (rf["componentDidUpdate"] = function (rP) {
                            this["props"]["onUpdate"] && this["props"]["onUpdate"]["call"](this, this, rP);
                        }),
                        (rf["componentWillUnmount"] = function () {
                            this["props"]["onUnmount"] && this["props"]["onUnmount"]["call"](this, this);
                        }),
                        (rf["render"] = function () {
                            return null;
                        }),
                        rX
                    );
                })(X["Component"]),
                rr = {},
                rE = 0x0;
            function rR(rN, rX) {
                return (
                    void 0x0 === rN && (rN = "/"),
                    void 0x0 === rX && (rX = {}),
                    "/" === rN
                        ? rN
                        : (function (rf) {
                              if (rr[rf]) return rr[rf];
                              var rP = r3()["compile"](rf);
                              return rE < 0x2710 && ((rr[rf] = rP), rE++), rP;
                          })(rN)(rX, { pretty: !0x0 })
                );
            }
            function rT(rN) {
                var rX = rN["computedMatch"],
                    rf = rN["to"],
                    rP = rN["push"],
                    rI = void 0x0 !== rP && rP;
                return X["createElement"](r7["Consumer"], null, function (rA) {
                    rA || (0x0, r0["Z"])(!0x1);
                    var rM = rA["history"],
                        ro = rA["staticContext"],
                        rt = rI ? rM["push"] : rM["replace"],
                        rp = (0x0, W["ob"])(rX ? ("string" == typeof rf ? rR(rf, rX["params"]) : (0x0, r1["Z"])({}, rf, { pathname: rR(rf["pathname"], rX["params"]) })) : rf);
                    return ro
                        ? (rt(rp), null)
                        : X["createElement"](r9, {
                              onMount: function () {
                                  rt(rp);
                              },
                              onUpdate: function (rk, re) {
                                  var rl = (0x0, W["ob"])(re["to"]);
                                  (0x0, W["Hp"])(rl, (0x0, r1["Z"])({}, rp, { key: rl["key"] })) || rt(rp);
                              },
                              to: rf,
                          });
                });
            }
            var rC = {},
                rd = 0x0;
            function rY(rN, rX) {
                void 0x0 === rX && (rX = {}), ("string" == typeof rX || Array["isArray"](rX)) && (rX = { path: rX });
                var rf = rX,
                    rP = rf["path"],
                    rI = rf["exact"],
                    rA = void 0x0 !== rI && rI,
                    rM = rf["strict"],
                    ro = void 0x0 !== rM && rM,
                    rt = rf["sensitive"],
                    rp = void 0x0 !== rt && rt;
                return []["concat"](rP)["reduce"](function (rk, re) {
                    if (!re && "" !== re) return null;
                    if (rk) return rk;
                    var rl = (function (rh, ra) {
                            var rc = "" + ra["end"] + ra["strict"] + ra["sensitive"],
                                rS = rC[rc] || (rC[rc] = {});
                            if (rS[rh]) return rS[rh];
                            var rg = [],
                                rW = { regexp: r3()(rh, rg, ra), keys: rg };
                            return rd < 0x2710 && ((rS[rh] = rW), rd++), rW;
                        })(re, { end: rA, strict: ro, sensitive: rp }),
                        rU = rl["regexp"],
                        rq = rl["keys"],
                        rw = rU["exec"](rN);
                    if (!rw) return null;
                    var rO = rw[0x0],
                        rj = rw["slice"](0x1),
                        ri = rN === rO;
                    return rA && !ri
                        ? null
                        : {
                              path: re,
                              url: "/" === re && "" === rO ? "/" : rO,
                              isExact: ri,
                              params: rq["reduce"](function (rh, ra, rc) {
                                  return (rh[ra["name"]] = rj[rc]), rh;
                              }, {}),
                          };
                }, null);
            }
            var rn = (function (rN) {
                function rX() {
                    return rN["apply"](this, arguments) || this;
                }
                return (
                    (0x0, Z["Z"])(rX, rN),
                    (rX["prototype"]["render"] = function () {
                        var rf = this;
                        return X["createElement"](r7["Consumer"], null, function (rP) {
                            rP || (0x0, r0["Z"])(!0x1);
                            var rI = rf["props"]["location"] || rP["location"],
                                rA = rf["props"]["computedMatch"] ? rf["props"]["computedMatch"] : rf["props"]["path"] ? rY(rI["pathname"], rf["props"]) : rP["match"],
                                rM = (0x0, r1["Z"])({}, rP, { location: rI, match: rA }),
                                ro = rf["props"],
                                rt = ro["children"],
                                rp = ro["component"],
                                rk = ro["render"];
                            return (
                                Array["isArray"](rt) &&
                                    (function (re) {
                                        return 0x0 === X["Children"]["count"](re);
                                    })(rt) &&
                                    (rt = null),
                                X["createElement"](r7["Provider"], { value: rM }, rM["match"] ? (rt ? ("function" == typeof rt ? rt(rM) : rt) : rp ? X["createElement"](rp, rM) : rk ? rk(rM) : null) : "function" == typeof rt ? rt(rM) : null)
                            );
                        });
                    }),
                    rX
                );
            })(X["Component"]);
            function rB(rN) {
                return "/" === rN["charAt"](0x0) ? rN : "/" + rN;
            }
            function rF(rN, rX) {
                if (!rN) return rX;
                var rf = rB(rN);
                return 0x0 !== rX["pathname"]["indexOf"](rf) ? rX : (0x0, r1["Z"])({}, rX, { pathname: rX["pathname"]["substr"](rf["length"]) });
            }
            function rb(rN) {
                return "string" == typeof rN ? rN : (0x0, W["Ep"])(rN);
            }
            function rZ(rN) {
                return function () {
                    (0x0, r0["Z"])(!0x1);
                };
            }
            function rm() {}
            X["Component"];
            var rv = (function (rN) {
                    function rX() {
                        return rN["apply"](this, arguments) || this;
                    }
                    return (
                        (0x0, Z["Z"])(rX, rN),
                        (rX["prototype"]["render"] = function () {
                            var rf = this;
                            return X["createElement"](r7["Consumer"], null, function (rP) {
                                rP || (0x0, r0["Z"])(!0x1);
                                var rI,
                                    rA,
                                    rM = rf["props"]["location"] || rP["location"];
                                return (
                                    X["Children"]["forEach"](rf["props"]["children"], function (ro) {
                                        if (null == rA && X["isValidElement"](ro)) {
                                            rI = ro;
                                            var rt = ro["props"]["path"] || ro["props"]["from"];
                                            rA = rt ? rY(rM["pathname"], (0x0, r1["Z"])({}, ro["props"], { path: rt })) : rP["match"];
                                        }
                                    }),
                                    rA ? X["cloneElement"](rI, { location: rM, computedMatch: rA }) : null
                                );
                            });
                        }),
                        rX
                    );
                })(X["Component"]),
                ru = X["useContext"];
            function ry() {
                return ru(r6);
            }
            function rD() {
                var rN = ru(r7)["match"];
                return rN ? rN["params"] : {};
            }
        },
        0x12b29: function (r) {
            r["exports"] =
                Array["isArray"] ||
                function (E) {
                    return "[object\x20Array]" == Object["prototype"]["toString"]["call"](E);
                };
        },
        0x9aea: function (E, R, T) {
            var C = T(0x12b29);
            (E["exports"] = N),
                (E["exports"]["parse"] = B),
                (E["exports"]["compile"] = function (X, P) {
                    return b(B(X, P), P);
                }),
                (E["exports"]["tokensToFunction"] = b),
                (E["exports"]["tokensToRegExp"] = D);
            var Y = new RegExp(["(\x5c\x5c.)", "([\x5c/.])?(?:(?:\x5c:(\x5cw+)(?:\x5c(((?:\x5c\x5c.|[^\x5c\x5c()])+)\x5c))?|\x5c(((?:\x5c\x5c.|[^\x5c\x5c()])+)\x5c))([+*?])?|(\x5c*))"]["join"]("|"), "g");
            function B(X, P) {
                for (var I, A = [], k = 0x0, U = 0x0, q = "", O = (P && P["delimiter"]) || "/"; null != (I = Y["exec"](X)); ) {
                    var j = I[0x0],
                        S = I[0x1],
                        W = I["index"];
                    if (((q += X["slice"](U, W)), (U = W + j["length"]), S)) q += S[0x1];
                    else {
                        var H = X[U],
                            K = I[0x2],
                            V = I[0x3],
                            J = I[0x4],
                            G = I[0x5],
                            L = I[0x6],
                            Q = I[0x7];
                        q && (A["push"](q), (q = ""));
                        var z = null != K && null != H && H !== K,
                            r0 = "+" === L || "*" === L,
                            r1 = "?" === L || "*" === L,
                            r2 = I[0x2] || O,
                            r3 = J || G;
                        A["push"]({ name: V || k++, prefix: K || "", delimiter: r2, optional: r1, repeat: r0, partial: z, asterisk: !!Q, pattern: r3 ? m(r3) : Q ? ".*" : "[^" + Z(r2) + "]+?" });
                    }
                }
                return U < X["length"] && (q += X["substr"](U)), q && A["push"](q), A;
            }
            function F(X) {
                return encodeURI(X)["replace"](/[\/?#]/g, function (P) {
                    return "%" + P["charCodeAt"](0x0)["toString"](0x10)["toUpperCase"]();
                });
            }
            function b(X, P) {
                for (var I = new Array(X["length"]), A = 0x0; A < X["length"]; A++) "object" == typeof X[A] && (I[A] = new RegExp("^(?:" + X[A]["pattern"] + ")$", y(P)));
                return function (M, p) {
                    for (var k = "", U = M || {}, q = (p || {})["pretty"] ? F : encodeURIComponent, w = 0x0; w < X["length"]; w++) {
                        var O = X[w];
                        if ("string" != typeof O) {
                            var j,
                                S = U[O["name"]];
                            if (null == S) {
                                if (O["optional"]) {
                                    O["partial"] && (k += O["prefix"]);
                                    continue;
                                }
                                throw new TypeError("Expected\x20\x22" + O["name"] + "\x22\x20to\x20be\x20defined");
                            }
                            if (C(S)) {
                                if (!O["repeat"]) throw new TypeError("Expected\x20\x22" + O["name"] + "\x22\x20to\x20not\x20repeat,\x20but\x20received\x20`" + JSON["stringify"](S) + "`");
                                if (0x0 === S["length"]) {
                                    if (O["optional"]) continue;
                                    throw new TypeError("Expected\x20\x22" + O["name"] + "\x22\x20to\x20not\x20be\x20empty");
                                }
                                for (var g = 0x0; g < S["length"]; g++) {
                                    if (((j = q(S[g])), !I[w]["test"](j)))
                                        throw new TypeError("Expected\x20all\x20\x22" + O["name"] + "\x22\x20to\x20match\x20\x22" + O["pattern"] + "\x22,\x20but\x20received\x20`" + JSON["stringify"](j) + "`");
                                    k += (0x0 === g ? O["prefix"] : O["delimiter"]) + j;
                                }
                            } else {
                                if (
                                    ((j = O["asterisk"]
                                        ? encodeURI(S)["replace"](/[?#]/g, function (W) {
                                              return "%" + W["charCodeAt"](0x0)["toString"](0x10)["toUpperCase"]();
                                          })
                                        : q(S)),
                                    !I[w]["test"](j))
                                )
                                    throw new TypeError("Expected\x20\x22" + O["name"] + "\x22\x20to\x20match\x20\x22" + O["pattern"] + "\x22,\x20but\x20received\x20\x22" + j + "\x22");
                                k += O["prefix"] + j;
                            }
                        } else k += O;
                    }
                    return k;
                };
            }
            function Z(X) {
                return X["replace"](/([.+*?=^!:${}()[\]|\/\\])/g, "\x5c$1");
            }
            function m(X) {
                return X["replace"](/([=!:$\/()])/g, "\x5c$1");
            }
            function v(X, P) {
                return (X["keys"] = P), X;
            }
            function y(X) {
                return X && X["sensitive"] ? "" : "i";
            }
            function D(X, P, I) {
                C(P) || ((I = P || I), (P = []));
                for (var A = (I = I || {})["strict"], M = !0x1 !== I["end"], k = "", U = 0x0; U < X["length"]; U++) {
                    var q = X[U];
                    if ("string" == typeof q) k += Z(q);
                    else {
                        var w = Z(q["prefix"]),
                            O = "(?:" + q["pattern"] + ")";
                        P["push"](q), q["repeat"] && (O += "(?:" + w + O + ")*"), (k += O = q["optional"] ? (q["partial"] ? w + "(" + O + ")?" : "(?:" + w + "(" + O + "))?") : w + "(" + O + ")");
                    }
                }
                var j = Z(I["delimiter"] || "/"),
                    S = k["slice"](-j["length"]) === j;
                return A || (k = (S ? k["slice"](0x0, -j["length"]) : k) + "(?:" + j + "(?=$))?"), (k += M ? "$" : A && S ? "" : "(?=" + j + "|$)"), v(new RegExp("^" + k, y(I)), P);
            }
            function N(X, P, I) {
                return (
                    C(P) || ((I = P || I), (P = [])),
                    (I = I || {}),
                    X instanceof RegExp
                        ? (function (A, M) {
                              var p = A["source"]["match"](/\((?!\?)/g);
                              if (p) {
                                  for (var k = 0x0; k < p["length"]; k++) M["push"]({ name: k, prefix: null, delimiter: null, optional: !0x1, repeat: !0x1, partial: !0x1, asterisk: !0x1, pattern: null });
                              }
                              return v(A, M);
                          })(X, P)
                        : C(X)
                        ? (function (A, M, p) {
                              for (var k = [], U = 0x0; U < A["length"]; U++) k["push"](N(A[U], M, p)["source"]);
                              return v(new RegExp("(?:" + k["join"]("|") + ")", y(p)), M);
                          })(X, P, I)
                        : (function (A, M, p) {
                              return D(B(A, p), M, p);
                          })(X, P, I)
                );
            }
        },
        0x7586: function (R, T) {
            "use strict";
            var C = "function" == typeof Symbol && Symbol["for"],
                Y = C ? Symbol["for"]("react.element") : 0xeac7,
                B = C ? Symbol["for"]("react.portal") : 0xeaca,
                F = C ? Symbol["for"]("react.fragment") : 0xeacb,
                Z = C ? Symbol["for"]("react.strict_mode") : 0xeacc,
                D = C ? Symbol["for"]("react.profiler") : 0xead2,
                N = C ? Symbol["for"]("react.provider") : 0xeacd,
                X = C ? Symbol["for"]("react.context") : 0xeace,
                P = C ? Symbol["for"]("react.async_mode") : 0xeacf,
                I = C ? Symbol["for"]("react.concurrent_mode") : 0xeacf,
                A = C ? Symbol["for"]("react.forward_ref") : 0xead0,
                M = C ? Symbol["for"]("react.suspense") : 0xead1,
                k = C ? Symbol["for"]("react.suspense_list") : 0xead8,
                U = C ? Symbol["for"]("react.memo") : 0xead3,
                q = C ? Symbol["for"]("react.lazy") : 0xead4,
                O = C ? Symbol["for"]("react.block") : 0xead9,
                j = C ? Symbol["for"]("react.fundamental") : 0xead5,
                S = C ? Symbol["for"]("react.responder") : 0xead6,
                W = C ? Symbol["for"]("react.scope") : 0xead7;
            function H(K) {
                if ("object" == typeof K && null !== K) {
                    var V = K["$$typeof"];
                    switch (V) {
                        case Y:
                            switch ((K = K["type"])) {
                                case P:
                                case I:
                                case F:
                                case D:
                                case Z:
                                case M:
                                    return K;
                                default:
                                    switch ((K = K && K["$$typeof"])) {
                                        case X:
                                        case A:
                                        case q:
                                        case U:
                                        case N:
                                            return K;
                                        default:
                                            return V;
                                    }
                            }
                        case B:
                            return V;
                    }
                }
            }
            function x(K) {
                return H(K) === I;
            }
        },
        0xc5e7: function (r, E, R) {
            "use strict";
            R(0x7586);
        },
        0x11ad8: function (Y, B, Z) {
            "use strict";
            var X = Z(0x6b1a),
                q = "function" == typeof Symbol && Symbol["for"],
                W = q ? Symbol["for"]("react.element") : 0xeac7,
                K = q ? Symbol["for"]("react.portal") : 0xeaca,
                V = q ? Symbol["for"]("react.fragment") : 0xeacb,
                J = q ? Symbol["for"]("react.strict_mode") : 0xeacc,
                Q = q ? Symbol["for"]("react.profiler") : 0xead2,
                z = q ? Symbol["for"]("react.provider") : 0xeacd,
                r0 = q ? Symbol["for"]("react.context") : 0xeace,
                r1 = q ? Symbol["for"]("react.forward_ref") : 0xead0,
                r2 = q ? Symbol["for"]("react.suspense") : 0xead1,
                r3 = q ? Symbol["for"]("react.memo") : 0xead3,
                r4 = q ? Symbol["for"]("react.lazy") : 0xead4,
                r5 = "function" == typeof Symbol && Symbol["iterator"];
            function r6(rI) {
                for (var rA = "https://reactjs.org/docs/error-decoder.html?invariant=" + rI, rM = 0x1; rM < arguments["length"]; rM++) rA += "&args[]=" + encodeURIComponent(arguments[rM]);
                return (
                    "Minified\x20React\x20error\x20#" +
                    rI +
                    ";\x20visit\x20" +
                    rA +
                    "\x20for\x20the\x20full\x20message\x20or\x20use\x20the\x20non-minified\x20dev\x20environment\x20for\x20full\x20errors\x20and\x20additional\x20helpful\x20warnings."
                );
            }
            var r7 = {
                    isMounted: function () {
                        return !0x1;
                    },
                    enqueueForceUpdate: function () {},
                    enqueueReplaceState: function () {},
                    enqueueSetState: function () {},
                },
                r8 = {};
            function r9(rI, rA, rM) {
                (this["props"] = rI), (this["context"] = rA), (this["refs"] = r8), (this["updater"] = rM || r7);
            }
            function rr() {}
            function rE(rI, rA, rM) {
                (this["props"] = rI), (this["context"] = rA), (this["refs"] = r8), (this["updater"] = rM || r7);
            }
            (r9["prototype"]["isReactComponent"] = {}),
                (r9["prototype"]["setState"] = function (rI, rA) {
                    if ("object" != typeof rI && "function" != typeof rI && null != rI) throw Error(r6(0x55));
                    this["updater"]["enqueueSetState"](this, rI, rA, "setState");
                }),
                (r9["prototype"]["forceUpdate"] = function (rI) {
                    this["updater"]["enqueueForceUpdate"](this, rI, "forceUpdate");
                }),
                (rr["prototype"] = r9["prototype"]);
            var rR = (rE["prototype"] = new rr());
            (rR["constructor"] = rE), X(rR, r9["prototype"]), (rR["isPureReactComponent"] = !0x0);
            var rT = { current: null },
                rC = Object["prototype"]["hasOwnProperty"],
                rd = { key: !0x0, ref: !0x0, __self: !0x0, __source: !0x0 };
            function rY(rI, rA, rM) {
                var ro,
                    rt = {},
                    rp = null,
                    rk = null;
                if (null != rA) {
                    for (ro in (void 0x0 !== rA["ref"] && (rk = rA["ref"]), void 0x0 !== rA["key"] && (rp = "" + rA["key"]), rA)) rC["call"](rA, ro) && !rd["hasOwnProperty"](ro) && (rt[ro] = rA[ro]);
                }
                var re = arguments["length"] - 0x2;
                if (0x1 === re) rt["children"] = rM;
                else {
                    if (0x1 < re) {
                        for (var rl = Array(re), rU = 0x0; rU < re; rU++) rl[rU] = arguments[rU + 0x2];
                        rt["children"] = rl;
                    }
                }
                if (rI && rI["defaultProps"]) {
                    for (ro in (re = rI["defaultProps"])) void 0x0 === rt[ro] && (rt[ro] = re[ro]);
                }
                return { $$typeof: W, type: rI, key: rp, ref: rk, props: rt, _owner: rT["current"] };
            }
            function rn(rI) {
                return "object" == typeof rI && null !== rI && rI["$$typeof"] === W;
            }
            var rB = /\/+/g,
                rF = [];
            function rb(rI, rA, rM, ro) {
                if (rF["length"]) {
                    var rt = rF["pop"]();
                    return (rt["result"] = rI), (rt["keyPrefix"] = rA), (rt["func"] = rM), (rt["context"] = ro), (rt["count"] = 0x0), rt;
                }
                return { result: rI, keyPrefix: rA, func: rM, context: ro, count: 0x0 };
            }
            function rZ(rI) {
                (rI["result"] = null), (rI["keyPrefix"] = null), (rI["func"] = null), (rI["context"] = null), (rI["count"] = 0x0), 0xa > rF["length"] && rF["push"](rI);
            }
            function rm(rI, rA, rM, ro) {
                var rt = typeof rI;
                ("undefined" !== rt && "boolean" !== rt) || (rI = null);
                var rp = !0x1;
                if (null === rI) rp = !0x0;
                else
                    switch (rt) {
                        case "string":
                        case "number":
                            rp = !0x0;
                            break;
                        case "object":
                            switch (rI["$$typeof"]) {
                                case W:
                                case K:
                                    rp = !0x0;
                            }
                    }
                if (rp) return rM(ro, rI, "" === rA ? "." + ru(rI, 0x0) : rA), 0x1;
                if (((rp = 0x0), (rA = "" === rA ? "." : rA + ":"), Array["isArray"](rI)))
                    for (var rk = 0x0; rk < rI["length"]; rk++) {
                        var re = rA + ru((rt = rI[rk]), rk);
                        rp += rm(rt, re, rM, ro);
                    }
                else {
                    if ((null === rI || "object" != typeof rI ? (re = null) : (re = "function" == typeof (re = (r5 && rI[r5]) || rI["@@iterator"]) ? re : null), "function" == typeof re)) {
                        for (rI = re["call"](rI), rk = 0x0; !(rt = rI["next"]())["done"]; ) rp += rm((rt = rt["value"]), (re = rA + ru(rt, rk++)), rM, ro);
                    } else {
                        if ("object" === rt) throw ((rM = "" + rI), Error(r6(0x1f, "[object\x20Object]" === rM ? "object\x20with\x20keys\x20{" + Object["keys"](rI)["join"](",\x20") + "}" : rM, "")));
                    }
                }
                return rp;
            }
            function rv(rI, rA, rM) {
                return null == rI ? 0x0 : rm(rI, "", rA, rM);
            }
            function ru(rI, rA) {
                return "object" == typeof rI && null !== rI && null != rI["key"]
                    ? (function (rM) {
                          var ro = { "=": "=0", ":": "=2" };
                          return (
                              "$" +
                              ("" + rM)["replace"](/[=:]/g, function (rt) {
                                  return ro[rt];
                              })
                          );
                      })(rI["key"])
                    : rA["toString"](0x24);
            }
            function ry(rI, rA) {
                rI["func"]["call"](rI["context"], rA, rI["count"]++);
            }
            function rD(rI, rA, rM) {
                var ro = rI["result"],
                    rt = rI["keyPrefix"];
                (rI = rI["func"]["call"](rI["context"], rA, rI["count"]++)),
                    Array["isArray"](rI)
                        ? rN(rI, ro, rM, function (rp) {
                              return rp;
                          })
                        : null != rI &&
                          (rn(rI) &&
                              (rI = (function (rp, rk) {
                                  return { $$typeof: W, type: rp["type"], key: rk, ref: rp["ref"], props: rp["props"], _owner: rp["_owner"] };
                              })(rI, rt + (!rI["key"] || (rA && rA["key"] === rI["key"]) ? "" : ("" + rI["key"])["replace"](rB, "$&/") + "/") + rM)),
                          ro["push"](rI));
            }
            function rN(rI, rA, rM, ro, rt) {
                var rp = "";
                null != rM && (rp = ("" + rM)["replace"](rB, "$&/") + "/"), rv(rI, rD, (rA = rb(rA, rp, ro, rt))), rZ(rA);
            }
            var rX = { current: null };
            function rf() {
                var rI = rX["current"];
                if (null === rI) throw Error(r6(0x141));
                return rI;
            }
            var rP = { ReactCurrentDispatcher: rX, ReactCurrentBatchConfig: { suspense: null }, ReactCurrentOwner: rT, IsSomeRendererActing: { current: !0x1 }, assign: X };
            (B["Children"] = {
                map: function (rI, rA, rM) {
                    if (null == rI) return rI;
                    var ro = [];
                    return rN(rI, ro, null, rA, rM), ro;
                },
                forEach: function (rI, rA, rM) {
                    if (null == rI) return rI;
                    rv(rI, ry, (rA = rb(null, null, rA, rM))), rZ(rA);
                },
                count: function (rI) {
                    return rv(
                        rI,
                        function () {
                            return null;
                        },
                        null
                    );
                },
                toArray: function (rI) {
                    var rA = [];
                    return (
                        rN(rI, rA, null, function (rM) {
                            return rM;
                        }),
                        rA
                    );
                },
                only: function (rI) {
                    if (!rn(rI)) throw Error(r6(0x8f));
                    return rI;
                },
            }),
                (B["Component"] = r9),
                (B["Fragment"] = V),
                (B["Profiler"] = Q),
                (B["PureComponent"] = rE),
                (B["StrictMode"] = J),
                (B["Suspense"] = r2),
                (B["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"] = rP),
                (B["cloneElement"] = function (rI, rA, rM) {
                    if (null == rI) throw Error(r6(0x10b, rI));
                    var ro = X({}, rI["props"]),
                        rt = rI["key"],
                        rp = rI["ref"],
                        rk = rI["_owner"];
                    if (null != rA) {
                        if ((void 0x0 !== rA["ref"] && ((rp = rA["ref"]), (rk = rT["current"])), void 0x0 !== rA["key"] && (rt = "" + rA["key"]), rI["type"] && rI["type"]["defaultProps"])) var re = rI["type"]["defaultProps"];
                        for (rl in rA) rC["call"](rA, rl) && !rd["hasOwnProperty"](rl) && (ro[rl] = void 0x0 === rA[rl] && void 0x0 !== re ? re[rl] : rA[rl]);
                    }
                    var rl = arguments["length"] - 0x2;
                    if (0x1 === rl) ro["children"] = rM;
                    else {
                        if (0x1 < rl) {
                            re = Array(rl);
                            for (var rU = 0x0; rU < rl; rU++) re[rU] = arguments[rU + 0x2];
                            ro["children"] = re;
                        }
                    }
                    return { $$typeof: W, type: rI["type"], key: rt, ref: rp, props: ro, _owner: rk };
                }),
                (B["createContext"] = function (rI, rA) {
                    return (
                        void 0x0 === rA && (rA = null),
                        ((rI = { $$typeof: r0, _calculateChangedBits: rA, _currentValue: rI, _currentValue2: rI, _threadCount: 0x0, Provider: null, Consumer: null })["Provider"] = { $$typeof: z, _context: rI }),
                        (rI["Consumer"] = rI)
                    );
                }),
                (B["createElement"] = rY),
                (B["createFactory"] = function (rI) {
                    var rA = rY["bind"](null, rI);
                    return (rA["type"] = rI), rA;
                }),
                (B["createRef"] = function () {
                    return { current: null };
                }),
                (B["forwardRef"] = function (rI) {
                    return { $$typeof: r1, render: rI };
                }),
                (B["isValidElement"] = rn),
                (B["lazy"] = function (rI) {
                    return { $$typeof: r4, _ctor: rI, _status: -0x1, _result: null };
                }),
                (B["memo"] = function (rI, rA) {
                    return { $$typeof: r3, type: rI, compare: void 0x0 === rA ? null : rA };
                }),
                (B["useCallback"] = function (rI, rA) {
                    return rf()["useCallback"](rI, rA);
                }),
                (B["useContext"] = function (rI, rA) {
                    return rf()["useContext"](rI, rA);
                }),
                (B["useDebugValue"] = function () {}),
                (B["useEffect"] = function (rI, rA) {
                    return rf()["useEffect"](rI, rA);
                }),
                (B["useImperativeHandle"] = function (rI, rA, rM) {
                    return rf()["useImperativeHandle"](rI, rA, rM);
                }),
                (B["useLayoutEffect"] = function (rI, rA) {
                    return rf()["useLayoutEffect"](rI, rA);
                }),
                (B["useMemo"] = function (rI, rA) {
                    return rf()["useMemo"](rI, rA);
                }),
                (B["useReducer"] = function (rI, rA, rM) {
                    return rf()["useReducer"](rI, rA, rM);
                }),
                (B["useRef"] = function (rI) {
                    return rf()["useRef"](rI);
                }),
                (B["useState"] = function (rI) {
                    return rf()["useState"](rI);
                }),
                (B["version"] = "16.14.0");
        },
        0x106de: function (r, E, R) {
            "use strict";
            r["exports"] = R(0x11ad8);
        },
        0x15a24: function (Y, B, F) {
            "use strict";
            F["d"](B, {
                yv: function () {
                    return rR;
                },
                OJ: function () {
                    return r3;
                },
                p5: function () {
                    return rE;
                },
            });
            var Z = "persist:",
                D = "persist/FLUSH",
                N = "persist/REHYDRATE",
                X = "persist/PAUSE",
                I = "persist/PERSIST",
                k = "persist/PURGE",
                U = "persist/REGISTER";
            function q(rT) {
                return (
                    (q =
                        "function" == typeof Symbol && "symbol" == typeof Symbol["iterator"]
                            ? function (rC) {
                                  return typeof rC;
                              }
                            : function (rC) {
                                  return rC && "function" == typeof Symbol && rC["constructor"] === Symbol && rC !== Symbol["prototype"] ? "symbol" : typeof rC;
                              }),
                    q(rT)
                );
            }
            function j(rT, rC) {
                var rd = Object["keys"](rT);
                if (Object["getOwnPropertySymbols"]) {
                    var rY = Object["getOwnPropertySymbols"](rT);
                    rC &&
                        (rY = rY["filter"](function (rn) {
                            return Object["getOwnPropertyDescriptor"](rT, rn)["enumerable"];
                        })),
                        rd["push"]["apply"](rd, rY);
                }
                return rd;
            }
            function W(rT, rC, rd) {
                return rC in rT ? Object["defineProperty"](rT, rC, { value: rd, enumerable: !0x0, configurable: !0x0, writable: !0x0 }) : (rT[rC] = rd), rT;
            }
            function H(rT, rC, rd, rY) {
                rY["debug"];
                var rn = (function (rB) {
                    for (var rF = 0x1; rF < arguments["length"]; rF++) {
                        var rb = null != arguments[rF] ? arguments[rF] : {};
                        rF % 0x2
                            ? j(rb, !0x0)["forEach"](function (rZ) {
                                  W(rB, rZ, rb[rZ]);
                              })
                            : Object["getOwnPropertyDescriptors"]
                            ? Object["defineProperties"](rB, Object["getOwnPropertyDescriptors"](rb))
                            : j(rb)["forEach"](function (rZ) {
                                  Object["defineProperty"](rB, rZ, Object["getOwnPropertyDescriptor"](rb, rZ));
                              });
                    }
                    return rB;
                })({}, rd);
                return (
                    rT &&
                        "object" === q(rT) &&
                        Object["keys"](rT)["forEach"](function (rB) {
                            "_persist" !== rB && rC[rB] === rd[rB] && (rn[rB] = rT[rB]);
                        }),
                    rn
                );
            }
            function K(rT) {
                var rC,
                    rd = rT["blacklist"] || null,
                    rY = rT["whitelist"] || null,
                    rn = rT["transforms"] || [],
                    rB = rT["throttle"] || 0x0,
                    rF = ""["concat"](void 0x0 !== rT["keyPrefix"] ? rT["keyPrefix"] : Z)["concat"](rT["key"]),
                    rb = rT["storage"];
                rC =
                    !0x1 === rT["serialize"]
                        ? function (rP) {
                              return rP;
                          }
                        : "function" == typeof rT["serialize"]
                        ? rT["serialize"]
                        : V;
                var rZ = rT["writeFailHandler"] || null,
                    rm = {},
                    rv = {},
                    ru = [],
                    ry = null,
                    rD = null;
                function rN() {
                    if (0x0 === ru["length"]) return ry && clearInterval(ry), void (ry = null);
                    var rP = ru["shift"](),
                        rI = rn["reduce"](function (rA, rM) {
                            return rM["in"](rA, rP, rm);
                        }, rm[rP]);
                    if (void 0x0 !== rI)
                        try {
                            rv[rP] = rC(rI);
                        } catch (rA) {
                            console["error"]("redux-persist/createPersistoid:\x20error\x20serializing\x20state", rA);
                        }
                    else delete rv[rP];
                    0x0 === ru["length"] &&
                        (Object["keys"](rv)["forEach"](function (rM) {
                            void 0x0 === rm[rM] && delete rv[rM];
                        }),
                        (rD = rb["setItem"](rF, rC(rv))["catch"](rf)));
                }
                function rX(rP) {
                    return (!rY || -0x1 !== rY["indexOf"](rP) || "_persist" === rP) && (!rd || -0x1 === rd["indexOf"](rP));
                }
                function rf(rP) {
                    rZ && rZ(rP);
                }
                return {
                    update: function (rP) {
                        Object["keys"](rP)["forEach"](function (rI) {
                            rX(rI) && rm[rI] !== rP[rI] && -0x1 === ru["indexOf"](rI) && ru["push"](rI);
                        }),
                            Object["keys"](rm)["forEach"](function (rI) {
                                void 0x0 === rP[rI] && rX(rI) && -0x1 === ru["indexOf"](rI) && void 0x0 !== rm[rI] && ru["push"](rI);
                            }),
                            null === ry && (ry = setInterval(rN, rB)),
                            (rm = rP);
                    },
                    flush: function () {
                        for (; 0x0 !== ru["length"]; ) rN();
                        return rD || Promise["resolve"]();
                    },
                };
            }
            function V(rT) {
                return JSON["stringify"](rT);
            }
            function J(rT) {
                var rC,
                    rd = rT["transforms"] || [],
                    rY = ""["concat"](void 0x0 !== rT["keyPrefix"] ? rT["keyPrefix"] : Z)["concat"](rT["key"]),
                    rn = rT["storage"];
                return (
                    rT["debug"],
                    ((rC =
                        !0x1 === rT["deserialize"]
                            ? function (rB) {
                                  return rB;
                              }
                            : "function" == typeof rT["deserialize"]
                            ? rT["deserialize"]
                            : G),
                    rn["getItem"](rY)["then"](function (rB) {
                        if (rB)
                            try {
                                var rF = {},
                                    rb = rC(rB);
                                return (
                                    Object["keys"](rb)["forEach"](function (rZ) {
                                        rF[rZ] = rd["reduceRight"](function (rm, rv) {
                                            return rv["out"](rm, rZ, rb);
                                        }, rC(rb[rZ]));
                                    }),
                                    rF
                                );
                            } catch (rZ) {
                                throw rZ;
                            }
                    }))
                );
            }
            function G(rT) {
                return JSON["parse"](rT);
            }
            function Q(rT) {
                0x0;
            }
            function z(rT, rC) {
                var rd = Object["keys"](rT);
                if (Object["getOwnPropertySymbols"]) {
                    var rY = Object["getOwnPropertySymbols"](rT);
                    rC &&
                        (rY = rY["filter"](function (rn) {
                            return Object["getOwnPropertyDescriptor"](rT, rn)["enumerable"];
                        })),
                        rd["push"]["apply"](rd, rY);
                }
                return rd;
            }
            function r0(rT) {
                for (var rC = 0x1; rC < arguments["length"]; rC++) {
                    var rd = null != arguments[rC] ? arguments[rC] : {};
                    rC % 0x2
                        ? z(rd, !0x0)["forEach"](function (rY) {
                              r1(rT, rY, rd[rY]);
                          })
                        : Object["getOwnPropertyDescriptors"]
                        ? Object["defineProperties"](rT, Object["getOwnPropertyDescriptors"](rd))
                        : z(rd)["forEach"](function (rY) {
                              Object["defineProperty"](rT, rY, Object["getOwnPropertyDescriptor"](rd, rY));
                          });
                }
                return rT;
            }
            function r1(rT, rC, rd) {
                return rC in rT ? Object["defineProperty"](rT, rC, { value: rd, enumerable: !0x0, configurable: !0x0, writable: !0x0 }) : (rT[rC] = rd), rT;
            }
            function r2(rT, rC) {
                if (null == rT) return {};
                var rd,
                    rY,
                    rn = (function (rF, rb) {
                        if (null == rF) return {};
                        var rZ,
                            rm,
                            rv = {},
                            ru = Object["keys"](rF);
                        for (rm = 0x0; rm < ru["length"]; rm++) (rZ = ru[rm]), rb["indexOf"](rZ) >= 0x0 || (rv[rZ] = rF[rZ]);
                        return rv;
                    })(rT, rC);
                if (Object["getOwnPropertySymbols"]) {
                    var rB = Object["getOwnPropertySymbols"](rT);
                    for (rY = 0x0; rY < rB["length"]; rY++) (rd = rB[rY]), rC["indexOf"](rd) >= 0x0 || (Object["prototype"]["propertyIsEnumerable"]["call"](rT, rd) && (rn[rd] = rT[rd]));
                }
                return rn;
            }
            function r3(rT, rC) {
                var rd = void 0x0 !== rT["version"] ? rT["version"] : -0x1,
                    rY = (rT["debug"], void 0x0 === rT["stateReconciler"] ? H : rT["stateReconciler"]),
                    rn = rT["getStoredState"] || J,
                    rB = void 0x0 !== rT["timeout"] ? rT["timeout"] : 0x1388,
                    rF = null,
                    rb = !0x1,
                    rZ = !0x0,
                    rm = function (rv) {
                        return rv["_persist"]["rehydrated"] && rF && !rZ && rF["update"](rv), rv;
                    };
                return function (rv, ru) {
                    var ry = rv || {},
                        rD = ry["_persist"],
                        rN = r2(ry, ["_persist"]);
                    if (ru["type"] === I) {
                        var rX = !0x1,
                            rf = function (ro, rt) {
                                rX || (ru["rehydrate"](rT["key"], ro, rt), (rX = !0x0));
                            };
                        if (
                            (rB &&
                                setTimeout(function () {
                                    !rX && rf(void 0x0, new Error("redux-persist:\x20persist\x20timed\x20out\x20for\x20persist\x20key\x20\x22"["concat"](rT["key"], "\x22")));
                                }, rB),
                            (rZ = !0x1),
                            rF || (rF = K(rT)),
                            rD)
                        )
                            return r0({}, rC(rN, ru), { _persist: rD });
                        if ("function" != typeof ru["rehydrate"] || "function" != typeof ru["register"])
                            throw new Error(
                                "redux-persist:\x20either\x20rehydrate\x20or\x20register\x20is\x20not\x20a\x20function\x20on\x20the\x20PERSIST\x20action.\x20This\x20can\x20happen\x20if\x20the\x20action\x20is\x20being\x20replayed.\x20This\x20is\x20an\x20unexplored\x20use\x20case,\x20please\x20open\x20an\x20issue\x20and\x20we\x20will\x20figure\x20out\x20a\x20resolution."
                            );
                        return (
                            ru["register"](rT["key"]),
                            rn(rT)["then"](
                                function (ro) {
                                    (
                                        rT["migrate"] ||
                                        function (rt, rp) {
                                            return Promise["resolve"](rt);
                                        }
                                    )(ro, rd)["then"](
                                        function (rt) {
                                            rf(rt);
                                        },
                                        function (rt) {
                                            rf(void 0x0, rt);
                                        }
                                    );
                                },
                                function (ro) {
                                    rf(void 0x0, ro);
                                }
                            ),
                            r0({}, rC(rN, ru), { _persist: { version: rd, rehydrated: !0x1 } })
                        );
                    }
                    if (ru["type"] === k)
                        return (
                            (rb = !0x0),
                            ru["result"](
                                (function (ro) {
                                    var rt = ro["storage"],
                                        rp = ""["concat"](void 0x0 !== ro["keyPrefix"] ? ro["keyPrefix"] : Z)["concat"](ro["key"]);
                                    return rt["removeItem"](rp, Q);
                                })(rT)
                            ),
                            r0({}, rC(rN, ru), { _persist: rD })
                        );
                    if (ru["type"] === D) return ru["result"](rF && rF["flush"]()), r0({}, rC(rN, ru), { _persist: rD });
                    if (ru["type"] === X) rZ = !0x0;
                    else {
                        if (ru["type"] === N) {
                            if (rb) return r0({}, rN, { _persist: r0({}, rD, { rehydrated: !0x0 }) });
                            if (ru["key"] === rT["key"]) {
                                var rP = rC(rN, ru),
                                    rI = ru["payload"],
                                    rA = r0({}, !0x1 !== rY && void 0x0 !== rI ? rY(rI, rv, rP, rT) : rP, { _persist: r0({}, rD, { rehydrated: !0x0 }) });
                                return rm(rA);
                            }
                        }
                    }
                    if (!rD) return rC(rv, ru);
                    var rM = rC(rN, ru);
                    return rM === rN ? rv : rm(r0({}, rM, { _persist: rD }));
                };
            }
            var r4 = F(0x3df1);
            function r5(rT) {
                return (
                    (function (rC) {
                        if (Array["isArray"](rC)) {
                            for (var rd = 0x0, rY = new Array(rC["length"]); rd < rC["length"]; rd++) rY[rd] = rC[rd];
                            return rY;
                        }
                    })(rT) ||
                    (function (rC) {
                        if (Symbol["iterator"] in Object(rC) || "[object\x20Arguments]" === Object["prototype"]["toString"]["call"](rC)) return Array["from"](rC);
                    })(rT) ||
                    (function () {
                        throw new TypeError("Invalid\x20attempt\x20to\x20spread\x20non-iterable\x20instance");
                    })()
                );
            }
            function r6(rT, rC) {
                var rd = Object["keys"](rT);
                if (Object["getOwnPropertySymbols"]) {
                    var rY = Object["getOwnPropertySymbols"](rT);
                    rC &&
                        (rY = rY["filter"](function (rn) {
                            return Object["getOwnPropertyDescriptor"](rT, rn)["enumerable"];
                        })),
                        rd["push"]["apply"](rd, rY);
                }
                return rd;
            }
            function r7(rT) {
                for (var rC = 0x1; rC < arguments["length"]; rC++) {
                    var rd = null != arguments[rC] ? arguments[rC] : {};
                    rC % 0x2
                        ? r6(rd, !0x0)["forEach"](function (rY) {
                              r8(rT, rY, rd[rY]);
                          })
                        : Object["getOwnPropertyDescriptors"]
                        ? Object["defineProperties"](rT, Object["getOwnPropertyDescriptors"](rd))
                        : r6(rd)["forEach"](function (rY) {
                              Object["defineProperty"](rT, rY, Object["getOwnPropertyDescriptor"](rd, rY));
                          });
                }
                return rT;
            }
            function r8(rT, rC, rd) {
                return rC in rT ? Object["defineProperty"](rT, rC, { value: rd, enumerable: !0x0, configurable: !0x0, writable: !0x0 }) : (rT[rC] = rd), rT;
            }
            var r9 = { registry: [], bootstrapped: !0x1 },
                rr = function () {
                    var rT = arguments["length"] > 0x0 && void 0x0 !== arguments[0x0] ? arguments[0x0] : r9,
                        rC = arguments["length"] > 0x1 ? arguments[0x1] : void 0x0;
                    switch (rC["type"]) {
                        case U:
                            return r7({}, rT, { registry: []["concat"](r5(rT["registry"]), [rC["key"]]) });
                        case N:
                            var rd = rT["registry"]["indexOf"](rC["key"]),
                                rY = r5(rT["registry"]);
                            return rY["splice"](rd, 0x1), r7({}, rT, { registry: rY, bootstrapped: 0x0 === rY["length"] });
                        default:
                            return rT;
                    }
                };
            function rE(rT, rC, rd) {
                var rY = rd || !0x1,
                    rn = (0x0, r4["MT"])(rr, r9, rC && rC["enhancer"] ? rC["enhancer"] : void 0x0),
                    rB = function (rZ) {
                        rn["dispatch"]({ type: U, key: rZ });
                    },
                    rF = function (rZ, rm, rv) {
                        var ru = { type: N, payload: rm, err: rv, key: rZ };
                        rT["dispatch"](ru), rn["dispatch"](ru), rY && rb["getState"]()["bootstrapped"] && (rY(), (rY = !0x1));
                    },
                    rb = r7({}, rn, {
                        purge: function () {
                            var rZ = [];
                            return (
                                rT["dispatch"]({
                                    type: k,
                                    result: function (rm) {
                                        rZ["push"](rm);
                                    },
                                }),
                                Promise["all"](rZ)
                            );
                        },
                        flush: function () {
                            var rZ = [];
                            return (
                                rT["dispatch"]({
                                    type: D,
                                    result: function (rm) {
                                        rZ["push"](rm);
                                    },
                                }),
                                Promise["all"](rZ)
                            );
                        },
                        pause: function () {
                            rT["dispatch"]({ type: X });
                        },
                        persist: function () {
                            rT["dispatch"]({ type: I, register: rB, rehydrate: rF });
                        },
                    });
                return (rC && rC["manualPersist"]) || rb["persist"](), rb;
            }
            function rR(rT, rC) {
                return (
                    (rC || {})["debug"],
                    function (rd, rY) {
                        if (!rd) return Promise["resolve"](void 0x0);
                        var rn = rd["_persist"] && void 0x0 !== rd["_persist"]["version"] ? rd["_persist"]["version"] : -0x1;
                        if (rn === rY) return Promise["resolve"](rd);
                        if (rn > rY) return Promise["resolve"](rd);
                        var rB = Object["keys"](rT)
                            ["map"](function (rb) {
                                return parseInt(rb);
                            })
                            ["filter"](function (rb) {
                                return rY >= rb && rb > rn;
                            })
                            ["sort"](function (rb, rZ) {
                                return rb - rZ;
                            });
                        try {
                            var rF = rB["reduce"](function (rb, rZ) {
                                return rT[rZ](rb);
                            }, rd);
                            return Promise["resolve"](rF);
                        } catch (rb) {
                            return Promise["reject"](rb);
                        }
                    }
                );
            }
        },
        0x5bc0: function (E, R, T) {
            "use strict";
            (R["__esModule"] = !0x0),
                (R["default"] = function (Y) {
                    var B = (0x0, d["default"])(Y);
                    return {
                        getItem: function (F) {
                            return new Promise(function (b, Z) {
                                b(B["getItem"](F));
                            });
                        },
                        setItem: function (F, b) {
                            return new Promise(function (Z, m) {
                                Z(B["setItem"](F, b));
                            });
                        },
                        removeItem: function (F) {
                            return new Promise(function (b, Z) {
                                b(B["removeItem"](F));
                            });
                        },
                    };
                });
            var C,
                d = (C = T(0x12dea)) && C["__esModule"] ? C : { default: C };
        },
        0x12dea: function (E, R) {
            "use strict";
            function T(Y) {
                return (
                    (T =
                        "function" == typeof Symbol && "symbol" == typeof Symbol["iterator"]
                            ? function (B) {
                                  return typeof B;
                              }
                            : function (B) {
                                  return B && "function" == typeof Symbol && B["constructor"] === Symbol && B !== Symbol["prototype"] ? "symbol" : typeof B;
                              }),
                    T(Y)
                );
            }
            function C() {}
            (R["__esModule"] = !0x0),
                (R["default"] = function (Y) {
                    var B = ""["concat"](Y, "Storage");
                    return (function (F) {
                        if ("object" !== ("undefined" == typeof self ? "undefined" : T(self)) || !(F in self)) return !0x1;
                        try {
                            var b = self[F],
                                Z = "redux-persist\x20"["concat"](F, "\x20test");
                            b["setItem"](Z, "test"), b["getItem"](Z), b["removeItem"](Z);
                        } catch (m) {
                            return !0x1;
                        }
                        return !0x0;
                    })(B)
                        ? self[B]
                        : d;
                });
            var d = { getItem: C, setItem: C, removeItem: C };
        },
        0x12bbe: function (E, R, T) {
            "use strict";
            var C;
            R["Z"] = void 0x0;
            var d = (0x0, ((C = T(0x5bc0)) && C["__esModule"] ? C : { default: C })["default"])("local");
            R["Z"] = d;
        },
        0x3df1: function (E, R, T) {
            "use strict";
            function C(I, A, M) {
                return A in I ? Object["defineProperty"](I, A, { value: M, enumerable: !0x0, configurable: !0x0, writable: !0x0 }) : (I[A] = M), I;
            }
            function Y(I, A) {
                var M = Object["keys"](I);
                if (Object["getOwnPropertySymbols"]) {
                    var p = Object["getOwnPropertySymbols"](I);
                    A &&
                        (p = p["filter"](function (k) {
                            return Object["getOwnPropertyDescriptor"](I, k)["enumerable"];
                        })),
                        M["push"]["apply"](M, p);
                }
                return M;
            }
            function B(I) {
                for (var A = 0x1; A < arguments["length"]; A++) {
                    var M = null != arguments[A] ? arguments[A] : {};
                    A % 0x2
                        ? Y(Object(M), !0x0)["forEach"](function (p) {
                              C(I, p, M[p]);
                          })
                        : Object["getOwnPropertyDescriptors"]
                        ? Object["defineProperties"](I, Object["getOwnPropertyDescriptors"](M))
                        : Y(Object(M))["forEach"](function (p) {
                              Object["defineProperty"](I, p, Object["getOwnPropertyDescriptor"](M, p));
                          });
                }
                return I;
            }
            function F(I) {
                return (
                    "Minified\x20Redux\x20error\x20#" + I + ";\x20visit\x20https://redux.js.org/Errors?code=" + I + "\x20for\x20the\x20full\x20message\x20or\x20use\x20the\x20non-minified\x20dev\x20environment\x20for\x20full\x20errors.\x20"
                );
            }
            T["d"](R, {
                md: function () {
                    return P;
                },
                UY: function () {
                    return N;
                },
                qC: function () {
                    return X;
                },
                MT: function () {
                    return D;
                },
            });
            var b = ("function" == typeof Symbol && Symbol["observable"]) || "@@observable",
                Z = function () {
                    return Math["random"]()["toString"](0x24)["substring"](0x7)["split"]("")["join"](".");
                },
                m = {
                    INIT: "@@redux/INIT" + Z(),
                    REPLACE: "@@redux/REPLACE" + Z(),
                    PROBE_UNKNOWN_ACTION: function () {
                        return "@@redux/PROBE_UNKNOWN_ACTION" + Z();
                    },
                };
            function y(I) {
                if ("object" != typeof I || null === I) return !0x1;
                for (var A = I; null !== Object["getPrototypeOf"](A); ) A = Object["getPrototypeOf"](A);
                return Object["getPrototypeOf"](I) === A;
            }
            function D(I, A, M) {
                var k;
                if (("function" == typeof A && "function" == typeof M) || ("function" == typeof M && "function" == typeof arguments[0x3])) throw new Error(F(0x0));
                if (("function" == typeof A && void 0x0 === M && ((M = A), (A = void 0x0)), void 0x0 !== M)) {
                    if ("function" != typeof M) throw new Error(F(0x1));
                    return M(D)(I, A);
                }
                if ("function" != typeof I) throw new Error(F(0x2));
                var U = I,
                    q = A,
                    O = [],
                    j = O,
                    S = !0x1;
                function W() {
                    j === O && (j = O["slice"]());
                }
                function H() {
                    if (S) throw new Error(F(0x3));
                    return q;
                }
                function x(G) {
                    if ("function" != typeof G) throw new Error(F(0x4));
                    if (S) throw new Error(F(0x5));
                    var L = !0x0;
                    return (
                        W(),
                        j["push"](G),
                        function () {
                            if (L) {
                                if (S) throw new Error(F(0x6));
                                (L = !0x1), W();
                                var Q = j["indexOf"](G);
                                j["splice"](Q, 0x1), (O = null);
                            }
                        }
                    );
                }
                function K(G) {
                    if (!y(G)) throw new Error(F(0x7));
                    if (void 0x0 === G["type"]) throw new Error(F(0x8));
                    if (S) throw new Error(F(0x9));
                    try {
                        (S = !0x0), (q = U(q, G));
                    } finally {
                        S = !0x1;
                    }
                    for (var L = (O = j), Q = 0x0; Q < L["length"]; Q++) {
                        (0x0, L[Q])();
                    }
                    return G;
                }
                function V(G) {
                    if ("function" != typeof G) throw new Error(F(0xa));
                    (U = G), K({ type: m["REPLACE"] });
                }
                function J() {
                    var G,
                        L = x;
                    return (
                        ((G = {
                            subscribe: function (Q) {
                                if ("object" != typeof Q || null === Q) throw new Error(F(0xb));
                                function z() {
                                    Q["next"] && Q["next"](H());
                                }
                                return z(), { unsubscribe: L(z) };
                            },
                        })[b] = function () {
                            return this;
                        }),
                        G
                    );
                }
                return K({ type: m["INIT"] }), ((k = { dispatch: K, subscribe: x, getState: H, replaceReducer: V })[b] = J), k;
            }
            function N(I) {
                for (var A = Object["keys"](I), M = {}, p = 0x0; p < A["length"]; p++) {
                    var k = A[p];
                    0x0, "function" == typeof I[k] && (M[k] = I[k]);
                }
                var U,
                    q = Object["keys"](M);
                try {
                    !(function (w) {
                        Object["keys"](w)["forEach"](function (O) {
                            var j = w[O];
                            if (void 0x0 === j(void 0x0, { type: m["INIT"] })) throw new Error(F(0xc));
                            if (void 0x0 === j(void 0x0, { type: m["PROBE_UNKNOWN_ACTION"]() })) throw new Error(F(0xd));
                        });
                    })(M);
                } catch (w) {
                    U = w;
                }
                return function (O, j) {
                    if ((void 0x0 === O && (O = {}), U)) throw U;
                    for (var S = !0x1, g = {}, W = 0x0; W < q["length"]; W++) {
                        var H = q[W],
                            x = M[H],
                            K = O[H],
                            V = x(K, j);
                        if (void 0x0 === V) {
                            j && j["type"];
                            throw new Error(F(0xe));
                        }
                        (g[H] = V), (S = S || V !== K);
                    }
                    return (S = S || q["length"] !== Object["keys"](O)["length"]) ? g : O;
                };
            }
            function X() {
                for (var I = arguments["length"], A = new Array(I), M = 0x0; M < I; M++) A[M] = arguments[M];
                return 0x0 === A["length"]
                    ? function (p) {
                          return p;
                      }
                    : 0x1 === A["length"]
                    ? A[0x0]
                    : A["reduce"](function (p, k) {
                          return function () {
                              return p(k["apply"](void 0x0, arguments));
                          };
                      });
            }
            function P() {
                for (var I = arguments["length"], A = new Array(I), M = 0x0; M < I; M++) A[M] = arguments[M];
                return function (p) {
                    return function () {
                        var k = p["apply"](void 0x0, arguments),
                            U = function () {
                                throw new Error(F(0xf));
                            },
                            q = {
                                getState: k["getState"],
                                dispatch: function () {
                                    return U["apply"](void 0x0, arguments);
                                },
                            },
                            w = A["map"](function (O) {
                                return O(q);
                            });
                        return (U = X["apply"](void 0x0, w)(k["dispatch"])), B(B({}, k), {}, { dispatch: U });
                    };
                };
            }
        },
        0x8b52: function (r) {
            var E = (function (C) {
                "use strict";
                var Y,
                    B = Object["prototype"],
                    F = B["hasOwnProperty"],
                    Z = "function" == typeof Symbol ? Symbol : {},
                    D = Z["iterator"] || "@@iterator",
                    N = Z["asyncIterator"] || "@@asyncIterator",
                    X = Z["toStringTag"] || "@@toStringTag";
                function P(r9, rr, rE) {
                    return Object["defineProperty"](r9, rr, { value: rE, enumerable: !0x0, configurable: !0x0, writable: !0x0 }), r9[rr];
                }
                try {
                    P({}, "");
                } catch (r9) {
                    P = function (rr, rE, rR) {
                        return (rr[rE] = rR);
                    };
                }
                function I(rr, rE, rR, rT) {
                    var rC = rE && rE["prototype"] instanceof K ? rE : K,
                        rd = Object["create"](rC["prototype"]),
                        rY = new r6(rT || []);
                    return (
                        (rd["_invoke"] = (function (rn, rB, rF) {
                            var rb = U;
                            return function (rZ, rm) {
                                if (rb === j) throw new Error("Generator\x20is\x20already\x20running");
                                if (rb === W) {
                                    if ("throw" === rZ) throw rm;
                                    return r8();
                                }
                                for (rF["method"] = rZ, rF["arg"] = rm; ; ) {
                                    var rv = rF["delegate"];
                                    if (rv) {
                                        var ru = r3(rv, rF);
                                        if (ru) {
                                            if (ru === H) continue;
                                            return ru;
                                        }
                                    }
                                    if ("next" === rF["method"]) rF["sent"] = rF["_sent"] = rF["arg"];
                                    else {
                                        if ("throw" === rF["method"]) {
                                            if (rb === U) throw ((rb = W), rF["arg"]);
                                            rF["dispatchException"](rF["arg"]);
                                        } else "return" === rF["method"] && rF["abrupt"]("return", rF["arg"]);
                                    }
                                    rb = j;
                                    var ry = k(rn, rB, rF);
                                    if ("normal" === ry["type"]) {
                                        if (((rb = rF["done"] ? W : q), ry["arg"] === H)) continue;
                                        return { value: ry["arg"], done: rF["done"] };
                                    }
                                    "throw" === ry["type"] && ((rb = W), (rF["method"] = "throw"), (rF["arg"] = ry["arg"]));
                                }
                            };
                        })(rr, rR, rY)),
                        rd
                    );
                }
                function k(rr, rE, rR) {
                    try {
                        return { type: "normal", arg: rr["call"](rE, rR) };
                    } catch (rT) {
                        return { type: "throw", arg: rT };
                    }
                }
                C["wrap"] = I;
                var U = "suspendedStart",
                    q = "suspendedYield",
                    j = "executing",
                    W = "completed",
                    H = {};
                function K() {}
                function V() {}
                function J() {}
                var G = {};
                P(G, D, function () {
                    return this;
                });
                var Q = Object["getPrototypeOf"],
                    z = Q && Q(Q(r7([])));
                z && z !== B && F["call"](z, D) && (G = z);
                var r0 = (J["prototype"] = K["prototype"] = Object["create"](G));
                function r1(rr) {
                    ["next", "throw", "return"]["forEach"](function (rE) {
                        P(rr, rE, function (rR) {
                            return this["_invoke"](rE, rR);
                        });
                    });
                }
                function r2(rr, rE) {
                    function rR(rC, rd, rY, rn) {
                        var rB = k(rr[rC], rr, rd);
                        if ("throw" !== rB["type"]) {
                            var rF = rB["arg"],
                                rb = rF["value"];
                            return rb && "object" == typeof rb && F["call"](rb, "__await")
                                ? rE["resolve"](rb["__await"])["then"](
                                      function (rZ) {
                                          rR("next", rZ, rY, rn);
                                      },
                                      function (rZ) {
                                          rR("throw", rZ, rY, rn);
                                      }
                                  )
                                : rE["resolve"](rb)["then"](
                                      function (rZ) {
                                          (rF["value"] = rZ), rY(rF);
                                      },
                                      function (rZ) {
                                          return rR("throw", rZ, rY, rn);
                                      }
                                  );
                        }
                        rn(rB["arg"]);
                    }
                    var rT;
                    this["_invoke"] = function (rC, rd) {
                        function rY() {
                            return new rE(function (rn, rB) {
                                rR(rC, rd, rn, rB);
                            });
                        }
                        return (rT = rT ? rT["then"](rY, rY) : rY());
                    };
                }
                function r3(rr, rE) {
                    var rR = rr["iterator"][rE["method"]];
                    if (rR === Y) {
                        if (((rE["delegate"] = null), "throw" === rE["method"])) {
                            if (rr["iterator"]["return"] && ((rE["method"] = "return"), (rE["arg"] = Y), r3(rr, rE), "throw" === rE["method"])) return H;
                            (rE["method"] = "throw"), (rE["arg"] = new TypeError("The\x20iterator\x20does\x20not\x20provide\x20a\x20\x27throw\x27\x20method"));
                        }
                        return H;
                    }
                    var rT = k(rR, rr["iterator"], rE["arg"]);
                    if ("throw" === rT["type"]) return (rE["method"] = "throw"), (rE["arg"] = rT["arg"]), (rE["delegate"] = null), H;
                    var rC = rT["arg"];
                    return rC
                        ? rC["done"]
                            ? ((rE[rr["resultName"]] = rC["value"]), (rE["next"] = rr["nextLoc"]), "return" !== rE["method"] && ((rE["method"] = "next"), (rE["arg"] = Y)), (rE["delegate"] = null), H)
                            : rC
                        : ((rE["method"] = "throw"), (rE["arg"] = new TypeError("iterator\x20result\x20is\x20not\x20an\x20object")), (rE["delegate"] = null), H);
                }
                function r4(rr) {
                    var rE = { tryLoc: rr[0x0] };
                    0x1 in rr && (rE["catchLoc"] = rr[0x1]), 0x2 in rr && ((rE["finallyLoc"] = rr[0x2]), (rE["afterLoc"] = rr[0x3])), this["tryEntries"]["push"](rE);
                }
                function r5(rr) {
                    var rE = rr["completion"] || {};
                    (rE["type"] = "normal"), delete rE["arg"], (rr["completion"] = rE);
                }
                function r6(rr) {
                    (this["tryEntries"] = [{ tryLoc: "root" }]), rr["forEach"](r4, this), this["reset"](!0x0);
                }
                function r7(rr) {
                    if (rr) {
                        var rE = rr[D];
                        if (rE) return rE["call"](rr);
                        if ("function" == typeof rr["next"]) return rr;
                        if (!isNaN(rr["length"])) {
                            var rR = -0x1,
                                rT = function rC() {
                                    for (; ++rR < rr["length"]; ) if (F["call"](rr, rR)) return (rC["value"] = rr[rR]), (rC["done"] = !0x1), rC;
                                    return (rC["value"] = Y), (rC["done"] = !0x0), rC;
                                };
                            return (rT["next"] = rT);
                        }
                    }
                    return { next: r8 };
                }
                function r8() {
                    return { value: Y, done: !0x0 };
                }
                return (
                    (V["prototype"] = J),
                    P(r0, "constructor", J),
                    P(J, "constructor", V),
                    (V["displayName"] = P(J, X, "GeneratorFunction")),
                    (C["isGeneratorFunction"] = function (rr) {
                        var rE = "function" == typeof rr && rr["constructor"];
                        return !!rE && (rE === V || "GeneratorFunction" === (rE["displayName"] || rE["name"]));
                    }),
                    (C["mark"] = function (rr) {
                        return Object["setPrototypeOf"] ? Object["setPrototypeOf"](rr, J) : ((rr["__proto__"] = J), P(rr, X, "GeneratorFunction")), (rr["prototype"] = Object["create"](r0)), rr;
                    }),
                    (C["awrap"] = function (rr) {
                        return { __await: rr };
                    }),
                    r1(r2["prototype"]),
                    P(r2["prototype"], N, function () {
                        return this;
                    }),
                    (C["AsyncIterator"] = r2),
                    (C["async"] = function (rr, rE, rR, rT, rC) {
                        void 0x0 === rC && (rC = Promise);
                        var rd = new r2(I(rr, rE, rR, rT), rC);
                        return C["isGeneratorFunction"](rE)
                            ? rd
                            : rd["next"]()["then"](function (rY) {
                                  return rY["done"] ? rY["value"] : rd["next"]();
                              });
                    }),
                    r1(r0),
                    P(r0, X, "Generator"),
                    P(r0, D, function () {
                        return this;
                    }),
                    P(r0, "toString", function () {
                        return "[object\x20Generator]";
                    }),
                    (C["keys"] = function (rr) {
                        var rE = [];
                        for (var rR in rr) rE["push"](rR);
                        return (
                            rE["reverse"](),
                            function rT() {
                                for (; rE["length"]; ) {
                                    var rC = rE["pop"]();
                                    if (rC in rr) return (rT["value"] = rC), (rT["done"] = !0x1), rT;
                                }
                                return (rT["done"] = !0x0), rT;
                            }
                        );
                    }),
                    (C["values"] = r7),
                    (r6["prototype"] = {
                        constructor: r6,
                        reset: function (rr) {
                            if (
                                ((this["prev"] = 0x0),
                                (this["next"] = 0x0),
                                (this["sent"] = this["_sent"] = Y),
                                (this["done"] = !0x1),
                                (this["delegate"] = null),
                                (this["method"] = "next"),
                                (this["arg"] = Y),
                                this["tryEntries"]["forEach"](r5),
                                !rr)
                            ) {
                                for (var rE in this) "t" === rE["charAt"](0x0) && F["call"](this, rE) && !isNaN(+rE["slice"](0x1)) && (this[rE] = Y);
                            }
                        },
                        stop: function () {
                            this["done"] = !0x0;
                            var rr = this["tryEntries"][0x0]["completion"];
                            if ("throw" === rr["type"]) throw rr["arg"];
                            return this["rval"];
                        },
                        dispatchException: function (rr) {
                            if (this["done"]) throw rr;
                            var rE = this;
                            function rR(rB, rF) {
                                return (rd["type"] = "throw"), (rd["arg"] = rr), (rE["next"] = rB), rF && ((rE["method"] = "next"), (rE["arg"] = Y)), !!rF;
                            }
                            for (var rT = this["tryEntries"]["length"] - 0x1; rT >= 0x0; --rT) {
                                var rC = this["tryEntries"][rT],
                                    rd = rC["completion"];
                                if ("root" === rC["tryLoc"]) return rR("end");
                                if (rC["tryLoc"] <= this["prev"]) {
                                    var rY = F["call"](rC, "catchLoc"),
                                        rn = F["call"](rC, "finallyLoc");
                                    if (rY && rn) {
                                        if (this["prev"] < rC["catchLoc"]) return rR(rC["catchLoc"], !0x0);
                                        if (this["prev"] < rC["finallyLoc"]) return rR(rC["finallyLoc"]);
                                    } else {
                                        if (rY) {
                                            if (this["prev"] < rC["catchLoc"]) return rR(rC["catchLoc"], !0x0);
                                        } else {
                                            if (!rn) throw new Error("try\x20statement\x20without\x20catch\x20or\x20finally");
                                            if (this["prev"] < rC["finallyLoc"]) return rR(rC["finallyLoc"]);
                                        }
                                    }
                                }
                            }
                        },
                        abrupt: function (rr, rE) {
                            for (var rR = this["tryEntries"]["length"] - 0x1; rR >= 0x0; --rR) {
                                var rT = this["tryEntries"][rR];
                                if (rT["tryLoc"] <= this["prev"] && F["call"](rT, "finallyLoc") && this["prev"] < rT["finallyLoc"]) {
                                    var rC = rT;
                                    break;
                                }
                            }
                            rC && ("break" === rr || "continue" === rr) && rC["tryLoc"] <= rE && rE <= rC["finallyLoc"] && (rC = null);
                            var rd = rC ? rC["completion"] : {};
                            return (rd["type"] = rr), (rd["arg"] = rE), rC ? ((this["method"] = "next"), (this["next"] = rC["finallyLoc"]), H) : this["complete"](rd);
                        },
                        complete: function (rr, rE) {
                            if ("throw" === rr["type"]) throw rr["arg"];
                            return (
                                "break" === rr["type"] || "continue" === rr["type"]
                                    ? (this["next"] = rr["arg"])
                                    : "return" === rr["type"]
                                    ? ((this["rval"] = this["arg"] = rr["arg"]), (this["method"] = "return"), (this["next"] = "end"))
                                    : "normal" === rr["type"] && rE && (this["next"] = rE),
                                H
                            );
                        },
                        finish: function (rr) {
                            for (var rE = this["tryEntries"]["length"] - 0x1; rE >= 0x0; --rE) {
                                var rR = this["tryEntries"][rE];
                                if (rR["finallyLoc"] === rr) return this["complete"](rR["completion"], rR["afterLoc"]), r5(rR), H;
                            }
                        },
                        catch: function (rr) {
                            for (var rE = this["tryEntries"]["length"] - 0x1; rE >= 0x0; --rE) {
                                var rR = this["tryEntries"][rE];
                                if (rR["tryLoc"] === rr) {
                                    var rT = rR["completion"];
                                    if ("throw" === rT["type"]) {
                                        var rC = rT["arg"];
                                        r5(rR);
                                    }
                                    return rC;
                                }
                            }
                            throw new Error("illegal\x20catch\x20attempt");
                        },
                        delegateYield: function (rr, rE, rR) {
                            return (this["delegate"] = { iterator: r7(rr), resultName: rE, nextLoc: rR }), "next" === this["method"] && (this["arg"] = Y), H;
                        },
                    }),
                    C
                );
            })(r["exports"]);
            try {
                regeneratorRuntime = E;
            } catch (R) {
                "object" == typeof globalThis ? (globalThis["regeneratorRuntime"] = E) : Function("r", "regeneratorRuntime\x20=\x20r")(E);
            }
        },
        0xea95: function (Y, B) {
            "use strict";
            var F, Z, X, q, W;
            if ("undefined" == typeof window || "function" != typeof MessageChannel) {
                var K = null,
                    V = null,
                    J = function () {
                        if (null !== K)
                            try {
                                var rf = B["unstable_now"]();
                                K(!0x0, rf), (K = null);
                            } catch (rP) {
                                throw (setTimeout(J, 0x0), rP);
                            }
                    },
                    Q = Date["now"]();
                (B["unstable_now"] = function () {
                    return Date["now"]() - Q;
                }),
                    (F = function (rf) {
                        null !== K ? setTimeout(F, 0x0, rf) : ((K = rf), setTimeout(J, 0x0));
                    }),
                    (Z = function (rf, rP) {
                        V = setTimeout(rf, rP);
                    }),
                    (X = function () {
                        clearTimeout(V);
                    }),
                    (q = function () {
                        return !0x1;
                    }),
                    (W = B["unstable_forceFrameRate"] = function () {});
            } else {
                var z = window["performance"],
                    r0 = window["Date"],
                    r1 = window["setTimeout"],
                    r2 = window["clearTimeout"];
                if ("undefined" != typeof console) {
                    var r3 = window["cancelAnimationFrame"];
                    "function" != typeof window["requestAnimationFrame"] &&
                        console["error"]("This\x20browser\x20doesn\x27t\x20support\x20requestAnimationFrame.\x20Make\x20sure\x20that\x20you\x20load\x20a\x20polyfill\x20in\x20older\x20browsers.\x20https://fb.me/react-polyfills"),
                        "function" != typeof r3 &&
                            console["error"]("This\x20browser\x20doesn\x27t\x20support\x20cancelAnimationFrame.\x20Make\x20sure\x20that\x20you\x20load\x20a\x20polyfill\x20in\x20older\x20browsers.\x20https://fb.me/react-polyfills");
                }
                if ("object" == typeof z && "function" == typeof z["now"])
                    B["unstable_now"] = function () {
                        return z["now"]();
                    };
                else {
                    var r4 = r0["now"]();
                    B["unstable_now"] = function () {
                        return r0["now"]() - r4;
                    };
                }
                var r5 = !0x1,
                    r6 = null,
                    r7 = -0x1,
                    r8 = 0x5,
                    r9 = 0x0;
                (q = function () {
                    return B["unstable_now"]() >= r9;
                }),
                    (W = function () {}),
                    (B["unstable_forceFrameRate"] = function (rf) {
                        0x0 > rf || 0x7d < rf
                            ? console["error"]("forceFrameRate\x20takes\x20a\x20positive\x20int\x20between\x200\x20and\x20125,\x20forcing\x20framerates\x20higher\x20than\x20125\x20fps\x20is\x20not\x20unsupported")
                            : (r8 = 0x0 < rf ? Math["floor"](0x3e8 / rf) : 0x5);
                    });
                var rr = new MessageChannel(),
                    rE = rr["port2"];
                (rr["port1"]["onmessage"] = function () {
                    if (null !== r6) {
                        var rf = B["unstable_now"]();
                        r9 = rf + r8;
                        try {
                            r6(!0x0, rf) ? rE["postMessage"](null) : ((r5 = !0x1), (r6 = null));
                        } catch (rP) {
                            throw (rE["postMessage"](null), rP);
                        }
                    } else r5 = !0x1;
                }),
                    (F = function (rf) {
                        (r6 = rf), r5 || ((r5 = !0x0), rE["postMessage"](null));
                    }),
                    (Z = function (rf, rP) {
                        r7 = r1(function () {
                            rf(B["unstable_now"]());
                        }, rP);
                    }),
                    (X = function () {
                        r2(r7), (r7 = -0x1);
                    });
            }
            function rR(rf, rP) {
                var rI = rf["length"];
                rf["push"](rP);
                ro: for (;;) {
                    var rA = (rI - 0x1) >>> 0x1,
                        rM = rf[rA];
                    if (!(void 0x0 !== rM && 0x0 < rd(rM, rP))) break ro;
                    (rf[rA] = rP), (rf[rI] = rM), (rI = rA);
                }
            }
            function rT(rf) {
                return void 0x0 === (rf = rf[0x0]) ? null : rf;
            }
            function rC(rf) {
                var rP = rf[0x0];
                if (void 0x0 !== rP) {
                    var rI = rf["pop"]();
                    if (rI !== rP) {
                        rf[0x0] = rI;
                        re: for (var rA = 0x0, rM = rf["length"]; rA < rM; ) {
                            var ro = 0x2 * (rA + 0x1) - 0x1,
                                rt = rf[ro],
                                rp = ro + 0x1,
                                rk = rf[rp];
                            if (void 0x0 !== rt && 0x0 > rd(rt, rI)) void 0x0 !== rk && 0x0 > rd(rk, rt) ? ((rf[rA] = rk), (rf[rp] = rI), (rA = rp)) : ((rf[rA] = rt), (rf[ro] = rI), (rA = ro));
                            else {
                                if (!(void 0x0 !== rk && 0x0 > rd(rk, rI))) break re;
                                (rf[rA] = rk), (rf[rp] = rI), (rA = rp);
                            }
                        }
                    }
                    return rP;
                }
                return null;
            }
            function rd(rf, rP) {
                var rI = rf["sortIndex"] - rP["sortIndex"];
                return 0x0 !== rI ? rI : rf["id"] - rP["id"];
            }
            var rY = [],
                rn = [],
                rB = 0x1,
                rF = null,
                rb = 0x3,
                rZ = !0x1,
                rm = !0x1,
                rv = !0x1;
            function ru(rf) {
                for (var rP = rT(rn); null !== rP; ) {
                    if (null === rP["callback"]) rC(rn);
                    else {
                        if (!(rP["startTime"] <= rf)) break;
                        rC(rn), (rP["sortIndex"] = rP["expirationTime"]), rR(rY, rP);
                    }
                    rP = rT(rn);
                }
            }
            function ry(rf) {
                if (((rv = !0x1), ru(rf), !rm)) {
                    if (null !== rT(rY)) (rm = !0x0), F(rD);
                    else {
                        var rP = rT(rn);
                        null !== rP && Z(ry, rP["startTime"] - rf);
                    }
                }
            }
            function rD(rf, rP) {
                (rm = !0x1), rv && ((rv = !0x1), X()), (rZ = !0x0);
                var rI = rb;
                try {
                    for (ru(rP), rF = rT(rY); null !== rF && (!(rF["expirationTime"] > rP) || (rf && !q())); ) {
                        var rA = rF["callback"];
                        if (null !== rA) {
                            (rF["callback"] = null), (rb = rF["priorityLevel"]);
                            var rM = rA(rF["expirationTime"] <= rP);
                            (rP = B["unstable_now"]()), "function" == typeof rM ? (rF["callback"] = rM) : rF === rT(rY) && rC(rY), ru(rP);
                        } else rC(rY);
                        rF = rT(rY);
                    }
                    if (null !== rF) var ro = !0x0;
                    else {
                        var rt = rT(rn);
                        null !== rt && Z(ry, rt["startTime"] - rP), (ro = !0x1);
                    }
                    return ro;
                } finally {
                    (rF = null), (rb = rI), (rZ = !0x1);
                }
            }
            function rN(rf) {
                switch (rf) {
                    case 0x1:
                        return -0x1;
                    case 0x2:
                        return 0xfa;
                    case 0x5:
                        return 0x3fffffff;
                    case 0x4:
                        return 0x2710;
                    default:
                        return 0x1388;
                }
            }
            var rX = W;
            (B["unstable_IdlePriority"] = 0x5),
                (B["unstable_ImmediatePriority"] = 0x1),
                (B["unstable_LowPriority"] = 0x4),
                (B["unstable_NormalPriority"] = 0x3),
                (B["unstable_Profiling"] = null),
                (B["unstable_UserBlockingPriority"] = 0x2),
                (B["unstable_cancelCallback"] = function (rf) {
                    rf["callback"] = null;
                }),
                (B["unstable_continueExecution"] = function () {
                    rm || rZ || ((rm = !0x0), F(rD));
                }),
                (B["unstable_getCurrentPriorityLevel"] = function () {
                    return rb;
                }),
                (B["unstable_getFirstCallbackNode"] = function () {
                    return rT(rY);
                }),
                (B["unstable_next"] = function (rf) {
                    switch (rb) {
                        case 0x1:
                        case 0x2:
                        case 0x3:
                            var rP = 0x3;
                            break;
                        default:
                            rP = rb;
                    }
                    var rI = rb;
                    rb = rP;
                    try {
                        return rf();
                    } finally {
                        rb = rI;
                    }
                }),
                (B["unstable_pauseExecution"] = function () {}),
                (B["unstable_requestPaint"] = rX),
                (B["unstable_runWithPriority"] = function (rf, rP) {
                    switch (rf) {
                        case 0x1:
                        case 0x2:
                        case 0x3:
                        case 0x4:
                        case 0x5:
                            break;
                        default:
                            rf = 0x3;
                    }
                    var rI = rb;
                    rb = rf;
                    try {
                        return rP();
                    } finally {
                        rb = rI;
                    }
                }),
                (B["unstable_scheduleCallback"] = function (rf, rP, rI) {
                    var rA = B["unstable_now"]();
                    if ("object" == typeof rI && null !== rI) {
                        var rM = rI["delay"];
                        (rM = "number" == typeof rM && 0x0 < rM ? rA + rM : rA), (rI = "number" == typeof rI["timeout"] ? rI["timeout"] : rN(rf));
                    } else (rI = rN(rf)), (rM = rA);
                    return (
                        (rf = { id: rB++, callback: rP, priorityLevel: rf, startTime: rM, expirationTime: (rI = rM + rI), sortIndex: -0x1 }),
                        rM > rA ? ((rf["sortIndex"] = rM), rR(rn, rf), null === rT(rY) && rf === rT(rn) && (rv ? X() : (rv = !0x0), Z(ry, rM - rA))) : ((rf["sortIndex"] = rI), rR(rY, rf), rm || rZ || ((rm = !0x0), F(rD))),
                        rf
                    );
                }),
                (B["unstable_shouldYield"] = function () {
                    var rf = B["unstable_now"]();
                    ru(rf);
                    var rP = rT(rY);
                    return (rP !== rF && null !== rF && null !== rP && null !== rP["callback"] && rP["startTime"] <= rf && rP["expirationTime"] < rF["expirationTime"]) || q();
                }),
                (B["unstable_wrapCallback"] = function (rf) {
                    var rP = rb;
                    return function () {
                        var rI = rb;
                        rb = rP;
                        try {
                            return rf["apply"](this, arguments);
                        } finally {
                            rb = rI;
                        }
                    };
                });
        },
        0xf960: function (r, E, R) {
            "use strict";
            r["exports"] = R(0xea95);
        },
        0x17a06: function (r) {
            r["exports"] = function (E, R, T, C) {
                var d = T ? T["call"](C, E, R) : void 0x0;
                if (void 0x0 !== d) return !!d;
                if (E === R) return !0x0;
                if ("object" != typeof E || !E || "object" != typeof R || !R) return !0x1;
                var Y = Object["keys"](E),
                    B = Object["keys"](R);
                if (Y["length"] !== B["length"]) return !0x1;
                for (var F = Object["prototype"]["hasOwnProperty"]["bind"](R), b = 0x0; b < Y["length"]; b++) {
                    var Z = Y[b];
                    if (!F(Z)) return !0x1;
                    var m = E[Z],
                        v = R[Z];
                    if (!0x1 === (d = T ? T["call"](C, m, v, Z) : void 0x0) || (void 0x0 === d && m !== v)) return !0x1;
                }
                return !0x0;
            };
        },
        0x71eb: function (r0, r1, r2) {
            "use strict";
            r2["d"](r1, {
                ZP: function () {
                    return ED;
                },
                F4: function () {
                    return Ey;
                },
            });
            var r3 = r2(0xe9d8),
                r4 = r2(0x106de),
                r5 = r2(0x17a06),
                r6 = r2["n"](r5),
                r7 = function (EN) {
                    function EX(R2, R3, R4, R5, R6) {
                        for (
                            var R7,
                                R8,
                                R9,
                                Rr,
                                RE,
                                RR = 0x0,
                                RT = 0x0,
                                RC = 0x0,
                                Rd = 0x0,
                                RY = 0x0,
                                Rn = 0x0,
                                RB = (R9 = R7 = 0x0),
                                RF = 0x0,
                                Rb = 0x0,
                                RZ = 0x0,
                                Rm = 0x0,
                                Rv = R4["length"],
                                Ru = Rv - 0x1,
                                Ry = "",
                                RD = "",
                                RN = "",
                                RX = "";
                            RF < Rv;

                        ) {
                            if (((R8 = R4["charCodeAt"](RF)), RF === Ru && 0x0 !== RT + Rd + RC + RR && (0x0 !== RT && (R8 = 0x2f === RT ? 0xa : 0x2f), (Rd = RC = RR = 0x0), Rv++, Ru++), 0x0 === RT + Rd + RC + RR)) {
                                if (RF === Ru && (0x0 < Rb && (Ry = Ry["replace"](El, "")), 0x0 < Ry["trim"]()["length"])) {
                                    switch (R8) {
                                        case 0x20:
                                        case 0x9:
                                        case 0x3b:
                                        case 0xd:
                                        case 0xa:
                                            break;
                                        default:
                                            Ry += R4["charAt"](RF);
                                    }
                                    R8 = 0x3b;
                                }
                                switch (R8) {
                                    case 0x7b:
                                        for (R7 = (Ry = Ry["trim"]())["charCodeAt"](0x0), R9 = 0x1, Rm = ++RF; RF < Rv; ) {
                                            switch ((R8 = R4["charCodeAt"](RF))) {
                                                case 0x7b:
                                                    R9++;
                                                    break;
                                                case 0x7d:
                                                    R9--;
                                                    break;
                                                case 0x2f:
                                                    switch ((R8 = R4["charCodeAt"](RF + 0x1))) {
                                                        case 0x2a:
                                                        case 0x2f:
                                                            Rf: {
                                                                for (RB = RF + 0x1; RB < Ru; ++RB)
                                                                    switch (R4["charCodeAt"](RB)) {
                                                                        case 0x2f:
                                                                            if (0x2a === R8 && 0x2a === R4["charCodeAt"](RB - 0x1) && RF + 0x2 !== RB) {
                                                                                RF = RB + 0x1;
                                                                                break Rf;
                                                                            }
                                                                            break;
                                                                        case 0xa:
                                                                            if (0x2f === R8) {
                                                                                RF = RB + 0x1;
                                                                                break Rf;
                                                                            }
                                                                    }
                                                                RF = RB;
                                                            }
                                                    }
                                                    break;
                                                case 0x5b:
                                                    R8++;
                                                case 0x28:
                                                    R8++;
                                                case 0x22:
                                                case 0x27:
                                                    for (; RF++ < Ru && R4["charCodeAt"](RF) !== R8; );
                                            }
                                            if (0x0 === R9) break;
                                            RF++;
                                        }
                                        if (((R9 = R4["substring"](Rm, RF)), 0x0 === R7 && (R7 = (Ry = Ry["replace"](Ee, "")["trim"]())["charCodeAt"](0x0)), 0x40 === R7)) {
                                            switch ((0x0 < Rb && (Ry = Ry["replace"](El, "")), (R8 = Ry["charCodeAt"](0x1)))) {
                                                case 0x64:
                                                case 0x6d:
                                                case 0x73:
                                                case 0x2d:
                                                    Rb = R3;
                                                    break;
                                                default:
                                                    Rb = EL;
                                            }
                                            if (
                                                ((Rm = (R9 = EX(R3, Rb, R9, R8, R6 + 0x1))["length"]),
                                                0x0 < Ez &&
                                                    ((RE = Eo(0x3, R9, (Rb = Ef(EL, Ry, RZ)), R3, Es, EV, Rm, R8, R6, R5)), (Ry = Rb["join"]("")), void 0x0 !== RE && 0x0 === (Rm = (R9 = RE["trim"]())["length"]) && ((R8 = 0x0), (R9 = ""))),
                                                0x0 < Rm)
                                            )
                                                switch (R8) {
                                                    case 0x73:
                                                        Ry = Ry["replace"](ES, EM);
                                                    case 0x64:
                                                    case 0x6d:
                                                    case 0x2d:
                                                        R9 = Ry + "{" + R9 + "}";
                                                        break;
                                                    case 0x6b:
                                                        (R9 = (Ry = Ry["replace"](Ei, "$1\x20$2")) + "{" + R9 + "}"), (R9 = 0x1 === EG || (0x2 === EG && EA("@" + R9, 0x3)) ? "@-webkit-" + R9 + "@" + R9 : "@" + R9);
                                                        break;
                                                    default:
                                                        (R9 = Ry + R9), 0x70 === R5 && ((RD += R9), (R9 = ""));
                                                }
                                            else R9 = "";
                                        } else R9 = EX(R3, Ef(R3, Ry, RZ), R9, R5, R6 + 0x1);
                                        (RN += R9), (R9 = RZ = Rb = RB = R7 = 0x0), (Ry = ""), (R8 = R4["charCodeAt"](++RF));
                                        break;
                                    case 0x7d:
                                    case 0x3b:
                                        if (0x1 < (Rm = (Ry = (0x0 < Rb ? Ry["replace"](El, "") : Ry)["trim"]())["length"]))
                                            switch (
                                                (0x0 === RB && ((R7 = Ry["charCodeAt"](0x0)), 0x2d === R7 || (0x60 < R7 && 0x7b > R7)) && (Rm = (Ry = Ry["replace"]("\x20", ":"))["length"]),
                                                0x0 < Ez && void 0x0 !== (RE = Eo(0x1, Ry, R3, R2, Es, EV, RD["length"], R5, R6, R5)) && 0x0 === (Rm = (Ry = RE["trim"]())["length"]) && (Ry = "\x00\x00"),
                                                (R7 = Ry["charCodeAt"](0x0)),
                                                (R8 = Ry["charCodeAt"](0x1)),
                                                R7)
                                            ) {
                                                case 0x0:
                                                    break;
                                                case 0x40:
                                                    if (0x69 === R8 || 0x63 === R8) {
                                                        RX += Ry + R4["charAt"](RF);
                                                        break;
                                                    }
                                                default:
                                                    0x3a !== Ry["charCodeAt"](Rm - 0x1) && (RD += EI(Ry, R7, R8, Ry["charCodeAt"](0x2)));
                                            }
                                        (RZ = Rb = RB = R7 = 0x0), (Ry = ""), (R8 = R4["charCodeAt"](++RF));
                                }
                            }
                            switch (R8) {
                                case 0xd:
                                case 0xa:
                                    0x2f === RT ? (RT = 0x0) : 0x0 === 0x1 + R7 && 0x6b !== R5 && 0x0 < Ry["length"] && ((Rb = 0x1), (Ry += "\x00")), 0x0 < Ez * R1 && Eo(0x0, Ry, R3, R2, Es, EV, RD["length"], R5, R6, R5), (EV = 0x1), Es++;
                                    break;
                                case 0x3b:
                                case 0x7d:
                                    if (0x0 === RT + Rd + RC + RR) {
                                        EV++;
                                        break;
                                    }
                                default:
                                    switch ((EV++, (Rr = R4["charAt"](RF)), R8)) {
                                        case 0x9:
                                        case 0x20:
                                            if (0x0 === Rd + RR + RT)
                                                switch (RY) {
                                                    case 0x2c:
                                                    case 0x3a:
                                                    case 0x9:
                                                    case 0x20:
                                                        Rr = "";
                                                        break;
                                                    default:
                                                        0x20 !== R8 && (Rr = "\x20");
                                                }
                                            break;
                                        case 0x0:
                                            Rr = "\x5c0";
                                            break;
                                        case 0xc:
                                            Rr = "\x5cf";
                                            break;
                                        case 0xb:
                                            Rr = "\x5cv";
                                            break;
                                        case 0x26:
                                            0x0 === Rd + RT + RR && ((Rb = RZ = 0x1), (Rr = "\x0c" + Rr));
                                            break;
                                        case 0x6c:
                                            if (0x0 === Rd + RT + RR + EJ && 0x0 < RB)
                                                switch (RF - RB) {
                                                    case 0x2:
                                                        0x70 === RY && 0x3a === R4["charCodeAt"](RF - 0x3) && (EJ = RY);
                                                    case 0x8:
                                                        0x6f === Rn && (EJ = Rn);
                                                }
                                            break;
                                        case 0x3a:
                                            0x0 === Rd + RT + RR && (RB = RF);
                                            break;
                                        case 0x2c:
                                            0x0 === RT + RC + Rd + RR && ((Rb = 0x1), (Rr += "\x0d"));
                                            break;
                                        case 0x22:
                                        case 0x27:
                                            0x0 === RT && (Rd = Rd === R8 ? 0x0 : 0x0 === Rd ? R8 : Rd);
                                            break;
                                        case 0x5b:
                                            0x0 === Rd + RT + RC && RR++;
                                            break;
                                        case 0x5d:
                                            0x0 === Rd + RT + RC && RR--;
                                            break;
                                        case 0x29:
                                            0x0 === Rd + RT + RR && RC--;
                                            break;
                                        case 0x28:
                                            if (0x0 === Rd + RT + RR) {
                                                if (0x0 === R7) {
                                                    if (0x2 * RY + 0x3 * Rn == 0x215);
                                                    else R7 = 0x1;
                                                }
                                                RC++;
                                            }
                                            break;
                                        case 0x40:
                                            0x0 === RT + RC + Rd + RR + RB + R9 && (R9 = 0x1);
                                            break;
                                        case 0x2a:
                                        case 0x2f:
                                            if (!(0x0 < Rd + RR + RC))
                                                switch (RT) {
                                                    case 0x0:
                                                        switch (0x2 * R8 + 0x3 * R4["charCodeAt"](RF + 0x1)) {
                                                            case 0xeb:
                                                                RT = 0x2f;
                                                                break;
                                                            case 0xdc:
                                                                (Rm = RF), (RT = 0x2a);
                                                        }
                                                        break;
                                                    case 0x2a:
                                                        0x2f === R8 && 0x2a === RY && Rm + 0x2 !== RF && (0x21 === R4["charCodeAt"](Rm + 0x2) && (RD += R4["substring"](Rm, RF + 0x1)), (Rr = ""), (RT = 0x0));
                                                }
                                    }
                                    0x0 === RT && (Ry += Rr);
                            }
                            (Rn = RY), (RY = R8), RF++;
                        }
                        if (0x0 < (Rm = RD["length"])) {
                            if (((Rb = R3), 0x0 < Ez && void 0x0 !== (RE = Eo(0x2, RD, Rb, R2, Es, EV, Rm, R5, R6, R5)) && 0x0 === (RD = RE)["length"])) return RX + RD + RN;
                            if (((RD = Rb["join"](",") + "{" + RD + "}"), 0x0 != EG * EJ)) {
                                switch ((0x2 !== EG || EA(RD, 0x2) || (EJ = 0x0), EJ)) {
                                    case 0x6f:
                                        RD = RD["replace"](Ea, ":-moz-$1") + RD;
                                        break;
                                    case 0x70:
                                        RD = RD["replace"](Eh, "::-webkit-input-$1") + RD["replace"](Eh, "::-moz-$1") + RD["replace"](Eh, ":-ms-input-$1") + RD;
                                }
                                EJ = 0x0;
                            }
                        }
                        return RX + RD + RN;
                    }
                    function Ef(R2, R3, R4) {
                        var R5 = R3["trim"]()["split"](EO);
                        R3 = R5;
                        var R6 = R5["length"],
                            R7 = R2["length"];
                        switch (R7) {
                            case 0x0:
                            case 0x1:
                                var R8 = 0x0;
                                for (R2 = 0x0 === R7 ? "" : R2[0x0] + "\x20"; R8 < R6; ++R8) R3[R8] = EP(R2, R3[R8], R4)["trim"]();
                                break;
                            default:
                                var R9 = (R8 = 0x0);
                                for (R3 = []; R8 < R6; ++R8) for (var Rr = 0x0; Rr < R7; ++Rr) R3[R9++] = EP(R2[Rr] + "\x20", R5[R8], R4)["trim"]();
                        }
                        return R3;
                    }
                    function EP(R2, R3, R4) {
                        var R5 = R3["charCodeAt"](0x0);
                        switch ((0x21 > R5 && (R5 = (R3 = R3["trim"]())["charCodeAt"](0x0)), R5)) {
                            case 0x26:
                                return R3["replace"](Ej, "$1" + R2["trim"]());
                            case 0x3a:
                                return R2["trim"]() + R3["replace"](Ej, "$1" + R2["trim"]());
                            default:
                                if (0x0 < 0x1 * R4 && 0x0 < R3["indexOf"]("\x0c")) return R3["replace"](Ej, (0x3a === R2["charCodeAt"](0x0) ? "" : "$1") + R2["trim"]());
                        }
                        return R2 + R3;
                    }
                    function EI(R2, R3, R4, R5) {
                        var R6 = R2 + ";",
                            R7 = 0x2 * R3 + 0x3 * R4 + 0x4 * R5;
                        if (0x3b0 === R7) {
                            R2 = R6["indexOf"](":", 0x9) + 0x1;
                            var R8 = R6["substring"](R2, R6["length"] - 0x1)["trim"]();
                            return (R8 = R6["substring"](0x0, R2)["trim"]() + R8 + ";"), 0x1 === EG || (0x2 === EG && EA(R8, 0x1)) ? "-webkit-" + R8 + R8 : R8;
                        }
                        if (0x0 === EG || (0x2 === EG && !EA(R6, 0x1))) return R6;
                        switch (R7) {
                            case 0x3f7:
                                return 0x61 === R6["charCodeAt"](0xa) ? "-webkit-" + R6 + R6 : R6;
                            case 0x3b7:
                                return 0x74 === R6["charCodeAt"](0x3) ? "-webkit-" + R6 + R6 : R6;
                            case 0x3c3:
                                return 0x6e === R6["charCodeAt"](0x5) ? "-webkit-" + R6 + R6 : R6;
                            case 0x3f1:
                                if (0x64 !== R6["charCodeAt"](0x4)) break;
                            case 0x3c9:
                            case 0x3ae:
                                return "-webkit-" + R6 + R6;
                            case 0x3d2:
                                return "-webkit-" + R6 + "-moz-" + R6 + R6;
                            case 0x3fb:
                            case 0x3d7:
                                return "-webkit-" + R6 + "-moz-" + R6 + "-ms-" + R6 + R6;
                            case 0x373:
                                if (0x2d === R6["charCodeAt"](0x8)) return "-webkit-" + R6 + R6;
                                if (0x0 < R6["indexOf"]("image-set(", 0xb)) return R6["replace"](EK, "$1-webkit-$2") + R6;
                                break;
                            case 0x3a4:
                                if (0x2d === R6["charCodeAt"](0x4))
                                    switch (R6["charCodeAt"](0x5)) {
                                        case 0x67:
                                            return "-webkit-box-" + R6["replace"]("-grow", "") + "-webkit-" + R6 + "-ms-" + R6["replace"]("grow", "positive") + R6;
                                        case 0x73:
                                            return "-webkit-" + R6 + "-ms-" + R6["replace"]("shrink", "negative") + R6;
                                        case 0x62:
                                            return "-webkit-" + R6 + "-ms-" + R6["replace"]("basis", "preferred-size") + R6;
                                    }
                                return "-webkit-" + R6 + "-ms-" + R6 + R6;
                            case 0x3c4:
                                return "-webkit-" + R6 + "-ms-flex-" + R6 + R6;
                            case 0x3ff:
                                if (0x63 !== R6["charCodeAt"](0x8)) break;
                                return "-webkit-box-pack" + (R8 = R6["substring"](R6["indexOf"](":", 0xf))["replace"]("flex-", "")["replace"]("space-between", "justify")) + "-webkit-" + R6 + "-ms-flex-pack" + R8 + R6;
                            case 0x3ed:
                                return Eq["test"](R6) ? R6["replace"](EU, ":-webkit-") + R6["replace"](EU, ":-moz-") + R6 : R6;
                            case 0x3e8:
                                switch (((R3 = (R8 = R6["substring"](0xd)["trim"]())["indexOf"]("-") + 0x1), R8["charCodeAt"](0x0) + R8["charCodeAt"](R3))) {
                                    case 0xe2:
                                        R8 = R6["replace"](Ec, "tb");
                                        break;
                                    case 0xe8:
                                        R8 = R6["replace"](Ec, "tb-rl");
                                        break;
                                    case 0xdc:
                                        R8 = R6["replace"](Ec, "lr");
                                        break;
                                    default:
                                        return R6;
                                }
                                return "-webkit-" + R6 + "-ms-" + R8 + R6;
                            case 0x3f9:
                                if (-0x1 === R6["indexOf"]("sticky", 0x9)) break;
                            case 0x3cf:
                                switch (
                                    ((R3 = (R6 = R2)["length"] - 0xa),
                                    (R7 = (R8 = (0x21 === R6["charCodeAt"](R3) ? R6["substring"](0x0, R3) : R6)["substring"](R2["indexOf"](":", 0x7) + 0x1)["trim"]())["charCodeAt"](0x0) + (0x0 | R8["charCodeAt"](0x7))))
                                ) {
                                    case 0xcb:
                                        if (0x6f > R8["charCodeAt"](0x8)) break;
                                    case 0x73:
                                        R6 = R6["replace"](R8, "-webkit-" + R8) + ";" + R6;
                                        break;
                                    case 0xcf:
                                    case 0x66:
                                        R6 = R6["replace"](R8, "-webkit-" + (0x66 < R7 ? "inline-" : "") + "box") + ";" + R6["replace"](R8, "-webkit-" + R8) + ";" + R6["replace"](R8, "-ms-" + R8 + "box") + ";" + R6;
                                }
                                return R6 + ";";
                            case 0x3aa:
                                if (0x2d === R6["charCodeAt"](0x5))
                                    switch (R6["charCodeAt"](0x6)) {
                                        case 0x69:
                                            return (R8 = R6["replace"]("-items", "")), "-webkit-" + R6 + "-webkit-box-" + R8 + "-ms-flex-" + R8 + R6;
                                        case 0x73:
                                            return "-webkit-" + R6 + "-ms-flex-item-" + R6["replace"](EW, "") + R6;
                                        default:
                                            return "-webkit-" + R6 + "-ms-flex-line-pack" + R6["replace"]("align-content", "")["replace"](EW, "") + R6;
                                    }
                                break;
                            case 0x3cd:
                            case 0x3dd:
                                if (0x2d !== R6["charCodeAt"](0x3) || 0x7a === R6["charCodeAt"](0x4)) break;
                            case 0x3a3:
                            case 0x3b9:
                                if (!0x0 === Ex["test"](R2))
                                    return 0x73 === (R8 = R2["substring"](R2["indexOf"](":") + 0x1))["charCodeAt"](0x0)
                                        ? EI(R2["replace"]("stretch", "fill-available"), R3, R4, R5)["replace"](":fill-available", ":stretch")
                                        : R6["replace"](R8, "-webkit-" + R8) + R6["replace"](R8, "-moz-" + R8["replace"]("fill-", "")) + R6;
                                break;
                            case 0x3c2:
                                if (((R6 = "-webkit-" + R6 + (0x66 === R6["charCodeAt"](0x5) ? "-ms-" + R6 : "") + R6), 0xd3 === R4 + R5 && 0x69 === R6["charCodeAt"](0xd) && 0x0 < R6["indexOf"]("transform", 0xa)))
                                    return R6["substring"](0x0, R6["indexOf"](";", 0x1b) + 0x1)["replace"](Ew, "$1-webkit-$2") + R6;
                        }
                        return R6;
                    }
                    function EA(R2, R3) {
                        var R4 = R2["indexOf"](0x1 === R3 ? ":" : "{"),
                            R5 = R2["substring"](0x0, 0x3 !== R3 ? R4 : 0xa);
                        return (R4 = R2["substring"](R4 + 0x1, R2["length"] - 0x1)), R0(0x2 !== R3 ? R5 : R5["replace"](EH, "$1"), R4, R3);
                    }
                    function EM(R2, R3) {
                        var R4 = EI(R3, R3["charCodeAt"](0x0), R3["charCodeAt"](0x1), R3["charCodeAt"](0x2));
                        return R4 !== R3 + ";" ? R4["replace"](Eg, "\x20or\x20($1)")["substring"](0x4) : "(" + R3 + ")";
                    }
                    function Eo(R2, R3, R4, R5, R6, R7, R8, R9, Rr, RE) {
                        for (var RR, RT = 0x0, RC = R3; RT < Ez; ++RT)
                            switch ((RR = EQ[RT]["call"](Ek, R2, RC, R4, R5, R6, R7, R8, R9, Rr, RE))) {
                                case void 0x0:
                                case !0x1:
                                case !0x0:
                                case null:
                                    break;
                                default:
                                    RC = RR;
                            }
                        if (RC !== R3) return RC;
                    }
                    function Ep(R2) {
                        return void 0x0 !== (R2 = R2["prefix"]) && ((R0 = null), R2 ? ("function" != typeof R2 ? (EG = 0x1) : ((EG = 0x2), (R0 = R2))) : (EG = 0x0)), Ep;
                    }
                    function Ek(R2, R3) {
                        var R4 = R2;
                        if ((0x21 > R4["charCodeAt"](0x0) && (R4 = R4["trim"]()), (R4 = [R4]), 0x0 < Ez)) {
                            var R5 = Eo(-0x1, R3, R4, R4, Es, EV, 0x0, 0x0, 0x0, 0x0);
                            void 0x0 !== R5 && "string" == typeof R5 && (R3 = R5);
                        }
                        var R6 = EX(EL, R4, R3, 0x0, 0x0);
                        return 0x0 < Ez && void 0x0 !== (R5 = Eo(-0x2, R6, R4, R4, Es, EV, R6["length"], 0x0, 0x0, 0x0)) && (R6 = R5), "", (EJ = 0x0), (EV = Es = 0x1), R6;
                    }
                    var Ee = /^\0+/g,
                        El = /[\0\r\f]/g,
                        EU = /: */g,
                        Eq = /zoo|gra/,
                        Ew = /([,: ])(transform)/g,
                        EO = /,\r+?/g,
                        Ej = /([\t\r\n ])*\f?&/g,
                        Ei = /@(k\w+)\s*(\S*)\s*/,
                        Eh = /::(place)/g,
                        Ea = /:(read-only)/g,
                        Ec = /[svh]\w+-[tblr]{2}/,
                        ES = /\(\s*(.*)\s*\)/g,
                        Eg = /([\s\S]*?);/g,
                        EW = /-self|flex-/g,
                        EH = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
                        Ex = /stretch|:\s*\w+\-(?:conte|avail)/,
                        EK = /([^-])(image-set\()/,
                        EV = 0x1,
                        Es = 0x1,
                        EJ = 0x0,
                        EG = 0x1,
                        EL = [],
                        EQ = [],
                        Ez = 0x0,
                        R0 = null,
                        R1 = 0x0;
                    return (
                        (Ek["use"] = function R2(R3) {
                            switch (R3) {
                                case void 0x0:
                                case null:
                                    Ez = EQ["length"] = 0x0;
                                    break;
                                default:
                                    if ("function" == typeof R3) EQ[Ez++] = R3;
                                    else {
                                        if ("object" == typeof R3) {
                                            for (var R4 = 0x0, R5 = R3["length"]; R4 < R5; ++R4) R2(R3[R4]);
                                        } else R1 = 0x0 | !!R3;
                                    }
                            }
                            return R2;
                        }),
                        (Ek["set"] = Ep),
                        void 0x0 !== EN && Ep(EN),
                        Ek
                    );
                },
                r8 = {
                    animationIterationCount: 0x1,
                    borderImageOutset: 0x1,
                    borderImageSlice: 0x1,
                    borderImageWidth: 0x1,
                    boxFlex: 0x1,
                    boxFlexGroup: 0x1,
                    boxOrdinalGroup: 0x1,
                    columnCount: 0x1,
                    columns: 0x1,
                    flex: 0x1,
                    flexGrow: 0x1,
                    flexPositive: 0x1,
                    flexShrink: 0x1,
                    flexNegative: 0x1,
                    flexOrder: 0x1,
                    gridRow: 0x1,
                    gridRowEnd: 0x1,
                    gridRowSpan: 0x1,
                    gridRowStart: 0x1,
                    gridColumn: 0x1,
                    gridColumnEnd: 0x1,
                    gridColumnSpan: 0x1,
                    gridColumnStart: 0x1,
                    msGridRow: 0x1,
                    msGridRowSpan: 0x1,
                    msGridColumn: 0x1,
                    msGridColumnSpan: 0x1,
                    fontWeight: 0x1,
                    lineHeight: 0x1,
                    opacity: 0x1,
                    order: 0x1,
                    orphans: 0x1,
                    tabSize: 0x1,
                    widows: 0x1,
                    zIndex: 0x1,
                    zoom: 0x1,
                    WebkitLineClamp: 0x1,
                    fillOpacity: 0x1,
                    floodOpacity: 0x1,
                    stopOpacity: 0x1,
                    strokeDasharray: 0x1,
                    strokeDashoffset: 0x1,
                    strokeMiterlimit: 0x1,
                    strokeOpacity: 0x1,
                    strokeWidth: 0x1,
                },
                r9 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
                rr = (function (EN) {
                    var EX = {};
                    return function (Ef) {
                        return void 0x0 === EX[Ef] && (EX[Ef] = EN(Ef)), EX[Ef];
                    };
                })(function (EN) {
                    return r9["test"](EN) || (0x6f === EN["charCodeAt"](0x0) && 0x6e === EN["charCodeAt"](0x1) && EN["charCodeAt"](0x2) < 0x5b);
                }),
                rE = r2(0x21e7),
                rR = r2["n"](rE);
            function rT() {
                return (rT =
                    Object["assign"] ||
                    function (EN) {
                        for (var EX = 0x1; EX < arguments["length"]; EX++) {
                            var Ef = arguments[EX];
                            for (var EP in Ef) Object["prototype"]["hasOwnProperty"]["call"](Ef, EP) && (EN[EP] = Ef[EP]);
                        }
                        return EN;
                    })["apply"](this, arguments);
            }
            var rC = function (EN, EX) {
                    for (var Ef = [EN[0x0]], EP = 0x0, EI = EX["length"]; EP < EI; EP += 0x1) Ef["push"](EX[EP], EN[EP + 0x1]);
                    return Ef;
                },
                rd = function (EN) {
                    return null !== EN && "object" == typeof EN && "[object\x20Object]" === (EN["toString"] ? EN["toString"]() : Object["prototype"]["toString"]["call"](EN)) && !(0x0, r3["typeOf"])(EN);
                },
                rY = Object["freeze"]([]),
                rn = Object["freeze"]({});
            function rB(EN) {
                return "function" == typeof EN;
            }
            function rF(EN) {
                return EN["displayName"] || EN["name"] || "Component";
            }
            function rb(EN) {
                return EN && "string" == typeof EN["styledComponentId"];
            }
            var rZ = ("undefined" != typeof process && (process["env"]["REACT_APP_SC_ATTR"] || process["env"]["SC_ATTR"])) || "data-styled",
                rm = "undefined" != typeof window && "HTMLElement" in window,
                rv = Boolean(
                    "boolean" == typeof SC_DISABLE_SPEEDY
                        ? SC_DISABLE_SPEEDY
                        : "undefined" != typeof process && void 0x0 !== process["env"]["REACT_APP_SC_DISABLE_SPEEDY"] && "" !== process["env"]["REACT_APP_SC_DISABLE_SPEEDY"]
                        ? "false" !== process["env"]["REACT_APP_SC_DISABLE_SPEEDY"] && process["env"]["REACT_APP_SC_DISABLE_SPEEDY"]
                        : "undefined" != typeof process &&
                          void 0x0 !== process["env"]["SC_DISABLE_SPEEDY"] &&
                          "" !== process["env"]["SC_DISABLE_SPEEDY"] &&
                          "false" !== process["env"]["SC_DISABLE_SPEEDY"] &&
                          process["env"]["SC_DISABLE_SPEEDY"]
                );
            function ru(EN) {
                for (var EX = arguments["length"], Ef = new Array(EX > 0x1 ? EX - 0x1 : 0x0), EP = 0x1; EP < EX; EP++) Ef[EP - 0x1] = arguments[EP];
                throw new Error("An\x20error\x20occurred.\x20See\x20https://git.io/JUIaE#" + EN + "\x20for\x20more\x20information." + (Ef["length"] > 0x0 ? "\x20Args:\x20" + Ef["join"](",\x20") : ""));
            }
            var ry = (function () {
                    function EN(Ef) {
                        (this["groupSizes"] = new Uint32Array(0x200)), (this["length"] = 0x200), (this["tag"] = Ef);
                    }
                    var EX = EN["prototype"];
                    return (
                        (EX["indexOfGroup"] = function (Ef) {
                            for (var EP = 0x0, EI = 0x0; EI < Ef; EI++) EP += this["groupSizes"][EI];
                            return EP;
                        }),
                        (EX["insertRules"] = function (Ef, EP) {
                            if (Ef >= this["groupSizes"]["length"]) {
                                for (var EI = this["groupSizes"], EA = EI["length"], EM = EA; Ef >= EM; ) (EM <<= 0x1) < 0x0 && ru(0x10, "" + Ef);
                                (this["groupSizes"] = new Uint32Array(EM)), this["groupSizes"]["set"](EI), (this["length"] = EM);
                                for (var Eo = EA; Eo < EM; Eo++) this["groupSizes"][Eo] = 0x0;
                            }
                            for (var Ep = this["indexOfGroup"](Ef + 0x1), Ek = 0x0, Ee = EP["length"]; Ek < Ee; Ek++) this["tag"]["insertRule"](Ep, EP[Ek]) && (this["groupSizes"][Ef]++, Ep++);
                        }),
                        (EX["clearGroup"] = function (Ef) {
                            if (Ef < this["length"]) {
                                var EP = this["groupSizes"][Ef],
                                    EI = this["indexOfGroup"](Ef),
                                    EA = EI + EP;
                                this["groupSizes"][Ef] = 0x0;
                                for (var EM = EI; EM < EA; EM++) this["tag"]["deleteRule"](EI);
                            }
                        }),
                        (EX["getGroup"] = function (Ef) {
                            var EP = "";
                            if (Ef >= this["length"] || 0x0 === this["groupSizes"][Ef]) return EP;
                            for (var EI = this["groupSizes"][Ef], EA = this["indexOfGroup"](Ef), EM = EA + EI, Eo = EA; Eo < EM; Eo++) EP += this["tag"]["getRule"](Eo) + "/*!sc*/\x0a";
                            return EP;
                        }),
                        EN
                    );
                })(),
                rD = new Map(),
                rN = new Map(),
                rX = 0x1,
                rf = function (EN) {
                    if (rD["has"](EN)) return rD["get"](EN);
                    for (; rN["has"](rX); ) rX++;
                    var EX = rX++;
                    return rD["set"](EN, EX), rN["set"](EX, EN), EX;
                },
                rP = function (EN) {
                    return rN["get"](EN);
                },
                rI = function (EN, EX) {
                    EX >= rX && (rX = EX + 0x1), rD["set"](EN, EX), rN["set"](EX, EN);
                },
                rA = "style[" + rZ + "][data-styled-version=\x225.3.3\x22]",
                rM = new RegExp("^" + rZ + "\x5c.g(\x5cd+)\x5c[id=\x22([\x5cw\x5cd-]+)\x22\x5c].*?\x22([^\x22]*)"),
                ro = function (EN, EX, Ef) {
                    for (var EP, EI = Ef["split"](","), EA = 0x0, EM = EI["length"]; EA < EM; EA++) (EP = EI[EA]) && EN["registerName"](EX, EP);
                },
                rp = function (EN, EX) {
                    for (var Ef = (EX["textContent"] || "")["split"]("/*!sc*/\x0a"), EP = [], EI = 0x0, EA = Ef["length"]; EI < EA; EI++) {
                        var EM = Ef[EI]["trim"]();
                        if (EM) {
                            var Eo = EM["match"](rM);
                            if (Eo) {
                                var Ep = 0x0 | parseInt(Eo[0x1], 0xa),
                                    Ek = Eo[0x2];
                                0x0 !== Ep && (rI(Ek, Ep), ro(EN, Ek, Eo[0x3]), EN["getTag"]()["insertRules"](Ep, EP)), (EP["length"] = 0x0);
                            } else EP["push"](EM);
                        }
                    }
                },
                rk = function () {
                    return "undefined" != typeof window && void 0x0 !== window["__webpack_nonce__"] ? window["__webpack_nonce__"] : null;
                },
                re = function (EN) {
                    var EX = document["head"],
                        Ef = EN || EX,
                        EP = document["createElement"]("style"),
                        EI = (function (Eo) {
                            for (var Ep = Eo["childNodes"], Ek = Ep["length"]; Ek >= 0x0; Ek--) {
                                var Ee = Ep[Ek];
                                if (Ee && 0x1 === Ee["nodeType"] && Ee["hasAttribute"](rZ)) return Ee;
                            }
                        })(Ef),
                        EA = void 0x0 !== EI ? EI["nextSibling"] : null;
                    EP["setAttribute"](rZ, "active"), EP["setAttribute"]("data-styled-version", "5.3.3");
                    var EM = rk();
                    return EM && EP["setAttribute"]("nonce", EM), Ef["insertBefore"](EP, EA), EP;
                },
                rl = (function () {
                    function EN(Ef) {
                        var EP = (this["element"] = re(Ef));
                        EP["appendChild"](document["createTextNode"]("")),
                            (this["sheet"] = (function (EI) {
                                if (EI["sheet"]) return EI["sheet"];
                                for (var EA = document["styleSheets"], EM = 0x0, Eo = EA["length"]; EM < Eo; EM++) {
                                    var Ep = EA[EM];
                                    if (Ep["ownerNode"] === EI) return Ep;
                                }
                                ru(0x11);
                            })(EP)),
                            (this["length"] = 0x0);
                    }
                    var EX = EN["prototype"];
                    return (
                        (EX["insertRule"] = function (Ef, EP) {
                            try {
                                return this["sheet"]["insertRule"](EP, Ef), this["length"]++, !0x0;
                            } catch (EI) {
                                return !0x1;
                            }
                        }),
                        (EX["deleteRule"] = function (Ef) {
                            this["sheet"]["deleteRule"](Ef), this["length"]--;
                        }),
                        (EX["getRule"] = function (Ef) {
                            var EP = this["sheet"]["cssRules"][Ef];
                            return void 0x0 !== EP && "string" == typeof EP["cssText"] ? EP["cssText"] : "";
                        }),
                        EN
                    );
                })(),
                rU = (function () {
                    function EN(Ef) {
                        var EP = (this["element"] = re(Ef));
                        (this["nodes"] = EP["childNodes"]), (this["length"] = 0x0);
                    }
                    var EX = EN["prototype"];
                    return (
                        (EX["insertRule"] = function (Ef, EP) {
                            if (Ef <= this["length"] && Ef >= 0x0) {
                                var EI = document["createTextNode"](EP),
                                    EA = this["nodes"][Ef];
                                return this["element"]["insertBefore"](EI, EA || null), this["length"]++, !0x0;
                            }
                            return !0x1;
                        }),
                        (EX["deleteRule"] = function (Ef) {
                            this["element"]["removeChild"](this["nodes"][Ef]), this["length"]--;
                        }),
                        (EX["getRule"] = function (Ef) {
                            return Ef < this["length"] ? this["nodes"][Ef]["textContent"] : "";
                        }),
                        EN
                    );
                })(),
                rq = (function () {
                    function EN(Ef) {
                        (this["rules"] = []), (this["length"] = 0x0);
                    }
                    var EX = EN["prototype"];
                    return (
                        (EX["insertRule"] = function (Ef, EP) {
                            return Ef <= this["length"] && (this["rules"]["splice"](Ef, 0x0, EP), this["length"]++, !0x0);
                        }),
                        (EX["deleteRule"] = function (Ef) {
                            this["rules"]["splice"](Ef, 0x1), this["length"]--;
                        }),
                        (EX["getRule"] = function (Ef) {
                            return Ef < this["length"] ? this["rules"][Ef] : "";
                        }),
                        EN
                    );
                })(),
                rw = rm,
                rO = { isServer: !rm, useCSSOMInjection: !rv },
                rj = (function () {
                    function EN(Ef, EP, EI) {
                        void 0x0 === Ef && (Ef = rn),
                            void 0x0 === EP && (EP = {}),
                            (this["options"] = rT({}, rO, {}, Ef)),
                            (this["gs"] = EP),
                            (this["names"] = new Map(EI)),
                            (this["server"] = !!Ef["isServer"]),
                            !this["server"] &&
                                rm &&
                                rw &&
                                ((rw = !0x1),
                                (function (EA) {
                                    for (var EM = document["querySelectorAll"](rA), Eo = 0x0, Ep = EM["length"]; Eo < Ep; Eo++) {
                                        var Ek = EM[Eo];
                                        Ek && "active" !== Ek["getAttribute"](rZ) && (rp(EA, Ek), Ek["parentNode"] && Ek["parentNode"]["removeChild"](Ek));
                                    }
                                })(this));
                    }
                    EN["registerId"] = function (Ef) {
                        return rf(Ef);
                    };
                    var EX = EN["prototype"];
                    return (
                        (EX["reconstructWithOptions"] = function (Ef, EP) {
                            return void 0x0 === EP && (EP = !0x0), new EN(rT({}, this["options"], {}, Ef), this["gs"], (EP && this["names"]) || void 0x0);
                        }),
                        (EX["allocateGSInstance"] = function (Ef) {
                            return (this["gs"][Ef] = (this["gs"][Ef] || 0x0) + 0x1);
                        }),
                        (EX["getTag"] = function () {
                            return this["tag"] || (this["tag"] = ((EI = (EP = this["options"])["isServer"]), (EA = EP["useCSSOMInjection"]), (EM = EP["target"]), (Ef = EI ? new rq(EM) : EA ? new rl(EM) : new rU(EM)), new ry(Ef)));
                            var Ef, EP, EI, EA, EM;
                        }),
                        (EX["hasNameForId"] = function (Ef, EP) {
                            return this["names"]["has"](Ef) && this["names"]["get"](Ef)["has"](EP);
                        }),
                        (EX["registerName"] = function (Ef, EP) {
                            if ((rf(Ef), this["names"]["has"](Ef))) this["names"]["get"](Ef)["add"](EP);
                            else {
                                var EI = new Set();
                                EI["add"](EP), this["names"]["set"](Ef, EI);
                            }
                        }),
                        (EX["insertRules"] = function (Ef, EP, EI) {
                            this["registerName"](Ef, EP), this["getTag"]()["insertRules"](rf(Ef), EI);
                        }),
                        (EX["clearNames"] = function (Ef) {
                            this["names"]["has"](Ef) && this["names"]["get"](Ef)["clear"]();
                        }),
                        (EX["clearRules"] = function (Ef) {
                            this["getTag"]()["clearGroup"](rf(Ef)), this["clearNames"](Ef);
                        }),
                        (EX["clearTag"] = function () {
                            this["tag"] = void 0x0;
                        }),
                        (EX["toString"] = function () {
                            return (function (Ef) {
                                for (var EP = Ef["getTag"](), EI = EP["length"], EA = "", EM = 0x0; EM < EI; EM++) {
                                    var Eo = rP(EM);
                                    if (void 0x0 !== Eo) {
                                        var Ep = Ef["names"]["get"](Eo),
                                            Ek = EP["getGroup"](EM);
                                        if (Ep && Ek && Ep["size"]) {
                                            var Ee = rZ + ".g" + EM + "[id=\x22" + Eo + "\x22]",
                                                El = "";
                                            void 0x0 !== Ep &&
                                                Ep["forEach"](function (EU) {
                                                    EU["length"] > 0x0 && (El += EU + ",");
                                                }),
                                                (EA += "" + Ek + Ee + "{content:\x22" + El + "\x22}/*!sc*/\x0a");
                                        }
                                    }
                                }
                                return EA;
                            })(this);
                        }),
                        EN
                    );
                })(),
                ri = /(a)(d)/gi,
                rh = function (EN) {
                    return String["fromCharCode"](EN + (EN > 0x19 ? 0x27 : 0x61));
                };
            function ra(EN) {
                var EX,
                    Ef = "";
                for (EX = Math["abs"](EN); EX > 0x34; EX = (EX / 0x34) | 0x0) Ef = rh(EX % 0x34) + Ef;
                return (rh(EX % 0x34) + Ef)["replace"](ri, "$1-$2");
            }
            var rc = function (EN, EX) {
                    for (var Ef = EX["length"]; Ef; ) EN = (0x21 * EN) ^ EX["charCodeAt"](--Ef);
                    return EN;
                },
                rS = function (EN) {
                    return rc(0x1505, EN);
                };
            function rg(EN) {
                for (var EX = 0x0; EX < EN["length"]; EX += 0x1) {
                    var Ef = EN[EX];
                    if (rB(Ef) && !rb(Ef)) return !0x1;
                }
                return !0x0;
            }
            var rW = rS("5.3.3"),
                rH = (function () {
                    function EN(EX, Ef, EP) {
                        (this["rules"] = EX),
                            (this["staticRulesId"] = ""),
                            (this["isStatic"] = (void 0x0 === EP || EP["isStatic"]) && rg(EX)),
                            (this["componentId"] = Ef),
                            (this["baseHash"] = rc(rW, Ef)),
                            (this["baseStyle"] = EP),
                            rj["registerId"](Ef);
                    }
                    return (
                        (EN["prototype"]["generateAndInjectStyles"] = function (EX, Ef, EP) {
                            var EI = this["componentId"],
                                EA = [];
                            if ((this["baseStyle"] && EA["push"](this["baseStyle"]["generateAndInjectStyles"](EX, Ef, EP)), this["isStatic"] && !EP["hash"])) {
                                if (this["staticRulesId"] && Ef["hasNameForId"](EI, this["staticRulesId"])) EA["push"](this["staticRulesId"]);
                                else {
                                    var EM = E8(this["rules"], EX, Ef, EP)["join"](""),
                                        Eo = ra(rc(this["baseHash"], EM) >>> 0x0);
                                    if (!Ef["hasNameForId"](EI, Eo)) {
                                        var Ep = EP(EM, "." + Eo, void 0x0, EI);
                                        Ef["insertRules"](EI, Eo, Ep);
                                    }
                                    EA["push"](Eo), (this["staticRulesId"] = Eo);
                                }
                            } else {
                                for (var Ek = this["rules"]["length"], Ee = rc(this["baseHash"], EP["hash"]), El = "", EU = 0x0; EU < Ek; EU++) {
                                    var Eq = this["rules"][EU];
                                    if ("string" == typeof Eq) El += Eq;
                                    else {
                                        if (Eq) {
                                            var Ew = E8(Eq, EX, Ef, EP),
                                                EO = Array["isArray"](Ew) ? Ew["join"]("") : Ew;
                                            (Ee = rc(Ee, EO + EU)), (El += EO);
                                        }
                                    }
                                }
                                if (El) {
                                    var Ej = ra(Ee >>> 0x0);
                                    if (!Ef["hasNameForId"](EI, Ej)) {
                                        var Ei = EP(El, "." + Ej, void 0x0, EI);
                                        Ef["insertRules"](EI, Ej, Ei);
                                    }
                                    EA["push"](Ej);
                                }
                            }
                            return EA["join"]("\x20");
                        }),
                        EN
                    );
                })(),
                rx = /^\s*\/\/.*$/gm,
                rK = [":", "[", ".", "#"];
            function rV(EN) {
                var EX,
                    Ef,
                    EP,
                    EI,
                    EA = void 0x0 === EN ? rn : EN,
                    EM = EA["options"],
                    Eo = void 0x0 === EM ? rn : EM,
                    Ep = EA["plugins"],
                    Ek = void 0x0 === Ep ? rY : Ep,
                    Ee = new r7(Eo),
                    El = [],
                    EU = (function (EO) {
                        function Ej(Ei) {
                            if (Ei)
                                try {
                                    EO(Ei + "}");
                                } catch (Eh) {}
                        }
                        return function (Ei, Eh, Ea, Ec, ES, Eg, EW, EH, Ex, EK) {
                            switch (Ei) {
                                case 0x1:
                                    if (0x0 === Ex && 0x40 === Eh["charCodeAt"](0x0)) return EO(Eh + ";"), "";
                                    break;
                                case 0x2:
                                    if (0x0 === EH) return Eh + "/*|*/";
                                    break;
                                case 0x3:
                                    switch (EH) {
                                        case 0x66:
                                        case 0x70:
                                            return EO(Ea[0x0] + Eh), "";
                                        default:
                                            return Eh + (0x0 === EK ? "/*|*/" : "");
                                    }
                                case -0x2:
                                    Eh["split"]("/*|*/}")["forEach"](Ej);
                            }
                        };
                    })(function (EO) {
                        El["push"](EO);
                    }),
                    Eq = function (EO, Ej, Ei) {
                        return (0x0 === Ej && -0x1 !== rK["indexOf"](Ei[Ef["length"]])) || Ei["match"](EI) ? EO : "." + EX;
                    };
                function Ew(EO, Ej, Ei, Eh) {
                    void 0x0 === Eh && (Eh = "&");
                    var Ea = EO["replace"](rx, ""),
                        Ec = Ej && Ei ? Ei + "\x20" + Ej + "\x20{\x20" + Ea + "\x20}" : Ea;
                    return (EX = Eh), (Ef = Ej), (EP = new RegExp("\x5c" + Ef + "\x5cb", "g")), (EI = new RegExp("(\x5c" + Ef + "\x5cb){2,}")), Ee(Ei || !Ej ? "" : Ej, Ec);
                }
                return (
                    Ee["use"](
                        []["concat"](Ek, [
                            function (EO, Ej, Ei) {
                                0x2 === EO && Ei["length"] && Ei[0x0]["lastIndexOf"](Ef) > 0x0 && (Ei[0x0] = Ei[0x0]["replace"](EP, Eq));
                            },
                            EU,
                            function (EO) {
                                if (-0x2 === EO) {
                                    var Ej = El;
                                    return (El = []), Ej;
                                }
                            },
                        ])
                    ),
                    (Ew["hash"] = Ek["length"]
                        ? Ek["reduce"](function (EO, Ej) {
                              return Ej["name"] || ru(0xf), rc(EO, Ej["name"]);
                          }, 0x1505)["toString"]()
                        : ""),
                    Ew
                );
            }
            var rs = r4["createContext"](),
                rJ = (rs["Consumer"], r4["createContext"]()),
                rG = (rJ["Consumer"], new rj()),
                rL = rV();
            function rQ() {
                return (0x0, r4["useContext"])(rs) || rG;
            }
            function rz() {
                return (0x0, r4["useContext"])(rJ) || rL;
            }
            function E0(EN) {
                var EX = (0x0, r4["useState"])(EN["stylisPlugins"]),
                    Ef = EX[0x0],
                    EP = EX[0x1],
                    EI = rQ(),
                    EA = (0x0, r4["useMemo"])(
                        function () {
                            var Eo = EI;
                            return (
                                EN["sheet"] ? (Eo = EN["sheet"]) : EN["target"] && (Eo = Eo["reconstructWithOptions"]({ target: EN["target"] }, !0x1)),
                                EN["disableCSSOMInjection"] && (Eo = Eo["reconstructWithOptions"]({ useCSSOMInjection: !0x1 })),
                                Eo
                            );
                        },
                        [EN["disableCSSOMInjection"], EN["sheet"], EN["target"]]
                    ),
                    EM = (0x0, r4["useMemo"])(
                        function () {
                            return rV({ options: { prefix: !EN["disableVendorPrefixes"] }, plugins: Ef });
                        },
                        [EN["disableVendorPrefixes"], Ef]
                    );
                return (
                    (0x0, r4["useEffect"])(
                        function () {
                            r6()(Ef, EN["stylisPlugins"]) || EP(EN["stylisPlugins"]);
                        },
                        [EN["stylisPlugins"]]
                    ),
                    r4["createElement"](rs["Provider"], { value: EA }, r4["createElement"](rJ["Provider"], { value: EM }, EN["children"]))
                );
            }
            var E1 = (function () {
                    function EN(EX, Ef) {
                        var EP = this;
                        (this["inject"] = function (EI, EA) {
                            void 0x0 === EA && (EA = rL);
                            var EM = EP["name"] + EA["hash"];
                            EI["hasNameForId"](EP["id"], EM) || EI["insertRules"](EP["id"], EM, EA(EP["rules"], EM, "@keyframes"));
                        }),
                            (this["toString"] = function () {
                                return ru(0xc, String(EP["name"]));
                            }),
                            (this["name"] = EX),
                            (this["id"] = "sc-keyframes-" + EX),
                            (this["rules"] = Ef);
                    }
                    return (
                        (EN["prototype"]["getName"] = function (EX) {
                            return void 0x0 === EX && (EX = rL), this["name"] + EX["hash"];
                        }),
                        EN
                    );
                })(),
                E2 = /([A-Z])/,
                E3 = /([A-Z])/g,
                E4 = /^ms-/,
                E5 = function (EN) {
                    return "-" + EN["toLowerCase"]();
                };
            function E6(EN) {
                return E2["test"](EN) ? EN["replace"](E3, E5)["replace"](E4, "-ms-") : EN;
            }
            var E7 = function (EN) {
                return null == EN || !0x1 === EN || "" === EN;
            };
            function E8(EN, EX, Ef, EP) {
                if (Array["isArray"](EN)) {
                    for (var EI, EA = [], EM = 0x0, Eo = EN["length"]; EM < Eo; EM += 0x1) "" !== (EI = E8(EN[EM], EX, Ef, EP)) && (Array["isArray"](EI) ? EA["push"]["apply"](EA, EI) : EA["push"](EI));
                    return EA;
                }
                return E7(EN)
                    ? ""
                    : rb(EN)
                    ? "." + EN["styledComponentId"]
                    : rB(EN)
                    ? "function" != typeof (Ep = EN) || (Ep["prototype"] && Ep["prototype"]["isReactComponent"]) || !EX
                        ? EN
                        : E8(EN(EX), EX, Ef, EP)
                    : EN instanceof E1
                    ? Ef
                        ? (EN["inject"](Ef, EP), EN["getName"](EP))
                        : EN
                    : rd(EN)
                    ? (function Ek(Ee, El) {
                          var EU,
                              Eq,
                              Ew = [];
                          for (var EO in Ee)
                              Ee["hasOwnProperty"](EO) &&
                                  !E7(Ee[EO]) &&
                                  ((Array["isArray"](Ee[EO]) && Ee[EO]["isCss"]) || rB(Ee[EO])
                                      ? Ew["push"](E6(EO) + ":", Ee[EO], ";")
                                      : rd(Ee[EO])
                                      ? Ew["push"]["apply"](Ew, Ek(Ee[EO], EO))
                                      : Ew["push"](
                                            E6(EO) + ":\x20" + ((EU = EO), (null == (Eq = Ee[EO]) || "boolean" == typeof Eq || "" === Eq ? "" : "number" != typeof Eq || 0x0 === Eq || EU in r8 ? String(Eq)["trim"]() : Eq + "px") + ";")
                                        ));
                          return El ? [El + "\x20{"]["concat"](Ew, ["}"]) : Ew;
                      })(EN)
                    : EN["toString"]();
                var Ep;
            }
            var E9 = function (EN) {
                return Array["isArray"](EN) && (EN["isCss"] = !0x0), EN;
            };
            function Er(EN) {
                for (var EX = arguments["length"], Ef = new Array(EX > 0x1 ? EX - 0x1 : 0x0), EP = 0x1; EP < EX; EP++) Ef[EP - 0x1] = arguments[EP];
                return rB(EN) || rd(EN) ? E9(E8(rC(rY, [EN]["concat"](Ef)))) : 0x0 === Ef["length"] && 0x1 === EN["length"] && "string" == typeof EN[0x0] ? EN : E9(E8(rC(EN, Ef)));
            }
            new Set();
            var EE = function (EN, EX, Ef) {
                    return void 0x0 === Ef && (Ef = rn), (EN["theme"] !== Ef["theme"] && EN["theme"]) || EX || Ef["theme"];
                },
                ER = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
                ET = /(^-|-$)/g;
            function EC(EN) {
                return EN["replace"](ER, "-")["replace"](ET, "");
            }
            var Ed = function (EN) {
                return ra(rS(EN) >>> 0x0);
            };
            function EY(EN) {
                return "string" == typeof EN && !0x0;
            }
            var En = function (EN) {
                    return "function" == typeof EN || ("object" == typeof EN && null !== EN && !Array["isArray"](EN));
                },
                EB = function (EN) {
                    return "__proto__" !== EN && "constructor" !== EN && "prototype" !== EN;
                };
            function EF(EN, EX, Ef) {
                var EP = EN[Ef];
                En(EX) && En(EP) ? Eb(EP, EX) : (EN[Ef] = EX);
            }
            function Eb(EN) {
                for (var EX = arguments["length"], Ef = new Array(EX > 0x1 ? EX - 0x1 : 0x0), EP = 0x1; EP < EX; EP++) Ef[EP - 0x1] = arguments[EP];
                for (var EI = 0x0, EA = Ef; EI < EA["length"]; EI++) {
                    var EM = EA[EI];
                    if (En(EM)) {
                        for (var Eo in EM) EB(Eo) && EF(EN, EM[Eo], Eo);
                    }
                }
                return EN;
            }
            var EZ = r4["createContext"]();
            EZ["Consumer"];
            var Em = {};
            function Ev(EN, EX, Ef) {
                var EP = rb(EN),
                    EI = !EY(EN),
                    EA = EX["attrs"],
                    EM = void 0x0 === EA ? rY : EA,
                    Eo = EX["componentId"],
                    Ep =
                        void 0x0 === Eo
                            ? (function (Eh, Ea) {
                                  var Ec = "string" != typeof Eh ? "sc" : EC(Eh);
                                  Em[Ec] = (Em[Ec] || 0x0) + 0x1;
                                  var ES = Ec + "-" + Ed("5.3.3" + Ec + Em[Ec]);
                                  return Ea ? Ea + "-" + ES : ES;
                              })(EX["displayName"], EX["parentComponentId"])
                            : Eo,
                    Ek = EX["displayName"],
                    Ee =
                        void 0x0 === Ek
                            ? (function (Eh) {
                                  return EY(Eh) ? "styled." + Eh : "Styled(" + rF(Eh) + ")";
                              })(EN)
                            : Ek,
                    El = EX["displayName"] && EX["componentId"] ? EC(EX["displayName"]) + "-" + EX["componentId"] : EX["componentId"] || Ep,
                    EU = EP && EN["attrs"] ? Array["prototype"]["concat"](EN["attrs"], EM)["filter"](Boolean) : EM,
                    Eq = EX["shouldForwardProp"];
                EP &&
                    EN["shouldForwardProp"] &&
                    (Eq = EX["shouldForwardProp"]
                        ? function (Eh, Ea, Ec) {
                              return EN["shouldForwardProp"](Eh, Ea, Ec) && EX["shouldForwardProp"](Eh, Ea, Ec);
                          }
                        : EN["shouldForwardProp"]);
                var Ew,
                    EO = new rH(Ef, El, EP ? EN["componentStyle"] : void 0x0),
                    Ej = EO["isStatic"] && 0x0 === EM["length"],
                    Ei = function (Eh, Ea) {
                        return (function (Ec, ES, Eg, EW) {
                            var EH = Ec["attrs"],
                                Ex = Ec["componentStyle"],
                                EK = Ec["defaultProps"],
                                EV = Ec["foldedComponentIds"],
                                Es = Ec["shouldForwardProp"],
                                EJ = Ec["styledComponentId"],
                                EG = Ec["target"],
                                EL = (function (R7, R8, R9) {
                                    void 0x0 === R7 && (R7 = rn);
                                    var Rr = rT({}, R8, { theme: R7 }),
                                        RE = {};
                                    return (
                                        R9["forEach"](function (RR) {
                                            var RT,
                                                RC,
                                                Rd,
                                                RY = RR;
                                            for (RT in (rB(RY) && (RY = RY(Rr)), RY)) Rr[RT] = RE[RT] = "className" === RT ? ((RC = RE[RT]), (Rd = RY[RT]), RC && Rd ? RC + "\x20" + Rd : RC || Rd) : RY[RT];
                                        }),
                                        [Rr, RE]
                                    );
                                })(EE(ES, (0x0, r4["useContext"])(EZ), EK) || rn, ES, EH),
                                EQ = EL[0x0],
                                Ez = EL[0x1],
                                R0 = (function (R7, R8, R9, Rr) {
                                    var RE = rQ(),
                                        RR = rz();
                                    return R8 ? R7["generateAndInjectStyles"](rn, RE, RR) : R7["generateAndInjectStyles"](R9, RE, RR);
                                })(Ex, EW, EQ),
                                R1 = Eg,
                                R2 = Ez["$as"] || ES["$as"] || Ez["as"] || ES["as"] || EG,
                                R3 = EY(R2),
                                R4 = Ez !== ES ? rT({}, ES, {}, Ez) : ES,
                                R5 = {};
                            for (var R6 in R4) "$" !== R6[0x0] && "as" !== R6 && ("forwardedAs" === R6 ? (R5["as"] = R4[R6]) : (Es ? Es(R6, rr, R2) : !R3 || rr(R6)) && (R5[R6] = R4[R6]));
                            return (
                                ES["style"] && Ez["style"] !== ES["style"] && (R5["style"] = rT({}, ES["style"], {}, Ez["style"])),
                                (R5["className"] = Array["prototype"]
                                    ["concat"](EV, EJ, R0 !== EJ ? R0 : null, ES["className"], Ez["className"])
                                    ["filter"](Boolean)
                                    ["join"]("\x20")),
                                (R5["ref"] = R1),
                                (0x0, r4["createElement"])(R2, R5)
                            );
                        })(Ew, Eh, Ea, Ej);
                    };
                return (
                    (Ei["displayName"] = Ee),
                    ((Ew = r4["forwardRef"](Ei))["attrs"] = EU),
                    (Ew["componentStyle"] = EO),
                    (Ew["displayName"] = Ee),
                    (Ew["shouldForwardProp"] = Eq),
                    (Ew["foldedComponentIds"] = EP ? Array["prototype"]["concat"](EN["foldedComponentIds"], EN["styledComponentId"]) : rY),
                    (Ew["styledComponentId"] = El),
                    (Ew["target"] = EP ? EN["target"] : EN),
                    (Ew["withComponent"] = function (Eh) {
                        var Ea = EX["componentId"],
                            Ec = (function (Eg, EW) {
                                if (null == Eg) return {};
                                var EH,
                                    Ex,
                                    EK = {},
                                    EV = Object["keys"](Eg);
                                for (Ex = 0x0; Ex < EV["length"]; Ex++) (EH = EV[Ex]), EW["indexOf"](EH) >= 0x0 || (EK[EH] = Eg[EH]);
                                return EK;
                            })(EX, ["componentId"]),
                            ES = Ea && Ea + "-" + (EY(Eh) ? Eh : EC(rF(Eh)));
                        return Ev(Eh, rT({}, Ec, { attrs: EU, componentId: ES }), Ef);
                    }),
                    Object["defineProperty"](Ew, "defaultProps", {
                        get: function () {
                            return this["_foldedDefaultProps"];
                        },
                        set: function (Eh) {
                            this["_foldedDefaultProps"] = EP ? Eb({}, EN["defaultProps"], Eh) : Eh;
                        },
                    }),
                    (Ew["toString"] = function () {
                        return "." + Ew["styledComponentId"];
                    }),
                    EI && rR()(Ew, EN, { attrs: !0x0, componentStyle: !0x0, displayName: !0x0, foldedComponentIds: !0x0, shouldForwardProp: !0x0, styledComponentId: !0x0, target: !0x0, withComponent: !0x0 }),
                    Ew
                );
            }
            var Eu = function (EN) {
                return (function EX(Ef, EP, EI) {
                    if ((void 0x0 === EI && (EI = rn), !(0x0, r3["isValidElementType"])(EP))) return ru(0x1, String(EP));
                    var EA = function () {
                        return Ef(EP, EI, Er["apply"](void 0x0, arguments));
                    };
                    return (
                        (EA["withConfig"] = function (EM) {
                            return EX(Ef, EP, rT({}, EI, {}, EM));
                        }),
                        (EA["attrs"] = function (EM) {
                            return EX(Ef, EP, rT({}, EI, { attrs: Array["prototype"]["concat"](EI["attrs"], EM)["filter"](Boolean) }));
                        }),
                        EA
                    );
                })(Ev, EN);
            };
            [
                "a",
                "abbr",
                "address",
                "area",
                "article",
                "aside",
                "audio",
                "b",
                "base",
                "bdi",
                "bdo",
                "big",
                "blockquote",
                "body",
                "br",
                "button",
                "canvas",
                "caption",
                "cite",
                "code",
                "col",
                "colgroup",
                "data",
                "datalist",
                "dd",
                "del",
                "details",
                "dfn",
                "dialog",
                "div",
                "dl",
                "dt",
                "em",
                "embed",
                "fieldset",
                "figcaption",
                "figure",
                "footer",
                "form",
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6",
                "head",
                "header",
                "hgroup",
                "hr",
                "html",
                "i",
                "iframe",
                "img",
                "input",
                "ins",
                "kbd",
                "keygen",
                "label",
                "legend",
                "li",
                "link",
                "main",
                "map",
                "mark",
                "marquee",
                "menu",
                "menuitem",
                "meta",
                "meter",
                "nav",
                "noscript",
                "object",
                "ol",
                "optgroup",
                "option",
                "output",
                "p",
                "param",
                "picture",
                "pre",
                "progress",
                "q",
                "rp",
                "rt",
                "ruby",
                "s",
                "samp",
                "script",
                "section",
                "select",
                "small",
                "source",
                "span",
                "strong",
                "style",
                "sub",
                "summary",
                "sup",
                "table",
                "tbody",
                "td",
                "textarea",
                "tfoot",
                "th",
                "thead",
                "time",
                "title",
                "tr",
                "track",
                "u",
                "ul",
                "var",
                "video",
                "wbr",
                "circle",
                "clipPath",
                "defs",
                "ellipse",
                "foreignObject",
                "g",
                "image",
                "line",
                "linearGradient",
                "marker",
                "mask",
                "path",
                "pattern",
                "polygon",
                "polyline",
                "radialGradient",
                "rect",
                "stop",
                "svg",
                "text",
                "textPath",
                "tspan",
            ]["forEach"](function (EN) {
                Eu[EN] = Eu(EN);
            }),
                !(function () {
                    function EN(Ef, EP) {
                        (this["rules"] = Ef), (this["componentId"] = EP), (this["isStatic"] = rg(Ef)), rj["registerId"](this["componentId"] + 0x1);
                    }
                    var EX = EN["prototype"];
                    (EX["createStyles"] = function (Ef, EP, EI, EA) {
                        var EM = EA(E8(this["rules"], EP, EI, EA)["join"](""), ""),
                            Eo = this["componentId"] + Ef;
                        EI["insertRules"](Eo, Eo, EM);
                    }),
                        (EX["removeStyles"] = function (Ef, EP) {
                            EP["clearRules"](this["componentId"] + Ef);
                        }),
                        (EX["renderStyles"] = function (Ef, EP, EI, EA) {
                            Ef > 0x2 && rj["registerId"](this["componentId"] + Ef), this["removeStyles"](Ef, EI), this["createStyles"](Ef, EP, EI, EA);
                        });
                })();
            function Ey(EN) {
                for (var EX = arguments["length"], Ef = new Array(EX > 0x1 ? EX - 0x1 : 0x0), EP = 0x1; EP < EX; EP++) Ef[EP - 0x1] = arguments[EP];
                var EI = Er["apply"](void 0x0, [EN]["concat"](Ef))["join"](""),
                    EA = Ed(EI);
                return new E1(EA, EI);
            }
            !(function () {
                function EN() {
                    var Ef = this;
                    (this["_emitSheetCSS"] = function () {
                        var EP = Ef["instance"]["toString"]();
                        if (!EP) return "";
                        var EI = rk();
                        return "<style\x20" + [EI && "nonce=\x22" + EI + "\x22", rZ + "=\x22true\x22", "data-styled-version=\x225.3.3\x22"]["filter"](Boolean)["join"]("\x20") + ">" + EP + "</style>";
                    }),
                        (this["getStyleTags"] = function () {
                            return Ef["sealed"] ? ru(0x2) : Ef["_emitSheetCSS"]();
                        }),
                        (this["getStyleElement"] = function () {
                            var EP;
                            if (Ef["sealed"]) return ru(0x2);
                            var EI = (((EP = {})[rZ] = ""), (EP["data-styled-version"] = "5.3.3"), (EP["dangerouslySetInnerHTML"] = { __html: Ef["instance"]["toString"]() }), EP),
                                EA = rk();
                            return EA && (EI["nonce"] = EA), [r4["createElement"]("style", rT({}, EI, { key: "sc-0-0" }))];
                        }),
                        (this["seal"] = function () {
                            Ef["sealed"] = !0x0;
                        }),
                        (this["instance"] = new rj({ isServer: !0x0 })),
                        (this["sealed"] = !0x1);
                }
                var EX = EN["prototype"];
                (EX["collectStyles"] = function (Ef) {
                    return this["sealed"] ? ru(0x2) : r4["createElement"](E0, { sheet: this["instance"] }, Ef);
                }),
                    (EX["interleaveWithNodeStream"] = function (Ef) {
                        return ru(0x3);
                    });
            })();
            var ED = Eu;
        },
        0x8a4: function (r0, r1, r2) {
            "use strict";
            r2["d"](r1, {
                Mig: function () {
                    return b8;
                },
                m7l: function () {
                    return FT;
                },
                Xcj: function () {
                    return ZE;
                },
                BbS: function () {
                    return bg;
                },
                Hmr: function () {
                    return bI;
                },
                SJI: function () {
                    return bS;
                },
                mTL: function () {
                    return bA;
                },
                N$j: function () {
                    return Yx;
                },
                ZzF: function () {
                    return R4;
                },
                nvb: function () {
                    return Tj;
                },
                TlE: function () {
                    return Rx;
                },
                u9r: function () {
                    return TR;
                },
                CtF: function () {
                    return Fd;
                },
                ROQ: function () {
                    return nb;
                },
                uWy: function () {
                    return rR;
                },
                Ilk: function () {
                    return Rq;
                },
                Ox3: function () {
                    return b7;
                },
                ehD: function () {
                    return r6;
                },
                USm: function () {
                    return EX;
                },
                pBf: function () {
                    return rQ;
                },
                hH6: function () {
                    return FZ;
                },
                a$l: function () {
                    return T0;
                },
                ybr: function () {
                    return YT;
                },
                Wl3: function () {
                    return r5;
                },
                ZAu: function () {
                    return Y6;
                },
                vmT: function () {
                    return Fz;
                },
                lb7: function () {
                    return bY;
                },
                SPe: function () {
                    return YL;
                },
                vpT: function () {
                    return YC;
                },
                kB5: function () {
                    return YB;
                },
                _C8: function () {
                    return F0;
                },
                Syv: function () {
                    return rk;
                },
                NMF: function () {
                    return rU;
                },
                x12: function () {
                    return n4;
                },
                nls: function () {
                    return YQ;
                },
                blk: function () {
                    return n8;
                },
                ejS: function () {
                    return n7;
                },
                wem: function () {
                    return rB;
                },
                D1R: function () {
                    return rb;
                },
                qyh: function () {
                    return rF;
                },
                aNw: function () {
                    return FF;
                },
                Zp0: function () {
                    return bC;
                },
                jAl: function () {
                    return rM;
                },
                YKA: function () {
                    return rp;
                },
                RsA: function () {
                    return r3;
                },
                F5T: function () {
                    return Rg;
                },
                M8C: function () {
                    return E2;
                },
                Vkp: function () {
                    return E4;
                },
                yGw: function () {
                    return Ey;
                },
                Kj0: function () {
                    return TA;
                },
                vBJ: function () {
                    return RW;
                },
                EJi: function () {
                    return BH;
                },
                Wid: function () {
                    return BW;
                },
                OoA: function () {
                    return rT;
                },
                M5h: function () {
                    return r7;
                },
                TyD: function () {
                    return rC;
                },
                aH4: function () {
                    return rY;
                },
                YLQ: function () {
                    return rd;
                },
                dUE: function () {
                    return F7;
                },
                Tme: function () {
                    return Eg;
                },
                iKG: function () {
                    return b5;
                },
                cPb: function () {
                    return Tx;
                },
                BKK: function () {
                    return C4;
                },
                cek: function () {
                    return b4;
                },
                woe: function () {
                    return nd;
                },
                UY4: function () {
                    return n9;
                },
                VYz: function () {
                    return bV;
                },
                iUV: function () {
                    return Z8;
                },
                _fP: function () {
                    return ER;
                },
                iLg: function () {
                    return F9;
                },
                wk1: function () {
                    return rf;
                },
                UCm: function () {
                    return rX;
                },
                rpg: function () {
                    return rE;
                },
                xsS: function () {
                    return EW;
                },
                jyz: function () {
                    return TW;
                },
                OdW: function () {
                    return YH;
                },
                _YX: function () {
                    return ZA;
                },
                TUv: function () {
                    return YS;
                },
                aLr: function () {
                    return R7;
                },
                $V: function () {
                    return ZB;
                },
                PMe: function () {
                    return b2;
                },
                jyi: function () {
                    return YM;
                },
                xeV: function () {
                    return YF;
                },
                QmN: function () {
                    return r4;
                },
                IOt: function () {
                    return rV;
                },
                xEZ: function () {
                    return E7;
                },
                dpR: function () {
                    return FX;
                },
                z$h: function () {
                    return rg;
                },
                UlW: function () {
                    return rS;
                },
                qlB: function () {
                    return RL;
                },
                WTc: function () {
                    return RV;
                },
                FM8: function () {
                    return E3;
                },
                Pa4: function () {
                    return Ed;
                },
                yC1: function () {
                    return FR;
                },
                CP7: function () {
                    return YE;
                },
                knz: function () {
                    return rH;
                },
            }),
                void 0x0 === Number["EPSILON"] && (Number["EPSILON"] = Math["pow"](0x2, -0x34)),
                void 0x0 === Number["isInteger"] &&
                    (Number["isInteger"] = function (mN) {
                        return "number" == typeof mN && isFinite(mN) && Math["floor"](mN) === mN;
                    }),
                void 0x0 === Math["sign"] &&
                    (Math["sign"] = function (mN) {
                        return mN < 0x0 ? -0x1 : mN > 0x0 ? 0x1 : +mN;
                    }),
                "name" in Function["prototype"] == !0x1 &&
                    Object["defineProperty"](Function["prototype"], "name", {
                        get: function () {
                            return this["toString"]()["match"](/^\s*function\s*([^\(\s]*)/)[0x1];
                        },
                    }),
                void 0x0 === Object["assign"] &&
                    (Object["assign"] = function (mN) {
                        if (null == mN) throw new TypeError("Cannot\x20convert\x20undefined\x20or\x20null\x20to\x20object");
                        const mX = Object(mN);
                        for (let mf = 0x1; mf < arguments["length"]; mf++) {
                            const mP = arguments[mf];
                            if (null != mP) {
                                for (const mI in mP) Object["prototype"]["hasOwnProperty"]["call"](mP, mI) && (mX[mI] = mP[mI]);
                            }
                        }
                        return mX;
                    });
            const r3 = { LEFT: 0x0, MIDDLE: 0x1, RIGHT: 0x2, ROTATE: 0x0, DOLLY: 0x1, PAN: 0x2 },
                r4 = { ROTATE: 0x0, PAN: 0x1, DOLLY_PAN: 0x2, DOLLY_ROTATE: 0x3 },
                r5 = 0x0,
                r6 = 0x2,
                r7 = 0x4,
                r8 = 0x64,
                r9 = 0x132,
                rE = 0x3e8,
                rR = 0x3e9,
                rT = 0x3ea,
                rC = 0x3eb,
                rd = 0x3ec,
                rY = 0x3ed,
                rB = 0x3ee,
                rF = 0x3ef,
                rb = 0x3f0,
                rZ = 0x3f1,
                rm = 0x3f4,
                rv = 0x3f6,
                ry = 0x3f7,
                rD = 0x3f8,
                rN = 0x3fc,
                rX = 0x3fe,
                rf = 0x3ff,
                rP = rf,
                rI = 0x402,
                rA = 0x403,
                rM = 0x898,
                rp = 0x899,
                rk = 0x8fc,
                rU = 0x8fd,
                rq = 0x8fe,
                rw = 0x960,
                rO = 0x961,
                rj = 0x962,
                rh = 0x9c4,
                rS = 0x1,
                rg = 0x2,
                rW = 0xbb8,
                rH = 0xbb9,
                rx = 0xbbf,
                rK = 0xbba,
                rV = 0x0,
                rJ = 0x1e00,
                rG = 0x88e4,
                rL = 0x88e8;
            function rQ() {}
            Object["assign"](rQ["prototype"], {
                addEventListener: function (mN, mX) {
                    void 0x0 === this["_listeners"] && (this["_listeners"] = {});
                    var mf = this["_listeners"];
                    void 0x0 === mf[mN] && (mf[mN] = []), -0x1 === mf[mN]["indexOf"](mX) && mf[mN]["push"](mX);
                },
                hasEventListener: function (mN, mX) {
                    if (void 0x0 === this["_listeners"]) return !0x1;
                    var mf = this["_listeners"];
                    return void 0x0 !== mf[mN] && -0x1 !== mf[mN]["indexOf"](mX);
                },
                removeEventListener: function (mN, mX) {
                    if (void 0x0 !== this["_listeners"]) {
                        var mf = this["_listeners"][mN];
                        if (void 0x0 !== mf) {
                            var mP = mf["indexOf"](mX);
                            -0x1 !== mP && mf["splice"](mP, 0x1);
                        }
                    }
                },
                dispatchEvent: function (mN) {
                    if (void 0x0 !== this["_listeners"]) {
                        var mX = this["_listeners"][mN["type"]];
                        if (void 0x0 !== mX) {
                            mN["target"] = this;
                            for (var mf = mX["slice"](0x0), mP = 0x0, mI = mf["length"]; mP < mI; mP++) mf[mP]["call"](this, mN);
                        }
                    }
                },
            });
            for (var rz = [], E0 = 0x0; E0 < 0x100; E0++) rz[E0] = (E0 < 0x10 ? "0" : "") + E0["toString"](0x10);
            var E1,
                E2 = {
                    DEG2RAD: Math["PI"] / 0xb4,
                    RAD2DEG: 0xb4 / Math["PI"],
                    generateUUID: function () {
                        var mN = (0xffffffff * Math["random"]()) | 0x0,
                            mX = (0xffffffff * Math["random"]()) | 0x0,
                            mf = (0xffffffff * Math["random"]()) | 0x0,
                            mP = (0xffffffff * Math["random"]()) | 0x0;
                        return (rz[0xff & mN] +
                            rz[(mN >> 0x8) & 0xff] +
                            rz[(mN >> 0x10) & 0xff] +
                            rz[(mN >> 0x18) & 0xff] +
                            "-" +
                            rz[0xff & mX] +
                            rz[(mX >> 0x8) & 0xff] +
                            "-" +
                            rz[((mX >> 0x10) & 0xf) | 0x40] +
                            rz[(mX >> 0x18) & 0xff] +
                            "-" +
                            rz[(0x3f & mf) | 0x80] +
                            rz[(mf >> 0x8) & 0xff] +
                            "-" +
                            rz[(mf >> 0x10) & 0xff] +
                            rz[(mf >> 0x18) & 0xff] +
                            rz[0xff & mP] +
                            rz[(mP >> 0x8) & 0xff] +
                            rz[(mP >> 0x10) & 0xff] +
                            rz[(mP >> 0x18) & 0xff])["toUpperCase"]();
                    },
                    clamp: function (mN, mX, mf) {
                        return Math["max"](mX, Math["min"](mf, mN));
                    },
                    euclideanModulo: function (mN, mX) {
                        return ((mN % mX) + mX) % mX;
                    },
                    mapLinear: function (mN, mX, mf, mP, mI) {
                        return mP + ((mN - mX) * (mI - mP)) / (mf - mX);
                    },
                    lerp: function (mN, mX, mf) {
                        return (0x1 - mf) * mN + mf * mX;
                    },
                    smoothstep: function (mN, mX, mf) {
                        return mN <= mX ? 0x0 : mN >= mf ? 0x1 : (mN = (mN - mX) / (mf - mX)) * mN * (0x3 - 0x2 * mN);
                    },
                    smootherstep: function (mN, mX, mf) {
                        return mN <= mX ? 0x0 : mN >= mf ? 0x1 : (mN = (mN - mX) / (mf - mX)) * mN * mN * (mN * (0x6 * mN - 0xf) + 0xa);
                    },
                    randInt: function (mN, mX) {
                        return mN + Math["floor"](Math["random"]() * (mX - mN + 0x1));
                    },
                    randFloat: function (mN, mX) {
                        return mN + Math["random"]() * (mX - mN);
                    },
                    randFloatSpread: function (mN) {
                        return mN * (0.5 - Math["random"]());
                    },
                    degToRad: function (mN) {
                        return mN * E2["DEG2RAD"];
                    },
                    radToDeg: function (mN) {
                        return mN * E2["RAD2DEG"];
                    },
                    isPowerOfTwo: function (mN) {
                        return 0x0 == (mN & (mN - 0x1)) && 0x0 !== mN;
                    },
                    ceilPowerOfTwo: function (mN) {
                        return Math["pow"](0x2, Math["ceil"](Math["log"](mN) / Math["LN2"]));
                    },
                    floorPowerOfTwo: function (mN) {
                        return Math["pow"](0x2, Math["floor"](Math["log"](mN) / Math["LN2"]));
                    },
                    setQuaternionFromProperEuler: function (mN, mX, mf, mP, mI) {
                        var mA = Math["cos"],
                            mM = Math["sin"],
                            mp = mA(mf / 0x2),
                            mk = mM(mf / 0x2),
                            mU = mA((mX + mP) / 0x2),
                            mq = mM((mX + mP) / 0x2),
                            mw = mA((mX - mP) / 0x2),
                            mO = mM((mX - mP) / 0x2),
                            mj = mA((mP - mX) / 0x2),
                            mh = mM((mP - mX) / 0x2);
                        switch (mI) {
                            case "XYX":
                                mN["set"](mp * mq, mk * mw, mk * mO, mp * mU);
                                break;
                            case "YZY":
                                mN["set"](mk * mO, mp * mq, mk * mw, mp * mU);
                                break;
                            case "ZXZ":
                                mN["set"](mk * mw, mk * mO, mp * mq, mp * mU);
                                break;
                            case "XZX":
                                mN["set"](mp * mq, mk * mh, mk * mj, mp * mU);
                                break;
                            case "YXY":
                                mN["set"](mk * mj, mp * mq, mk * mh, mp * mU);
                                break;
                            case "ZYZ":
                                mN["set"](mk * mh, mk * mj, mp * mq, mp * mU);
                                break;
                            default:
                                console["warn"]("THREE.MathUtils:\x20.setQuaternionFromProperEuler()\x20encountered\x20an\x20unknown\x20order:\x20" + mI);
                        }
                    },
                };
            function E3(mN, mX) {
                (this["x"] = mN || 0x0), (this["y"] = mX || 0x0);
            }
            function E4() {
                (this["elements"] = [0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1]), arguments["length"] > 0x0 && console["error"]("THREE.Matrix3:\x20the\x20constructor\x20no\x20longer\x20reads\x20arguments.\x20use\x20.set()\x20instead.");
            }
            Object["defineProperties"](E3["prototype"], {
                width: {
                    get: function () {
                        return this["x"];
                    },
                    set: function (mN) {
                        this["x"] = mN;
                    },
                },
                height: {
                    get: function () {
                        return this["y"];
                    },
                    set: function (mN) {
                        this["y"] = mN;
                    },
                },
            }),
                Object["assign"](E3["prototype"], {
                    isVector2: !0x0,
                    set: function (mN, mX) {
                        return (this["x"] = mN), (this["y"] = mX), this;
                    },
                    setScalar: function (mN) {
                        return (this["x"] = mN), (this["y"] = mN), this;
                    },
                    setX: function (mN) {
                        return (this["x"] = mN), this;
                    },
                    setY: function (mN) {
                        return (this["y"] = mN), this;
                    },
                    setComponent: function (mN, mX) {
                        switch (mN) {
                            case 0x0:
                                this["x"] = mX;
                                break;
                            case 0x1:
                                this["y"] = mX;
                                break;
                            default:
                                throw new Error("index\x20is\x20out\x20of\x20range:\x20" + mN);
                        }
                        return this;
                    },
                    getComponent: function (mN) {
                        switch (mN) {
                            case 0x0:
                                return this["x"];
                            case 0x1:
                                return this["y"];
                            default:
                                throw new Error("index\x20is\x20out\x20of\x20range:\x20" + mN);
                        }
                    },
                    clone: function () {
                        return new this["constructor"](this["x"], this["y"]);
                    },
                    copy: function (mN) {
                        return (this["x"] = mN["x"]), (this["y"] = mN["y"]), this;
                    },
                    add: function (mN, mX) {
                        return void 0x0 !== mX
                            ? (console["warn"]("THREE.Vector2:\x20.add()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.addVectors(\x20a,\x20b\x20)\x20instead."), this["addVectors"](mN, mX))
                            : ((this["x"] += mN["x"]), (this["y"] += mN["y"]), this);
                    },
                    addScalar: function (mN) {
                        return (this["x"] += mN), (this["y"] += mN), this;
                    },
                    addVectors: function (mN, mX) {
                        return (this["x"] = mN["x"] + mX["x"]), (this["y"] = mN["y"] + mX["y"]), this;
                    },
                    addScaledVector: function (mN, mX) {
                        return (this["x"] += mN["x"] * mX), (this["y"] += mN["y"] * mX), this;
                    },
                    sub: function (mN, mX) {
                        return void 0x0 !== mX
                            ? (console["warn"]("THREE.Vector2:\x20.sub()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.subVectors(\x20a,\x20b\x20)\x20instead."), this["subVectors"](mN, mX))
                            : ((this["x"] -= mN["x"]), (this["y"] -= mN["y"]), this);
                    },
                    subScalar: function (mN) {
                        return (this["x"] -= mN), (this["y"] -= mN), this;
                    },
                    subVectors: function (mN, mX) {
                        return (this["x"] = mN["x"] - mX["x"]), (this["y"] = mN["y"] - mX["y"]), this;
                    },
                    multiply: function (mN) {
                        return (this["x"] *= mN["x"]), (this["y"] *= mN["y"]), this;
                    },
                    multiplyScalar: function (mN) {
                        return (this["x"] *= mN), (this["y"] *= mN), this;
                    },
                    divide: function (mN) {
                        return (this["x"] /= mN["x"]), (this["y"] /= mN["y"]), this;
                    },
                    divideScalar: function (mN) {
                        return this["multiplyScalar"](0x1 / mN);
                    },
                    applyMatrix3: function (mN) {
                        var mX = this["x"],
                            mf = this["y"],
                            mP = mN["elements"];
                        return (this["x"] = mP[0x0] * mX + mP[0x3] * mf + mP[0x6]), (this["y"] = mP[0x1] * mX + mP[0x4] * mf + mP[0x7]), this;
                    },
                    min: function (mN) {
                        return (this["x"] = Math["min"](this["x"], mN["x"])), (this["y"] = Math["min"](this["y"], mN["y"])), this;
                    },
                    max: function (mN) {
                        return (this["x"] = Math["max"](this["x"], mN["x"])), (this["y"] = Math["max"](this["y"], mN["y"])), this;
                    },
                    clamp: function (mN, mX) {
                        return (this["x"] = Math["max"](mN["x"], Math["min"](mX["x"], this["x"]))), (this["y"] = Math["max"](mN["y"], Math["min"](mX["y"], this["y"]))), this;
                    },
                    clampScalar: function (mN, mX) {
                        return (this["x"] = Math["max"](mN, Math["min"](mX, this["x"]))), (this["y"] = Math["max"](mN, Math["min"](mX, this["y"]))), this;
                    },
                    clampLength: function (mN, mX) {
                        var mf = this["length"]();
                        return this["divideScalar"](mf || 0x1)["multiplyScalar"](Math["max"](mN, Math["min"](mX, mf)));
                    },
                    floor: function () {
                        return (this["x"] = Math["floor"](this["x"])), (this["y"] = Math["floor"](this["y"])), this;
                    },
                    ceil: function () {
                        return (this["x"] = Math["ceil"](this["x"])), (this["y"] = Math["ceil"](this["y"])), this;
                    },
                    round: function () {
                        return (this["x"] = Math["round"](this["x"])), (this["y"] = Math["round"](this["y"])), this;
                    },
                    roundToZero: function () {
                        return (this["x"] = this["x"] < 0x0 ? Math["ceil"](this["x"]) : Math["floor"](this["x"])), (this["y"] = this["y"] < 0x0 ? Math["ceil"](this["y"]) : Math["floor"](this["y"])), this;
                    },
                    negate: function () {
                        return (this["x"] = -this["x"]), (this["y"] = -this["y"]), this;
                    },
                    dot: function (mN) {
                        return this["x"] * mN["x"] + this["y"] * mN["y"];
                    },
                    cross: function (mN) {
                        return this["x"] * mN["y"] - this["y"] * mN["x"];
                    },
                    lengthSq: function () {
                        return this["x"] * this["x"] + this["y"] * this["y"];
                    },
                    length: function () {
                        return Math["sqrt"](this["x"] * this["x"] + this["y"] * this["y"]);
                    },
                    manhattanLength: function () {
                        return Math["abs"](this["x"]) + Math["abs"](this["y"]);
                    },
                    normalize: function () {
                        return this["divideScalar"](this["length"]() || 0x1);
                    },
                    angle: function () {
                        return Math["atan2"](-this["y"], -this["x"]) + Math["PI"];
                    },
                    distanceTo: function (mN) {
                        return Math["sqrt"](this["distanceToSquared"](mN));
                    },
                    distanceToSquared: function (mN) {
                        var mX = this["x"] - mN["x"],
                            mf = this["y"] - mN["y"];
                        return mX * mX + mf * mf;
                    },
                    manhattanDistanceTo: function (mN) {
                        return Math["abs"](this["x"] - mN["x"]) + Math["abs"](this["y"] - mN["y"]);
                    },
                    setLength: function (mN) {
                        return this["normalize"]()["multiplyScalar"](mN);
                    },
                    lerp: function (mN, mX) {
                        return (this["x"] += (mN["x"] - this["x"]) * mX), (this["y"] += (mN["y"] - this["y"]) * mX), this;
                    },
                    lerpVectors: function (mN, mX, mf) {
                        return (this["x"] = mN["x"] + (mX["x"] - mN["x"]) * mf), (this["y"] = mN["y"] + (mX["y"] - mN["y"]) * mf), this;
                    },
                    equals: function (mN) {
                        return mN["x"] === this["x"] && mN["y"] === this["y"];
                    },
                    fromArray: function (mN, mX) {
                        return void 0x0 === mX && (mX = 0x0), (this["x"] = mN[mX]), (this["y"] = mN[mX + 0x1]), this;
                    },
                    toArray: function (mN, mX) {
                        return void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0), (mN[mX] = this["x"]), (mN[mX + 0x1] = this["y"]), mN;
                    },
                    fromBufferAttribute: function (mN, mX, mf) {
                        return void 0x0 !== mf && console["warn"]("THREE.Vector2:\x20offset\x20has\x20been\x20removed\x20from\x20.fromBufferAttribute()."), (this["x"] = mN["getX"](mX)), (this["y"] = mN["getY"](mX)), this;
                    },
                    rotateAround: function (mN, mX) {
                        var mf = Math["cos"](mX),
                            mP = Math["sin"](mX),
                            mI = this["x"] - mN["x"],
                            mA = this["y"] - mN["y"];
                        return (this["x"] = mI * mf - mA * mP + mN["x"]), (this["y"] = mI * mP + mA * mf + mN["y"]), this;
                    },
                    random: function () {
                        return (this["x"] = Math["random"]()), (this["y"] = Math["random"]()), this;
                    },
                }),
                Object["assign"](E4["prototype"], {
                    isMatrix3: !0x0,
                    set: function (mN, mX, mf, mP, mI, mA, mM, mp, mk) {
                        var mU = this["elements"];
                        return (mU[0x0] = mN), (mU[0x1] = mP), (mU[0x2] = mM), (mU[0x3] = mX), (mU[0x4] = mI), (mU[0x5] = mp), (mU[0x6] = mf), (mU[0x7] = mA), (mU[0x8] = mk), this;
                    },
                    identity: function () {
                        return this["set"](0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1), this;
                    },
                    clone: function () {
                        return new this["constructor"]()["fromArray"](this["elements"]);
                    },
                    copy: function (mN) {
                        var mX = this["elements"],
                            mf = mN["elements"];
                        return (mX[0x0] = mf[0x0]), (mX[0x1] = mf[0x1]), (mX[0x2] = mf[0x2]), (mX[0x3] = mf[0x3]), (mX[0x4] = mf[0x4]), (mX[0x5] = mf[0x5]), (mX[0x6] = mf[0x6]), (mX[0x7] = mf[0x7]), (mX[0x8] = mf[0x8]), this;
                    },
                    extractBasis: function (mN, mX, mf) {
                        return mN["setFromMatrix3Column"](this, 0x0), mX["setFromMatrix3Column"](this, 0x1), mf["setFromMatrix3Column"](this, 0x2), this;
                    },
                    setFromMatrix4: function (mN) {
                        var mX = mN["elements"];
                        return this["set"](mX[0x0], mX[0x4], mX[0x8], mX[0x1], mX[0x5], mX[0x9], mX[0x2], mX[0x6], mX[0xa]), this;
                    },
                    multiply: function (mN) {
                        return this["multiplyMatrices"](this, mN);
                    },
                    premultiply: function (mN) {
                        return this["multiplyMatrices"](mN, this);
                    },
                    multiplyMatrices: function (mN, mX) {
                        var mf = mN["elements"],
                            mP = mX["elements"],
                            mI = this["elements"],
                            mA = mf[0x0],
                            mM = mf[0x3],
                            mp = mf[0x6],
                            mk = mf[0x1],
                            mU = mf[0x4],
                            mq = mf[0x7],
                            mw = mf[0x2],
                            mO = mf[0x5],
                            mj = mf[0x8],
                            mh = mP[0x0],
                            mS = mP[0x3],
                            mg = mP[0x6],
                            mW = mP[0x1],
                            mH = mP[0x4],
                            mx = mP[0x7],
                            mK = mP[0x2],
                            mV = mP[0x5],
                            mJ = mP[0x8];
                        return (
                            (mI[0x0] = mA * mh + mM * mW + mp * mK),
                            (mI[0x3] = mA * mS + mM * mH + mp * mV),
                            (mI[0x6] = mA * mg + mM * mx + mp * mJ),
                            (mI[0x1] = mk * mh + mU * mW + mq * mK),
                            (mI[0x4] = mk * mS + mU * mH + mq * mV),
                            (mI[0x7] = mk * mg + mU * mx + mq * mJ),
                            (mI[0x2] = mw * mh + mO * mW + mj * mK),
                            (mI[0x5] = mw * mS + mO * mH + mj * mV),
                            (mI[0x8] = mw * mg + mO * mx + mj * mJ),
                            this
                        );
                    },
                    multiplyScalar: function (mN) {
                        var mX = this["elements"];
                        return (mX[0x0] *= mN), (mX[0x3] *= mN), (mX[0x6] *= mN), (mX[0x1] *= mN), (mX[0x4] *= mN), (mX[0x7] *= mN), (mX[0x2] *= mN), (mX[0x5] *= mN), (mX[0x8] *= mN), this;
                    },
                    determinant: function () {
                        var mN = this["elements"],
                            mX = mN[0x0],
                            mf = mN[0x1],
                            mP = mN[0x2],
                            mI = mN[0x3],
                            mA = mN[0x4],
                            mM = mN[0x5],
                            mp = mN[0x6],
                            mk = mN[0x7],
                            mU = mN[0x8];
                        return mX * mA * mU - mX * mM * mk - mf * mI * mU + mf * mM * mp + mP * mI * mk - mP * mA * mp;
                    },
                    getInverse: function (mN, mX) {
                        void 0x0 !== mX && console["warn"]("THREE.Matrix3:\x20.getInverse()\x20can\x20no\x20longer\x20be\x20configured\x20to\x20throw\x20on\x20degenerate.");
                        var mf = mN["elements"],
                            mP = this["elements"],
                            mI = mf[0x0],
                            mA = mf[0x1],
                            mM = mf[0x2],
                            mp = mf[0x3],
                            mk = mf[0x4],
                            mU = mf[0x5],
                            mq = mf[0x6],
                            mw = mf[0x7],
                            mO = mf[0x8],
                            mj = mO * mk - mU * mw,
                            mh = mU * mq - mO * mp,
                            mS = mw * mp - mk * mq,
                            mg = mI * mj + mA * mh + mM * mS;
                        if (0x0 === mg) return this["set"](0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
                        var mW = 0x1 / mg;
                        return (
                            (mP[0x0] = mj * mW),
                            (mP[0x1] = (mM * mw - mO * mA) * mW),
                            (mP[0x2] = (mU * mA - mM * mk) * mW),
                            (mP[0x3] = mh * mW),
                            (mP[0x4] = (mO * mI - mM * mq) * mW),
                            (mP[0x5] = (mM * mp - mU * mI) * mW),
                            (mP[0x6] = mS * mW),
                            (mP[0x7] = (mA * mq - mw * mI) * mW),
                            (mP[0x8] = (mk * mI - mA * mp) * mW),
                            this
                        );
                    },
                    transpose: function () {
                        var mN,
                            mX = this["elements"];
                        return (mN = mX[0x1]), (mX[0x1] = mX[0x3]), (mX[0x3] = mN), (mN = mX[0x2]), (mX[0x2] = mX[0x6]), (mX[0x6] = mN), (mN = mX[0x5]), (mX[0x5] = mX[0x7]), (mX[0x7] = mN), this;
                    },
                    getNormalMatrix: function (mN) {
                        return this["setFromMatrix4"](mN)["getInverse"](this)["transpose"]();
                    },
                    transposeIntoArray: function (mN) {
                        var mX = this["elements"];
                        return (mN[0x0] = mX[0x0]), (mN[0x1] = mX[0x3]), (mN[0x2] = mX[0x6]), (mN[0x3] = mX[0x1]), (mN[0x4] = mX[0x4]), (mN[0x5] = mX[0x7]), (mN[0x6] = mX[0x2]), (mN[0x7] = mX[0x5]), (mN[0x8] = mX[0x8]), this;
                    },
                    setUvTransform: function (mN, mX, mf, mP, mI, mA, mM) {
                        var mp = Math["cos"](mI),
                            mk = Math["sin"](mI);
                        this["set"](mf * mp, mf * mk, -mf * (mp * mA + mk * mM) + mA + mN, -mP * mk, mP * mp, -mP * (-mk * mA + mp * mM) + mM + mX, 0x0, 0x0, 0x1);
                    },
                    scale: function (mN, mX) {
                        var mf = this["elements"];
                        return (mf[0x0] *= mN), (mf[0x3] *= mN), (mf[0x6] *= mN), (mf[0x1] *= mX), (mf[0x4] *= mX), (mf[0x7] *= mX), this;
                    },
                    rotate: function (mN) {
                        var mX = Math["cos"](mN),
                            mf = Math["sin"](mN),
                            mP = this["elements"],
                            mI = mP[0x0],
                            mA = mP[0x3],
                            mM = mP[0x6],
                            mp = mP[0x1],
                            mk = mP[0x4],
                            mU = mP[0x7];
                        return (mP[0x0] = mX * mI + mf * mp), (mP[0x3] = mX * mA + mf * mk), (mP[0x6] = mX * mM + mf * mU), (mP[0x1] = -mf * mI + mX * mp), (mP[0x4] = -mf * mA + mX * mk), (mP[0x7] = -mf * mM + mX * mU), this;
                    },
                    translate: function (mN, mX) {
                        var mf = this["elements"];
                        return (mf[0x0] += mN * mf[0x2]), (mf[0x3] += mN * mf[0x5]), (mf[0x6] += mN * mf[0x8]), (mf[0x1] += mX * mf[0x2]), (mf[0x4] += mX * mf[0x5]), (mf[0x7] += mX * mf[0x8]), this;
                    },
                    equals: function (mN) {
                        for (var mX = this["elements"], mf = mN["elements"], mP = 0x0; mP < 0x9; mP++) if (mX[mP] !== mf[mP]) return !0x1;
                        return !0x0;
                    },
                    fromArray: function (mN, mX) {
                        void 0x0 === mX && (mX = 0x0);
                        for (var mf = 0x0; mf < 0x9; mf++) this["elements"][mf] = mN[mf + mX];
                        return this;
                    },
                    toArray: function (mN, mX) {
                        void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0);
                        var mf = this["elements"];
                        return (
                            (mN[mX] = mf[0x0]),
                            (mN[mX + 0x1] = mf[0x1]),
                            (mN[mX + 0x2] = mf[0x2]),
                            (mN[mX + 0x3] = mf[0x3]),
                            (mN[mX + 0x4] = mf[0x4]),
                            (mN[mX + 0x5] = mf[0x5]),
                            (mN[mX + 0x6] = mf[0x6]),
                            (mN[mX + 0x7] = mf[0x7]),
                            (mN[mX + 0x8] = mf[0x8]),
                            mN
                        );
                    },
                });
            var E5 = {
                    getDataURL: function (mN) {
                        var mX;
                        if ("undefined" == typeof HTMLCanvasElement) return mN["src"];
                        if (mN instanceof HTMLCanvasElement) mX = mN;
                        else {
                            void 0x0 === E1 && (E1 = document["createElementNS"]("http://www.w3.org/1999/xhtml", "canvas")), (E1["width"] = mN["width"]), (E1["height"] = mN["height"]);
                            var mf = E1["getContext"]("2d");
                            mN instanceof ImageData ? mf["putImageData"](mN, 0x0, 0x0) : mf["drawImage"](mN, 0x0, 0x0, mN["width"], mN["height"]), (mX = E1);
                        }
                        return mX["width"] > 0x800 || mX["height"] > 0x800 ? mX["toDataURL"]("image/jpeg", 0.6) : mX["toDataURL"]("image/png");
                    },
                },
                E6 = 0x0;
            function E7(mN, mX, mf, mP, mI, mA, mM, mp, mk, mU) {
                Object["defineProperty"](this, "id", { value: E6++ }),
                    (this["uuid"] = E2["generateUUID"]()),
                    (this["name"] = ""),
                    (this["image"] = void 0x0 !== mN ? mN : E7["DEFAULT_IMAGE"]),
                    (this["mipmaps"] = []),
                    (this["mapping"] = void 0x0 !== mX ? mX : E7["DEFAULT_MAPPING"]),
                    (this["wrapS"] = void 0x0 !== mf ? mf : rR),
                    (this["wrapT"] = void 0x0 !== mP ? mP : rR),
                    (this["magFilter"] = void 0x0 !== mI ? mI : rB),
                    (this["minFilter"] = void 0x0 !== mA ? mA : rb),
                    (this["anisotropy"] = void 0x0 !== mk ? mk : 0x1),
                    (this["format"] = void 0x0 !== mM ? mM : rf),
                    (this["internalFormat"] = null),
                    (this["type"] = void 0x0 !== mp ? mp : rZ),
                    (this["offset"] = new E3(0x0, 0x0)),
                    (this["repeat"] = new E3(0x1, 0x1)),
                    (this["center"] = new E3(0x0, 0x0)),
                    (this["rotation"] = 0x0),
                    (this["matrixAutoUpdate"] = !0x0),
                    (this["matrix"] = new E4()),
                    (this["generateMipmaps"] = !0x0),
                    (this["premultiplyAlpha"] = !0x1),
                    (this["flipY"] = !0x0),
                    (this["unpackAlignment"] = 0x4),
                    (this["encoding"] = void 0x0 !== mU ? mU : rW),
                    (this["version"] = 0x0),
                    (this["onUpdate"] = null);
            }
            function E8(mN, mX, mf, mP) {
                (this["x"] = mN || 0x0), (this["y"] = mX || 0x0), (this["z"] = mf || 0x0), (this["w"] = void 0x0 !== mP ? mP : 0x1);
            }
            function E9(mN, mX, mf) {
                (this["width"] = mN),
                    (this["height"] = mX),
                    (this["scissor"] = new E8(0x0, 0x0, mN, mX)),
                    (this["scissorTest"] = !0x1),
                    (this["viewport"] = new E8(0x0, 0x0, mN, mX)),
                    (mf = mf || {}),
                    (this["texture"] = new E7(void 0x0, mf["mapping"], mf["wrapS"], mf["wrapT"], mf["magFilter"], mf["minFilter"], mf["format"], mf["type"], mf["anisotropy"], mf["encoding"])),
                    (this["texture"]["image"] = {}),
                    (this["texture"]["image"]["width"] = mN),
                    (this["texture"]["image"]["height"] = mX),
                    (this["texture"]["generateMipmaps"] = void 0x0 !== mf["generateMipmaps"] && mf["generateMipmaps"]),
                    (this["texture"]["minFilter"] = void 0x0 !== mf["minFilter"] ? mf["minFilter"] : rB),
                    (this["depthBuffer"] = void 0x0 === mf["depthBuffer"] || mf["depthBuffer"]),
                    (this["stencilBuffer"] = void 0x0 === mf["stencilBuffer"] || mf["stencilBuffer"]),
                    (this["depthTexture"] = void 0x0 !== mf["depthTexture"] ? mf["depthTexture"] : null);
            }
            function EE(mN, mX, mf) {
                E9["call"](this, mN, mX, mf), (this["samples"] = 0x4);
            }
            function ER(mN, mX, mf, mP) {
                (this["_x"] = mN || 0x0), (this["_y"] = mX || 0x0), (this["_z"] = mf || 0x0), (this["_w"] = void 0x0 !== mP ? mP : 0x1);
            }
            (E7["DEFAULT_IMAGE"] = void 0x0),
                (E7["DEFAULT_MAPPING"] = 0x12c),
                (E7["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                    constructor: E7,
                    isTexture: !0x0,
                    updateMatrix: function () {
                        this["matrix"]["setUvTransform"](this["offset"]["x"], this["offset"]["y"], this["repeat"]["x"], this["repeat"]["y"], this["rotation"], this["center"]["x"], this["center"]["y"]);
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    copy: function (mN) {
                        return (
                            (this["name"] = mN["name"]),
                            (this["image"] = mN["image"]),
                            (this["mipmaps"] = mN["mipmaps"]["slice"](0x0)),
                            (this["mapping"] = mN["mapping"]),
                            (this["wrapS"] = mN["wrapS"]),
                            (this["wrapT"] = mN["wrapT"]),
                            (this["magFilter"] = mN["magFilter"]),
                            (this["minFilter"] = mN["minFilter"]),
                            (this["anisotropy"] = mN["anisotropy"]),
                            (this["format"] = mN["format"]),
                            (this["internalFormat"] = mN["internalFormat"]),
                            (this["type"] = mN["type"]),
                            this["offset"]["copy"](mN["offset"]),
                            this["repeat"]["copy"](mN["repeat"]),
                            this["center"]["copy"](mN["center"]),
                            (this["rotation"] = mN["rotation"]),
                            (this["matrixAutoUpdate"] = mN["matrixAutoUpdate"]),
                            this["matrix"]["copy"](mN["matrix"]),
                            (this["generateMipmaps"] = mN["generateMipmaps"]),
                            (this["premultiplyAlpha"] = mN["premultiplyAlpha"]),
                            (this["flipY"] = mN["flipY"]),
                            (this["unpackAlignment"] = mN["unpackAlignment"]),
                            (this["encoding"] = mN["encoding"]),
                            this
                        );
                    },
                    toJSON: function (mN) {
                        var mX = void 0x0 === mN || "string" == typeof mN;
                        if (!mX && void 0x0 !== mN["textures"][this["uuid"]]) return mN["textures"][this["uuid"]];
                        var mf = {
                            metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
                            uuid: this["uuid"],
                            name: this["name"],
                            mapping: this["mapping"],
                            repeat: [this["repeat"]["x"], this["repeat"]["y"]],
                            offset: [this["offset"]["x"], this["offset"]["y"]],
                            center: [this["center"]["x"], this["center"]["y"]],
                            rotation: this["rotation"],
                            wrap: [this["wrapS"], this["wrapT"]],
                            format: this["format"],
                            type: this["type"],
                            encoding: this["encoding"],
                            minFilter: this["minFilter"],
                            magFilter: this["magFilter"],
                            anisotropy: this["anisotropy"],
                            flipY: this["flipY"],
                            premultiplyAlpha: this["premultiplyAlpha"],
                            unpackAlignment: this["unpackAlignment"],
                        };
                        if (void 0x0 !== this["image"]) {
                            var mP = this["image"];
                            if ((void 0x0 === mP["uuid"] && (mP["uuid"] = E2["generateUUID"]()), !mX && void 0x0 === mN["images"][mP["uuid"]])) {
                                var mI;
                                if (Array["isArray"](mP)) {
                                    mI = [];
                                    for (var mA = 0x0, mM = mP["length"]; mA < mM; mA++) mI["push"](E5["getDataURL"](mP[mA]));
                                } else mI = E5["getDataURL"](mP);
                                mN["images"][mP["uuid"]] = { uuid: mP["uuid"], url: mI };
                            }
                            mf["image"] = mP["uuid"];
                        }
                        return mX || (mN["textures"][this["uuid"]] = mf), mf;
                    },
                    dispose: function () {
                        this["dispatchEvent"]({ type: "dispose" });
                    },
                    transformUv: function (mN) {
                        if (0x12c !== this["mapping"]) return mN;
                        if ((mN["applyMatrix3"](this["matrix"]), mN["x"] < 0x0 || mN["x"] > 0x1))
                            switch (this["wrapS"]) {
                                case rE:
                                    mN["x"] = mN["x"] - Math["floor"](mN["x"]);
                                    break;
                                case rR:
                                    mN["x"] = mN["x"] < 0x0 ? 0x0 : 0x1;
                                    break;
                                case rT:
                                    0x1 === Math["abs"](Math["floor"](mN["x"]) % 0x2) ? (mN["x"] = Math["ceil"](mN["x"]) - mN["x"]) : (mN["x"] = mN["x"] - Math["floor"](mN["x"]));
                            }
                        if (mN["y"] < 0x0 || mN["y"] > 0x1)
                            switch (this["wrapT"]) {
                                case rE:
                                    mN["y"] = mN["y"] - Math["floor"](mN["y"]);
                                    break;
                                case rR:
                                    mN["y"] = mN["y"] < 0x0 ? 0x0 : 0x1;
                                    break;
                                case rT:
                                    0x1 === Math["abs"](Math["floor"](mN["y"]) % 0x2) ? (mN["y"] = Math["ceil"](mN["y"]) - mN["y"]) : (mN["y"] = mN["y"] - Math["floor"](mN["y"]));
                            }
                        return this["flipY"] && (mN["y"] = 0x1 - mN["y"]), mN;
                    },
                })),
                Object["defineProperty"](E7["prototype"], "needsUpdate", {
                    set: function (mN) {
                        !0x0 === mN && this["version"]++;
                    },
                }),
                Object["defineProperties"](E8["prototype"], {
                    width: {
                        get: function () {
                            return this["z"];
                        },
                        set: function (mN) {
                            this["z"] = mN;
                        },
                    },
                    height: {
                        get: function () {
                            return this["w"];
                        },
                        set: function (mN) {
                            this["w"] = mN;
                        },
                    },
                }),
                Object["assign"](E8["prototype"], {
                    isVector4: !0x0,
                    set: function (mN, mX, mf, mP) {
                        return (this["x"] = mN), (this["y"] = mX), (this["z"] = mf), (this["w"] = mP), this;
                    },
                    setScalar: function (mN) {
                        return (this["x"] = mN), (this["y"] = mN), (this["z"] = mN), (this["w"] = mN), this;
                    },
                    setX: function (mN) {
                        return (this["x"] = mN), this;
                    },
                    setY: function (mN) {
                        return (this["y"] = mN), this;
                    },
                    setZ: function (mN) {
                        return (this["z"] = mN), this;
                    },
                    setW: function (mN) {
                        return (this["w"] = mN), this;
                    },
                    setComponent: function (mN, mX) {
                        switch (mN) {
                            case 0x0:
                                this["x"] = mX;
                                break;
                            case 0x1:
                                this["y"] = mX;
                                break;
                            case 0x2:
                                this["z"] = mX;
                                break;
                            case 0x3:
                                this["w"] = mX;
                                break;
                            default:
                                throw new Error("index\x20is\x20out\x20of\x20range:\x20" + mN);
                        }
                        return this;
                    },
                    getComponent: function (mN) {
                        switch (mN) {
                            case 0x0:
                                return this["x"];
                            case 0x1:
                                return this["y"];
                            case 0x2:
                                return this["z"];
                            case 0x3:
                                return this["w"];
                            default:
                                throw new Error("index\x20is\x20out\x20of\x20range:\x20" + mN);
                        }
                    },
                    clone: function () {
                        return new this["constructor"](this["x"], this["y"], this["z"], this["w"]);
                    },
                    copy: function (mN) {
                        return (this["x"] = mN["x"]), (this["y"] = mN["y"]), (this["z"] = mN["z"]), (this["w"] = void 0x0 !== mN["w"] ? mN["w"] : 0x1), this;
                    },
                    add: function (mN, mX) {
                        return void 0x0 !== mX
                            ? (console["warn"]("THREE.Vector4:\x20.add()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.addVectors(\x20a,\x20b\x20)\x20instead."), this["addVectors"](mN, mX))
                            : ((this["x"] += mN["x"]), (this["y"] += mN["y"]), (this["z"] += mN["z"]), (this["w"] += mN["w"]), this);
                    },
                    addScalar: function (mN) {
                        return (this["x"] += mN), (this["y"] += mN), (this["z"] += mN), (this["w"] += mN), this;
                    },
                    addVectors: function (mN, mX) {
                        return (this["x"] = mN["x"] + mX["x"]), (this["y"] = mN["y"] + mX["y"]), (this["z"] = mN["z"] + mX["z"]), (this["w"] = mN["w"] + mX["w"]), this;
                    },
                    addScaledVector: function (mN, mX) {
                        return (this["x"] += mN["x"] * mX), (this["y"] += mN["y"] * mX), (this["z"] += mN["z"] * mX), (this["w"] += mN["w"] * mX), this;
                    },
                    sub: function (mN, mX) {
                        return void 0x0 !== mX
                            ? (console["warn"]("THREE.Vector4:\x20.sub()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.subVectors(\x20a,\x20b\x20)\x20instead."), this["subVectors"](mN, mX))
                            : ((this["x"] -= mN["x"]), (this["y"] -= mN["y"]), (this["z"] -= mN["z"]), (this["w"] -= mN["w"]), this);
                    },
                    subScalar: function (mN) {
                        return (this["x"] -= mN), (this["y"] -= mN), (this["z"] -= mN), (this["w"] -= mN), this;
                    },
                    subVectors: function (mN, mX) {
                        return (this["x"] = mN["x"] - mX["x"]), (this["y"] = mN["y"] - mX["y"]), (this["z"] = mN["z"] - mX["z"]), (this["w"] = mN["w"] - mX["w"]), this;
                    },
                    multiplyScalar: function (mN) {
                        return (this["x"] *= mN), (this["y"] *= mN), (this["z"] *= mN), (this["w"] *= mN), this;
                    },
                    applyMatrix4: function (mN) {
                        var mX = this["x"],
                            mf = this["y"],
                            mP = this["z"],
                            mI = this["w"],
                            mA = mN["elements"];
                        return (
                            (this["x"] = mA[0x0] * mX + mA[0x4] * mf + mA[0x8] * mP + mA[0xc] * mI),
                            (this["y"] = mA[0x1] * mX + mA[0x5] * mf + mA[0x9] * mP + mA[0xd] * mI),
                            (this["z"] = mA[0x2] * mX + mA[0x6] * mf + mA[0xa] * mP + mA[0xe] * mI),
                            (this["w"] = mA[0x3] * mX + mA[0x7] * mf + mA[0xb] * mP + mA[0xf] * mI),
                            this
                        );
                    },
                    divideScalar: function (mN) {
                        return this["multiplyScalar"](0x1 / mN);
                    },
                    setAxisAngleFromQuaternion: function (mN) {
                        this["w"] = 0x2 * Math["acos"](mN["w"]);
                        var mX = Math["sqrt"](0x1 - mN["w"] * mN["w"]);
                        return mX < 0.0001 ? ((this["x"] = 0x1), (this["y"] = 0x0), (this["z"] = 0x0)) : ((this["x"] = mN["x"] / mX), (this["y"] = mN["y"] / mX), (this["z"] = mN["z"] / mX)), this;
                    },
                    setAxisAngleFromRotationMatrix: function (mN) {
                        var mX,
                            mf,
                            mP,
                            mI,
                            mA = 0.01,
                            mM = 0.1,
                            mp = mN["elements"],
                            mk = mp[0x0],
                            mU = mp[0x4],
                            mq = mp[0x8],
                            mw = mp[0x1],
                            mO = mp[0x5],
                            mj = mp[0x9],
                            mh = mp[0x2],
                            mS = mp[0x6],
                            mg = mp[0xa];
                        if (Math["abs"](mU - mw) < mA && Math["abs"](mq - mh) < mA && Math["abs"](mj - mS) < mA) {
                            if (Math["abs"](mU + mw) < mM && Math["abs"](mq + mh) < mM && Math["abs"](mj + mS) < mM && Math["abs"](mk + mO + mg - 0x3) < mM) return this["set"](0x1, 0x0, 0x0, 0x0), this;
                            mX = Math["PI"];
                            var mW = (mk + 0x1) / 0x2,
                                mH = (mO + 0x1) / 0x2,
                                mx = (mg + 0x1) / 0x2,
                                mK = (mU + mw) / 0x4,
                                mV = (mq + mh) / 0x4,
                                mJ = (mj + mS) / 0x4;
                            return (
                                mW > mH && mW > mx
                                    ? mW < mA
                                        ? ((mf = 0x0), (mP = 0.707106781), (mI = 0.707106781))
                                        : ((mP = mK / (mf = Math["sqrt"](mW))), (mI = mV / mf))
                                    : mH > mx
                                    ? mH < mA
                                        ? ((mf = 0.707106781), (mP = 0x0), (mI = 0.707106781))
                                        : ((mf = mK / (mP = Math["sqrt"](mH))), (mI = mJ / mP))
                                    : mx < mA
                                    ? ((mf = 0.707106781), (mP = 0.707106781), (mI = 0x0))
                                    : ((mf = mV / (mI = Math["sqrt"](mx))), (mP = mJ / mI)),
                                this["set"](mf, mP, mI, mX),
                                this
                            );
                        }
                        var mG = Math["sqrt"]((mS - mj) * (mS - mj) + (mq - mh) * (mq - mh) + (mw - mU) * (mw - mU));
                        return Math["abs"](mG) < 0.001 && (mG = 0x1), (this["x"] = (mS - mj) / mG), (this["y"] = (mq - mh) / mG), (this["z"] = (mw - mU) / mG), (this["w"] = Math["acos"]((mk + mO + mg - 0x1) / 0x2)), this;
                    },
                    min: function (mN) {
                        return (this["x"] = Math["min"](this["x"], mN["x"])), (this["y"] = Math["min"](this["y"], mN["y"])), (this["z"] = Math["min"](this["z"], mN["z"])), (this["w"] = Math["min"](this["w"], mN["w"])), this;
                    },
                    max: function (mN) {
                        return (this["x"] = Math["max"](this["x"], mN["x"])), (this["y"] = Math["max"](this["y"], mN["y"])), (this["z"] = Math["max"](this["z"], mN["z"])), (this["w"] = Math["max"](this["w"], mN["w"])), this;
                    },
                    clamp: function (mN, mX) {
                        return (
                            (this["x"] = Math["max"](mN["x"], Math["min"](mX["x"], this["x"]))),
                            (this["y"] = Math["max"](mN["y"], Math["min"](mX["y"], this["y"]))),
                            (this["z"] = Math["max"](mN["z"], Math["min"](mX["z"], this["z"]))),
                            (this["w"] = Math["max"](mN["w"], Math["min"](mX["w"], this["w"]))),
                            this
                        );
                    },
                    clampScalar: function (mN, mX) {
                        return (
                            (this["x"] = Math["max"](mN, Math["min"](mX, this["x"]))),
                            (this["y"] = Math["max"](mN, Math["min"](mX, this["y"]))),
                            (this["z"] = Math["max"](mN, Math["min"](mX, this["z"]))),
                            (this["w"] = Math["max"](mN, Math["min"](mX, this["w"]))),
                            this
                        );
                    },
                    clampLength: function (mN, mX) {
                        var mf = this["length"]();
                        return this["divideScalar"](mf || 0x1)["multiplyScalar"](Math["max"](mN, Math["min"](mX, mf)));
                    },
                    floor: function () {
                        return (this["x"] = Math["floor"](this["x"])), (this["y"] = Math["floor"](this["y"])), (this["z"] = Math["floor"](this["z"])), (this["w"] = Math["floor"](this["w"])), this;
                    },
                    ceil: function () {
                        return (this["x"] = Math["ceil"](this["x"])), (this["y"] = Math["ceil"](this["y"])), (this["z"] = Math["ceil"](this["z"])), (this["w"] = Math["ceil"](this["w"])), this;
                    },
                    round: function () {
                        return (this["x"] = Math["round"](this["x"])), (this["y"] = Math["round"](this["y"])), (this["z"] = Math["round"](this["z"])), (this["w"] = Math["round"](this["w"])), this;
                    },
                    roundToZero: function () {
                        return (
                            (this["x"] = this["x"] < 0x0 ? Math["ceil"](this["x"]) : Math["floor"](this["x"])),
                            (this["y"] = this["y"] < 0x0 ? Math["ceil"](this["y"]) : Math["floor"](this["y"])),
                            (this["z"] = this["z"] < 0x0 ? Math["ceil"](this["z"]) : Math["floor"](this["z"])),
                            (this["w"] = this["w"] < 0x0 ? Math["ceil"](this["w"]) : Math["floor"](this["w"])),
                            this
                        );
                    },
                    negate: function () {
                        return (this["x"] = -this["x"]), (this["y"] = -this["y"]), (this["z"] = -this["z"]), (this["w"] = -this["w"]), this;
                    },
                    dot: function (mN) {
                        return this["x"] * mN["x"] + this["y"] * mN["y"] + this["z"] * mN["z"] + this["w"] * mN["w"];
                    },
                    lengthSq: function () {
                        return this["x"] * this["x"] + this["y"] * this["y"] + this["z"] * this["z"] + this["w"] * this["w"];
                    },
                    length: function () {
                        return Math["sqrt"](this["x"] * this["x"] + this["y"] * this["y"] + this["z"] * this["z"] + this["w"] * this["w"]);
                    },
                    manhattanLength: function () {
                        return Math["abs"](this["x"]) + Math["abs"](this["y"]) + Math["abs"](this["z"]) + Math["abs"](this["w"]);
                    },
                    normalize: function () {
                        return this["divideScalar"](this["length"]() || 0x1);
                    },
                    setLength: function (mN) {
                        return this["normalize"]()["multiplyScalar"](mN);
                    },
                    lerp: function (mN, mX) {
                        return (this["x"] += (mN["x"] - this["x"]) * mX), (this["y"] += (mN["y"] - this["y"]) * mX), (this["z"] += (mN["z"] - this["z"]) * mX), (this["w"] += (mN["w"] - this["w"]) * mX), this;
                    },
                    lerpVectors: function (mN, mX, mf) {
                        return (this["x"] = mN["x"] + (mX["x"] - mN["x"]) * mf), (this["y"] = mN["y"] + (mX["y"] - mN["y"]) * mf), (this["z"] = mN["z"] + (mX["z"] - mN["z"]) * mf), (this["w"] = mN["w"] + (mX["w"] - mN["w"]) * mf), this;
                    },
                    equals: function (mN) {
                        return mN["x"] === this["x"] && mN["y"] === this["y"] && mN["z"] === this["z"] && mN["w"] === this["w"];
                    },
                    fromArray: function (mN, mX) {
                        return void 0x0 === mX && (mX = 0x0), (this["x"] = mN[mX]), (this["y"] = mN[mX + 0x1]), (this["z"] = mN[mX + 0x2]), (this["w"] = mN[mX + 0x3]), this;
                    },
                    toArray: function (mN, mX) {
                        return void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0), (mN[mX] = this["x"]), (mN[mX + 0x1] = this["y"]), (mN[mX + 0x2] = this["z"]), (mN[mX + 0x3] = this["w"]), mN;
                    },
                    fromBufferAttribute: function (mN, mX, mf) {
                        return (
                            void 0x0 !== mf && console["warn"]("THREE.Vector4:\x20offset\x20has\x20been\x20removed\x20from\x20.fromBufferAttribute()."),
                            (this["x"] = mN["getX"](mX)),
                            (this["y"] = mN["getY"](mX)),
                            (this["z"] = mN["getZ"](mX)),
                            (this["w"] = mN["getW"](mX)),
                            this
                        );
                    },
                    random: function () {
                        return (this["x"] = Math["random"]()), (this["y"] = Math["random"]()), (this["z"] = Math["random"]()), (this["w"] = Math["random"]()), this;
                    },
                }),
                (E9["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                    constructor: E9,
                    isWebGLRenderTarget: !0x0,
                    setSize: function (mN, mX) {
                        (this["width"] === mN && this["height"] === mX) || ((this["width"] = mN), (this["height"] = mX), (this["texture"]["image"]["width"] = mN), (this["texture"]["image"]["height"] = mX), this["dispose"]()),
                            this["viewport"]["set"](0x0, 0x0, mN, mX),
                            this["scissor"]["set"](0x0, 0x0, mN, mX);
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    copy: function (mN) {
                        return (
                            (this["width"] = mN["width"]),
                            (this["height"] = mN["height"]),
                            this["viewport"]["copy"](mN["viewport"]),
                            (this["texture"] = mN["texture"]["clone"]()),
                            (this["depthBuffer"] = mN["depthBuffer"]),
                            (this["stencilBuffer"] = mN["stencilBuffer"]),
                            (this["depthTexture"] = mN["depthTexture"]),
                            this
                        );
                    },
                    dispose: function () {
                        this["dispatchEvent"]({ type: "dispose" });
                    },
                })),
                (EE["prototype"] = Object["assign"](Object["create"](E9["prototype"]), {
                    constructor: EE,
                    isWebGLMultisampleRenderTarget: !0x0,
                    copy: function (mN) {
                        return E9["prototype"]["copy"]["call"](this, mN), (this["samples"] = mN["samples"]), this;
                    },
                })),
                Object["assign"](ER, {
                    slerp: function (mN, mX, mf, mP) {
                        return mf["copy"](mN)["slerp"](mX, mP);
                    },
                    slerpFlat: function (mN, mX, mf, mP, mI, mA, mM) {
                        var mp = mf[mP + 0x0],
                            mk = mf[mP + 0x1],
                            mU = mf[mP + 0x2],
                            mq = mf[mP + 0x3],
                            mw = mI[mA + 0x0],
                            mO = mI[mA + 0x1],
                            mj = mI[mA + 0x2],
                            mh = mI[mA + 0x3];
                        if (mq !== mh || mp !== mw || mk !== mO || mU !== mj) {
                            var mS = 0x1 - mM,
                                mg = mp * mw + mk * mO + mU * mj + mq * mh,
                                mW = mg >= 0x0 ? 0x1 : -0x1,
                                mH = 0x1 - mg * mg;
                            if (mH > Number["EPSILON"]) {
                                var mx = Math["sqrt"](mH),
                                    mK = Math["atan2"](mx, mg * mW);
                                (mS = Math["sin"](mS * mK) / mx), (mM = Math["sin"](mM * mK) / mx);
                            }
                            var mV = mM * mW;
                            if (((mp = mp * mS + mw * mV), (mk = mk * mS + mO * mV), (mU = mU * mS + mj * mV), (mq = mq * mS + mh * mV), mS === 0x1 - mM)) {
                                var mJ = 0x1 / Math["sqrt"](mp * mp + mk * mk + mU * mU + mq * mq);
                                (mp *= mJ), (mk *= mJ), (mU *= mJ), (mq *= mJ);
                            }
                        }
                        (mN[mX] = mp), (mN[mX + 0x1] = mk), (mN[mX + 0x2] = mU), (mN[mX + 0x3] = mq);
                    },
                    multiplyQuaternionsFlat: function (mN, mX, mf, mP, mI, mA) {
                        var mM = mf[mP],
                            mp = mf[mP + 0x1],
                            mk = mf[mP + 0x2],
                            mU = mf[mP + 0x3],
                            mq = mI[mA],
                            mw = mI[mA + 0x1],
                            mO = mI[mA + 0x2],
                            mj = mI[mA + 0x3];
                        return (
                            (mN[mX] = mM * mj + mU * mq + mp * mO - mk * mw),
                            (mN[mX + 0x1] = mp * mj + mU * mw + mk * mq - mM * mO),
                            (mN[mX + 0x2] = mk * mj + mU * mO + mM * mw - mp * mq),
                            (mN[mX + 0x3] = mU * mj - mM * mq - mp * mw - mk * mO),
                            mN
                        );
                    },
                }),
                Object["defineProperties"](ER["prototype"], {
                    x: {
                        get: function () {
                            return this["_x"];
                        },
                        set: function (mN) {
                            (this["_x"] = mN), this["_onChangeCallback"]();
                        },
                    },
                    y: {
                        get: function () {
                            return this["_y"];
                        },
                        set: function (mN) {
                            (this["_y"] = mN), this["_onChangeCallback"]();
                        },
                    },
                    z: {
                        get: function () {
                            return this["_z"];
                        },
                        set: function (mN) {
                            (this["_z"] = mN), this["_onChangeCallback"]();
                        },
                    },
                    w: {
                        get: function () {
                            return this["_w"];
                        },
                        set: function (mN) {
                            (this["_w"] = mN), this["_onChangeCallback"]();
                        },
                    },
                }),
                Object["assign"](ER["prototype"], {
                    isQuaternion: !0x0,
                    set: function (mN, mX, mf, mP) {
                        return (this["_x"] = mN), (this["_y"] = mX), (this["_z"] = mf), (this["_w"] = mP), this["_onChangeCallback"](), this;
                    },
                    clone: function () {
                        return new this["constructor"](this["_x"], this["_y"], this["_z"], this["_w"]);
                    },
                    copy: function (mN) {
                        return (this["_x"] = mN["x"]), (this["_y"] = mN["y"]), (this["_z"] = mN["z"]), (this["_w"] = mN["w"]), this["_onChangeCallback"](), this;
                    },
                    setFromEuler: function (mN, mX) {
                        if (!mN || !mN["isEuler"]) throw new Error("THREE.Quaternion:\x20.setFromEuler()\x20now\x20expects\x20an\x20Euler\x20rotation\x20rather\x20than\x20a\x20Vector3\x20and\x20order.");
                        var mf = mN["_x"],
                            mP = mN["_y"],
                            mI = mN["_z"],
                            mA = mN["order"],
                            mM = Math["cos"],
                            mp = Math["sin"],
                            mk = mM(mf / 0x2),
                            mU = mM(mP / 0x2),
                            mq = mM(mI / 0x2),
                            mw = mp(mf / 0x2),
                            mO = mp(mP / 0x2),
                            mj = mp(mI / 0x2);
                        switch (mA) {
                            case "XYZ":
                                (this["_x"] = mw * mU * mq + mk * mO * mj), (this["_y"] = mk * mO * mq - mw * mU * mj), (this["_z"] = mk * mU * mj + mw * mO * mq), (this["_w"] = mk * mU * mq - mw * mO * mj);
                                break;
                            case "YXZ":
                                (this["_x"] = mw * mU * mq + mk * mO * mj), (this["_y"] = mk * mO * mq - mw * mU * mj), (this["_z"] = mk * mU * mj - mw * mO * mq), (this["_w"] = mk * mU * mq + mw * mO * mj);
                                break;
                            case "ZXY":
                                (this["_x"] = mw * mU * mq - mk * mO * mj), (this["_y"] = mk * mO * mq + mw * mU * mj), (this["_z"] = mk * mU * mj + mw * mO * mq), (this["_w"] = mk * mU * mq - mw * mO * mj);
                                break;
                            case "ZYX":
                                (this["_x"] = mw * mU * mq - mk * mO * mj), (this["_y"] = mk * mO * mq + mw * mU * mj), (this["_z"] = mk * mU * mj - mw * mO * mq), (this["_w"] = mk * mU * mq + mw * mO * mj);
                                break;
                            case "YZX":
                                (this["_x"] = mw * mU * mq + mk * mO * mj), (this["_y"] = mk * mO * mq + mw * mU * mj), (this["_z"] = mk * mU * mj - mw * mO * mq), (this["_w"] = mk * mU * mq - mw * mO * mj);
                                break;
                            case "XZY":
                                (this["_x"] = mw * mU * mq - mk * mO * mj), (this["_y"] = mk * mO * mq - mw * mU * mj), (this["_z"] = mk * mU * mj + mw * mO * mq), (this["_w"] = mk * mU * mq + mw * mO * mj);
                                break;
                            default:
                                console["warn"]("THREE.Quaternion:\x20.setFromEuler()\x20encountered\x20an\x20unknown\x20order:\x20" + mA);
                        }
                        return !0x1 !== mX && this["_onChangeCallback"](), this;
                    },
                    setFromAxisAngle: function (mN, mX) {
                        var mf = mX / 0x2,
                            mP = Math["sin"](mf);
                        return (this["_x"] = mN["x"] * mP), (this["_y"] = mN["y"] * mP), (this["_z"] = mN["z"] * mP), (this["_w"] = Math["cos"](mf)), this["_onChangeCallback"](), this;
                    },
                    setFromRotationMatrix: function (mN) {
                        var mX,
                            mf = mN["elements"],
                            mP = mf[0x0],
                            mI = mf[0x4],
                            mA = mf[0x8],
                            mM = mf[0x1],
                            mp = mf[0x5],
                            mk = mf[0x9],
                            mU = mf[0x2],
                            mq = mf[0x6],
                            mw = mf[0xa],
                            mO = mP + mp + mw;
                        return (
                            mO > 0x0
                                ? ((mX = 0.5 / Math["sqrt"](mO + 0x1)), (this["_w"] = 0.25 / mX), (this["_x"] = (mq - mk) * mX), (this["_y"] = (mA - mU) * mX), (this["_z"] = (mM - mI) * mX))
                                : mP > mp && mP > mw
                                ? ((mX = 0x2 * Math["sqrt"](0x1 + mP - mp - mw)), (this["_w"] = (mq - mk) / mX), (this["_x"] = 0.25 * mX), (this["_y"] = (mI + mM) / mX), (this["_z"] = (mA + mU) / mX))
                                : mp > mw
                                ? ((mX = 0x2 * Math["sqrt"](0x1 + mp - mP - mw)), (this["_w"] = (mA - mU) / mX), (this["_x"] = (mI + mM) / mX), (this["_y"] = 0.25 * mX), (this["_z"] = (mk + mq) / mX))
                                : ((mX = 0x2 * Math["sqrt"](0x1 + mw - mP - mp)), (this["_w"] = (mM - mI) / mX), (this["_x"] = (mA + mU) / mX), (this["_y"] = (mk + mq) / mX), (this["_z"] = 0.25 * mX)),
                            this["_onChangeCallback"](),
                            this
                        );
                    },
                    setFromUnitVectors: function (mN, mX) {
                        var mf = mN["dot"](mX) + 0x1;
                        return (
                            mf < 0.000001
                                ? ((mf = 0x0),
                                  Math["abs"](mN["x"]) > Math["abs"](mN["z"])
                                      ? ((this["_x"] = -mN["y"]), (this["_y"] = mN["x"]), (this["_z"] = 0x0), (this["_w"] = mf))
                                      : ((this["_x"] = 0x0), (this["_y"] = -mN["z"]), (this["_z"] = mN["y"]), (this["_w"] = mf)))
                                : ((this["_x"] = mN["y"] * mX["z"] - mN["z"] * mX["y"]), (this["_y"] = mN["z"] * mX["x"] - mN["x"] * mX["z"]), (this["_z"] = mN["x"] * mX["y"] - mN["y"] * mX["x"]), (this["_w"] = mf)),
                            this["normalize"]()
                        );
                    },
                    angleTo: function (mN) {
                        return 0x2 * Math["acos"](Math["abs"](E2["clamp"](this["dot"](mN), -0x1, 0x1)));
                    },
                    rotateTowards: function (mN, mX) {
                        var mf = this["angleTo"](mN);
                        if (0x0 === mf) return this;
                        var mP = Math["min"](0x1, mX / mf);
                        return this["slerp"](mN, mP), this;
                    },
                    inverse: function () {
                        return this["conjugate"]();
                    },
                    conjugate: function () {
                        return (this["_x"] *= -0x1), (this["_y"] *= -0x1), (this["_z"] *= -0x1), this["_onChangeCallback"](), this;
                    },
                    dot: function (mN) {
                        return this["_x"] * mN["_x"] + this["_y"] * mN["_y"] + this["_z"] * mN["_z"] + this["_w"] * mN["_w"];
                    },
                    lengthSq: function () {
                        return this["_x"] * this["_x"] + this["_y"] * this["_y"] + this["_z"] * this["_z"] + this["_w"] * this["_w"];
                    },
                    length: function () {
                        return Math["sqrt"](this["_x"] * this["_x"] + this["_y"] * this["_y"] + this["_z"] * this["_z"] + this["_w"] * this["_w"]);
                    },
                    normalize: function () {
                        var mN = this["length"]();
                        return (
                            0x0 === mN
                                ? ((this["_x"] = 0x0), (this["_y"] = 0x0), (this["_z"] = 0x0), (this["_w"] = 0x1))
                                : ((mN = 0x1 / mN), (this["_x"] = this["_x"] * mN), (this["_y"] = this["_y"] * mN), (this["_z"] = this["_z"] * mN), (this["_w"] = this["_w"] * mN)),
                            this["_onChangeCallback"](),
                            this
                        );
                    },
                    multiply: function (mN, mX) {
                        return void 0x0 !== mX
                            ? (console["warn"]("THREE.Quaternion:\x20.multiply()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.multiplyQuaternions(\x20a,\x20b\x20)\x20instead."), this["multiplyQuaternions"](mN, mX))
                            : this["multiplyQuaternions"](this, mN);
                    },
                    premultiply: function (mN) {
                        return this["multiplyQuaternions"](mN, this);
                    },
                    multiplyQuaternions: function (mN, mX) {
                        var mf = mN["_x"],
                            mP = mN["_y"],
                            mI = mN["_z"],
                            mA = mN["_w"],
                            mM = mX["_x"],
                            mp = mX["_y"],
                            mk = mX["_z"],
                            mU = mX["_w"];
                        return (
                            (this["_x"] = mf * mU + mA * mM + mP * mk - mI * mp),
                            (this["_y"] = mP * mU + mA * mp + mI * mM - mf * mk),
                            (this["_z"] = mI * mU + mA * mk + mf * mp - mP * mM),
                            (this["_w"] = mA * mU - mf * mM - mP * mp - mI * mk),
                            this["_onChangeCallback"](),
                            this
                        );
                    },
                    slerp: function (mN, mX) {
                        if (0x0 === mX) return this;
                        if (0x1 === mX) return this["copy"](mN);
                        var mf = this["_x"],
                            mP = this["_y"],
                            mI = this["_z"],
                            mA = this["_w"],
                            mM = mA * mN["_w"] + mf * mN["_x"] + mP * mN["_y"] + mI * mN["_z"];
                        if ((mM < 0x0 ? ((this["_w"] = -mN["_w"]), (this["_x"] = -mN["_x"]), (this["_y"] = -mN["_y"]), (this["_z"] = -mN["_z"]), (mM = -mM)) : this["copy"](mN), mM >= 0x1))
                            return (this["_w"] = mA), (this["_x"] = mf), (this["_y"] = mP), (this["_z"] = mI), this;
                        var mp = 0x1 - mM * mM;
                        if (mp <= Number["EPSILON"]) {
                            var mk = 0x1 - mX;
                            return (
                                (this["_w"] = mk * mA + mX * this["_w"]),
                                (this["_x"] = mk * mf + mX * this["_x"]),
                                (this["_y"] = mk * mP + mX * this["_y"]),
                                (this["_z"] = mk * mI + mX * this["_z"]),
                                this["normalize"](),
                                this["_onChangeCallback"](),
                                this
                            );
                        }
                        var mU = Math["sqrt"](mp),
                            mq = Math["atan2"](mU, mM),
                            mw = Math["sin"]((0x1 - mX) * mq) / mU,
                            mO = Math["sin"](mX * mq) / mU;
                        return (this["_w"] = mA * mw + this["_w"] * mO), (this["_x"] = mf * mw + this["_x"] * mO), (this["_y"] = mP * mw + this["_y"] * mO), (this["_z"] = mI * mw + this["_z"] * mO), this["_onChangeCallback"](), this;
                    },
                    equals: function (mN) {
                        return mN["_x"] === this["_x"] && mN["_y"] === this["_y"] && mN["_z"] === this["_z"] && mN["_w"] === this["_w"];
                    },
                    fromArray: function (mN, mX) {
                        return void 0x0 === mX && (mX = 0x0), (this["_x"] = mN[mX]), (this["_y"] = mN[mX + 0x1]), (this["_z"] = mN[mX + 0x2]), (this["_w"] = mN[mX + 0x3]), this["_onChangeCallback"](), this;
                    },
                    toArray: function (mN, mX) {
                        return void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0), (mN[mX] = this["_x"]), (mN[mX + 0x1] = this["_y"]), (mN[mX + 0x2] = this["_z"]), (mN[mX + 0x3] = this["_w"]), mN;
                    },
                    fromBufferAttribute: function (mN, mX) {
                        return (this["_x"] = mN["getX"](mX)), (this["_y"] = mN["getY"](mX)), (this["_z"] = mN["getZ"](mX)), (this["_w"] = mN["getW"](mX)), this;
                    },
                    _onChange: function (mN) {
                        return (this["_onChangeCallback"] = mN), this;
                    },
                    _onChangeCallback: function () {},
                });
            var ET = new Ed(),
                EC = new ER();
            function Ed(mN, mX, mf) {
                (this["x"] = mN || 0x0), (this["y"] = mX || 0x0), (this["z"] = mf || 0x0);
            }
            Object["assign"](Ed["prototype"], {
                isVector3: !0x0,
                set: function (mN, mX, mf) {
                    return (this["x"] = mN), (this["y"] = mX), (this["z"] = mf), this;
                },
                setScalar: function (mN) {
                    return (this["x"] = mN), (this["y"] = mN), (this["z"] = mN), this;
                },
                setX: function (mN) {
                    return (this["x"] = mN), this;
                },
                setY: function (mN) {
                    return (this["y"] = mN), this;
                },
                setZ: function (mN) {
                    return (this["z"] = mN), this;
                },
                setComponent: function (mN, mX) {
                    switch (mN) {
                        case 0x0:
                            this["x"] = mX;
                            break;
                        case 0x1:
                            this["y"] = mX;
                            break;
                        case 0x2:
                            this["z"] = mX;
                            break;
                        default:
                            throw new Error("index\x20is\x20out\x20of\x20range:\x20" + mN);
                    }
                    return this;
                },
                getComponent: function (mN) {
                    switch (mN) {
                        case 0x0:
                            return this["x"];
                        case 0x1:
                            return this["y"];
                        case 0x2:
                            return this["z"];
                        default:
                            throw new Error("index\x20is\x20out\x20of\x20range:\x20" + mN);
                    }
                },
                clone: function () {
                    return new this["constructor"](this["x"], this["y"], this["z"]);
                },
                copy: function (mN) {
                    return (this["x"] = mN["x"]), (this["y"] = mN["y"]), (this["z"] = mN["z"]), this;
                },
                add: function (mN, mX) {
                    return void 0x0 !== mX
                        ? (console["warn"]("THREE.Vector3:\x20.add()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.addVectors(\x20a,\x20b\x20)\x20instead."), this["addVectors"](mN, mX))
                        : ((this["x"] += mN["x"]), (this["y"] += mN["y"]), (this["z"] += mN["z"]), this);
                },
                addScalar: function (mN) {
                    return (this["x"] += mN), (this["y"] += mN), (this["z"] += mN), this;
                },
                addVectors: function (mN, mX) {
                    return (this["x"] = mN["x"] + mX["x"]), (this["y"] = mN["y"] + mX["y"]), (this["z"] = mN["z"] + mX["z"]), this;
                },
                addScaledVector: function (mN, mX) {
                    return (this["x"] += mN["x"] * mX), (this["y"] += mN["y"] * mX), (this["z"] += mN["z"] * mX), this;
                },
                sub: function (mN, mX) {
                    return void 0x0 !== mX
                        ? (console["warn"]("THREE.Vector3:\x20.sub()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.subVectors(\x20a,\x20b\x20)\x20instead."), this["subVectors"](mN, mX))
                        : ((this["x"] -= mN["x"]), (this["y"] -= mN["y"]), (this["z"] -= mN["z"]), this);
                },
                subScalar: function (mN) {
                    return (this["x"] -= mN), (this["y"] -= mN), (this["z"] -= mN), this;
                },
                subVectors: function (mN, mX) {
                    return (this["x"] = mN["x"] - mX["x"]), (this["y"] = mN["y"] - mX["y"]), (this["z"] = mN["z"] - mX["z"]), this;
                },
                multiply: function (mN, mX) {
                    return void 0x0 !== mX
                        ? (console["warn"]("THREE.Vector3:\x20.multiply()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.multiplyVectors(\x20a,\x20b\x20)\x20instead."), this["multiplyVectors"](mN, mX))
                        : ((this["x"] *= mN["x"]), (this["y"] *= mN["y"]), (this["z"] *= mN["z"]), this);
                },
                multiplyScalar: function (mN) {
                    return (this["x"] *= mN), (this["y"] *= mN), (this["z"] *= mN), this;
                },
                multiplyVectors: function (mN, mX) {
                    return (this["x"] = mN["x"] * mX["x"]), (this["y"] = mN["y"] * mX["y"]), (this["z"] = mN["z"] * mX["z"]), this;
                },
                applyEuler: function (mN) {
                    return (
                        (mN && mN["isEuler"]) || console["error"]("THREE.Vector3:\x20.applyEuler()\x20now\x20expects\x20an\x20Euler\x20rotation\x20rather\x20than\x20a\x20Vector3\x20and\x20order."),
                        this["applyQuaternion"](EC["setFromEuler"](mN))
                    );
                },
                applyAxisAngle: function (mN, mX) {
                    return this["applyQuaternion"](EC["setFromAxisAngle"](mN, mX));
                },
                applyMatrix3: function (mN) {
                    var mX = this["x"],
                        mf = this["y"],
                        mP = this["z"],
                        mI = mN["elements"];
                    return (this["x"] = mI[0x0] * mX + mI[0x3] * mf + mI[0x6] * mP), (this["y"] = mI[0x1] * mX + mI[0x4] * mf + mI[0x7] * mP), (this["z"] = mI[0x2] * mX + mI[0x5] * mf + mI[0x8] * mP), this;
                },
                applyNormalMatrix: function (mN) {
                    return this["applyMatrix3"](mN)["normalize"]();
                },
                applyMatrix4: function (mN) {
                    var mX = this["x"],
                        mf = this["y"],
                        mP = this["z"],
                        mI = mN["elements"],
                        mA = 0x1 / (mI[0x3] * mX + mI[0x7] * mf + mI[0xb] * mP + mI[0xf]);
                    return (
                        (this["x"] = (mI[0x0] * mX + mI[0x4] * mf + mI[0x8] * mP + mI[0xc]) * mA),
                        (this["y"] = (mI[0x1] * mX + mI[0x5] * mf + mI[0x9] * mP + mI[0xd]) * mA),
                        (this["z"] = (mI[0x2] * mX + mI[0x6] * mf + mI[0xa] * mP + mI[0xe]) * mA),
                        this
                    );
                },
                applyQuaternion: function (mN) {
                    var mX = this["x"],
                        mf = this["y"],
                        mP = this["z"],
                        mI = mN["x"],
                        mA = mN["y"],
                        mM = mN["z"],
                        mp = mN["w"],
                        mk = mp * mX + mA * mP - mM * mf,
                        mU = mp * mf + mM * mX - mI * mP,
                        mq = mp * mP + mI * mf - mA * mX,
                        mw = -mI * mX - mA * mf - mM * mP;
                    return (this["x"] = mk * mp + mw * -mI + mU * -mM - mq * -mA), (this["y"] = mU * mp + mw * -mA + mq * -mI - mk * -mM), (this["z"] = mq * mp + mw * -mM + mk * -mA - mU * -mI), this;
                },
                project: function (mN) {
                    return this["applyMatrix4"](mN["matrixWorldInverse"])["applyMatrix4"](mN["projectionMatrix"]);
                },
                unproject: function (mN) {
                    return this["applyMatrix4"](mN["projectionMatrixInverse"])["applyMatrix4"](mN["matrixWorld"]);
                },
                transformDirection: function (mN) {
                    var mX = this["x"],
                        mf = this["y"],
                        mP = this["z"],
                        mI = mN["elements"];
                    return (this["x"] = mI[0x0] * mX + mI[0x4] * mf + mI[0x8] * mP), (this["y"] = mI[0x1] * mX + mI[0x5] * mf + mI[0x9] * mP), (this["z"] = mI[0x2] * mX + mI[0x6] * mf + mI[0xa] * mP), this["normalize"]();
                },
                divide: function (mN) {
                    return (this["x"] /= mN["x"]), (this["y"] /= mN["y"]), (this["z"] /= mN["z"]), this;
                },
                divideScalar: function (mN) {
                    return this["multiplyScalar"](0x1 / mN);
                },
                min: function (mN) {
                    return (this["x"] = Math["min"](this["x"], mN["x"])), (this["y"] = Math["min"](this["y"], mN["y"])), (this["z"] = Math["min"](this["z"], mN["z"])), this;
                },
                max: function (mN) {
                    return (this["x"] = Math["max"](this["x"], mN["x"])), (this["y"] = Math["max"](this["y"], mN["y"])), (this["z"] = Math["max"](this["z"], mN["z"])), this;
                },
                clamp: function (mN, mX) {
                    return (this["x"] = Math["max"](mN["x"], Math["min"](mX["x"], this["x"]))), (this["y"] = Math["max"](mN["y"], Math["min"](mX["y"], this["y"]))), (this["z"] = Math["max"](mN["z"], Math["min"](mX["z"], this["z"]))), this;
                },
                clampScalar: function (mN, mX) {
                    return (this["x"] = Math["max"](mN, Math["min"](mX, this["x"]))), (this["y"] = Math["max"](mN, Math["min"](mX, this["y"]))), (this["z"] = Math["max"](mN, Math["min"](mX, this["z"]))), this;
                },
                clampLength: function (mN, mX) {
                    var mf = this["length"]();
                    return this["divideScalar"](mf || 0x1)["multiplyScalar"](Math["max"](mN, Math["min"](mX, mf)));
                },
                floor: function () {
                    return (this["x"] = Math["floor"](this["x"])), (this["y"] = Math["floor"](this["y"])), (this["z"] = Math["floor"](this["z"])), this;
                },
                ceil: function () {
                    return (this["x"] = Math["ceil"](this["x"])), (this["y"] = Math["ceil"](this["y"])), (this["z"] = Math["ceil"](this["z"])), this;
                },
                round: function () {
                    return (this["x"] = Math["round"](this["x"])), (this["y"] = Math["round"](this["y"])), (this["z"] = Math["round"](this["z"])), this;
                },
                roundToZero: function () {
                    return (
                        (this["x"] = this["x"] < 0x0 ? Math["ceil"](this["x"]) : Math["floor"](this["x"])),
                        (this["y"] = this["y"] < 0x0 ? Math["ceil"](this["y"]) : Math["floor"](this["y"])),
                        (this["z"] = this["z"] < 0x0 ? Math["ceil"](this["z"]) : Math["floor"](this["z"])),
                        this
                    );
                },
                negate: function () {
                    return (this["x"] = -this["x"]), (this["y"] = -this["y"]), (this["z"] = -this["z"]), this;
                },
                dot: function (mN) {
                    return this["x"] * mN["x"] + this["y"] * mN["y"] + this["z"] * mN["z"];
                },
                lengthSq: function () {
                    return this["x"] * this["x"] + this["y"] * this["y"] + this["z"] * this["z"];
                },
                length: function () {
                    return Math["sqrt"](this["x"] * this["x"] + this["y"] * this["y"] + this["z"] * this["z"]);
                },
                manhattanLength: function () {
                    return Math["abs"](this["x"]) + Math["abs"](this["y"]) + Math["abs"](this["z"]);
                },
                normalize: function () {
                    return this["divideScalar"](this["length"]() || 0x1);
                },
                setLength: function (mN) {
                    return this["normalize"]()["multiplyScalar"](mN);
                },
                lerp: function (mN, mX) {
                    return (this["x"] += (mN["x"] - this["x"]) * mX), (this["y"] += (mN["y"] - this["y"]) * mX), (this["z"] += (mN["z"] - this["z"]) * mX), this;
                },
                lerpVectors: function (mN, mX, mf) {
                    return (this["x"] = mN["x"] + (mX["x"] - mN["x"]) * mf), (this["y"] = mN["y"] + (mX["y"] - mN["y"]) * mf), (this["z"] = mN["z"] + (mX["z"] - mN["z"]) * mf), this;
                },
                cross: function (mN, mX) {
                    return void 0x0 !== mX
                        ? (console["warn"]("THREE.Vector3:\x20.cross()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.crossVectors(\x20a,\x20b\x20)\x20instead."), this["crossVectors"](mN, mX))
                        : this["crossVectors"](this, mN);
                },
                crossVectors: function (mN, mX) {
                    var mf = mN["x"],
                        mP = mN["y"],
                        mI = mN["z"],
                        mA = mX["x"],
                        mM = mX["y"],
                        mp = mX["z"];
                    return (this["x"] = mP * mp - mI * mM), (this["y"] = mI * mA - mf * mp), (this["z"] = mf * mM - mP * mA), this;
                },
                projectOnVector: function (mN) {
                    var mX = mN["lengthSq"]();
                    if (0x0 === mX) return this["set"](0x0, 0x0, 0x0);
                    var mf = mN["dot"](this) / mX;
                    return this["copy"](mN)["multiplyScalar"](mf);
                },
                projectOnPlane: function (mN) {
                    return ET["copy"](this)["projectOnVector"](mN), this["sub"](ET);
                },
                reflect: function (mN) {
                    return this["sub"](ET["copy"](mN)["multiplyScalar"](0x2 * this["dot"](mN)));
                },
                angleTo: function (mN) {
                    var mX = Math["sqrt"](this["lengthSq"]() * mN["lengthSq"]());
                    if (0x0 === mX) return Math["PI"] / 0x2;
                    var mf = this["dot"](mN) / mX;
                    return Math["acos"](E2["clamp"](mf, -0x1, 0x1));
                },
                distanceTo: function (mN) {
                    return Math["sqrt"](this["distanceToSquared"](mN));
                },
                distanceToSquared: function (mN) {
                    var mX = this["x"] - mN["x"],
                        mf = this["y"] - mN["y"],
                        mP = this["z"] - mN["z"];
                    return mX * mX + mf * mf + mP * mP;
                },
                manhattanDistanceTo: function (mN) {
                    return Math["abs"](this["x"] - mN["x"]) + Math["abs"](this["y"] - mN["y"]) + Math["abs"](this["z"] - mN["z"]);
                },
                setFromSpherical: function (mN) {
                    return this["setFromSphericalCoords"](mN["radius"], mN["phi"], mN["theta"]);
                },
                setFromSphericalCoords: function (mN, mX, mf) {
                    var mP = Math["sin"](mX) * mN;
                    return (this["x"] = mP * Math["sin"](mf)), (this["y"] = Math["cos"](mX) * mN), (this["z"] = mP * Math["cos"](mf)), this;
                },
                setFromCylindrical: function (mN) {
                    return this["setFromCylindricalCoords"](mN["radius"], mN["theta"], mN["y"]);
                },
                setFromCylindricalCoords: function (mN, mX, mf) {
                    return (this["x"] = mN * Math["sin"](mX)), (this["y"] = mf), (this["z"] = mN * Math["cos"](mX)), this;
                },
                setFromMatrixPosition: function (mN) {
                    var mX = mN["elements"];
                    return (this["x"] = mX[0xc]), (this["y"] = mX[0xd]), (this["z"] = mX[0xe]), this;
                },
                setFromMatrixScale: function (mN) {
                    var mX = this["setFromMatrixColumn"](mN, 0x0)["length"](),
                        mf = this["setFromMatrixColumn"](mN, 0x1)["length"](),
                        mP = this["setFromMatrixColumn"](mN, 0x2)["length"]();
                    return (this["x"] = mX), (this["y"] = mf), (this["z"] = mP), this;
                },
                setFromMatrixColumn: function (mN, mX) {
                    return this["fromArray"](mN["elements"], 0x4 * mX);
                },
                setFromMatrix3Column: function (mN, mX) {
                    return this["fromArray"](mN["elements"], 0x3 * mX);
                },
                equals: function (mN) {
                    return mN["x"] === this["x"] && mN["y"] === this["y"] && mN["z"] === this["z"];
                },
                fromArray: function (mN, mX) {
                    return void 0x0 === mX && (mX = 0x0), (this["x"] = mN[mX]), (this["y"] = mN[mX + 0x1]), (this["z"] = mN[mX + 0x2]), this;
                },
                toArray: function (mN, mX) {
                    return void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0), (mN[mX] = this["x"]), (mN[mX + 0x1] = this["y"]), (mN[mX + 0x2] = this["z"]), mN;
                },
                fromBufferAttribute: function (mN, mX, mf) {
                    return (
                        void 0x0 !== mf && console["warn"]("THREE.Vector3:\x20offset\x20has\x20been\x20removed\x20from\x20.fromBufferAttribute()."),
                        (this["x"] = mN["getX"](mX)),
                        (this["y"] = mN["getY"](mX)),
                        (this["z"] = mN["getZ"](mX)),
                        this
                    );
                },
                random: function () {
                    return (this["x"] = Math["random"]()), (this["y"] = Math["random"]()), (this["z"] = Math["random"]()), this;
                },
            });
            var EY = new Ed(),
                EB = new Ey(),
                EF = new Ed(0x0, 0x0, 0x0),
                Eb = new Ed(0x1, 0x1, 0x1),
                EZ = new Ed(),
                Em = new Ed(),
                Ev = new Ed();
            function Ey() {
                (this["elements"] = [0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1]),
                    arguments["length"] > 0x0 && console["error"]("THREE.Matrix4:\x20the\x20constructor\x20no\x20longer\x20reads\x20arguments.\x20use\x20.set()\x20instead.");
            }
            Object["assign"](Ey["prototype"], {
                isMatrix4: !0x0,
                set: function (mN, mX, mf, mP, mI, mA, mM, mp, mk, mU, mq, mw, mO, mj, mh, mS) {
                    var mg = this["elements"];
                    return (
                        (mg[0x0] = mN),
                        (mg[0x4] = mX),
                        (mg[0x8] = mf),
                        (mg[0xc] = mP),
                        (mg[0x1] = mI),
                        (mg[0x5] = mA),
                        (mg[0x9] = mM),
                        (mg[0xd] = mp),
                        (mg[0x2] = mk),
                        (mg[0x6] = mU),
                        (mg[0xa] = mq),
                        (mg[0xe] = mw),
                        (mg[0x3] = mO),
                        (mg[0x7] = mj),
                        (mg[0xb] = mh),
                        (mg[0xf] = mS),
                        this
                    );
                },
                identity: function () {
                    return this["set"](0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                clone: function () {
                    return new Ey()["fromArray"](this["elements"]);
                },
                copy: function (mN) {
                    var mX = this["elements"],
                        mf = mN["elements"];
                    return (
                        (mX[0x0] = mf[0x0]),
                        (mX[0x1] = mf[0x1]),
                        (mX[0x2] = mf[0x2]),
                        (mX[0x3] = mf[0x3]),
                        (mX[0x4] = mf[0x4]),
                        (mX[0x5] = mf[0x5]),
                        (mX[0x6] = mf[0x6]),
                        (mX[0x7] = mf[0x7]),
                        (mX[0x8] = mf[0x8]),
                        (mX[0x9] = mf[0x9]),
                        (mX[0xa] = mf[0xa]),
                        (mX[0xb] = mf[0xb]),
                        (mX[0xc] = mf[0xc]),
                        (mX[0xd] = mf[0xd]),
                        (mX[0xe] = mf[0xe]),
                        (mX[0xf] = mf[0xf]),
                        this
                    );
                },
                copyPosition: function (mN) {
                    var mX = this["elements"],
                        mf = mN["elements"];
                    return (mX[0xc] = mf[0xc]), (mX[0xd] = mf[0xd]), (mX[0xe] = mf[0xe]), this;
                },
                extractBasis: function (mN, mX, mf) {
                    return mN["setFromMatrixColumn"](this, 0x0), mX["setFromMatrixColumn"](this, 0x1), mf["setFromMatrixColumn"](this, 0x2), this;
                },
                makeBasis: function (mN, mX, mf) {
                    return this["set"](mN["x"], mX["x"], mf["x"], 0x0, mN["y"], mX["y"], mf["y"], 0x0, mN["z"], mX["z"], mf["z"], 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                extractRotation: function (mN) {
                    var mX = this["elements"],
                        mf = mN["elements"],
                        mP = 0x1 / EY["setFromMatrixColumn"](mN, 0x0)["length"](),
                        mI = 0x1 / EY["setFromMatrixColumn"](mN, 0x1)["length"](),
                        mA = 0x1 / EY["setFromMatrixColumn"](mN, 0x2)["length"]();
                    return (
                        (mX[0x0] = mf[0x0] * mP),
                        (mX[0x1] = mf[0x1] * mP),
                        (mX[0x2] = mf[0x2] * mP),
                        (mX[0x3] = 0x0),
                        (mX[0x4] = mf[0x4] * mI),
                        (mX[0x5] = mf[0x5] * mI),
                        (mX[0x6] = mf[0x6] * mI),
                        (mX[0x7] = 0x0),
                        (mX[0x8] = mf[0x8] * mA),
                        (mX[0x9] = mf[0x9] * mA),
                        (mX[0xa] = mf[0xa] * mA),
                        (mX[0xb] = 0x0),
                        (mX[0xc] = 0x0),
                        (mX[0xd] = 0x0),
                        (mX[0xe] = 0x0),
                        (mX[0xf] = 0x1),
                        this
                    );
                },
                makeRotationFromEuler: function (mN) {
                    (mN && mN["isEuler"]) || console["error"]("THREE.Matrix4:\x20.makeRotationFromEuler()\x20now\x20expects\x20a\x20Euler\x20rotation\x20rather\x20than\x20a\x20Vector3\x20and\x20order.");
                    var mX = this["elements"],
                        mf = mN["x"],
                        mP = mN["y"],
                        mI = mN["z"],
                        mA = Math["cos"](mf),
                        mM = Math["sin"](mf),
                        mp = Math["cos"](mP),
                        mk = Math["sin"](mP),
                        mU = Math["cos"](mI),
                        mq = Math["sin"](mI);
                    if ("XYZ" === mN["order"]) {
                        var mw = mA * mU,
                            mO = mA * mq,
                            mj = mM * mU,
                            mh = mM * mq;
                        (mX[0x0] = mp * mU), (mX[0x4] = -mp * mq), (mX[0x8] = mk), (mX[0x1] = mO + mj * mk), (mX[0x5] = mw - mh * mk), (mX[0x9] = -mM * mp), (mX[0x2] = mh - mw * mk), (mX[0x6] = mj + mO * mk), (mX[0xa] = mA * mp);
                    } else {
                        if ("YXZ" === mN["order"]) {
                            var mS = mp * mU,
                                mg = mp * mq,
                                mW = mk * mU,
                                mH = mk * mq;
                            (mX[0x0] = mS + mH * mM), (mX[0x4] = mW * mM - mg), (mX[0x8] = mA * mk), (mX[0x1] = mA * mq), (mX[0x5] = mA * mU), (mX[0x9] = -mM), (mX[0x2] = mg * mM - mW), (mX[0x6] = mH + mS * mM), (mX[0xa] = mA * mp);
                        } else {
                            if ("ZXY" === mN["order"])
                                (mS = mp * mU),
                                    (mg = mp * mq),
                                    (mW = mk * mU),
                                    (mH = mk * mq),
                                    ((mX[0x0] = mS - mH * mM),
                                    (mX[0x4] = -mA * mq),
                                    (mX[0x8] = mW + mg * mM),
                                    (mX[0x1] = mg + mW * mM),
                                    (mX[0x5] = mA * mU),
                                    (mX[0x9] = mH - mS * mM),
                                    (mX[0x2] = -mA * mk),
                                    (mX[0x6] = mM),
                                    (mX[0xa] = mA * mp));
                            else {
                                if ("ZYX" === mN["order"])
                                    (mw = mA * mU),
                                        (mO = mA * mq),
                                        (mj = mM * mU),
                                        (mh = mM * mq),
                                        ((mX[0x0] = mp * mU),
                                        (mX[0x4] = mj * mk - mO),
                                        (mX[0x8] = mw * mk + mh),
                                        (mX[0x1] = mp * mq),
                                        (mX[0x5] = mh * mk + mw),
                                        (mX[0x9] = mO * mk - mj),
                                        (mX[0x2] = -mk),
                                        (mX[0x6] = mM * mp),
                                        (mX[0xa] = mA * mp));
                                else {
                                    if ("YZX" === mN["order"]) {
                                        var mx = mA * mp,
                                            mK = mA * mk,
                                            mV = mM * mp,
                                            mJ = mM * mk;
                                        (mX[0x0] = mp * mU),
                                            (mX[0x4] = mJ - mx * mq),
                                            (mX[0x8] = mV * mq + mK),
                                            (mX[0x1] = mq),
                                            (mX[0x5] = mA * mU),
                                            (mX[0x9] = -mM * mU),
                                            (mX[0x2] = -mk * mU),
                                            (mX[0x6] = mK * mq + mV),
                                            (mX[0xa] = mx - mJ * mq);
                                    } else
                                        "XZY" === mN["order"] &&
                                            ((mx = mA * mp),
                                            (mK = mA * mk),
                                            (mV = mM * mp),
                                            (mJ = mM * mk),
                                            ((mX[0x0] = mp * mU),
                                            (mX[0x4] = -mq),
                                            (mX[0x8] = mk * mU),
                                            (mX[0x1] = mx * mq + mJ),
                                            (mX[0x5] = mA * mU),
                                            (mX[0x9] = mK * mq - mV),
                                            (mX[0x2] = mV * mq - mK),
                                            (mX[0x6] = mM * mU),
                                            (mX[0xa] = mJ * mq + mx)));
                                }
                            }
                        }
                    }
                    return (mX[0x3] = 0x0), (mX[0x7] = 0x0), (mX[0xb] = 0x0), (mX[0xc] = 0x0), (mX[0xd] = 0x0), (mX[0xe] = 0x0), (mX[0xf] = 0x1), this;
                },
                makeRotationFromQuaternion: function (mN) {
                    return this["compose"](EF, mN, Eb);
                },
                lookAt: function (mN, mX, mf) {
                    var mP = this["elements"];
                    return (
                        Ev["subVectors"](mN, mX),
                        0x0 === Ev["lengthSq"]() && (Ev["z"] = 0x1),
                        Ev["normalize"](),
                        EZ["crossVectors"](mf, Ev),
                        0x0 === EZ["lengthSq"]() && (0x1 === Math["abs"](mf["z"]) ? (Ev["x"] += 0.0001) : (Ev["z"] += 0.0001), Ev["normalize"](), EZ["crossVectors"](mf, Ev)),
                        EZ["normalize"](),
                        Em["crossVectors"](Ev, EZ),
                        (mP[0x0] = EZ["x"]),
                        (mP[0x4] = Em["x"]),
                        (mP[0x8] = Ev["x"]),
                        (mP[0x1] = EZ["y"]),
                        (mP[0x5] = Em["y"]),
                        (mP[0x9] = Ev["y"]),
                        (mP[0x2] = EZ["z"]),
                        (mP[0x6] = Em["z"]),
                        (mP[0xa] = Ev["z"]),
                        this
                    );
                },
                multiply: function (mN, mX) {
                    return void 0x0 !== mX
                        ? (console["warn"]("THREE.Matrix4:\x20.multiply()\x20now\x20only\x20accepts\x20one\x20argument.\x20Use\x20.multiplyMatrices(\x20a,\x20b\x20)\x20instead."), this["multiplyMatrices"](mN, mX))
                        : this["multiplyMatrices"](this, mN);
                },
                premultiply: function (mN) {
                    return this["multiplyMatrices"](mN, this);
                },
                multiplyMatrices: function (mN, mX) {
                    var mf = mN["elements"],
                        mP = mX["elements"],
                        mI = this["elements"],
                        mA = mf[0x0],
                        mM = mf[0x4],
                        mp = mf[0x8],
                        mk = mf[0xc],
                        mU = mf[0x1],
                        mq = mf[0x5],
                        mw = mf[0x9],
                        mO = mf[0xd],
                        mj = mf[0x2],
                        mh = mf[0x6],
                        mS = mf[0xa],
                        mg = mf[0xe],
                        mW = mf[0x3],
                        mH = mf[0x7],
                        mx = mf[0xb],
                        mK = mf[0xf],
                        mV = mP[0x0],
                        mJ = mP[0x4],
                        mG = mP[0x8],
                        mL = mP[0xc],
                        mQ = mP[0x1],
                        mz = mP[0x5],
                        v0 = mP[0x9],
                        v1 = mP[0xd],
                        v2 = mP[0x2],
                        v3 = mP[0x6],
                        v4 = mP[0xa],
                        v5 = mP[0xe],
                        v6 = mP[0x3],
                        v7 = mP[0x7],
                        v8 = mP[0xb],
                        v9 = mP[0xf];
                    return (
                        (mI[0x0] = mA * mV + mM * mQ + mp * v2 + mk * v6),
                        (mI[0x4] = mA * mJ + mM * mz + mp * v3 + mk * v7),
                        (mI[0x8] = mA * mG + mM * v0 + mp * v4 + mk * v8),
                        (mI[0xc] = mA * mL + mM * v1 + mp * v5 + mk * v9),
                        (mI[0x1] = mU * mV + mq * mQ + mw * v2 + mO * v6),
                        (mI[0x5] = mU * mJ + mq * mz + mw * v3 + mO * v7),
                        (mI[0x9] = mU * mG + mq * v0 + mw * v4 + mO * v8),
                        (mI[0xd] = mU * mL + mq * v1 + mw * v5 + mO * v9),
                        (mI[0x2] = mj * mV + mh * mQ + mS * v2 + mg * v6),
                        (mI[0x6] = mj * mJ + mh * mz + mS * v3 + mg * v7),
                        (mI[0xa] = mj * mG + mh * v0 + mS * v4 + mg * v8),
                        (mI[0xe] = mj * mL + mh * v1 + mS * v5 + mg * v9),
                        (mI[0x3] = mW * mV + mH * mQ + mx * v2 + mK * v6),
                        (mI[0x7] = mW * mJ + mH * mz + mx * v3 + mK * v7),
                        (mI[0xb] = mW * mG + mH * v0 + mx * v4 + mK * v8),
                        (mI[0xf] = mW * mL + mH * v1 + mx * v5 + mK * v9),
                        this
                    );
                },
                multiplyScalar: function (mN) {
                    var mX = this["elements"];
                    return (
                        (mX[0x0] *= mN),
                        (mX[0x4] *= mN),
                        (mX[0x8] *= mN),
                        (mX[0xc] *= mN),
                        (mX[0x1] *= mN),
                        (mX[0x5] *= mN),
                        (mX[0x9] *= mN),
                        (mX[0xd] *= mN),
                        (mX[0x2] *= mN),
                        (mX[0x6] *= mN),
                        (mX[0xa] *= mN),
                        (mX[0xe] *= mN),
                        (mX[0x3] *= mN),
                        (mX[0x7] *= mN),
                        (mX[0xb] *= mN),
                        (mX[0xf] *= mN),
                        this
                    );
                },
                determinant: function () {
                    var mN = this["elements"],
                        mX = mN[0x0],
                        mf = mN[0x4],
                        mP = mN[0x8],
                        mI = mN[0xc],
                        mA = mN[0x1],
                        mM = mN[0x5],
                        mp = mN[0x9],
                        mk = mN[0xd],
                        mU = mN[0x2],
                        mq = mN[0x6],
                        mw = mN[0xa],
                        mO = mN[0xe];
                    return (
                        mN[0x3] * (+mI * mp * mq - mP * mk * mq - mI * mM * mw + mf * mk * mw + mP * mM * mO - mf * mp * mO) +
                        mN[0x7] * (+mX * mp * mO - mX * mk * mw + mI * mA * mw - mP * mA * mO + mP * mk * mU - mI * mp * mU) +
                        mN[0xb] * (+mX * mk * mq - mX * mM * mO - mI * mA * mq + mf * mA * mO + mI * mM * mU - mf * mk * mU) +
                        mN[0xf] * (-mP * mM * mU - mX * mp * mq + mX * mM * mw + mP * mA * mq - mf * mA * mw + mf * mp * mU)
                    );
                },
                transpose: function () {
                    var mN,
                        mX = this["elements"];
                    return (
                        (mN = mX[0x1]),
                        (mX[0x1] = mX[0x4]),
                        (mX[0x4] = mN),
                        (mN = mX[0x2]),
                        (mX[0x2] = mX[0x8]),
                        (mX[0x8] = mN),
                        (mN = mX[0x6]),
                        (mX[0x6] = mX[0x9]),
                        (mX[0x9] = mN),
                        (mN = mX[0x3]),
                        (mX[0x3] = mX[0xc]),
                        (mX[0xc] = mN),
                        (mN = mX[0x7]),
                        (mX[0x7] = mX[0xd]),
                        (mX[0xd] = mN),
                        (mN = mX[0xb]),
                        (mX[0xb] = mX[0xe]),
                        (mX[0xe] = mN),
                        this
                    );
                },
                setPosition: function (mN, mX, mf) {
                    var mP = this["elements"];
                    return mN["isVector3"] ? ((mP[0xc] = mN["x"]), (mP[0xd] = mN["y"]), (mP[0xe] = mN["z"])) : ((mP[0xc] = mN), (mP[0xd] = mX), (mP[0xe] = mf)), this;
                },
                getInverse: function (mN, mX) {
                    void 0x0 !== mX && console["warn"]("THREE.Matrix4:\x20.getInverse()\x20can\x20no\x20longer\x20be\x20configured\x20to\x20throw\x20on\x20degenerate.");
                    var mf = this["elements"],
                        mP = mN["elements"],
                        mI = mP[0x0],
                        mA = mP[0x1],
                        mM = mP[0x2],
                        mp = mP[0x3],
                        mk = mP[0x4],
                        mU = mP[0x5],
                        mq = mP[0x6],
                        mw = mP[0x7],
                        mO = mP[0x8],
                        mj = mP[0x9],
                        mh = mP[0xa],
                        mS = mP[0xb],
                        mg = mP[0xc],
                        mW = mP[0xd],
                        mH = mP[0xe],
                        mx = mP[0xf],
                        mK = mj * mH * mw - mW * mh * mw + mW * mq * mS - mU * mH * mS - mj * mq * mx + mU * mh * mx,
                        mV = mg * mh * mw - mO * mH * mw - mg * mq * mS + mk * mH * mS + mO * mq * mx - mk * mh * mx,
                        mJ = mO * mW * mw - mg * mj * mw + mg * mU * mS - mk * mW * mS - mO * mU * mx + mk * mj * mx,
                        mG = mg * mj * mq - mO * mW * mq - mg * mU * mh + mk * mW * mh + mO * mU * mH - mk * mj * mH,
                        mL = mI * mK + mA * mV + mM * mJ + mp * mG;
                    if (0x0 === mL) return this["set"](0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
                    var mQ = 0x1 / mL;
                    return (
                        (mf[0x0] = mK * mQ),
                        (mf[0x1] = (mW * mh * mp - mj * mH * mp - mW * mM * mS + mA * mH * mS + mj * mM * mx - mA * mh * mx) * mQ),
                        (mf[0x2] = (mU * mH * mp - mW * mq * mp + mW * mM * mw - mA * mH * mw - mU * mM * mx + mA * mq * mx) * mQ),
                        (mf[0x3] = (mj * mq * mp - mU * mh * mp - mj * mM * mw + mA * mh * mw + mU * mM * mS - mA * mq * mS) * mQ),
                        (mf[0x4] = mV * mQ),
                        (mf[0x5] = (mO * mH * mp - mg * mh * mp + mg * mM * mS - mI * mH * mS - mO * mM * mx + mI * mh * mx) * mQ),
                        (mf[0x6] = (mg * mq * mp - mk * mH * mp - mg * mM * mw + mI * mH * mw + mk * mM * mx - mI * mq * mx) * mQ),
                        (mf[0x7] = (mk * mh * mp - mO * mq * mp + mO * mM * mw - mI * mh * mw - mk * mM * mS + mI * mq * mS) * mQ),
                        (mf[0x8] = mJ * mQ),
                        (mf[0x9] = (mg * mj * mp - mO * mW * mp - mg * mA * mS + mI * mW * mS + mO * mA * mx - mI * mj * mx) * mQ),
                        (mf[0xa] = (mk * mW * mp - mg * mU * mp + mg * mA * mw - mI * mW * mw - mk * mA * mx + mI * mU * mx) * mQ),
                        (mf[0xb] = (mO * mU * mp - mk * mj * mp - mO * mA * mw + mI * mj * mw + mk * mA * mS - mI * mU * mS) * mQ),
                        (mf[0xc] = mG * mQ),
                        (mf[0xd] = (mO * mW * mM - mg * mj * mM + mg * mA * mh - mI * mW * mh - mO * mA * mH + mI * mj * mH) * mQ),
                        (mf[0xe] = (mg * mU * mM - mk * mW * mM - mg * mA * mq + mI * mW * mq + mk * mA * mH - mI * mU * mH) * mQ),
                        (mf[0xf] = (mk * mj * mM - mO * mU * mM + mO * mA * mq - mI * mj * mq - mk * mA * mh + mI * mU * mh) * mQ),
                        this
                    );
                },
                scale: function (mN) {
                    var mX = this["elements"],
                        mf = mN["x"],
                        mP = mN["y"],
                        mI = mN["z"];
                    return (mX[0x0] *= mf), (mX[0x4] *= mP), (mX[0x8] *= mI), (mX[0x1] *= mf), (mX[0x5] *= mP), (mX[0x9] *= mI), (mX[0x2] *= mf), (mX[0x6] *= mP), (mX[0xa] *= mI), (mX[0x3] *= mf), (mX[0x7] *= mP), (mX[0xb] *= mI), this;
                },
                getMaxScaleOnAxis: function () {
                    var mN = this["elements"],
                        mX = mN[0x0] * mN[0x0] + mN[0x1] * mN[0x1] + mN[0x2] * mN[0x2],
                        mf = mN[0x4] * mN[0x4] + mN[0x5] * mN[0x5] + mN[0x6] * mN[0x6],
                        mP = mN[0x8] * mN[0x8] + mN[0x9] * mN[0x9] + mN[0xa] * mN[0xa];
                    return Math["sqrt"](Math["max"](mX, mf, mP));
                },
                makeTranslation: function (mN, mX, mf) {
                    return this["set"](0x1, 0x0, 0x0, mN, 0x0, 0x1, 0x0, mX, 0x0, 0x0, 0x1, mf, 0x0, 0x0, 0x0, 0x1), this;
                },
                makeRotationX: function (mN) {
                    var mX = Math["cos"](mN),
                        mf = Math["sin"](mN);
                    return this["set"](0x1, 0x0, 0x0, 0x0, 0x0, mX, -mf, 0x0, 0x0, mf, mX, 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                makeRotationY: function (mN) {
                    var mX = Math["cos"](mN),
                        mf = Math["sin"](mN);
                    return this["set"](mX, 0x0, mf, 0x0, 0x0, 0x1, 0x0, 0x0, -mf, 0x0, mX, 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                makeRotationZ: function (mN) {
                    var mX = Math["cos"](mN),
                        mf = Math["sin"](mN);
                    return this["set"](mX, -mf, 0x0, 0x0, mf, mX, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                makeRotationAxis: function (mN, mX) {
                    var mf = Math["cos"](mX),
                        mP = Math["sin"](mX),
                        mI = 0x1 - mf,
                        mA = mN["x"],
                        mM = mN["y"],
                        mp = mN["z"],
                        mk = mI * mA,
                        mU = mI * mM;
                    return (
                        this["set"](mk * mA + mf, mk * mM - mP * mp, mk * mp + mP * mM, 0x0, mk * mM + mP * mp, mU * mM + mf, mU * mp - mP * mA, 0x0, mk * mp - mP * mM, mU * mp + mP * mA, mI * mp * mp + mf, 0x0, 0x0, 0x0, 0x0, 0x1), this
                    );
                },
                makeScale: function (mN, mX, mf) {
                    return this["set"](mN, 0x0, 0x0, 0x0, 0x0, mX, 0x0, 0x0, 0x0, 0x0, mf, 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                makeShear: function (mN, mX, mf) {
                    return this["set"](0x1, mX, mf, 0x0, mN, 0x1, mf, 0x0, mN, mX, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1), this;
                },
                compose: function (mN, mX, mf) {
                    var mP = this["elements"],
                        mI = mX["_x"],
                        mA = mX["_y"],
                        mM = mX["_z"],
                        mp = mX["_w"],
                        mk = mI + mI,
                        mU = mA + mA,
                        mq = mM + mM,
                        mw = mI * mk,
                        mO = mI * mU,
                        mj = mI * mq,
                        mh = mA * mU,
                        mS = mA * mq,
                        mg = mM * mq,
                        mW = mp * mk,
                        mH = mp * mU,
                        mx = mp * mq,
                        mK = mf["x"],
                        mV = mf["y"],
                        mJ = mf["z"];
                    return (
                        (mP[0x0] = (0x1 - (mh + mg)) * mK),
                        (mP[0x1] = (mO + mx) * mK),
                        (mP[0x2] = (mj - mH) * mK),
                        (mP[0x3] = 0x0),
                        (mP[0x4] = (mO - mx) * mV),
                        (mP[0x5] = (0x1 - (mw + mg)) * mV),
                        (mP[0x6] = (mS + mW) * mV),
                        (mP[0x7] = 0x0),
                        (mP[0x8] = (mj + mH) * mJ),
                        (mP[0x9] = (mS - mW) * mJ),
                        (mP[0xa] = (0x1 - (mw + mh)) * mJ),
                        (mP[0xb] = 0x0),
                        (mP[0xc] = mN["x"]),
                        (mP[0xd] = mN["y"]),
                        (mP[0xe] = mN["z"]),
                        (mP[0xf] = 0x1),
                        this
                    );
                },
                decompose: function (mN, mX, mf) {
                    var mP = this["elements"],
                        mI = EY["set"](mP[0x0], mP[0x1], mP[0x2])["length"](),
                        mA = EY["set"](mP[0x4], mP[0x5], mP[0x6])["length"](),
                        mM = EY["set"](mP[0x8], mP[0x9], mP[0xa])["length"]();
                    this["determinant"]() < 0x0 && (mI = -mI), (mN["x"] = mP[0xc]), (mN["y"] = mP[0xd]), (mN["z"] = mP[0xe]), EB["copy"](this);
                    var mp = 0x1 / mI,
                        mk = 0x1 / mA,
                        mU = 0x1 / mM;
                    return (
                        (EB["elements"][0x0] *= mp),
                        (EB["elements"][0x1] *= mp),
                        (EB["elements"][0x2] *= mp),
                        (EB["elements"][0x4] *= mk),
                        (EB["elements"][0x5] *= mk),
                        (EB["elements"][0x6] *= mk),
                        (EB["elements"][0x8] *= mU),
                        (EB["elements"][0x9] *= mU),
                        (EB["elements"][0xa] *= mU),
                        mX["setFromRotationMatrix"](EB),
                        (mf["x"] = mI),
                        (mf["y"] = mA),
                        (mf["z"] = mM),
                        this
                    );
                },
                makePerspective: function (mN, mX, mf, mP, mI, mA) {
                    void 0x0 === mA && console["warn"]("THREE.Matrix4:\x20.makePerspective()\x20has\x20been\x20redefined\x20and\x20has\x20a\x20new\x20signature.\x20Please\x20check\x20the\x20docs.");
                    var mM = this["elements"],
                        mp = (0x2 * mI) / (mX - mN),
                        mk = (0x2 * mI) / (mf - mP),
                        mU = (mX + mN) / (mX - mN),
                        mq = (mf + mP) / (mf - mP),
                        mw = -(mA + mI) / (mA - mI),
                        mO = (-0x2 * mA * mI) / (mA - mI);
                    return (
                        (mM[0x0] = mp),
                        (mM[0x4] = 0x0),
                        (mM[0x8] = mU),
                        (mM[0xc] = 0x0),
                        (mM[0x1] = 0x0),
                        (mM[0x5] = mk),
                        (mM[0x9] = mq),
                        (mM[0xd] = 0x0),
                        (mM[0x2] = 0x0),
                        (mM[0x6] = 0x0),
                        (mM[0xa] = mw),
                        (mM[0xe] = mO),
                        (mM[0x3] = 0x0),
                        (mM[0x7] = 0x0),
                        (mM[0xb] = -0x1),
                        (mM[0xf] = 0x0),
                        this
                    );
                },
                makeOrthographic: function (mN, mX, mf, mP, mI, mA) {
                    var mM = this["elements"],
                        mp = 0x1 / (mX - mN),
                        mk = 0x1 / (mf - mP),
                        mU = 0x1 / (mA - mI),
                        mq = (mX + mN) * mp,
                        mw = (mf + mP) * mk,
                        mO = (mA + mI) * mU;
                    return (
                        (mM[0x0] = 0x2 * mp),
                        (mM[0x4] = 0x0),
                        (mM[0x8] = 0x0),
                        (mM[0xc] = -mq),
                        (mM[0x1] = 0x0),
                        (mM[0x5] = 0x2 * mk),
                        (mM[0x9] = 0x0),
                        (mM[0xd] = -mw),
                        (mM[0x2] = 0x0),
                        (mM[0x6] = 0x0),
                        (mM[0xa] = -0x2 * mU),
                        (mM[0xe] = -mO),
                        (mM[0x3] = 0x0),
                        (mM[0x7] = 0x0),
                        (mM[0xb] = 0x0),
                        (mM[0xf] = 0x1),
                        this
                    );
                },
                equals: function (mN) {
                    for (var mX = this["elements"], mf = mN["elements"], mP = 0x0; mP < 0x10; mP++) if (mX[mP] !== mf[mP]) return !0x1;
                    return !0x0;
                },
                fromArray: function (mN, mX) {
                    void 0x0 === mX && (mX = 0x0);
                    for (var mf = 0x0; mf < 0x10; mf++) this["elements"][mf] = mN[mf + mX];
                    return this;
                },
                toArray: function (mN, mX) {
                    void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0);
                    var mf = this["elements"];
                    return (
                        (mN[mX] = mf[0x0]),
                        (mN[mX + 0x1] = mf[0x1]),
                        (mN[mX + 0x2] = mf[0x2]),
                        (mN[mX + 0x3] = mf[0x3]),
                        (mN[mX + 0x4] = mf[0x4]),
                        (mN[mX + 0x5] = mf[0x5]),
                        (mN[mX + 0x6] = mf[0x6]),
                        (mN[mX + 0x7] = mf[0x7]),
                        (mN[mX + 0x8] = mf[0x8]),
                        (mN[mX + 0x9] = mf[0x9]),
                        (mN[mX + 0xa] = mf[0xa]),
                        (mN[mX + 0xb] = mf[0xb]),
                        (mN[mX + 0xc] = mf[0xc]),
                        (mN[mX + 0xd] = mf[0xd]),
                        (mN[mX + 0xe] = mf[0xe]),
                        (mN[mX + 0xf] = mf[0xf]),
                        mN
                    );
                },
            });
            var ED = new Ey(),
                EN = new ER();
            function EX(mN, mX, mf, mP) {
                (this["_x"] = mN || 0x0), (this["_y"] = mX || 0x0), (this["_z"] = mf || 0x0), (this["_order"] = mP || EX["DefaultOrder"]);
            }
            function Ef() {
                this["mask"] = 0x1;
            }
            (EX["RotationOrders"] = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
                (EX["DefaultOrder"] = "XYZ"),
                Object["defineProperties"](EX["prototype"], {
                    x: {
                        get: function () {
                            return this["_x"];
                        },
                        set: function (mN) {
                            (this["_x"] = mN), this["_onChangeCallback"]();
                        },
                    },
                    y: {
                        get: function () {
                            return this["_y"];
                        },
                        set: function (mN) {
                            (this["_y"] = mN), this["_onChangeCallback"]();
                        },
                    },
                    z: {
                        get: function () {
                            return this["_z"];
                        },
                        set: function (mN) {
                            (this["_z"] = mN), this["_onChangeCallback"]();
                        },
                    },
                    order: {
                        get: function () {
                            return this["_order"];
                        },
                        set: function (mN) {
                            (this["_order"] = mN), this["_onChangeCallback"]();
                        },
                    },
                }),
                Object["assign"](EX["prototype"], {
                    isEuler: !0x0,
                    set: function (mN, mX, mf, mP) {
                        return (this["_x"] = mN), (this["_y"] = mX), (this["_z"] = mf), (this["_order"] = mP || this["_order"]), this["_onChangeCallback"](), this;
                    },
                    clone: function () {
                        return new this["constructor"](this["_x"], this["_y"], this["_z"], this["_order"]);
                    },
                    copy: function (mN) {
                        return (this["_x"] = mN["_x"]), (this["_y"] = mN["_y"]), (this["_z"] = mN["_z"]), (this["_order"] = mN["_order"]), this["_onChangeCallback"](), this;
                    },
                    setFromRotationMatrix: function (mN, mX, mf) {
                        var mP = E2["clamp"],
                            mI = mN["elements"],
                            mA = mI[0x0],
                            mM = mI[0x4],
                            mp = mI[0x8],
                            mk = mI[0x1],
                            mU = mI[0x5],
                            mq = mI[0x9],
                            mw = mI[0x2],
                            mO = mI[0x6],
                            mj = mI[0xa];
                        switch ((mX = mX || this["_order"])) {
                            case "XYZ":
                                (this["_y"] = Math["asin"](mP(mp, -0x1, 0x1))),
                                    Math["abs"](mp) < 0.9999999 ? ((this["_x"] = Math["atan2"](-mq, mj)), (this["_z"] = Math["atan2"](-mM, mA))) : ((this["_x"] = Math["atan2"](mO, mU)), (this["_z"] = 0x0));
                                break;
                            case "YXZ":
                                (this["_x"] = Math["asin"](-mP(mq, -0x1, 0x1))),
                                    Math["abs"](mq) < 0.9999999 ? ((this["_y"] = Math["atan2"](mp, mj)), (this["_z"] = Math["atan2"](mk, mU))) : ((this["_y"] = Math["atan2"](-mw, mA)), (this["_z"] = 0x0));
                                break;
                            case "ZXY":
                                (this["_x"] = Math["asin"](mP(mO, -0x1, 0x1))),
                                    Math["abs"](mO) < 0.9999999 ? ((this["_y"] = Math["atan2"](-mw, mj)), (this["_z"] = Math["atan2"](-mM, mU))) : ((this["_y"] = 0x0), (this["_z"] = Math["atan2"](mk, mA)));
                                break;
                            case "ZYX":
                                (this["_y"] = Math["asin"](-mP(mw, -0x1, 0x1))),
                                    Math["abs"](mw) < 0.9999999 ? ((this["_x"] = Math["atan2"](mO, mj)), (this["_z"] = Math["atan2"](mk, mA))) : ((this["_x"] = 0x0), (this["_z"] = Math["atan2"](-mM, mU)));
                                break;
                            case "YZX":
                                (this["_z"] = Math["asin"](mP(mk, -0x1, 0x1))),
                                    Math["abs"](mk) < 0.9999999 ? ((this["_x"] = Math["atan2"](-mq, mU)), (this["_y"] = Math["atan2"](-mw, mA))) : ((this["_x"] = 0x0), (this["_y"] = Math["atan2"](mp, mj)));
                                break;
                            case "XZY":
                                (this["_z"] = Math["asin"](-mP(mM, -0x1, 0x1))),
                                    Math["abs"](mM) < 0.9999999 ? ((this["_x"] = Math["atan2"](mO, mU)), (this["_y"] = Math["atan2"](mp, mA))) : ((this["_x"] = Math["atan2"](-mq, mj)), (this["_y"] = 0x0));
                                break;
                            default:
                                console["warn"]("THREE.Euler:\x20.setFromRotationMatrix()\x20encountered\x20an\x20unknown\x20order:\x20" + mX);
                        }
                        return (this["_order"] = mX), !0x1 !== mf && this["_onChangeCallback"](), this;
                    },
                    setFromQuaternion: function (mN, mX, mf) {
                        return ED["makeRotationFromQuaternion"](mN), this["setFromRotationMatrix"](ED, mX, mf);
                    },
                    setFromVector3: function (mN, mX) {
                        return this["set"](mN["x"], mN["y"], mN["z"], mX || this["_order"]);
                    },
                    reorder: function (mN) {
                        return EN["setFromEuler"](this), this["setFromQuaternion"](EN, mN);
                    },
                    equals: function (mN) {
                        return mN["_x"] === this["_x"] && mN["_y"] === this["_y"] && mN["_z"] === this["_z"] && mN["_order"] === this["_order"];
                    },
                    fromArray: function (mN) {
                        return (this["_x"] = mN[0x0]), (this["_y"] = mN[0x1]), (this["_z"] = mN[0x2]), void 0x0 !== mN[0x3] && (this["_order"] = mN[0x3]), this["_onChangeCallback"](), this;
                    },
                    toArray: function (mN, mX) {
                        return void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0), (mN[mX] = this["_x"]), (mN[mX + 0x1] = this["_y"]), (mN[mX + 0x2] = this["_z"]), (mN[mX + 0x3] = this["_order"]), mN;
                    },
                    toVector3: function (mN) {
                        return mN ? mN["set"](this["_x"], this["_y"], this["_z"]) : new Ed(this["_x"], this["_y"], this["_z"]);
                    },
                    _onChange: function (mN) {
                        return (this["_onChangeCallback"] = mN), this;
                    },
                    _onChangeCallback: function () {},
                }),
                Object["assign"](Ef["prototype"], {
                    set: function (mN) {
                        this["mask"] = (0x1 << mN) | 0x0;
                    },
                    enable: function (mN) {
                        this["mask"] |= (0x1 << mN) | 0x0;
                    },
                    enableAll: function () {
                        this["mask"] = -0x1;
                    },
                    toggle: function (mN) {
                        this["mask"] ^= (0x1 << mN) | 0x0;
                    },
                    disable: function (mN) {
                        this["mask"] &= ~((0x1 << mN) | 0x0);
                    },
                    disableAll: function () {
                        this["mask"] = 0x0;
                    },
                    test: function (mN) {
                        return 0x0 != (this["mask"] & mN["mask"]);
                    },
                });
            let EP = 0x0;
            const EI = new Ed(),
                EA = new ER(),
                EM = new Ey(),
                Ep = new Ed(),
                Ek = new Ed(),
                EU = new Ed(),
                Eq = new ER(),
                Ew = new Ed(0x1, 0x0, 0x0),
                EO = new Ed(0x0, 0x1, 0x0),
                Ej = new Ed(0x0, 0x0, 0x1),
                Eh = { type: "added" },
                ES = { type: "removed" };
            function Eg() {
                Object["defineProperty"](this, "id", { value: EP++ }),
                    (this["uuid"] = E2["generateUUID"]()),
                    (this["name"] = ""),
                    (this["type"] = "Object3D"),
                    (this["parent"] = null),
                    (this["children"] = []),
                    (this["up"] = Eg["DefaultUp"]["clone"]());
                var mN = new Ed(),
                    mX = new EX(),
                    mf = new ER(),
                    mP = new Ed(0x1, 0x1, 0x1);
                mX["_onChange"](function () {
                    mf["setFromEuler"](mX, !0x1);
                }),
                    mf["_onChange"](function () {
                        mX["setFromQuaternion"](mf, void 0x0, !0x1);
                    }),
                    Object["defineProperties"](this, {
                        position: { configurable: !0x0, enumerable: !0x0, value: mN },
                        rotation: { configurable: !0x0, enumerable: !0x0, value: mX },
                        quaternion: { configurable: !0x0, enumerable: !0x0, value: mf },
                        scale: { configurable: !0x0, enumerable: !0x0, value: mP },
                        modelViewMatrix: { value: new Ey() },
                        normalMatrix: { value: new E4() },
                    }),
                    (this["matrix"] = new Ey()),
                    (this["matrixWorld"] = new Ey()),
                    (this["matrixAutoUpdate"] = Eg["DefaultMatrixAutoUpdate"]),
                    (this["matrixWorldNeedsUpdate"] = !0x1),
                    (this["layers"] = new Ef()),
                    (this["visible"] = !0x0),
                    (this["castShadow"] = !0x1),
                    (this["receiveShadow"] = !0x1),
                    (this["frustumCulled"] = !0x0),
                    (this["renderOrder"] = 0x0),
                    (this["userData"] = {});
            }
            function EW() {
                Eg["call"](this),
                    (this["type"] = "Scene"),
                    (this["background"] = null),
                    (this["environment"] = null),
                    (this["fog"] = null),
                    (this["overrideMaterial"] = null),
                    (this["autoUpdate"] = !0x0),
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__["dispatchEvent"](new CustomEvent("observe", { detail: this }));
            }
            (Eg["DefaultUp"] = new Ed(0x0, 0x1, 0x0)),
                (Eg["DefaultMatrixAutoUpdate"] = !0x0),
                (Eg["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                    constructor: Eg,
                    isObject3D: !0x0,
                    onBeforeRender: function () {},
                    onAfterRender: function () {},
                    applyMatrix4: function (mN) {
                        this["matrixAutoUpdate"] && this["updateMatrix"](), this["matrix"]["premultiply"](mN), this["matrix"]["decompose"](this["position"], this["quaternion"], this["scale"]);
                    },
                    applyQuaternion: function (mN) {
                        return this["quaternion"]["premultiply"](mN), this;
                    },
                    setRotationFromAxisAngle: function (mN, mX) {
                        this["quaternion"]["setFromAxisAngle"](mN, mX);
                    },
                    setRotationFromEuler: function (mN) {
                        this["quaternion"]["setFromEuler"](mN, !0x0);
                    },
                    setRotationFromMatrix: function (mN) {
                        this["quaternion"]["setFromRotationMatrix"](mN);
                    },
                    setRotationFromQuaternion: function (mN) {
                        this["quaternion"]["copy"](mN);
                    },
                    rotateOnAxis: function (mN, mX) {
                        return EA["setFromAxisAngle"](mN, mX), this["quaternion"]["multiply"](EA), this;
                    },
                    rotateOnWorldAxis: function (mN, mX) {
                        return EA["setFromAxisAngle"](mN, mX), this["quaternion"]["premultiply"](EA), this;
                    },
                    rotateX: function (mN) {
                        return this["rotateOnAxis"](Ew, mN);
                    },
                    rotateY: function (mN) {
                        return this["rotateOnAxis"](EO, mN);
                    },
                    rotateZ: function (mN) {
                        return this["rotateOnAxis"](Ej, mN);
                    },
                    translateOnAxis: function (mN, mX) {
                        return EI["copy"](mN)["applyQuaternion"](this["quaternion"]), this["position"]["add"](EI["multiplyScalar"](mX)), this;
                    },
                    translateX: function (mN) {
                        return this["translateOnAxis"](Ew, mN);
                    },
                    translateY: function (mN) {
                        return this["translateOnAxis"](EO, mN);
                    },
                    translateZ: function (mN) {
                        return this["translateOnAxis"](Ej, mN);
                    },
                    localToWorld: function (mN) {
                        return mN["applyMatrix4"](this["matrixWorld"]);
                    },
                    worldToLocal: function (mN) {
                        return mN["applyMatrix4"](EM["getInverse"](this["matrixWorld"]));
                    },
                    lookAt: function (mN, mX, mf) {
                        mN["isVector3"] ? Ep["copy"](mN) : Ep["set"](mN, mX, mf);
                        var mP = this["parent"];
                        this["updateWorldMatrix"](!0x0, !0x1),
                            Ek["setFromMatrixPosition"](this["matrixWorld"]),
                            this["isCamera"] || this["isLight"] ? EM["lookAt"](Ek, Ep, this["up"]) : EM["lookAt"](Ep, Ek, this["up"]),
                            this["quaternion"]["setFromRotationMatrix"](EM),
                            mP && (EM["extractRotation"](mP["matrixWorld"]), EA["setFromRotationMatrix"](EM), this["quaternion"]["premultiply"](EA["inverse"]()));
                    },
                    add: function (mN) {
                        if (arguments["length"] > 0x1) {
                            for (var mX = 0x0; mX < arguments["length"]; mX++) this["add"](arguments[mX]);
                            return this;
                        }
                        return mN === this
                            ? (console["error"]("THREE.Object3D.add:\x20object\x20can\x27t\x20be\x20added\x20as\x20a\x20child\x20of\x20itself.", mN), this)
                            : (mN && mN["isObject3D"]
                                  ? (null !== mN["parent"] && mN["parent"]["remove"](mN), (mN["parent"] = this), this["children"]["push"](mN), mN["dispatchEvent"](Eh))
                                  : console["error"]("THREE.Object3D.add:\x20object\x20not\x20an\x20instance\x20of\x20THREE.Object3D.", mN),
                              this);
                    },
                    remove: function (mN) {
                        if (arguments["length"] > 0x1) {
                            for (var mX = 0x0; mX < arguments["length"]; mX++) this["remove"](arguments[mX]);
                            return this;
                        }
                        var mf = this["children"]["indexOf"](mN);
                        return -0x1 !== mf && ((mN["parent"] = null), this["children"]["splice"](mf, 0x1), mN["dispatchEvent"](ES)), this;
                    },
                    attach: function (mN) {
                        return (
                            this["updateWorldMatrix"](!0x0, !0x1),
                            EM["getInverse"](this["matrixWorld"]),
                            null !== mN["parent"] && (mN["parent"]["updateWorldMatrix"](!0x0, !0x1), EM["multiply"](mN["parent"]["matrixWorld"])),
                            mN["applyMatrix4"](EM),
                            mN["updateWorldMatrix"](!0x1, !0x1),
                            this["add"](mN),
                            this
                        );
                    },
                    getObjectById: function (mN) {
                        return this["getObjectByProperty"]("id", mN);
                    },
                    getObjectByName: function (mN) {
                        return this["getObjectByProperty"]("name", mN);
                    },
                    getObjectByProperty: function (mN, mX) {
                        if (this[mN] === mX) return this;
                        for (var mf = 0x0, mP = this["children"]["length"]; mf < mP; mf++) {
                            var mI = this["children"][mf]["getObjectByProperty"](mN, mX);
                            if (void 0x0 !== mI) return mI;
                        }
                    },
                    getWorldPosition: function (mN) {
                        return (
                            void 0x0 === mN && (console["warn"]("THREE.Object3D:\x20.getWorldPosition()\x20target\x20is\x20now\x20required"), (mN = new Ed())),
                            this["updateMatrixWorld"](!0x0),
                            mN["setFromMatrixPosition"](this["matrixWorld"])
                        );
                    },
                    getWorldQuaternion: function (mN) {
                        return (
                            void 0x0 === mN && (console["warn"]("THREE.Object3D:\x20.getWorldQuaternion()\x20target\x20is\x20now\x20required"), (mN = new ER())),
                            this["updateMatrixWorld"](!0x0),
                            this["matrixWorld"]["decompose"](Ek, mN, EU),
                            mN
                        );
                    },
                    getWorldScale: function (mN) {
                        return (
                            void 0x0 === mN && (console["warn"]("THREE.Object3D:\x20.getWorldScale()\x20target\x20is\x20now\x20required"), (mN = new Ed())), this["updateMatrixWorld"](!0x0), this["matrixWorld"]["decompose"](Ek, Eq, mN), mN
                        );
                    },
                    getWorldDirection: function (mN) {
                        void 0x0 === mN && (console["warn"]("THREE.Object3D:\x20.getWorldDirection()\x20target\x20is\x20now\x20required"), (mN = new Ed())), this["updateMatrixWorld"](!0x0);
                        var mX = this["matrixWorld"]["elements"];
                        return mN["set"](mX[0x8], mX[0x9], mX[0xa])["normalize"]();
                    },
                    raycast: function () {},
                    traverse: function (mN) {
                        mN(this);
                        for (var mX = this["children"], mf = 0x0, mP = mX["length"]; mf < mP; mf++) mX[mf]["traverse"](mN);
                    },
                    traverseVisible: function (mN) {
                        if (!0x1 !== this["visible"]) {
                            mN(this);
                            for (var mX = this["children"], mf = 0x0, mP = mX["length"]; mf < mP; mf++) mX[mf]["traverseVisible"](mN);
                        }
                    },
                    traverseAncestors: function (mN) {
                        var mX = this["parent"];
                        null !== mX && (mN(mX), mX["traverseAncestors"](mN));
                    },
                    updateMatrix: function () {
                        this["matrix"]["compose"](this["position"], this["quaternion"], this["scale"]), (this["matrixWorldNeedsUpdate"] = !0x0);
                    },
                    updateMatrixWorld: function (mN) {
                        this["matrixAutoUpdate"] && this["updateMatrix"](),
                            (this["matrixWorldNeedsUpdate"] || mN) &&
                                (null === this["parent"] ? this["matrixWorld"]["copy"](this["matrix"]) : this["matrixWorld"]["multiplyMatrices"](this["parent"]["matrixWorld"], this["matrix"]),
                                (this["matrixWorldNeedsUpdate"] = !0x1),
                                (mN = !0x0));
                        for (var mX = this["children"], mf = 0x0, mP = mX["length"]; mf < mP; mf++) mX[mf]["updateMatrixWorld"](mN);
                    },
                    updateWorldMatrix: function (mN, mX) {
                        var mf = this["parent"];
                        if (
                            (!0x0 === mN && null !== mf && mf["updateWorldMatrix"](!0x0, !0x1),
                            this["matrixAutoUpdate"] && this["updateMatrix"](),
                            null === this["parent"] ? this["matrixWorld"]["copy"](this["matrix"]) : this["matrixWorld"]["multiplyMatrices"](this["parent"]["matrixWorld"], this["matrix"]),
                            !0x0 === mX)
                        ) {
                            for (var mP = this["children"], mI = 0x0, mA = mP["length"]; mI < mA; mI++) mP[mI]["updateWorldMatrix"](!0x1, !0x0);
                        }
                    },
                    toJSON: function (mN) {
                        var mX = void 0x0 === mN || "string" == typeof mN,
                            mf = {};
                        mX && ((mN = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }), (mf["metadata"] = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }));
                        var mP = {};
                        function mI(mg, mW) {
                            return void 0x0 === mg[mW["uuid"]] && (mg[mW["uuid"]] = mW["toJSON"](mN)), mW["uuid"];
                        }
                        if (
                            ((mP["uuid"] = this["uuid"]),
                            (mP["type"] = this["type"]),
                            "" !== this["name"] && (mP["name"] = this["name"]),
                            !0x0 === this["castShadow"] && (mP["castShadow"] = !0x0),
                            !0x0 === this["receiveShadow"] && (mP["receiveShadow"] = !0x0),
                            !0x1 === this["visible"] && (mP["visible"] = !0x1),
                            !0x1 === this["frustumCulled"] && (mP["frustumCulled"] = !0x1),
                            0x0 !== this["renderOrder"] && (mP["renderOrder"] = this["renderOrder"]),
                            "{}" !== JSON["stringify"](this["userData"]) && (mP["userData"] = this["userData"]),
                            (mP["layers"] = this["layers"]["mask"]),
                            (mP["matrix"] = this["matrix"]["toArray"]()),
                            !0x1 === this["matrixAutoUpdate"] && (mP["matrixAutoUpdate"] = !0x1),
                            this["isInstancedMesh"] && ((mP["type"] = "InstancedMesh"), (mP["count"] = this["count"]), (mP["instanceMatrix"] = this["instanceMatrix"]["toJSON"]())),
                            this["isMesh"] || this["isLine"] || this["isPoints"])
                        ) {
                            mP["geometry"] = mI(mN["geometries"], this["geometry"]);
                            var mA = this["geometry"]["parameters"];
                            if (void 0x0 !== mA && void 0x0 !== mA["shapes"]) {
                                var mM = mA["shapes"];
                                if (Array["isArray"](mM))
                                    for (var mp = 0x0, mk = mM["length"]; mp < mk; mp++) {
                                        var mU = mM[mp];
                                        mI(mN["shapes"], mU);
                                    }
                                else mI(mN["shapes"], mM);
                            }
                        }
                        if (void 0x0 !== this["material"]) {
                            if (Array["isArray"](this["material"])) {
                                var mq = [];
                                for (mp = 0x0, mk = this["material"]["length"]; mp < mk; mp++) mq["push"](mI(mN["materials"], this["material"][mp]));
                                mP["material"] = mq;
                            } else mP["material"] = mI(mN["materials"], this["material"]);
                        }
                        if (this["children"]["length"] > 0x0) {
                            mP["children"] = [];
                            for (mp = 0x0; mp < this["children"]["length"]; mp++) mP["children"]["push"](this["children"][mp]["toJSON"](mN)["object"]);
                        }
                        if (mX) {
                            var mw = mS(mN["geometries"]),
                                mO = mS(mN["materials"]),
                                mj = mS(mN["textures"]),
                                mh = mS(mN["images"]);
                            (mM = mS(mN["shapes"])),
                                (mw["length"] > 0x0 && (mf["geometries"] = mw),
                                mO["length"] > 0x0 && (mf["materials"] = mO),
                                mj["length"] > 0x0 && (mf["textures"] = mj),
                                mh["length"] > 0x0 && (mf["images"] = mh),
                                mM["length"] > 0x0 && (mf["shapes"] = mM));
                        }
                        return (mf["object"] = mP), mf;
                        function mS(mg) {
                            var mW = [];
                            for (var mH in mg) {
                                var mx = mg[mH];
                                delete mx["metadata"], mW["push"](mx);
                            }
                            return mW;
                        }
                    },
                    clone: function (mN) {
                        return new this["constructor"]()["copy"](this, mN);
                    },
                    copy: function (mN, mX) {
                        if (
                            (void 0x0 === mX && (mX = !0x0),
                            (this["name"] = mN["name"]),
                            this["up"]["copy"](mN["up"]),
                            this["position"]["copy"](mN["position"]),
                            this["quaternion"]["copy"](mN["quaternion"]),
                            this["scale"]["copy"](mN["scale"]),
                            this["matrix"]["copy"](mN["matrix"]),
                            this["matrixWorld"]["copy"](mN["matrixWorld"]),
                            (this["matrixAutoUpdate"] = mN["matrixAutoUpdate"]),
                            (this["matrixWorldNeedsUpdate"] = mN["matrixWorldNeedsUpdate"]),
                            (this["layers"]["mask"] = mN["layers"]["mask"]),
                            (this["visible"] = mN["visible"]),
                            (this["castShadow"] = mN["castShadow"]),
                            (this["receiveShadow"] = mN["receiveShadow"]),
                            (this["frustumCulled"] = mN["frustumCulled"]),
                            (this["renderOrder"] = mN["renderOrder"]),
                            (this["userData"] = JSON["parse"](JSON["stringify"](mN["userData"]))),
                            !0x0 === mX)
                        )
                            for (var mf = 0x0; mf < mN["children"]["length"]; mf++) {
                                var mP = mN["children"][mf];
                                this["add"](mP["clone"]());
                            }
                        return this;
                    },
                })),
                (EW["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                    constructor: EW,
                    isScene: !0x0,
                    copy: function (mN, mX) {
                        return (
                            Eg["prototype"]["copy"]["call"](this, mN, mX),
                            null !== mN["background"] && (this["background"] = mN["background"]["clone"]()),
                            null !== mN["environment"] && (this["environment"] = mN["environment"]["clone"]()),
                            null !== mN["fog"] && (this["fog"] = mN["fog"]["clone"]()),
                            null !== mN["overrideMaterial"] && (this["overrideMaterial"] = mN["overrideMaterial"]["clone"]()),
                            (this["autoUpdate"] = mN["autoUpdate"]),
                            (this["matrixAutoUpdate"] = mN["matrixAutoUpdate"]),
                            this
                        );
                    },
                    toJSON: function (mN) {
                        var mX = Eg["prototype"]["toJSON"]["call"](this, mN);
                        return (
                            null !== this["background"] && (mX["object"]["background"] = this["background"]["toJSON"](mN)),
                            null !== this["environment"] && (mX["object"]["environment"] = this["environment"]["toJSON"](mN)),
                            null !== this["fog"] && (mX["object"]["fog"] = this["fog"]["toJSON"]()),
                            mX
                        );
                    },
                    dispose: function () {
                        this["dispatchEvent"]({ type: "dispose" });
                    },
                }));
            var EH = [new Ed(), new Ed(), new Ed(), new Ed(), new Ed(), new Ed(), new Ed(), new Ed()],
                Ex = new Ed(),
                EK = new R4(),
                EV = new Ed(),
                EJ = new Ed(),
                EG = new Ed(),
                EL = new Ed(),
                EQ = new Ed(),
                Ez = new Ed(),
                R0 = new Ed(),
                R1 = new Ed(),
                R2 = new Ed(),
                R3 = new Ed();
            function R4(mN, mX) {
                (this["min"] = void 0x0 !== mN ? mN : new Ed(0x1 / 0x0, 0x1 / 0x0, 0x1 / 0x0)), (this["max"] = void 0x0 !== mX ? mX : new Ed(-0x1 / 0x0, -0x1 / 0x0, -0x1 / 0x0));
            }
            function R5(mN, mX, mf, mP, mI) {
                var mA, mM;
                for (mA = 0x0, mM = mN["length"] - 0x3; mA <= mM; mA += 0x3) {
                    R3["fromArray"](mN, mA);
                    var mp = mI["x"] * Math["abs"](R3["x"]) + mI["y"] * Math["abs"](R3["y"]) + mI["z"] * Math["abs"](R3["z"]),
                        mk = mX["dot"](R3),
                        mU = mf["dot"](R3),
                        mq = mP["dot"](R3);
                    if (Math["max"](-Math["max"](mk, mU, mq), Math["min"](mk, mU, mq)) > mp) return !0x1;
                }
                return !0x0;
            }
            Object["assign"](R4["prototype"], {
                isBox3: !0x0,
                set: function (mN, mX) {
                    return this["min"]["copy"](mN), this["max"]["copy"](mX), this;
                },
                setFromArray: function (mN) {
                    for (var mX = 0x1 / 0x0, mf = 0x1 / 0x0, mP = 0x1 / 0x0, mI = -0x1 / 0x0, mA = -0x1 / 0x0, mM = -0x1 / 0x0, mp = 0x0, mk = mN["length"]; mp < mk; mp += 0x3) {
                        var mU = mN[mp],
                            mq = mN[mp + 0x1],
                            mw = mN[mp + 0x2];
                        mU < mX && (mX = mU), mq < mf && (mf = mq), mw < mP && (mP = mw), mU > mI && (mI = mU), mq > mA && (mA = mq), mw > mM && (mM = mw);
                    }
                    return this["min"]["set"](mX, mf, mP), this["max"]["set"](mI, mA, mM), this;
                },
                setFromBufferAttribute: function (mN) {
                    for (var mX = 0x1 / 0x0, mf = 0x1 / 0x0, mP = 0x1 / 0x0, mI = -0x1 / 0x0, mA = -0x1 / 0x0, mM = -0x1 / 0x0, mp = 0x0, mk = mN["count"]; mp < mk; mp++) {
                        var mU = mN["getX"](mp),
                            mq = mN["getY"](mp),
                            mw = mN["getZ"](mp);
                        mU < mX && (mX = mU), mq < mf && (mf = mq), mw < mP && (mP = mw), mU > mI && (mI = mU), mq > mA && (mA = mq), mw > mM && (mM = mw);
                    }
                    return this["min"]["set"](mX, mf, mP), this["max"]["set"](mI, mA, mM), this;
                },
                setFromPoints: function (mN) {
                    this["makeEmpty"]();
                    for (var mX = 0x0, mf = mN["length"]; mX < mf; mX++) this["expandByPoint"](mN[mX]);
                    return this;
                },
                setFromCenterAndSize: function (mN, mX) {
                    var mf = Ex["copy"](mX)["multiplyScalar"](0.5);
                    return this["min"]["copy"](mN)["sub"](mf), this["max"]["copy"](mN)["add"](mf), this;
                },
                setFromObject: function (mN) {
                    return this["makeEmpty"](), this["expandByObject"](mN);
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    return this["min"]["copy"](mN["min"]), this["max"]["copy"](mN["max"]), this;
                },
                makeEmpty: function () {
                    return (this["min"]["x"] = this["min"]["y"] = this["min"]["z"] = 0x1 / 0x0), (this["max"]["x"] = this["max"]["y"] = this["max"]["z"] = -0x1 / 0x0), this;
                },
                isEmpty: function () {
                    return this["max"]["x"] < this["min"]["x"] || this["max"]["y"] < this["min"]["y"] || this["max"]["z"] < this["min"]["z"];
                },
                getCenter: function (mN) {
                    return (
                        void 0x0 === mN && (console["warn"]("THREE.Box3:\x20.getCenter()\x20target\x20is\x20now\x20required"), (mN = new Ed())),
                        this["isEmpty"]() ? mN["set"](0x0, 0x0, 0x0) : mN["addVectors"](this["min"], this["max"])["multiplyScalar"](0.5)
                    );
                },
                getSize: function (mN) {
                    return void 0x0 === mN && (console["warn"]("THREE.Box3:\x20.getSize()\x20target\x20is\x20now\x20required"), (mN = new Ed())), this["isEmpty"]() ? mN["set"](0x0, 0x0, 0x0) : mN["subVectors"](this["max"], this["min"]);
                },
                expandByPoint: function (mN) {
                    return this["min"]["min"](mN), this["max"]["max"](mN), this;
                },
                expandByVector: function (mN) {
                    return this["min"]["sub"](mN), this["max"]["add"](mN), this;
                },
                expandByScalar: function (mN) {
                    return this["min"]["addScalar"](-mN), this["max"]["addScalar"](mN), this;
                },
                expandByObject: function (mN) {
                    mN["updateWorldMatrix"](!0x1, !0x1);
                    var mX = mN["geometry"];
                    void 0x0 !== mX && (null === mX["boundingBox"] && mX["computeBoundingBox"](), EK["copy"](mX["boundingBox"]), EK["applyMatrix4"](mN["matrixWorld"]), this["union"](EK));
                    for (var mf = mN["children"], mP = 0x0, mI = mf["length"]; mP < mI; mP++) this["expandByObject"](mf[mP]);
                    return this;
                },
                containsPoint: function (mN) {
                    return !(mN["x"] < this["min"]["x"] || mN["x"] > this["max"]["x"] || mN["y"] < this["min"]["y"] || mN["y"] > this["max"]["y"] || mN["z"] < this["min"]["z"] || mN["z"] > this["max"]["z"]);
                },
                containsBox: function (mN) {
                    return (
                        this["min"]["x"] <= mN["min"]["x"] &&
                        mN["max"]["x"] <= this["max"]["x"] &&
                        this["min"]["y"] <= mN["min"]["y"] &&
                        mN["max"]["y"] <= this["max"]["y"] &&
                        this["min"]["z"] <= mN["min"]["z"] &&
                        mN["max"]["z"] <= this["max"]["z"]
                    );
                },
                getParameter: function (mN, mX) {
                    return (
                        void 0x0 === mX && (console["warn"]("THREE.Box3:\x20.getParameter()\x20target\x20is\x20now\x20required"), (mX = new Ed())),
                        mX["set"](
                            (mN["x"] - this["min"]["x"]) / (this["max"]["x"] - this["min"]["x"]),
                            (mN["y"] - this["min"]["y"]) / (this["max"]["y"] - this["min"]["y"]),
                            (mN["z"] - this["min"]["z"]) / (this["max"]["z"] - this["min"]["z"])
                        )
                    );
                },
                intersectsBox: function (mN) {
                    return !(
                        mN["max"]["x"] < this["min"]["x"] ||
                        mN["min"]["x"] > this["max"]["x"] ||
                        mN["max"]["y"] < this["min"]["y"] ||
                        mN["min"]["y"] > this["max"]["y"] ||
                        mN["max"]["z"] < this["min"]["z"] ||
                        mN["min"]["z"] > this["max"]["z"]
                    );
                },
                intersectsSphere: function (mN) {
                    return this["clampPoint"](mN["center"], Ex), Ex["distanceToSquared"](mN["center"]) <= mN["radius"] * mN["radius"];
                },
                intersectsPlane: function (mN) {
                    var mX, mf;
                    return (
                        mN["normal"]["x"] > 0x0 ? ((mX = mN["normal"]["x"] * this["min"]["x"]), (mf = mN["normal"]["x"] * this["max"]["x"])) : ((mX = mN["normal"]["x"] * this["max"]["x"]), (mf = mN["normal"]["x"] * this["min"]["x"])),
                        mN["normal"]["y"] > 0x0 ? ((mX += mN["normal"]["y"] * this["min"]["y"]), (mf += mN["normal"]["y"] * this["max"]["y"])) : ((mX += mN["normal"]["y"] * this["max"]["y"]), (mf += mN["normal"]["y"] * this["min"]["y"])),
                        mN["normal"]["z"] > 0x0 ? ((mX += mN["normal"]["z"] * this["min"]["z"]), (mf += mN["normal"]["z"] * this["max"]["z"])) : ((mX += mN["normal"]["z"] * this["max"]["z"]), (mf += mN["normal"]["z"] * this["min"]["z"])),
                        mX <= -mN["constant"] && mf >= -mN["constant"]
                    );
                },
                intersectsTriangle: function (mN) {
                    if (this["isEmpty"]()) return !0x1;
                    this["getCenter"](R0),
                        R1["subVectors"](this["max"], R0),
                        EV["subVectors"](mN["a"], R0),
                        EJ["subVectors"](mN["b"], R0),
                        EG["subVectors"](mN["c"], R0),
                        EL["subVectors"](EJ, EV),
                        EQ["subVectors"](EG, EJ),
                        Ez["subVectors"](EV, EG);
                    var mX = [
                        0x0,
                        -EL["z"],
                        EL["y"],
                        0x0,
                        -EQ["z"],
                        EQ["y"],
                        0x0,
                        -Ez["z"],
                        Ez["y"],
                        EL["z"],
                        0x0,
                        -EL["x"],
                        EQ["z"],
                        0x0,
                        -EQ["x"],
                        Ez["z"],
                        0x0,
                        -Ez["x"],
                        -EL["y"],
                        EL["x"],
                        0x0,
                        -EQ["y"],
                        EQ["x"],
                        0x0,
                        -Ez["y"],
                        Ez["x"],
                        0x0,
                    ];
                    return !!R5(mX, EV, EJ, EG, R1) && !!R5((mX = [0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1]), EV, EJ, EG, R1) && (R2["crossVectors"](EL, EQ), R5((mX = [R2["x"], R2["y"], R2["z"]]), EV, EJ, EG, R1));
                },
                clampPoint: function (mN, mX) {
                    return void 0x0 === mX && (console["warn"]("THREE.Box3:\x20.clampPoint()\x20target\x20is\x20now\x20required"), (mX = new Ed())), mX["copy"](mN)["clamp"](this["min"], this["max"]);
                },
                distanceToPoint: function (mN) {
                    return Ex["copy"](mN)["clamp"](this["min"], this["max"])["sub"](mN)["length"]();
                },
                getBoundingSphere: function (mN) {
                    return void 0x0 === mN && console["error"]("THREE.Box3:\x20.getBoundingSphere()\x20target\x20is\x20now\x20required"), this["getCenter"](mN["center"]), (mN["radius"] = 0.5 * this["getSize"](Ex)["length"]()), mN;
                },
                intersect: function (mN) {
                    return this["min"]["max"](mN["min"]), this["max"]["min"](mN["max"]), this["isEmpty"]() && this["makeEmpty"](), this;
                },
                union: function (mN) {
                    return this["min"]["min"](mN["min"]), this["max"]["max"](mN["max"]), this;
                },
                applyMatrix4: function (mN) {
                    return (
                        this["isEmpty"]() ||
                            (EH[0x0]["set"](this["min"]["x"], this["min"]["y"], this["min"]["z"])["applyMatrix4"](mN),
                            EH[0x1]["set"](this["min"]["x"], this["min"]["y"], this["max"]["z"])["applyMatrix4"](mN),
                            EH[0x2]["set"](this["min"]["x"], this["max"]["y"], this["min"]["z"])["applyMatrix4"](mN),
                            EH[0x3]["set"](this["min"]["x"], this["max"]["y"], this["max"]["z"])["applyMatrix4"](mN),
                            EH[0x4]["set"](this["max"]["x"], this["min"]["y"], this["min"]["z"])["applyMatrix4"](mN),
                            EH[0x5]["set"](this["max"]["x"], this["min"]["y"], this["max"]["z"])["applyMatrix4"](mN),
                            EH[0x6]["set"](this["max"]["x"], this["max"]["y"], this["min"]["z"])["applyMatrix4"](mN),
                            EH[0x7]["set"](this["max"]["x"], this["max"]["y"], this["max"]["z"])["applyMatrix4"](mN),
                            this["setFromPoints"](EH)),
                        this
                    );
                },
                translate: function (mN) {
                    return this["min"]["add"](mN), this["max"]["add"](mN), this;
                },
                equals: function (mN) {
                    return mN["min"]["equals"](this["min"]) && mN["max"]["equals"](this["max"]);
                },
            });
            var R6 = new R4();
            function R7(mN, mX) {
                (this["center"] = void 0x0 !== mN ? mN : new Ed()), (this["radius"] = void 0x0 !== mX ? mX : -0x1);
            }
            Object["assign"](R7["prototype"], {
                set: function (mN, mX) {
                    return this["center"]["copy"](mN), (this["radius"] = mX), this;
                },
                setFromPoints: function (mN, mX) {
                    var mf = this["center"];
                    void 0x0 !== mX ? mf["copy"](mX) : R6["setFromPoints"](mN)["getCenter"](mf);
                    for (var mP = 0x0, mI = 0x0, mA = mN["length"]; mI < mA; mI++) mP = Math["max"](mP, mf["distanceToSquared"](mN[mI]));
                    return (this["radius"] = Math["sqrt"](mP)), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    return this["center"]["copy"](mN["center"]), (this["radius"] = mN["radius"]), this;
                },
                isEmpty: function () {
                    return this["radius"] < 0x0;
                },
                makeEmpty: function () {
                    return this["center"]["set"](0x0, 0x0, 0x0), (this["radius"] = -0x1), this;
                },
                containsPoint: function (mN) {
                    return mN["distanceToSquared"](this["center"]) <= this["radius"] * this["radius"];
                },
                distanceToPoint: function (mN) {
                    return mN["distanceTo"](this["center"]) - this["radius"];
                },
                intersectsSphere: function (mN) {
                    var mX = this["radius"] + mN["radius"];
                    return mN["center"]["distanceToSquared"](this["center"]) <= mX * mX;
                },
                intersectsBox: function (mN) {
                    return mN["intersectsSphere"](this);
                },
                intersectsPlane: function (mN) {
                    return Math["abs"](mN["distanceToPoint"](this["center"])) <= this["radius"];
                },
                clampPoint: function (mN, mX) {
                    var mf = this["center"]["distanceToSquared"](mN);
                    return (
                        void 0x0 === mX && (console["warn"]("THREE.Sphere:\x20.clampPoint()\x20target\x20is\x20now\x20required"), (mX = new Ed())),
                        mX["copy"](mN),
                        mf > this["radius"] * this["radius"] && (mX["sub"](this["center"])["normalize"](), mX["multiplyScalar"](this["radius"])["add"](this["center"])),
                        mX
                    );
                },
                getBoundingBox: function (mN) {
                    return (
                        void 0x0 === mN && (console["warn"]("THREE.Sphere:\x20.getBoundingBox()\x20target\x20is\x20now\x20required"), (mN = new R4())),
                        this["isEmpty"]() ? (mN["makeEmpty"](), mN) : (mN["set"](this["center"], this["center"]), mN["expandByScalar"](this["radius"]), mN)
                    );
                },
                applyMatrix4: function (mN) {
                    return this["center"]["applyMatrix4"](mN), (this["radius"] = this["radius"] * mN["getMaxScaleOnAxis"]()), this;
                },
                translate: function (mN) {
                    return this["center"]["add"](mN), this;
                },
                equals: function (mN) {
                    return mN["center"]["equals"](this["center"]) && mN["radius"] === this["radius"];
                },
            });
            var R8 = new Ed(),
                R9 = new Ed(),
                RE = new Ed(),
                RR = new Ed(),
                RT = new Ed(),
                RC = new Ed(),
                Rd = new Ed();
            function RY(mN, mX) {
                (this["origin"] = void 0x0 !== mN ? mN : new Ed()), (this["direction"] = void 0x0 !== mX ? mX : new Ed(0x0, 0x0, -0x1));
            }
            Object["assign"](RY["prototype"], {
                set: function (mN, mX) {
                    return this["origin"]["copy"](mN), this["direction"]["copy"](mX), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    return this["origin"]["copy"](mN["origin"]), this["direction"]["copy"](mN["direction"]), this;
                },
                at: function (mN, mX) {
                    return void 0x0 === mX && (console["warn"]("THREE.Ray:\x20.at()\x20target\x20is\x20now\x20required"), (mX = new Ed())), mX["copy"](this["direction"])["multiplyScalar"](mN)["add"](this["origin"]);
                },
                lookAt: function (mN) {
                    return this["direction"]["copy"](mN)["sub"](this["origin"])["normalize"](), this;
                },
                recast: function (mN) {
                    return this["origin"]["copy"](this["at"](mN, R8)), this;
                },
                closestPointToPoint: function (mN, mX) {
                    void 0x0 === mX && (console["warn"]("THREE.Ray:\x20.closestPointToPoint()\x20target\x20is\x20now\x20required"), (mX = new Ed())), mX["subVectors"](mN, this["origin"]);
                    var mf = mX["dot"](this["direction"]);
                    return mf < 0x0 ? mX["copy"](this["origin"]) : mX["copy"](this["direction"])["multiplyScalar"](mf)["add"](this["origin"]);
                },
                distanceToPoint: function (mN) {
                    return Math["sqrt"](this["distanceSqToPoint"](mN));
                },
                distanceSqToPoint: function (mN) {
                    var mX = R8["subVectors"](mN, this["origin"])["dot"](this["direction"]);
                    return mX < 0x0 ? this["origin"]["distanceToSquared"](mN) : (R8["copy"](this["direction"])["multiplyScalar"](mX)["add"](this["origin"]), R8["distanceToSquared"](mN));
                },
                distanceSqToSegment: function (mN, mX, mf, mP) {
                    R9["copy"](mN)["add"](mX)["multiplyScalar"](0.5), RE["copy"](mX)["sub"](mN)["normalize"](), RR["copy"](this["origin"])["sub"](R9);
                    var mI,
                        mA,
                        mM,
                        mp,
                        mk = 0.5 * mN["distanceTo"](mX),
                        mU = -this["direction"]["dot"](RE),
                        mq = RR["dot"](this["direction"]),
                        mw = -RR["dot"](RE),
                        mO = RR["lengthSq"](),
                        mj = Math["abs"](0x1 - mU * mU);
                    if (mj > 0x0) {
                        if (((mA = mU * mq - mw), (mp = mk * mj), (mI = mU * mw - mq) >= 0x0)) {
                            if (mA >= -mp) {
                                if (mA <= mp) {
                                    var mh = 0x1 / mj;
                                    mM = (mI *= mh) * (mI + mU * (mA *= mh) + 0x2 * mq) + mA * (mU * mI + mA + 0x2 * mw) + mO;
                                } else (mA = mk), (mM = -(mI = Math["max"](0x0, -(mU * mA + mq))) * mI + mA * (mA + 0x2 * mw) + mO);
                            } else (mA = -mk), (mM = -(mI = Math["max"](0x0, -(mU * mA + mq))) * mI + mA * (mA + 0x2 * mw) + mO);
                        } else
                            mA <= -mp
                                ? (mM = -(mI = Math["max"](0x0, -(-mU * mk + mq))) * mI + (mA = mI > 0x0 ? -mk : Math["min"](Math["max"](-mk, -mw), mk)) * (mA + 0x2 * mw) + mO)
                                : mA <= mp
                                ? ((mI = 0x0), (mM = (mA = Math["min"](Math["max"](-mk, -mw), mk)) * (mA + 0x2 * mw) + mO))
                                : (mM = -(mI = Math["max"](0x0, -(mU * mk + mq))) * mI + (mA = mI > 0x0 ? mk : Math["min"](Math["max"](-mk, -mw), mk)) * (mA + 0x2 * mw) + mO);
                    } else (mA = mU > 0x0 ? -mk : mk), (mM = -(mI = Math["max"](0x0, -(mU * mA + mq))) * mI + mA * (mA + 0x2 * mw) + mO);
                    return mf && mf["copy"](this["direction"])["multiplyScalar"](mI)["add"](this["origin"]), mP && mP["copy"](RE)["multiplyScalar"](mA)["add"](R9), mM;
                },
                intersectSphere: function (mN, mX) {
                    R8["subVectors"](mN["center"], this["origin"]);
                    var mf = R8["dot"](this["direction"]),
                        mP = R8["dot"](R8) - mf * mf,
                        mI = mN["radius"] * mN["radius"];
                    if (mP > mI) return null;
                    var mA = Math["sqrt"](mI - mP),
                        mM = mf - mA,
                        mp = mf + mA;
                    return mM < 0x0 && mp < 0x0 ? null : mM < 0x0 ? this["at"](mp, mX) : this["at"](mM, mX);
                },
                intersectsSphere: function (mN) {
                    return this["distanceSqToPoint"](mN["center"]) <= mN["radius"] * mN["radius"];
                },
                distanceToPlane: function (mN) {
                    var mX = mN["normal"]["dot"](this["direction"]);
                    if (0x0 === mX) return 0x0 === mN["distanceToPoint"](this["origin"]) ? 0x0 : null;
                    var mf = -(this["origin"]["dot"](mN["normal"]) + mN["constant"]) / mX;
                    return mf >= 0x0 ? mf : null;
                },
                intersectPlane: function (mN, mX) {
                    var mf = this["distanceToPlane"](mN);
                    return null === mf ? null : this["at"](mf, mX);
                },
                intersectsPlane: function (mN) {
                    var mX = mN["distanceToPoint"](this["origin"]);
                    return 0x0 === mX || mN["normal"]["dot"](this["direction"]) * mX < 0x0;
                },
                intersectBox: function (mN, mX) {
                    var mf,
                        mP,
                        mI,
                        mA,
                        mM,
                        mp,
                        mk = 0x1 / this["direction"]["x"],
                        mU = 0x1 / this["direction"]["y"],
                        mq = 0x1 / this["direction"]["z"],
                        mw = this["origin"];
                    return (
                        mk >= 0x0 ? ((mf = (mN["min"]["x"] - mw["x"]) * mk), (mP = (mN["max"]["x"] - mw["x"]) * mk)) : ((mf = (mN["max"]["x"] - mw["x"]) * mk), (mP = (mN["min"]["x"] - mw["x"]) * mk)),
                        mU >= 0x0 ? ((mI = (mN["min"]["y"] - mw["y"]) * mU), (mA = (mN["max"]["y"] - mw["y"]) * mU)) : ((mI = (mN["max"]["y"] - mw["y"]) * mU), (mA = (mN["min"]["y"] - mw["y"]) * mU)),
                        mf > mA || mI > mP
                            ? null
                            : ((mI > mf || mf != mf) && (mf = mI),
                              (mA < mP || mP != mP) && (mP = mA),
                              mq >= 0x0 ? ((mM = (mN["min"]["z"] - mw["z"]) * mq), (mp = (mN["max"]["z"] - mw["z"]) * mq)) : ((mM = (mN["max"]["z"] - mw["z"]) * mq), (mp = (mN["min"]["z"] - mw["z"]) * mq)),
                              mf > mp || mM > mP ? null : ((mM > mf || mf != mf) && (mf = mM), (mp < mP || mP != mP) && (mP = mp), mP < 0x0 ? null : this["at"](mf >= 0x0 ? mf : mP, mX)))
                    );
                },
                intersectsBox: function (mN) {
                    return null !== this["intersectBox"](mN, R8);
                },
                intersectTriangle: function (mN, mX, mf, mP, mI) {
                    RT["subVectors"](mX, mN), RC["subVectors"](mf, mN), Rd["crossVectors"](RT, RC);
                    var mA,
                        mM = this["direction"]["dot"](Rd);
                    if (mM > 0x0) {
                        if (mP) return null;
                        mA = 0x1;
                    } else {
                        if (!(mM < 0x0)) return null;
                        (mA = -0x1), (mM = -mM);
                    }
                    RR["subVectors"](this["origin"], mN);
                    var mp = mA * this["direction"]["dot"](RC["crossVectors"](RR, RC));
                    if (mp < 0x0) return null;
                    var mk = mA * this["direction"]["dot"](RT["cross"](RR));
                    if (mk < 0x0) return null;
                    if (mp + mk > mM) return null;
                    var mU = -mA * RR["dot"](Rd);
                    return mU < 0x0 ? null : this["at"](mU / mM, mI);
                },
                applyMatrix4: function (mN) {
                    return this["origin"]["applyMatrix4"](mN), this["direction"]["transformDirection"](mN), this;
                },
                equals: function (mN) {
                    return mN["origin"]["equals"](this["origin"]) && mN["direction"]["equals"](this["direction"]);
                },
            });
            var RB = new Ed(),
                RF = new Ed(),
                Rb = new E4();
            function RZ(mN, mX) {
                (this["normal"] = void 0x0 !== mN ? mN : new Ed(0x1, 0x0, 0x0)), (this["constant"] = void 0x0 !== mX ? mX : 0x0);
            }
            Object["assign"](RZ["prototype"], {
                isPlane: !0x0,
                set: function (mN, mX) {
                    return this["normal"]["copy"](mN), (this["constant"] = mX), this;
                },
                setComponents: function (mN, mX, mf, mP) {
                    return this["normal"]["set"](mN, mX, mf), (this["constant"] = mP), this;
                },
                setFromNormalAndCoplanarPoint: function (mN, mX) {
                    return this["normal"]["copy"](mN), (this["constant"] = -mX["dot"](this["normal"])), this;
                },
                setFromCoplanarPoints: function (mN, mX, mf) {
                    var mP = RB["subVectors"](mf, mX)["cross"](RF["subVectors"](mN, mX))["normalize"]();
                    return this["setFromNormalAndCoplanarPoint"](mP, mN), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    return this["normal"]["copy"](mN["normal"]), (this["constant"] = mN["constant"]), this;
                },
                normalize: function () {
                    var mN = 0x1 / this["normal"]["length"]();
                    return this["normal"]["multiplyScalar"](mN), (this["constant"] *= mN), this;
                },
                negate: function () {
                    return (this["constant"] *= -0x1), this["normal"]["negate"](), this;
                },
                distanceToPoint: function (mN) {
                    return this["normal"]["dot"](mN) + this["constant"];
                },
                distanceToSphere: function (mN) {
                    return this["distanceToPoint"](mN["center"]) - mN["radius"];
                },
                projectPoint: function (mN, mX) {
                    return void 0x0 === mX && (console["warn"]("THREE.Plane:\x20.projectPoint()\x20target\x20is\x20now\x20required"), (mX = new Ed())), mX["copy"](this["normal"])["multiplyScalar"](-this["distanceToPoint"](mN))["add"](mN);
                },
                intersectLine: function (mN, mX) {
                    void 0x0 === mX && (console["warn"]("THREE.Plane:\x20.intersectLine()\x20target\x20is\x20now\x20required"), (mX = new Ed()));
                    var mf = mN["delta"](RB),
                        mP = this["normal"]["dot"](mf);
                    if (0x0 === mP) return 0x0 === this["distanceToPoint"](mN["start"]) ? mX["copy"](mN["start"]) : void 0x0;
                    var mI = -(mN["start"]["dot"](this["normal"]) + this["constant"]) / mP;
                    return mI < 0x0 || mI > 0x1 ? void 0x0 : mX["copy"](mf)["multiplyScalar"](mI)["add"](mN["start"]);
                },
                intersectsLine: function (mN) {
                    var mX = this["distanceToPoint"](mN["start"]),
                        mf = this["distanceToPoint"](mN["end"]);
                    return (mX < 0x0 && mf > 0x0) || (mf < 0x0 && mX > 0x0);
                },
                intersectsBox: function (mN) {
                    return mN["intersectsPlane"](this);
                },
                intersectsSphere: function (mN) {
                    return mN["intersectsPlane"](this);
                },
                coplanarPoint: function (mN) {
                    return void 0x0 === mN && (console["warn"]("THREE.Plane:\x20.coplanarPoint()\x20target\x20is\x20now\x20required"), (mN = new Ed())), mN["copy"](this["normal"])["multiplyScalar"](-this["constant"]);
                },
                applyMatrix4: function (mN, mX) {
                    var mf = mX || Rb["getNormalMatrix"](mN),
                        mP = this["coplanarPoint"](RB)["applyMatrix4"](mN),
                        mI = this["normal"]["applyMatrix3"](mf)["normalize"]();
                    return (this["constant"] = -mP["dot"](mI)), this;
                },
                translate: function (mN) {
                    return (this["constant"] -= mN["dot"](this["normal"])), this;
                },
                equals: function (mN) {
                    return mN["normal"]["equals"](this["normal"]) && mN["constant"] === this["constant"];
                },
            });
            var Rm = new Ed(),
                Rv = new Ed(),
                Ry = new Ed(),
                RD = new Ed(),
                RN = new Ed(),
                RX = new Ed(),
                Rf = new Ed(),
                RP = new Ed(),
                RI = new Ed(),
                RA = new Ed();
            function RM(mN, mX, mf) {
                (this["a"] = void 0x0 !== mN ? mN : new Ed()), (this["b"] = void 0x0 !== mX ? mX : new Ed()), (this["c"] = void 0x0 !== mf ? mf : new Ed());
            }
            Object["assign"](RM, {
                getNormal: function (mN, mX, mf, mP) {
                    void 0x0 === mP && (console["warn"]("THREE.Triangle:\x20.getNormal()\x20target\x20is\x20now\x20required"), (mP = new Ed())), mP["subVectors"](mf, mX), Rm["subVectors"](mN, mX), mP["cross"](Rm);
                    var mI = mP["lengthSq"]();
                    return mI > 0x0 ? mP["multiplyScalar"](0x1 / Math["sqrt"](mI)) : mP["set"](0x0, 0x0, 0x0);
                },
                getBarycoord: function (mN, mX, mf, mP, mI) {
                    Rm["subVectors"](mP, mX), Rv["subVectors"](mf, mX), Ry["subVectors"](mN, mX);
                    var mA = Rm["dot"](Rm),
                        mM = Rm["dot"](Rv),
                        mp = Rm["dot"](Ry),
                        mk = Rv["dot"](Rv),
                        mU = Rv["dot"](Ry),
                        mq = mA * mk - mM * mM;
                    if ((void 0x0 === mI && (console["warn"]("THREE.Triangle:\x20.getBarycoord()\x20target\x20is\x20now\x20required"), (mI = new Ed())), 0x0 === mq)) return mI["set"](-0x2, -0x1, -0x1);
                    var mw = 0x1 / mq,
                        mO = (mk * mp - mM * mU) * mw,
                        mj = (mA * mU - mM * mp) * mw;
                    return mI["set"](0x1 - mO - mj, mj, mO);
                },
                containsPoint: function (mN, mX, mf, mP) {
                    return RM["getBarycoord"](mN, mX, mf, mP, RD), RD["x"] >= 0x0 && RD["y"] >= 0x0 && RD["x"] + RD["y"] <= 0x1;
                },
                getUV: function (mN, mX, mf, mP, mI, mA, mM, mp) {
                    return this["getBarycoord"](mN, mX, mf, mP, RD), mp["set"](0x0, 0x0), mp["addScaledVector"](mI, RD["x"]), mp["addScaledVector"](mA, RD["y"]), mp["addScaledVector"](mM, RD["z"]), mp;
                },
                isFrontFacing: function (mN, mX, mf, mP) {
                    return Rm["subVectors"](mf, mX), Rv["subVectors"](mN, mX), Rm["cross"](Rv)["dot"](mP) < 0x0;
                },
            }),
                Object["assign"](RM["prototype"], {
                    set: function (mN, mX, mf) {
                        return this["a"]["copy"](mN), this["b"]["copy"](mX), this["c"]["copy"](mf), this;
                    },
                    setFromPointsAndIndices: function (mN, mX, mf, mP) {
                        return this["a"]["copy"](mN[mX]), this["b"]["copy"](mN[mf]), this["c"]["copy"](mN[mP]), this;
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    copy: function (mN) {
                        return this["a"]["copy"](mN["a"]), this["b"]["copy"](mN["b"]), this["c"]["copy"](mN["c"]), this;
                    },
                    getArea: function () {
                        return Rm["subVectors"](this["c"], this["b"]), Rv["subVectors"](this["a"], this["b"]), 0.5 * Rm["cross"](Rv)["length"]();
                    },
                    getMidpoint: function (mN) {
                        return (
                            void 0x0 === mN && (console["warn"]("THREE.Triangle:\x20.getMidpoint()\x20target\x20is\x20now\x20required"), (mN = new Ed())),
                            mN["addVectors"](this["a"], this["b"])
                                ["add"](this["c"])
                                ["multiplyScalar"](0x1 / 0x3)
                        );
                    },
                    getNormal: function (mN) {
                        return RM["getNormal"](this["a"], this["b"], this["c"], mN);
                    },
                    getPlane: function (mN) {
                        return void 0x0 === mN && (console["warn"]("THREE.Triangle:\x20.getPlane()\x20target\x20is\x20now\x20required"), (mN = new RZ())), mN["setFromCoplanarPoints"](this["a"], this["b"], this["c"]);
                    },
                    getBarycoord: function (mN, mX) {
                        return RM["getBarycoord"](mN, this["a"], this["b"], this["c"], mX);
                    },
                    getUV: function (mN, mX, mf, mP, mI) {
                        return RM["getUV"](mN, this["a"], this["b"], this["c"], mX, mf, mP, mI);
                    },
                    containsPoint: function (mN) {
                        return RM["containsPoint"](mN, this["a"], this["b"], this["c"]);
                    },
                    isFrontFacing: function (mN) {
                        return RM["isFrontFacing"](this["a"], this["b"], this["c"], mN);
                    },
                    intersectsBox: function (mN) {
                        return mN["intersectsTriangle"](this);
                    },
                    closestPointToPoint: function (mN, mX) {
                        void 0x0 === mX && (console["warn"]("THREE.Triangle:\x20.closestPointToPoint()\x20target\x20is\x20now\x20required"), (mX = new Ed()));
                        var mf,
                            mP,
                            mI = this["a"],
                            mA = this["b"],
                            mM = this["c"];
                        RN["subVectors"](mA, mI), RX["subVectors"](mM, mI), RP["subVectors"](mN, mI);
                        var mp = RN["dot"](RP),
                            mk = RX["dot"](RP);
                        if (mp <= 0x0 && mk <= 0x0) return mX["copy"](mI);
                        RI["subVectors"](mN, mA);
                        var mU = RN["dot"](RI),
                            mq = RX["dot"](RI);
                        if (mU >= 0x0 && mq <= mU) return mX["copy"](mA);
                        var mw = mp * mq - mU * mk;
                        if (mw <= 0x0 && mp >= 0x0 && mU <= 0x0) return (mf = mp / (mp - mU)), mX["copy"](mI)["addScaledVector"](RN, mf);
                        RA["subVectors"](mN, mM);
                        var mO = RN["dot"](RA),
                            mj = RX["dot"](RA);
                        if (mj >= 0x0 && mO <= mj) return mX["copy"](mM);
                        var mh = mO * mk - mp * mj;
                        if (mh <= 0x0 && mk >= 0x0 && mj <= 0x0) return (mP = mk / (mk - mj)), mX["copy"](mI)["addScaledVector"](RX, mP);
                        var mS = mU * mj - mO * mq;
                        if (mS <= 0x0 && mq - mU >= 0x0 && mO - mj >= 0x0) return Rf["subVectors"](mM, mA), (mP = (mq - mU) / (mq - mU + (mO - mj))), mX["copy"](mA)["addScaledVector"](Rf, mP);
                        var mg = 0x1 / (mS + mh + mw);
                        return (mf = mh * mg), (mP = mw * mg), mX["copy"](mI)["addScaledVector"](RN, mf)["addScaledVector"](RX, mP);
                    },
                    equals: function (mN) {
                        return mN["a"]["equals"](this["a"]) && mN["b"]["equals"](this["b"]) && mN["c"]["equals"](this["c"]);
                    },
                });
            var Rp = {
                    aliceblue: 0xf0f8ff,
                    antiquewhite: 0xfaebd7,
                    aqua: 0xffff,
                    aquamarine: 0x7fffd4,
                    azure: 0xf0ffff,
                    beige: 0xf5f5dc,
                    bisque: 0xffe4c4,
                    black: 0x0,
                    blanchedalmond: 0xffebcd,
                    blue: 0xff,
                    blueviolet: 0x8a2be2,
                    brown: 0xa52a2a,
                    burlywood: 0xdeb887,
                    cadetblue: 0x5f9ea0,
                    chartreuse: 0x7fff00,
                    chocolate: 0xd2691e,
                    coral: 0xff7f50,
                    cornflowerblue: 0x6495ed,
                    cornsilk: 0xfff8dc,
                    crimson: 0xdc143c,
                    cyan: 0xffff,
                    darkblue: 0x8b,
                    darkcyan: 0x8b8b,
                    darkgoldenrod: 0xb8860b,
                    darkgray: 0xa9a9a9,
                    darkgreen: 0x6400,
                    darkgrey: 0xa9a9a9,
                    darkkhaki: 0xbdb76b,
                    darkmagenta: 0x8b008b,
                    darkolivegreen: 0x556b2f,
                    darkorange: 0xff8c00,
                    darkorchid: 0x9932cc,
                    darkred: 0x8b0000,
                    darksalmon: 0xe9967a,
                    darkseagreen: 0x8fbc8f,
                    darkslateblue: 0x483d8b,
                    darkslategray: 0x2f4f4f,
                    darkslategrey: 0x2f4f4f,
                    darkturquoise: 0xced1,
                    darkviolet: 0x9400d3,
                    deeppink: 0xff1493,
                    deepskyblue: 0xbfff,
                    dimgray: 0x696969,
                    dimgrey: 0x696969,
                    dodgerblue: 0x1e90ff,
                    firebrick: 0xb22222,
                    floralwhite: 0xfffaf0,
                    forestgreen: 0x228b22,
                    fuchsia: 0xff00ff,
                    gainsboro: 0xdcdcdc,
                    ghostwhite: 0xf8f8ff,
                    gold: 0xffd700,
                    goldenrod: 0xdaa520,
                    gray: 0x808080,
                    green: 0x8000,
                    greenyellow: 0xadff2f,
                    grey: 0x808080,
                    honeydew: 0xf0fff0,
                    hotpink: 0xff69b4,
                    indianred: 0xcd5c5c,
                    indigo: 0x4b0082,
                    ivory: 0xfffff0,
                    khaki: 0xf0e68c,
                    lavender: 0xe6e6fa,
                    lavenderblush: 0xfff0f5,
                    lawngreen: 0x7cfc00,
                    lemonchiffon: 0xfffacd,
                    lightblue: 0xadd8e6,
                    lightcoral: 0xf08080,
                    lightcyan: 0xe0ffff,
                    lightgoldenrodyellow: 0xfafad2,
                    lightgray: 0xd3d3d3,
                    lightgreen: 0x90ee90,
                    lightgrey: 0xd3d3d3,
                    lightpink: 0xffb6c1,
                    lightsalmon: 0xffa07a,
                    lightseagreen: 0x20b2aa,
                    lightskyblue: 0x87cefa,
                    lightslategray: 0x778899,
                    lightslategrey: 0x778899,
                    lightsteelblue: 0xb0c4de,
                    lightyellow: 0xffffe0,
                    lime: 0xff00,
                    limegreen: 0x32cd32,
                    linen: 0xfaf0e6,
                    magenta: 0xff00ff,
                    maroon: 0x800000,
                    mediumaquamarine: 0x66cdaa,
                    mediumblue: 0xcd,
                    mediumorchid: 0xba55d3,
                    mediumpurple: 0x9370db,
                    mediumseagreen: 0x3cb371,
                    mediumslateblue: 0x7b68ee,
                    mediumspringgreen: 0xfa9a,
                    mediumturquoise: 0x48d1cc,
                    mediumvioletred: 0xc71585,
                    midnightblue: 0x191970,
                    mintcream: 0xf5fffa,
                    mistyrose: 0xffe4e1,
                    moccasin: 0xffe4b5,
                    navajowhite: 0xffdead,
                    navy: 0x80,
                    oldlace: 0xfdf5e6,
                    olive: 0x808000,
                    olivedrab: 0x6b8e23,
                    orange: 0xffa500,
                    orangered: 0xff4500,
                    orchid: 0xda70d6,
                    palegoldenrod: 0xeee8aa,
                    palegreen: 0x98fb98,
                    paleturquoise: 0xafeeee,
                    palevioletred: 0xdb7093,
                    papayawhip: 0xffefd5,
                    peachpuff: 0xffdab9,
                    peru: 0xcd853f,
                    pink: 0xffc0cb,
                    plum: 0xdda0dd,
                    powderblue: 0xb0e0e6,
                    purple: 0x800080,
                    rebeccapurple: 0x663399,
                    red: 0xff0000,
                    rosybrown: 0xbc8f8f,
                    royalblue: 0x4169e1,
                    saddlebrown: 0x8b4513,
                    salmon: 0xfa8072,
                    sandybrown: 0xf4a460,
                    seagreen: 0x2e8b57,
                    seashell: 0xfff5ee,
                    sienna: 0xa0522d,
                    silver: 0xc0c0c0,
                    skyblue: 0x87ceeb,
                    slateblue: 0x6a5acd,
                    slategray: 0x708090,
                    slategrey: 0x708090,
                    snow: 0xfffafa,
                    springgreen: 0xff7f,
                    steelblue: 0x4682b4,
                    tan: 0xd2b48c,
                    teal: 0x8080,
                    thistle: 0xd8bfd8,
                    tomato: 0xff6347,
                    turquoise: 0x40e0d0,
                    violet: 0xee82ee,
                    wheat: 0xf5deb3,
                    white: 0xffffff,
                    whitesmoke: 0xf5f5f5,
                    yellow: 0xffff00,
                    yellowgreen: 0x9acd32,
                },
                Rk = { h: 0x0, s: 0x0, l: 0x0 },
                RU = { h: 0x0, s: 0x0, l: 0x0 };
            function Rq(mN, mX, mf) {
                return void 0x0 === mX && void 0x0 === mf ? this["set"](mN) : this["setRGB"](mN, mX, mf);
            }
            function Rw(mN, mX, mf) {
                return mf < 0x0 && (mf += 0x1), mf > 0x1 && (mf -= 0x1), mf < 0x1 / 0x6 ? mN + 0x6 * (mX - mN) * mf : mf < 0.5 ? mX : mf < 0x2 / 0x3 ? mN + 0x6 * (mX - mN) * (0x2 / 0x3 - mf) : mN;
            }
            function RO(mN) {
                return mN < 0.04045 ? 0.0773993808 * mN : Math["pow"](0.9478672986 * mN + 0.0521327014, 2.4);
            }
            function Rj(mN) {
                return mN < 0.0031308 ? 12.92 * mN : 1.055 * Math["pow"](mN, 0.41666) - 0.055;
            }
            function Rh(mN, mX, mf, mP, mI, mA) {
                (this["a"] = mN),
                    (this["b"] = mX),
                    (this["c"] = mf),
                    (this["normal"] = mP && mP["isVector3"] ? mP : new Ed()),
                    (this["vertexNormals"] = Array["isArray"](mP) ? mP : []),
                    (this["color"] = mI && mI["isColor"] ? mI : new Rq()),
                    (this["vertexColors"] = Array["isArray"](mI) ? mI : []),
                    (this["materialIndex"] = void 0x0 !== mA ? mA : 0x0);
            }
            Object["assign"](Rq["prototype"], {
                isColor: !0x0,
                r: 0x1,
                g: 0x1,
                b: 0x1,
                set: function (mN) {
                    return mN && mN["isColor"] ? this["copy"](mN) : "number" == typeof mN ? this["setHex"](mN) : "string" == typeof mN && this["setStyle"](mN), this;
                },
                setScalar: function (mN) {
                    return (this["r"] = mN), (this["g"] = mN), (this["b"] = mN), this;
                },
                setHex: function (mN) {
                    return (mN = Math["floor"](mN)), (this["r"] = ((mN >> 0x10) & 0xff) / 0xff), (this["g"] = ((mN >> 0x8) & 0xff) / 0xff), (this["b"] = (0xff & mN) / 0xff), this;
                },
                setRGB: function (mN, mX, mf) {
                    return (this["r"] = mN), (this["g"] = mX), (this["b"] = mf), this;
                },
                setHSL: function (mN, mX, mf) {
                    if (((mN = E2["euclideanModulo"](mN, 0x1)), (mX = E2["clamp"](mX, 0x0, 0x1)), (mf = E2["clamp"](mf, 0x0, 0x1)), 0x0 === mX)) this["r"] = this["g"] = this["b"] = mf;
                    else {
                        var mP = mf <= 0.5 ? mf * (0x1 + mX) : mf + mX - mf * mX,
                            mI = 0x2 * mf - mP;
                        (this["r"] = Rw(mI, mP, mN + 0x1 / 0x3)), (this["g"] = Rw(mI, mP, mN)), (this["b"] = Rw(mI, mP, mN - 0x1 / 0x3));
                    }
                    return this;
                },
                setStyle: function (mN) {
                    function mX(mw) {
                        void 0x0 !== mw && parseFloat(mw) < 0x1 && console["warn"]("THREE.Color:\x20Alpha\x20component\x20of\x20" + mN + "\x20will\x20be\x20ignored.");
                    }
                    var mf;
                    if ((mf = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/["exec"](mN))) {
                        var mP,
                            mI = mf[0x1],
                            mA = mf[0x2];
                        switch (mI) {
                            case "rgb":
                            case "rgba":
                                if ((mP = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/["exec"](mA)))
                                    return (
                                        (this["r"] = Math["min"](0xff, parseInt(mP[0x1], 0xa)) / 0xff),
                                        (this["g"] = Math["min"](0xff, parseInt(mP[0x2], 0xa)) / 0xff),
                                        (this["b"] = Math["min"](0xff, parseInt(mP[0x3], 0xa)) / 0xff),
                                        mX(mP[0x5]),
                                        this
                                    );
                                if ((mP = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/["exec"](mA)))
                                    return (
                                        (this["r"] = Math["min"](0x64, parseInt(mP[0x1], 0xa)) / 0x64),
                                        (this["g"] = Math["min"](0x64, parseInt(mP[0x2], 0xa)) / 0x64),
                                        (this["b"] = Math["min"](0x64, parseInt(mP[0x3], 0xa)) / 0x64),
                                        mX(mP[0x5]),
                                        this
                                    );
                                break;
                            case "hsl":
                            case "hsla":
                                if ((mP = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/["exec"](mA))) {
                                    var mM = parseFloat(mP[0x1]) / 0x168,
                                        mp = parseInt(mP[0x2], 0xa) / 0x64,
                                        mk = parseInt(mP[0x3], 0xa) / 0x64;
                                    return mX(mP[0x5]), this["setHSL"](mM, mp, mk);
                                }
                        }
                    } else {
                        if ((mf = /^\#([A-Fa-f0-9]+)$/["exec"](mN))) {
                            var mU = mf[0x1],
                                mq = mU["length"];
                            if (0x3 === mq)
                                return (
                                    (this["r"] = parseInt(mU["charAt"](0x0) + mU["charAt"](0x0), 0x10) / 0xff),
                                    (this["g"] = parseInt(mU["charAt"](0x1) + mU["charAt"](0x1), 0x10) / 0xff),
                                    (this["b"] = parseInt(mU["charAt"](0x2) + mU["charAt"](0x2), 0x10) / 0xff),
                                    this
                                );
                            if (0x6 === mq)
                                return (
                                    (this["r"] = parseInt(mU["charAt"](0x0) + mU["charAt"](0x1), 0x10) / 0xff),
                                    (this["g"] = parseInt(mU["charAt"](0x2) + mU["charAt"](0x3), 0x10) / 0xff),
                                    (this["b"] = parseInt(mU["charAt"](0x4) + mU["charAt"](0x5), 0x10) / 0xff),
                                    this
                                );
                        }
                    }
                    return mN && mN["length"] > 0x0 ? this["setColorName"](mN) : this;
                },
                setColorName: function (mN) {
                    var mX = Rp[mN];
                    return void 0x0 !== mX ? this["setHex"](mX) : console["warn"]("THREE.Color:\x20Unknown\x20color\x20" + mN), this;
                },
                clone: function () {
                    return new this["constructor"](this["r"], this["g"], this["b"]);
                },
                copy: function (mN) {
                    return (this["r"] = mN["r"]), (this["g"] = mN["g"]), (this["b"] = mN["b"]), this;
                },
                copyGammaToLinear: function (mN, mX) {
                    return void 0x0 === mX && (mX = 0x2), (this["r"] = Math["pow"](mN["r"], mX)), (this["g"] = Math["pow"](mN["g"], mX)), (this["b"] = Math["pow"](mN["b"], mX)), this;
                },
                copyLinearToGamma: function (mN, mX) {
                    void 0x0 === mX && (mX = 0x2);
                    var mf = mX > 0x0 ? 0x1 / mX : 0x1;
                    return (this["r"] = Math["pow"](mN["r"], mf)), (this["g"] = Math["pow"](mN["g"], mf)), (this["b"] = Math["pow"](mN["b"], mf)), this;
                },
                convertGammaToLinear: function (mN) {
                    return this["copyGammaToLinear"](this, mN), this;
                },
                convertLinearToGamma: function (mN) {
                    return this["copyLinearToGamma"](this, mN), this;
                },
                copySRGBToLinear: function (mN) {
                    return (this["r"] = RO(mN["r"])), (this["g"] = RO(mN["g"])), (this["b"] = RO(mN["b"])), this;
                },
                copyLinearToSRGB: function (mN) {
                    return (this["r"] = Rj(mN["r"])), (this["g"] = Rj(mN["g"])), (this["b"] = Rj(mN["b"])), this;
                },
                convertSRGBToLinear: function () {
                    return this["copySRGBToLinear"](this), this;
                },
                convertLinearToSRGB: function () {
                    return this["copyLinearToSRGB"](this), this;
                },
                getHex: function () {
                    return ((0xff * this["r"]) << 0x10) ^ ((0xff * this["g"]) << 0x8) ^ ((0xff * this["b"]) << 0x0);
                },
                getHexString: function () {
                    return ("000000" + this["getHex"]()["toString"](0x10))["slice"](-0x6);
                },
                getHSL: function (mN) {
                    void 0x0 === mN && (console["warn"]("THREE.Color:\x20.getHSL()\x20target\x20is\x20now\x20required"), (mN = { h: 0x0, s: 0x0, l: 0x0 }));
                    var mX,
                        mf,
                        mP = this["r"],
                        mI = this["g"],
                        mA = this["b"],
                        mM = Math["max"](mP, mI, mA),
                        mp = Math["min"](mP, mI, mA),
                        mk = (mp + mM) / 0x2;
                    if (mp === mM) (mX = 0x0), (mf = 0x0);
                    else {
                        var mU = mM - mp;
                        switch (((mf = mk <= 0.5 ? mU / (mM + mp) : mU / (0x2 - mM - mp)), mM)) {
                            case mP:
                                mX = (mI - mA) / mU + (mI < mA ? 0x6 : 0x0);
                                break;
                            case mI:
                                mX = (mA - mP) / mU + 0x2;
                                break;
                            case mA:
                                mX = (mP - mI) / mU + 0x4;
                        }
                        mX /= 0x6;
                    }
                    return (mN["h"] = mX), (mN["s"] = mf), (mN["l"] = mk), mN;
                },
                getStyle: function () {
                    return "rgb(" + ((0xff * this["r"]) | 0x0) + "," + ((0xff * this["g"]) | 0x0) + "," + ((0xff * this["b"]) | 0x0) + ")";
                },
                offsetHSL: function (mN, mX, mf) {
                    return this["getHSL"](Rk), (Rk["h"] += mN), (Rk["s"] += mX), (Rk["l"] += mf), this["setHSL"](Rk["h"], Rk["s"], Rk["l"]), this;
                },
                add: function (mN) {
                    return (this["r"] += mN["r"]), (this["g"] += mN["g"]), (this["b"] += mN["b"]), this;
                },
                addColors: function (mN, mX) {
                    return (this["r"] = mN["r"] + mX["r"]), (this["g"] = mN["g"] + mX["g"]), (this["b"] = mN["b"] + mX["b"]), this;
                },
                addScalar: function (mN) {
                    return (this["r"] += mN), (this["g"] += mN), (this["b"] += mN), this;
                },
                sub: function (mN) {
                    return (this["r"] = Math["max"](0x0, this["r"] - mN["r"])), (this["g"] = Math["max"](0x0, this["g"] - mN["g"])), (this["b"] = Math["max"](0x0, this["b"] - mN["b"])), this;
                },
                multiply: function (mN) {
                    return (this["r"] *= mN["r"]), (this["g"] *= mN["g"]), (this["b"] *= mN["b"]), this;
                },
                multiplyScalar: function (mN) {
                    return (this["r"] *= mN), (this["g"] *= mN), (this["b"] *= mN), this;
                },
                lerp: function (mN, mX) {
                    return (this["r"] += (mN["r"] - this["r"]) * mX), (this["g"] += (mN["g"] - this["g"]) * mX), (this["b"] += (mN["b"] - this["b"]) * mX), this;
                },
                lerpHSL: function (mN, mX) {
                    this["getHSL"](Rk), mN["getHSL"](RU);
                    var mf = E2["lerp"](Rk["h"], RU["h"], mX),
                        mP = E2["lerp"](Rk["s"], RU["s"], mX),
                        mI = E2["lerp"](Rk["l"], RU["l"], mX);
                    return this["setHSL"](mf, mP, mI), this;
                },
                equals: function (mN) {
                    return mN["r"] === this["r"] && mN["g"] === this["g"] && mN["b"] === this["b"];
                },
                fromArray: function (mN, mX) {
                    return void 0x0 === mX && (mX = 0x0), (this["r"] = mN[mX]), (this["g"] = mN[mX + 0x1]), (this["b"] = mN[mX + 0x2]), this;
                },
                toArray: function (mN, mX) {
                    return void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0), (mN[mX] = this["r"]), (mN[mX + 0x1] = this["g"]), (mN[mX + 0x2] = this["b"]), mN;
                },
                toJSON: function () {
                    return this["getHex"]();
                },
            }),
                (Rq["NAMES"] = Rp),
                Object["assign"](Rh["prototype"], {
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    copy: function (mN) {
                        (this["a"] = mN["a"]), (this["b"] = mN["b"]), (this["c"] = mN["c"]), this["normal"]["copy"](mN["normal"]), this["color"]["copy"](mN["color"]), (this["materialIndex"] = mN["materialIndex"]);
                        for (var mX = 0x0, mf = mN["vertexNormals"]["length"]; mX < mf; mX++) this["vertexNormals"][mX] = mN["vertexNormals"][mX]["clone"]();
                        for (mX = 0x0, mf = mN["vertexColors"]["length"]; mX < mf; mX++) this["vertexColors"][mX] = mN["vertexColors"][mX]["clone"]();
                        return this;
                    },
                });
            var RS = 0x0;
            function Rg() {
                Object["defineProperty"](this, "id", { value: RS++ }),
                    (this["uuid"] = E2["generateUUID"]()),
                    (this["name"] = ""),
                    (this["type"] = "Material"),
                    (this["fog"] = !0x0),
                    (this["blending"] = 0x1),
                    (this["side"] = r5),
                    (this["flatShading"] = !0x1),
                    (this["vertexColors"] = !0x1),
                    (this["opacity"] = 0x1),
                    (this["transparent"] = !0x1),
                    (this["blendSrc"] = 0xcc),
                    (this["blendDst"] = 0xcd),
                    (this["blendEquation"] = r8),
                    (this["blendSrcAlpha"] = null),
                    (this["blendDstAlpha"] = null),
                    (this["blendEquationAlpha"] = null),
                    (this["depthFunc"] = 0x3),
                    (this["depthTest"] = !0x0),
                    (this["depthWrite"] = !0x0),
                    (this["stencilWriteMask"] = 0xff),
                    (this["stencilFunc"] = 0x207),
                    (this["stencilRef"] = 0x0),
                    (this["stencilFuncMask"] = 0xff),
                    (this["stencilFail"] = rJ),
                    (this["stencilZFail"] = rJ),
                    (this["stencilZPass"] = rJ),
                    (this["stencilWrite"] = !0x1),
                    (this["clippingPlanes"] = null),
                    (this["clipIntersection"] = !0x1),
                    (this["clipShadows"] = !0x1),
                    (this["shadowSide"] = null),
                    (this["colorWrite"] = !0x0),
                    (this["precision"] = null),
                    (this["polygonOffset"] = !0x1),
                    (this["polygonOffsetFactor"] = 0x0),
                    (this["polygonOffsetUnits"] = 0x0),
                    (this["dithering"] = !0x1),
                    (this["alphaTest"] = 0x0),
                    (this["premultipliedAlpha"] = !0x1),
                    (this["visible"] = !0x0),
                    (this["toneMapped"] = !0x0),
                    (this["userData"] = {}),
                    (this["version"] = 0x0);
            }
            function RW(mN) {
                Rg["call"](this),
                    (this["type"] = "MeshBasicMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["map"] = null),
                    (this["lightMap"] = null),
                    (this["lightMapIntensity"] = 0x1),
                    (this["aoMap"] = null),
                    (this["aoMapIntensity"] = 0x1),
                    (this["specularMap"] = null),
                    (this["alphaMap"] = null),
                    (this["envMap"] = null),
                    (this["combine"] = 0x0),
                    (this["reflectivity"] = 0x1),
                    (this["refractionRatio"] = 0.98),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["wireframeLinecap"] = "round"),
                    (this["wireframeLinejoin"] = "round"),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    this["setValues"](mN);
            }
            (Rg["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                constructor: Rg,
                isMaterial: !0x0,
                onBeforeCompile: function () {},
                setValues: function (mN) {
                    if (void 0x0 !== mN)
                        for (var mX in mN) {
                            var mf = mN[mX];
                            if (void 0x0 !== mf) {
                                if ("shading" !== mX) {
                                    var mP = this[mX];
                                    void 0x0 !== mP
                                        ? mP && mP["isColor"]
                                            ? mP["set"](mf)
                                            : mP && mP["isVector3"] && mf && mf["isVector3"]
                                            ? mP["copy"](mf)
                                            : (this[mX] = mf)
                                        : console["warn"]("THREE." + this["type"] + ":\x20\x27" + mX + "\x27\x20is\x20not\x20a\x20property\x20of\x20this\x20material.");
                                } else console["warn"]("THREE." + this["type"] + ":\x20.shading\x20has\x20been\x20removed.\x20Use\x20the\x20boolean\x20.flatShading\x20instead."), (this["flatShading"] = 0x1 === mf);
                            } else console["warn"]("THREE.Material:\x20\x27" + mX + "\x27\x20parameter\x20is\x20undefined.");
                        }
                },
                toJSON: function (mN) {
                    var mX = void 0x0 === mN || "string" == typeof mN;
                    mX && (mN = { textures: {}, images: {} });
                    var mf = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
                    function mP(mM) {
                        var mp = [];
                        for (var mk in mM) {
                            var mU = mM[mk];
                            delete mU["metadata"], mp["push"](mU);
                        }
                        return mp;
                    }
                    if (
                        ((mf["uuid"] = this["uuid"]),
                        (mf["type"] = this["type"]),
                        "" !== this["name"] && (mf["name"] = this["name"]),
                        this["color"] && this["color"]["isColor"] && (mf["color"] = this["color"]["getHex"]()),
                        void 0x0 !== this["roughness"] && (mf["roughness"] = this["roughness"]),
                        void 0x0 !== this["metalness"] && (mf["metalness"] = this["metalness"]),
                        this["sheen"] && this["sheen"]["isColor"] && (mf["sheen"] = this["sheen"]["getHex"]()),
                        this["emissive"] && this["emissive"]["isColor"] && (mf["emissive"] = this["emissive"]["getHex"]()),
                        this["emissiveIntensity"] && 0x1 !== this["emissiveIntensity"] && (mf["emissiveIntensity"] = this["emissiveIntensity"]),
                        this["specular"] && this["specular"]["isColor"] && (mf["specular"] = this["specular"]["getHex"]()),
                        void 0x0 !== this["shininess"] && (mf["shininess"] = this["shininess"]),
                        void 0x0 !== this["clearcoat"] && (mf["clearcoat"] = this["clearcoat"]),
                        void 0x0 !== this["clearcoatRoughness"] && (mf["clearcoatRoughness"] = this["clearcoatRoughness"]),
                        this["clearcoatMap"] && this["clearcoatMap"]["isTexture"] && (mf["clearcoatMap"] = this["clearcoatMap"]["toJSON"](mN)["uuid"]),
                        this["clearcoatRoughnessMap"] && this["clearcoatRoughnessMap"]["isTexture"] && (mf["clearcoatRoughnessMap"] = this["clearcoatRoughnessMap"]["toJSON"](mN)["uuid"]),
                        this["clearcoatNormalMap"] &&
                            this["clearcoatNormalMap"]["isTexture"] &&
                            ((mf["clearcoatNormalMap"] = this["clearcoatNormalMap"]["toJSON"](mN)["uuid"]), (mf["clearcoatNormalScale"] = this["clearcoatNormalScale"]["toArray"]())),
                        this["map"] && this["map"]["isTexture"] && (mf["map"] = this["map"]["toJSON"](mN)["uuid"]),
                        this["matcap"] && this["matcap"]["isTexture"] && (mf["matcap"] = this["matcap"]["toJSON"](mN)["uuid"]),
                        this["alphaMap"] && this["alphaMap"]["isTexture"] && (mf["alphaMap"] = this["alphaMap"]["toJSON"](mN)["uuid"]),
                        this["lightMap"] && this["lightMap"]["isTexture"] && (mf["lightMap"] = this["lightMap"]["toJSON"](mN)["uuid"]),
                        this["aoMap"] && this["aoMap"]["isTexture"] && ((mf["aoMap"] = this["aoMap"]["toJSON"](mN)["uuid"]), (mf["aoMapIntensity"] = this["aoMapIntensity"])),
                        this["bumpMap"] && this["bumpMap"]["isTexture"] && ((mf["bumpMap"] = this["bumpMap"]["toJSON"](mN)["uuid"]), (mf["bumpScale"] = this["bumpScale"])),
                        this["normalMap"] &&
                            this["normalMap"]["isTexture"] &&
                            ((mf["normalMap"] = this["normalMap"]["toJSON"](mN)["uuid"]), (mf["normalMapType"] = this["normalMapType"]), (mf["normalScale"] = this["normalScale"]["toArray"]())),
                        this["displacementMap"] &&
                            this["displacementMap"]["isTexture"] &&
                            ((mf["displacementMap"] = this["displacementMap"]["toJSON"](mN)["uuid"]), (mf["displacementScale"] = this["displacementScale"]), (mf["displacementBias"] = this["displacementBias"])),
                        this["roughnessMap"] && this["roughnessMap"]["isTexture"] && (mf["roughnessMap"] = this["roughnessMap"]["toJSON"](mN)["uuid"]),
                        this["metalnessMap"] && this["metalnessMap"]["isTexture"] && (mf["metalnessMap"] = this["metalnessMap"]["toJSON"](mN)["uuid"]),
                        this["emissiveMap"] && this["emissiveMap"]["isTexture"] && (mf["emissiveMap"] = this["emissiveMap"]["toJSON"](mN)["uuid"]),
                        this["specularMap"] && this["specularMap"]["isTexture"] && (mf["specularMap"] = this["specularMap"]["toJSON"](mN)["uuid"]),
                        this["envMap"] &&
                            this["envMap"]["isTexture"] &&
                            ((mf["envMap"] = this["envMap"]["toJSON"](mN)["uuid"]),
                            (mf["reflectivity"] = this["reflectivity"]),
                            (mf["refractionRatio"] = this["refractionRatio"]),
                            void 0x0 !== this["combine"] && (mf["combine"] = this["combine"]),
                            void 0x0 !== this["envMapIntensity"] && (mf["envMapIntensity"] = this["envMapIntensity"])),
                        this["gradientMap"] && this["gradientMap"]["isTexture"] && (mf["gradientMap"] = this["gradientMap"]["toJSON"](mN)["uuid"]),
                        void 0x0 !== this["size"] && (mf["size"] = this["size"]),
                        void 0x0 !== this["sizeAttenuation"] && (mf["sizeAttenuation"] = this["sizeAttenuation"]),
                        0x1 !== this["blending"] && (mf["blending"] = this["blending"]),
                        !0x0 === this["flatShading"] && (mf["flatShading"] = this["flatShading"]),
                        this["side"] !== r5 && (mf["side"] = this["side"]),
                        this["vertexColors"] && (mf["vertexColors"] = !0x0),
                        this["opacity"] < 0x1 && (mf["opacity"] = this["opacity"]),
                        !0x0 === this["transparent"] && (mf["transparent"] = this["transparent"]),
                        (mf["depthFunc"] = this["depthFunc"]),
                        (mf["depthTest"] = this["depthTest"]),
                        (mf["depthWrite"] = this["depthWrite"]),
                        (mf["stencilWrite"] = this["stencilWrite"]),
                        (mf["stencilWriteMask"] = this["stencilWriteMask"]),
                        (mf["stencilFunc"] = this["stencilFunc"]),
                        (mf["stencilRef"] = this["stencilRef"]),
                        (mf["stencilFuncMask"] = this["stencilFuncMask"]),
                        (mf["stencilFail"] = this["stencilFail"]),
                        (mf["stencilZFail"] = this["stencilZFail"]),
                        (mf["stencilZPass"] = this["stencilZPass"]),
                        this["rotation"] && 0x0 !== this["rotation"] && (mf["rotation"] = this["rotation"]),
                        !0x0 === this["polygonOffset"] && (mf["polygonOffset"] = !0x0),
                        0x0 !== this["polygonOffsetFactor"] && (mf["polygonOffsetFactor"] = this["polygonOffsetFactor"]),
                        0x0 !== this["polygonOffsetUnits"] && (mf["polygonOffsetUnits"] = this["polygonOffsetUnits"]),
                        this["linewidth"] && 0x1 !== this["linewidth"] && (mf["linewidth"] = this["linewidth"]),
                        void 0x0 !== this["dashSize"] && (mf["dashSize"] = this["dashSize"]),
                        void 0x0 !== this["gapSize"] && (mf["gapSize"] = this["gapSize"]),
                        void 0x0 !== this["scale"] && (mf["scale"] = this["scale"]),
                        !0x0 === this["dithering"] && (mf["dithering"] = !0x0),
                        this["alphaTest"] > 0x0 && (mf["alphaTest"] = this["alphaTest"]),
                        !0x0 === this["premultipliedAlpha"] && (mf["premultipliedAlpha"] = this["premultipliedAlpha"]),
                        !0x0 === this["wireframe"] && (mf["wireframe"] = this["wireframe"]),
                        this["wireframeLinewidth"] > 0x1 && (mf["wireframeLinewidth"] = this["wireframeLinewidth"]),
                        "round" !== this["wireframeLinecap"] && (mf["wireframeLinecap"] = this["wireframeLinecap"]),
                        "round" !== this["wireframeLinejoin"] && (mf["wireframeLinejoin"] = this["wireframeLinejoin"]),
                        !0x0 === this["morphTargets"] && (mf["morphTargets"] = !0x0),
                        !0x0 === this["morphNormals"] && (mf["morphNormals"] = !0x0),
                        !0x0 === this["skinning"] && (mf["skinning"] = !0x0),
                        !0x1 === this["visible"] && (mf["visible"] = !0x1),
                        !0x1 === this["toneMapped"] && (mf["toneMapped"] = !0x1),
                        "{}" !== JSON["stringify"](this["userData"]) && (mf["userData"] = this["userData"]),
                        mX)
                    ) {
                        var mI = mP(mN["textures"]),
                            mA = mP(mN["images"]);
                        mI["length"] > 0x0 && (mf["textures"] = mI), mA["length"] > 0x0 && (mf["images"] = mA);
                    }
                    return mf;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    (this["name"] = mN["name"]),
                        (this["fog"] = mN["fog"]),
                        (this["blending"] = mN["blending"]),
                        (this["side"] = mN["side"]),
                        (this["flatShading"] = mN["flatShading"]),
                        (this["vertexColors"] = mN["vertexColors"]),
                        (this["opacity"] = mN["opacity"]),
                        (this["transparent"] = mN["transparent"]),
                        (this["blendSrc"] = mN["blendSrc"]),
                        (this["blendDst"] = mN["blendDst"]),
                        (this["blendEquation"] = mN["blendEquation"]),
                        (this["blendSrcAlpha"] = mN["blendSrcAlpha"]),
                        (this["blendDstAlpha"] = mN["blendDstAlpha"]),
                        (this["blendEquationAlpha"] = mN["blendEquationAlpha"]),
                        (this["depthFunc"] = mN["depthFunc"]),
                        (this["depthTest"] = mN["depthTest"]),
                        (this["depthWrite"] = mN["depthWrite"]),
                        (this["stencilWriteMask"] = mN["stencilWriteMask"]),
                        (this["stencilFunc"] = mN["stencilFunc"]),
                        (this["stencilRef"] = mN["stencilRef"]),
                        (this["stencilFuncMask"] = mN["stencilFuncMask"]),
                        (this["stencilFail"] = mN["stencilFail"]),
                        (this["stencilZFail"] = mN["stencilZFail"]),
                        (this["stencilZPass"] = mN["stencilZPass"]),
                        (this["stencilWrite"] = mN["stencilWrite"]);
                    var mX = mN["clippingPlanes"],
                        mf = null;
                    if (null !== mX) {
                        var mP = mX["length"];
                        mf = new Array(mP);
                        for (var mI = 0x0; mI !== mP; ++mI) mf[mI] = mX[mI]["clone"]();
                    }
                    return (
                        (this["clippingPlanes"] = mf),
                        (this["clipIntersection"] = mN["clipIntersection"]),
                        (this["clipShadows"] = mN["clipShadows"]),
                        (this["shadowSide"] = mN["shadowSide"]),
                        (this["colorWrite"] = mN["colorWrite"]),
                        (this["precision"] = mN["precision"]),
                        (this["polygonOffset"] = mN["polygonOffset"]),
                        (this["polygonOffsetFactor"] = mN["polygonOffsetFactor"]),
                        (this["polygonOffsetUnits"] = mN["polygonOffsetUnits"]),
                        (this["dithering"] = mN["dithering"]),
                        (this["alphaTest"] = mN["alphaTest"]),
                        (this["premultipliedAlpha"] = mN["premultipliedAlpha"]),
                        (this["visible"] = mN["visible"]),
                        (this["toneMapped"] = mN["toneMapped"]),
                        (this["userData"] = JSON["parse"](JSON["stringify"](mN["userData"]))),
                        this
                    );
                },
                dispose: function () {
                    this["dispatchEvent"]({ type: "dispose" });
                },
            })),
                Object["defineProperty"](Rg["prototype"], "needsUpdate", {
                    set: function (mN) {
                        !0x0 === mN && this["version"]++;
                    },
                }),
                (RW["prototype"] = Object["create"](Rg["prototype"])),
                (RW["prototype"]["constructor"] = RW),
                (RW["prototype"]["isMeshBasicMaterial"] = !0x0),
                (RW["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        (this["map"] = mN["map"]),
                        (this["lightMap"] = mN["lightMap"]),
                        (this["lightMapIntensity"] = mN["lightMapIntensity"]),
                        (this["aoMap"] = mN["aoMap"]),
                        (this["aoMapIntensity"] = mN["aoMapIntensity"]),
                        (this["specularMap"] = mN["specularMap"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["envMap"] = mN["envMap"]),
                        (this["combine"] = mN["combine"]),
                        (this["reflectivity"] = mN["reflectivity"]),
                        (this["refractionRatio"] = mN["refractionRatio"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["wireframeLinecap"] = mN["wireframeLinecap"]),
                        (this["wireframeLinejoin"] = mN["wireframeLinejoin"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        this
                    );
                });
            var RH = new Ed();
            function Rx(mN, mX, mf) {
                if (Array["isArray"](mN)) throw new TypeError("THREE.BufferAttribute:\x20array\x20should\x20be\x20a\x20Typed\x20Array.");
                (this["name"] = ""),
                    (this["array"] = mN),
                    (this["itemSize"] = mX),
                    (this["count"] = void 0x0 !== mN ? mN["length"] / mX : 0x0),
                    (this["normalized"] = !0x0 === mf),
                    (this["usage"] = rG),
                    (this["updateRange"] = { offset: 0x0, count: -0x1 }),
                    (this["version"] = 0x0);
            }
            function RK(mN, mX, mf) {
                Rx["call"](this, new Int8Array(mN), mX, mf);
            }
            function RV(mN, mX, mf) {
                Rx["call"](this, new Uint8Array(mN), mX, mf);
            }
            function RJ(mN, mX, mf) {
                Rx["call"](this, new Uint8ClampedArray(mN), mX, mf);
            }
            function RG(mN, mX, mf) {
                Rx["call"](this, new Int16Array(mN), mX, mf);
            }
            function RL(mN, mX, mf) {
                Rx["call"](this, new Uint16Array(mN), mX, mf);
            }
            function RQ(mN, mX, mf) {
                Rx["call"](this, new Int32Array(mN), mX, mf);
            }
            function Rz(mN, mX, mf) {
                Rx["call"](this, new Uint32Array(mN), mX, mf);
            }
            function T0(mN, mX, mf) {
                Rx["call"](this, new Float32Array(mN), mX, mf);
            }
            function T1(mN, mX, mf) {
                Rx["call"](this, new Float64Array(mN), mX, mf);
            }
            function T2() {
                (this["vertices"] = []),
                    (this["normals"] = []),
                    (this["colors"] = []),
                    (this["uvs"] = []),
                    (this["uvs2"] = []),
                    (this["groups"] = []),
                    (this["morphTargets"] = {}),
                    (this["skinWeights"] = []),
                    (this["skinIndices"] = []),
                    (this["boundingBox"] = null),
                    (this["boundingSphere"] = null),
                    (this["verticesNeedUpdate"] = !0x1),
                    (this["normalsNeedUpdate"] = !0x1),
                    (this["colorsNeedUpdate"] = !0x1),
                    (this["uvsNeedUpdate"] = !0x1),
                    (this["groupsNeedUpdate"] = !0x1);
            }
            function T3(mN) {
                if (0x0 === mN["length"]) return -0x1 / 0x0;
                let mX = mN[0x0];
                for (let mf = 0x1, mP = mN["length"]; mf < mP; ++mf) mN[mf] > mX && (mX = mN[mf]);
                return mX;
            }
            Object["defineProperty"](Rx["prototype"], "needsUpdate", {
                set: function (mN) {
                    !0x0 === mN && this["version"]++;
                },
            }),
                Object["assign"](Rx["prototype"], {
                    isBufferAttribute: !0x0,
                    onUploadCallback: function () {},
                    setUsage: function (mN) {
                        return (this["usage"] = mN), this;
                    },
                    copy: function (mN) {
                        return (
                            (this["name"] = mN["name"]),
                            (this["array"] = new mN["array"]["constructor"](mN["array"])),
                            (this["itemSize"] = mN["itemSize"]),
                            (this["count"] = mN["count"]),
                            (this["normalized"] = mN["normalized"]),
                            (this["usage"] = mN["usage"]),
                            this
                        );
                    },
                    copyAt: function (mN, mX, mf) {
                        (mN *= this["itemSize"]), (mf *= mX["itemSize"]);
                        for (var mP = 0x0, mI = this["itemSize"]; mP < mI; mP++) this["array"][mN + mP] = mX["array"][mf + mP];
                        return this;
                    },
                    copyArray: function (mN) {
                        return this["array"]["set"](mN), this;
                    },
                    copyColorsArray: function (mN) {
                        for (var mX = this["array"], mf = 0x0, mP = 0x0, mI = mN["length"]; mP < mI; mP++) {
                            var mA = mN[mP];
                            void 0x0 === mA && (console["warn"]("THREE.BufferAttribute.copyColorsArray():\x20color\x20is\x20undefined", mP), (mA = new Rq())), (mX[mf++] = mA["r"]), (mX[mf++] = mA["g"]), (mX[mf++] = mA["b"]);
                        }
                        return this;
                    },
                    copyVector2sArray: function (mN) {
                        for (var mX = this["array"], mf = 0x0, mP = 0x0, mI = mN["length"]; mP < mI; mP++) {
                            var mA = mN[mP];
                            void 0x0 === mA && (console["warn"]("THREE.BufferAttribute.copyVector2sArray():\x20vector\x20is\x20undefined", mP), (mA = new E3())), (mX[mf++] = mA["x"]), (mX[mf++] = mA["y"]);
                        }
                        return this;
                    },
                    copyVector3sArray: function (mN) {
                        for (var mX = this["array"], mf = 0x0, mP = 0x0, mI = mN["length"]; mP < mI; mP++) {
                            var mA = mN[mP];
                            void 0x0 === mA && (console["warn"]("THREE.BufferAttribute.copyVector3sArray():\x20vector\x20is\x20undefined", mP), (mA = new Ed())), (mX[mf++] = mA["x"]), (mX[mf++] = mA["y"]), (mX[mf++] = mA["z"]);
                        }
                        return this;
                    },
                    copyVector4sArray: function (mN) {
                        for (var mX = this["array"], mf = 0x0, mP = 0x0, mI = mN["length"]; mP < mI; mP++) {
                            var mA = mN[mP];
                            void 0x0 === mA && (console["warn"]("THREE.BufferAttribute.copyVector4sArray():\x20vector\x20is\x20undefined", mP), (mA = new E8())),
                                (mX[mf++] = mA["x"]),
                                (mX[mf++] = mA["y"]),
                                (mX[mf++] = mA["z"]),
                                (mX[mf++] = mA["w"]);
                        }
                        return this;
                    },
                    applyMatrix3: function (mN) {
                        for (var mX = 0x0, mf = this["count"]; mX < mf; mX++) (RH["x"] = this["getX"](mX)), (RH["y"] = this["getY"](mX)), (RH["z"] = this["getZ"](mX)), RH["applyMatrix3"](mN), this["setXYZ"](mX, RH["x"], RH["y"], RH["z"]);
                        return this;
                    },
                    applyMatrix4: function (mN) {
                        for (var mX = 0x0, mf = this["count"]; mX < mf; mX++) (RH["x"] = this["getX"](mX)), (RH["y"] = this["getY"](mX)), (RH["z"] = this["getZ"](mX)), RH["applyMatrix4"](mN), this["setXYZ"](mX, RH["x"], RH["y"], RH["z"]);
                        return this;
                    },
                    applyNormalMatrix: function (mN) {
                        for (var mX = 0x0, mf = this["count"]; mX < mf; mX++)
                            (RH["x"] = this["getX"](mX)), (RH["y"] = this["getY"](mX)), (RH["z"] = this["getZ"](mX)), RH["applyNormalMatrix"](mN), this["setXYZ"](mX, RH["x"], RH["y"], RH["z"]);
                        return this;
                    },
                    transformDirection: function (mN) {
                        for (var mX = 0x0, mf = this["count"]; mX < mf; mX++)
                            (RH["x"] = this["getX"](mX)), (RH["y"] = this["getY"](mX)), (RH["z"] = this["getZ"](mX)), RH["transformDirection"](mN), this["setXYZ"](mX, RH["x"], RH["y"], RH["z"]);
                        return this;
                    },
                    set: function (mN, mX) {
                        return void 0x0 === mX && (mX = 0x0), this["array"]["set"](mN, mX), this;
                    },
                    getX: function (mN) {
                        return this["array"][mN * this["itemSize"]];
                    },
                    setX: function (mN, mX) {
                        return (this["array"][mN * this["itemSize"]] = mX), this;
                    },
                    getY: function (mN) {
                        return this["array"][mN * this["itemSize"] + 0x1];
                    },
                    setY: function (mN, mX) {
                        return (this["array"][mN * this["itemSize"] + 0x1] = mX), this;
                    },
                    getZ: function (mN) {
                        return this["array"][mN * this["itemSize"] + 0x2];
                    },
                    setZ: function (mN, mX) {
                        return (this["array"][mN * this["itemSize"] + 0x2] = mX), this;
                    },
                    getW: function (mN) {
                        return this["array"][mN * this["itemSize"] + 0x3];
                    },
                    setW: function (mN, mX) {
                        return (this["array"][mN * this["itemSize"] + 0x3] = mX), this;
                    },
                    setXY: function (mN, mX, mf) {
                        return (mN *= this["itemSize"]), (this["array"][mN + 0x0] = mX), (this["array"][mN + 0x1] = mf), this;
                    },
                    setXYZ: function (mN, mX, mf, mP) {
                        return (mN *= this["itemSize"]), (this["array"][mN + 0x0] = mX), (this["array"][mN + 0x1] = mf), (this["array"][mN + 0x2] = mP), this;
                    },
                    setXYZW: function (mN, mX, mf, mP, mI) {
                        return (mN *= this["itemSize"]), (this["array"][mN + 0x0] = mX), (this["array"][mN + 0x1] = mf), (this["array"][mN + 0x2] = mP), (this["array"][mN + 0x3] = mI), this;
                    },
                    onUpload: function (mN) {
                        return (this["onUploadCallback"] = mN), this;
                    },
                    clone: function () {
                        return new this["constructor"](this["array"], this["itemSize"])["copy"](this);
                    },
                    toJSON: function () {
                        return { itemSize: this["itemSize"], type: this["array"]["constructor"]["name"], array: Array["prototype"]["slice"]["call"](this["array"]), normalized: this["normalized"] };
                    },
                }),
                (RK["prototype"] = Object["create"](Rx["prototype"])),
                (RK["prototype"]["constructor"] = RK),
                (RV["prototype"] = Object["create"](Rx["prototype"])),
                (RV["prototype"]["constructor"] = RV),
                (RJ["prototype"] = Object["create"](Rx["prototype"])),
                (RJ["prototype"]["constructor"] = RJ),
                (RG["prototype"] = Object["create"](Rx["prototype"])),
                (RG["prototype"]["constructor"] = RG),
                (RL["prototype"] = Object["create"](Rx["prototype"])),
                (RL["prototype"]["constructor"] = RL),
                (RQ["prototype"] = Object["create"](Rx["prototype"])),
                (RQ["prototype"]["constructor"] = RQ),
                (Rz["prototype"] = Object["create"](Rx["prototype"])),
                (Rz["prototype"]["constructor"] = Rz),
                (T0["prototype"] = Object["create"](Rx["prototype"])),
                (T0["prototype"]["constructor"] = T0),
                (T1["prototype"] = Object["create"](Rx["prototype"])),
                (T1["prototype"]["constructor"] = T1),
                Object["assign"](T2["prototype"], {
                    computeGroups: function (mN) {
                        for (var mX, mf = [], mP = void 0x0, mI = mN["faces"], mA = 0x0; mA < mI["length"]; mA++) {
                            var mM = mI[mA];
                            mM["materialIndex"] !== mP && ((mP = mM["materialIndex"]), void 0x0 !== mX && ((mX["count"] = 0x3 * mA - mX["start"]), mf["push"](mX)), (mX = { start: 0x3 * mA, materialIndex: mP }));
                        }
                        void 0x0 !== mX && ((mX["count"] = 0x3 * mA - mX["start"]), mf["push"](mX)), (this["groups"] = mf);
                    },
                    fromGeometry: function (mN) {
                        var mX,
                            mf = mN["faces"],
                            mP = mN["vertices"],
                            mI = mN["faceVertexUvs"],
                            mA = mI[0x0] && mI[0x0]["length"] > 0x0,
                            mM = mI[0x1] && mI[0x1]["length"] > 0x0,
                            mp = mN["morphTargets"],
                            mk = mp["length"];
                        if (mk > 0x0) {
                            mX = [];
                            for (var mU = 0x0; mU < mk; mU++) mX[mU] = { name: mp[mU]["name"], data: [] };
                            this["morphTargets"]["position"] = mX;
                        }
                        var mq,
                            mw = mN["morphNormals"],
                            mO = mw["length"];
                        if (mO > 0x0) {
                            mq = [];
                            for (mU = 0x0; mU < mO; mU++) mq[mU] = { name: mw[mU]["name"], data: [] };
                            this["morphTargets"]["normal"] = mq;
                        }
                        var mj = mN["skinIndices"],
                            mh = mN["skinWeights"],
                            mS = mj["length"] === mP["length"],
                            mg = mh["length"] === mP["length"];
                        mP["length"] > 0x0 && 0x0 === mf["length"] && console["error"]("THREE.DirectGeometry:\x20Faceless\x20geometries\x20are\x20not\x20supported.");
                        for (mU = 0x0; mU < mf["length"]; mU++) {
                            var mW = mf[mU];
                            this["vertices"]["push"](mP[mW["a"]], mP[mW["b"]], mP[mW["c"]]);
                            var mH = mW["vertexNormals"];
                            if (0x3 === mH["length"]) this["normals"]["push"](mH[0x0], mH[0x1], mH[0x2]);
                            else {
                                var mx = mW["normal"];
                                this["normals"]["push"](mx, mx, mx);
                            }
                            var mK,
                                mV = mW["vertexColors"];
                            if (0x3 === mV["length"]) this["colors"]["push"](mV[0x0], mV[0x1], mV[0x2]);
                            else {
                                var mJ = mW["color"];
                                this["colors"]["push"](mJ, mJ, mJ);
                            }
                            if (!0x0 === mA)
                                void 0x0 !== (mK = mI[0x0][mU])
                                    ? this["uvs"]["push"](mK[0x0], mK[0x1], mK[0x2])
                                    : (console["warn"]("THREE.DirectGeometry.fromGeometry():\x20Undefined\x20vertexUv\x20", mU), this["uvs"]["push"](new E3(), new E3(), new E3()));
                            if (!0x0 === mM)
                                void 0x0 !== (mK = mI[0x1][mU])
                                    ? this["uvs2"]["push"](mK[0x0], mK[0x1], mK[0x2])
                                    : (console["warn"]("THREE.DirectGeometry.fromGeometry():\x20Undefined\x20vertexUv2\x20", mU), this["uvs2"]["push"](new E3(), new E3(), new E3()));
                            for (var mG = 0x0; mG < mk; mG++) {
                                var mL = mp[mG]["vertices"];
                                mX[mG]["data"]["push"](mL[mW["a"]], mL[mW["b"]], mL[mW["c"]]);
                            }
                            for (mG = 0x0; mG < mO; mG++) {
                                var mQ = mw[mG]["vertexNormals"][mU];
                                mq[mG]["data"]["push"](mQ["a"], mQ["b"], mQ["c"]);
                            }
                            mS && this["skinIndices"]["push"](mj[mW["a"]], mj[mW["b"]], mj[mW["c"]]), mg && this["skinWeights"]["push"](mh[mW["a"]], mh[mW["b"]], mh[mW["c"]]);
                        }
                        return (
                            this["computeGroups"](mN),
                            (this["verticesNeedUpdate"] = mN["verticesNeedUpdate"]),
                            (this["normalsNeedUpdate"] = mN["normalsNeedUpdate"]),
                            (this["colorsNeedUpdate"] = mN["colorsNeedUpdate"]),
                            (this["uvsNeedUpdate"] = mN["uvsNeedUpdate"]),
                            (this["groupsNeedUpdate"] = mN["groupsNeedUpdate"]),
                            null !== mN["boundingSphere"] && (this["boundingSphere"] = mN["boundingSphere"]["clone"]()),
                            null !== mN["boundingBox"] && (this["boundingBox"] = mN["boundingBox"]["clone"]()),
                            this
                        );
                    },
                });
            var T4 = 0x1,
                T5 = new Ey(),
                T6 = new Eg(),
                T7 = new Ed(),
                T8 = new R4(),
                T9 = new R4(),
                TE = new Ed();
            function TR() {
                Object["defineProperty"](this, "id", { value: (T4 += 0x2) }),
                    (this["uuid"] = E2["generateUUID"]()),
                    (this["name"] = ""),
                    (this["type"] = "BufferGeometry"),
                    (this["index"] = null),
                    (this["attributes"] = {}),
                    (this["morphAttributes"] = {}),
                    (this["morphTargetsRelative"] = !0x1),
                    (this["groups"] = []),
                    (this["boundingBox"] = null),
                    (this["boundingSphere"] = null),
                    (this["drawRange"] = { start: 0x0, count: 0x1 / 0x0 }),
                    (this["userData"] = {});
            }
            TR["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                constructor: TR,
                isBufferGeometry: !0x0,
                getIndex: function () {
                    return this["index"];
                },
                setIndex: function (mN) {
                    Array["isArray"](mN) ? (this["index"] = new (T3(mN) > 0xffff ? Rz : RL)(mN, 0x1)) : (this["index"] = mN);
                },
                getAttribute: function (mN) {
                    return this["attributes"][mN];
                },
                setAttribute: function (mN, mX) {
                    return (this["attributes"][mN] = mX), this;
                },
                deleteAttribute: function (mN) {
                    return delete this["attributes"][mN], this;
                },
                addGroup: function (mN, mX, mf) {
                    this["groups"]["push"]({ start: mN, count: mX, materialIndex: void 0x0 !== mf ? mf : 0x0 });
                },
                clearGroups: function () {
                    this["groups"] = [];
                },
                setDrawRange: function (mN, mX) {
                    (this["drawRange"]["start"] = mN), (this["drawRange"]["count"] = mX);
                },
                applyMatrix4: function (mN) {
                    var mX = this["attributes"]["position"];
                    void 0x0 !== mX && (mX["applyMatrix4"](mN), (mX["needsUpdate"] = !0x0));
                    var mf = this["attributes"]["normal"];
                    if (void 0x0 !== mf) {
                        var mP = new E4()["getNormalMatrix"](mN);
                        mf["applyNormalMatrix"](mP), (mf["needsUpdate"] = !0x0);
                    }
                    var mI = this["attributes"]["tangent"];
                    return (
                        void 0x0 !== mI && (mI["transformDirection"](mN), (mI["needsUpdate"] = !0x0)), null !== this["boundingBox"] && this["computeBoundingBox"](), null !== this["boundingSphere"] && this["computeBoundingSphere"](), this
                    );
                },
                rotateX: function (mN) {
                    return T5["makeRotationX"](mN), this["applyMatrix4"](T5), this;
                },
                rotateY: function (mN) {
                    return T5["makeRotationY"](mN), this["applyMatrix4"](T5), this;
                },
                rotateZ: function (mN) {
                    return T5["makeRotationZ"](mN), this["applyMatrix4"](T5), this;
                },
                translate: function (mN, mX, mf) {
                    return T5["makeTranslation"](mN, mX, mf), this["applyMatrix4"](T5), this;
                },
                scale: function (mN, mX, mf) {
                    return T5["makeScale"](mN, mX, mf), this["applyMatrix4"](T5), this;
                },
                lookAt: function (mN) {
                    return T6["lookAt"](mN), T6["updateMatrix"](), this["applyMatrix4"](T6["matrix"]), this;
                },
                center: function () {
                    return this["computeBoundingBox"](), this["boundingBox"]["getCenter"](T7)["negate"](), this["translate"](T7["x"], T7["y"], T7["z"]), this;
                },
                setFromObject: function (mN) {
                    var mX = mN["geometry"];
                    if (mN["isPoints"] || mN["isLine"]) {
                        var mf = new T0(0x3 * mX["vertices"]["length"], 0x3),
                            mP = new T0(0x3 * mX["colors"]["length"], 0x3);
                        if (
                            (this["setAttribute"]("position", mf["copyVector3sArray"](mX["vertices"])),
                            this["setAttribute"]("color", mP["copyColorsArray"](mX["colors"])),
                            mX["lineDistances"] && mX["lineDistances"]["length"] === mX["vertices"]["length"])
                        ) {
                            var mI = new T0(mX["lineDistances"]["length"], 0x1);
                            this["setAttribute"]("lineDistance", mI["copyArray"](mX["lineDistances"]));
                        }
                        null !== mX["boundingSphere"] && (this["boundingSphere"] = mX["boundingSphere"]["clone"]()), null !== mX["boundingBox"] && (this["boundingBox"] = mX["boundingBox"]["clone"]());
                    } else mN["isMesh"] && mX && mX["isGeometry"] && this["fromGeometry"](mX);
                    return this;
                },
                setFromPoints: function (mN) {
                    for (var mX = [], mf = 0x0, mP = mN["length"]; mf < mP; mf++) {
                        var mI = mN[mf];
                        mX["push"](mI["x"], mI["y"], mI["z"] || 0x0);
                    }
                    return this["setAttribute"]("position", new T0(mX, 0x3)), this;
                },
                updateFromObject: function (mN) {
                    var mX,
                        mf = mN["geometry"];
                    if (mN["isMesh"]) {
                        var mP = mf["__directGeometry"];
                        if ((!0x0 === mf["elementsNeedUpdate"] && ((mP = void 0x0), (mf["elementsNeedUpdate"] = !0x1)), void 0x0 === mP)) return this["fromGeometry"](mf);
                        (mP["verticesNeedUpdate"] = mf["verticesNeedUpdate"]),
                            (mP["normalsNeedUpdate"] = mf["normalsNeedUpdate"]),
                            (mP["colorsNeedUpdate"] = mf["colorsNeedUpdate"]),
                            (mP["uvsNeedUpdate"] = mf["uvsNeedUpdate"]),
                            (mP["groupsNeedUpdate"] = mf["groupsNeedUpdate"]),
                            (mf["verticesNeedUpdate"] = !0x1),
                            (mf["normalsNeedUpdate"] = !0x1),
                            (mf["colorsNeedUpdate"] = !0x1),
                            (mf["uvsNeedUpdate"] = !0x1),
                            (mf["groupsNeedUpdate"] = !0x1),
                            (mf = mP);
                    }
                    return (
                        !0x0 === mf["verticesNeedUpdate"] && (void 0x0 !== (mX = this["attributes"]["position"]) && (mX["copyVector3sArray"](mf["vertices"]), (mX["needsUpdate"] = !0x0)), (mf["verticesNeedUpdate"] = !0x1)),
                        !0x0 === mf["normalsNeedUpdate"] && (void 0x0 !== (mX = this["attributes"]["normal"]) && (mX["copyVector3sArray"](mf["normals"]), (mX["needsUpdate"] = !0x0)), (mf["normalsNeedUpdate"] = !0x1)),
                        !0x0 === mf["colorsNeedUpdate"] && (void 0x0 !== (mX = this["attributes"]["color"]) && (mX["copyColorsArray"](mf["colors"]), (mX["needsUpdate"] = !0x0)), (mf["colorsNeedUpdate"] = !0x1)),
                        mf["uvsNeedUpdate"] && (void 0x0 !== (mX = this["attributes"]["uv"]) && (mX["copyVector2sArray"](mf["uvs"]), (mX["needsUpdate"] = !0x0)), (mf["uvsNeedUpdate"] = !0x1)),
                        mf["lineDistancesNeedUpdate"] && (void 0x0 !== (mX = this["attributes"]["lineDistance"]) && (mX["copyArray"](mf["lineDistances"]), (mX["needsUpdate"] = !0x0)), (mf["lineDistancesNeedUpdate"] = !0x1)),
                        mf["groupsNeedUpdate"] && (mf["computeGroups"](mN["geometry"]), (this["groups"] = mf["groups"]), (mf["groupsNeedUpdate"] = !0x1)),
                        this
                    );
                },
                fromGeometry: function (mN) {
                    return (mN["__directGeometry"] = new T2()["fromGeometry"](mN)), this["fromDirectGeometry"](mN["__directGeometry"]);
                },
                fromDirectGeometry: function (mN) {
                    var mX = new Float32Array(0x3 * mN["vertices"]["length"]);
                    if ((this["setAttribute"]("position", new Rx(mX, 0x3)["copyVector3sArray"](mN["vertices"])), mN["normals"]["length"] > 0x0)) {
                        var mf = new Float32Array(0x3 * mN["normals"]["length"]);
                        this["setAttribute"]("normal", new Rx(mf, 0x3)["copyVector3sArray"](mN["normals"]));
                    }
                    if (mN["colors"]["length"] > 0x0) {
                        var mP = new Float32Array(0x3 * mN["colors"]["length"]);
                        this["setAttribute"]("color", new Rx(mP, 0x3)["copyColorsArray"](mN["colors"]));
                    }
                    if (mN["uvs"]["length"] > 0x0) {
                        var mI = new Float32Array(0x2 * mN["uvs"]["length"]);
                        this["setAttribute"]("uv", new Rx(mI, 0x2)["copyVector2sArray"](mN["uvs"]));
                    }
                    if (mN["uvs2"]["length"] > 0x0) {
                        var mA = new Float32Array(0x2 * mN["uvs2"]["length"]);
                        this["setAttribute"]("uv2", new Rx(mA, 0x2)["copyVector2sArray"](mN["uvs2"]));
                    }
                    for (var mM in ((this["groups"] = mN["groups"]), mN["morphTargets"])) {
                        for (var mp = [], mk = mN["morphTargets"][mM], mU = 0x0, mq = mk["length"]; mU < mq; mU++) {
                            var mw = mk[mU],
                                mO = new T0(0x3 * mw["data"]["length"], 0x3);
                            (mO["name"] = mw["name"]), mp["push"](mO["copyVector3sArray"](mw["data"]));
                        }
                        this["morphAttributes"][mM] = mp;
                    }
                    if (mN["skinIndices"]["length"] > 0x0) {
                        var mj = new T0(0x4 * mN["skinIndices"]["length"], 0x4);
                        this["setAttribute"]("skinIndex", mj["copyVector4sArray"](mN["skinIndices"]));
                    }
                    if (mN["skinWeights"]["length"] > 0x0) {
                        var mh = new T0(0x4 * mN["skinWeights"]["length"], 0x4);
                        this["setAttribute"]("skinWeight", mh["copyVector4sArray"](mN["skinWeights"]));
                    }
                    return null !== mN["boundingSphere"] && (this["boundingSphere"] = mN["boundingSphere"]["clone"]()), null !== mN["boundingBox"] && (this["boundingBox"] = mN["boundingBox"]["clone"]()), this;
                },
                computeBoundingBox: function () {
                    null === this["boundingBox"] && (this["boundingBox"] = new R4());
                    var mN = this["attributes"]["position"],
                        mX = this["morphAttributes"]["position"];
                    if (void 0x0 !== mN) {
                        if ((this["boundingBox"]["setFromBufferAttribute"](mN), mX))
                            for (var mf = 0x0, mP = mX["length"]; mf < mP; mf++) {
                                var mI = mX[mf];
                                T8["setFromBufferAttribute"](mI),
                                    this["morphTargetsRelative"]
                                        ? (TE["addVectors"](this["boundingBox"]["min"], T8["min"]), this["boundingBox"]["expandByPoint"](TE), TE["addVectors"](this["boundingBox"]["max"], T8["max"]), this["boundingBox"]["expandByPoint"](TE))
                                        : (this["boundingBox"]["expandByPoint"](T8["min"]), this["boundingBox"]["expandByPoint"](T8["max"]));
                            }
                    } else this["boundingBox"]["makeEmpty"]();
                    (isNaN(this["boundingBox"]["min"]["x"]) || isNaN(this["boundingBox"]["min"]["y"]) || isNaN(this["boundingBox"]["min"]["z"])) &&
                        console["error"]("THREE.BufferGeometry.computeBoundingBox:\x20Computed\x20min/max\x20have\x20NaN\x20values.\x20The\x20\x22position\x22\x20attribute\x20is\x20likely\x20to\x20have\x20NaN\x20values.", this);
                },
                computeBoundingSphere: function () {
                    null === this["boundingSphere"] && (this["boundingSphere"] = new R7());
                    var mN = this["attributes"]["position"],
                        mX = this["morphAttributes"]["position"];
                    if (mN) {
                        var mf = this["boundingSphere"]["center"];
                        if ((T8["setFromBufferAttribute"](mN), mX))
                            for (var mP = 0x0, mI = mX["length"]; mP < mI; mP++) {
                                var mA = mX[mP];
                                T9["setFromBufferAttribute"](mA),
                                    this["morphTargetsRelative"]
                                        ? (TE["addVectors"](T8["min"], T9["min"]), T8["expandByPoint"](TE), TE["addVectors"](T8["max"], T9["max"]), T8["expandByPoint"](TE))
                                        : (T8["expandByPoint"](T9["min"]), T8["expandByPoint"](T9["max"]));
                            }
                        T8["getCenter"](mf);
                        var mM = 0x0;
                        for (mP = 0x0, mI = mN["count"]; mP < mI; mP++) TE["fromBufferAttribute"](mN, mP), (mM = Math["max"](mM, mf["distanceToSquared"](TE)));
                        if (mX)
                            for (mP = 0x0, mI = mX["length"]; mP < mI; mP++) {
                                mA = mX[mP];
                                for (var mp = this["morphTargetsRelative"], mk = 0x0, mU = mA["count"]; mk < mU; mk++)
                                    TE["fromBufferAttribute"](mA, mk), mp && (T7["fromBufferAttribute"](mN, mk), TE["add"](T7)), (mM = Math["max"](mM, mf["distanceToSquared"](TE)));
                            }
                        (this["boundingSphere"]["radius"] = Math["sqrt"](mM)),
                            isNaN(this["boundingSphere"]["radius"]) &&
                                console["error"]("THREE.BufferGeometry.computeBoundingSphere():\x20Computed\x20radius\x20is\x20NaN.\x20The\x20\x22position\x22\x20attribute\x20is\x20likely\x20to\x20have\x20NaN\x20values.", this);
                    }
                },
                computeFaceNormals: function () {},
                computeVertexNormals: function () {
                    var mN = this["index"],
                        mX = this["attributes"];
                    if (mX["position"]) {
                        var mf = mX["position"]["array"];
                        if (void 0x0 === mX["normal"]) this["setAttribute"]("normal", new Rx(new Float32Array(mf["length"]), 0x3));
                        else {
                            for (var mP = mX["normal"]["array"], mI = 0x0, mA = mP["length"]; mI < mA; mI++) mP[mI] = 0x0;
                        }
                        var mM,
                            mp,
                            mk,
                            mU = mX["normal"]["array"],
                            mq = new Ed(),
                            mw = new Ed(),
                            mO = new Ed(),
                            mj = new Ed(),
                            mh = new Ed();
                        if (mN) {
                            var mS = mN["array"];
                            for (mI = 0x0, mA = mN["count"]; mI < mA; mI += 0x3)
                                (mM = 0x3 * mS[mI + 0x0]),
                                    (mp = 0x3 * mS[mI + 0x1]),
                                    (mk = 0x3 * mS[mI + 0x2]),
                                    mq["fromArray"](mf, mM),
                                    mw["fromArray"](mf, mp),
                                    mO["fromArray"](mf, mk),
                                    mj["subVectors"](mO, mw),
                                    mh["subVectors"](mq, mw),
                                    mj["cross"](mh),
                                    (mU[mM] += mj["x"]),
                                    (mU[mM + 0x1] += mj["y"]),
                                    (mU[mM + 0x2] += mj["z"]),
                                    (mU[mp] += mj["x"]),
                                    (mU[mp + 0x1] += mj["y"]),
                                    (mU[mp + 0x2] += mj["z"]),
                                    (mU[mk] += mj["x"]),
                                    (mU[mk + 0x1] += mj["y"]),
                                    (mU[mk + 0x2] += mj["z"]);
                        } else {
                            for (mI = 0x0, mA = mf["length"]; mI < mA; mI += 0x9)
                                mq["fromArray"](mf, mI),
                                    mw["fromArray"](mf, mI + 0x3),
                                    mO["fromArray"](mf, mI + 0x6),
                                    mj["subVectors"](mO, mw),
                                    mh["subVectors"](mq, mw),
                                    mj["cross"](mh),
                                    (mU[mI] = mj["x"]),
                                    (mU[mI + 0x1] = mj["y"]),
                                    (mU[mI + 0x2] = mj["z"]),
                                    (mU[mI + 0x3] = mj["x"]),
                                    (mU[mI + 0x4] = mj["y"]),
                                    (mU[mI + 0x5] = mj["z"]),
                                    (mU[mI + 0x6] = mj["x"]),
                                    (mU[mI + 0x7] = mj["y"]),
                                    (mU[mI + 0x8] = mj["z"]);
                        }
                        this["normalizeNormals"](), (mX["normal"]["needsUpdate"] = !0x0);
                    }
                },
                merge: function (mN, mX) {
                    if (mN && mN["isBufferGeometry"]) {
                        void 0x0 === mX &&
                            ((mX = 0x0),
                            console["warn"]("THREE.BufferGeometry.merge():\x20Overwriting\x20original\x20geometry,\x20starting\x20at\x20offset=0.\x20Use\x20BufferGeometryUtils.mergeBufferGeometries()\x20for\x20lossless\x20merge."));
                        var mf = this["attributes"];
                        for (var mP in mf)
                            if (void 0x0 !== mN["attributes"][mP]) {
                                for (var mI = mf[mP]["array"], mA = mN["attributes"][mP], mM = mA["array"], mp = mA["itemSize"] * mX, mk = Math["min"](mM["length"], mI["length"] - mp), mU = 0x0, mq = mp; mU < mk; mU++, mq++)
                                    mI[mq] = mM[mU];
                            }
                        return this;
                    }
                    console["error"]("THREE.BufferGeometry.merge():\x20geometry\x20not\x20an\x20instance\x20of\x20THREE.BufferGeometry.", mN);
                },
                normalizeNormals: function () {
                    for (var mN = this["attributes"]["normal"], mX = 0x0, mf = mN["count"]; mX < mf; mX++)
                        (TE["x"] = mN["getX"](mX)), (TE["y"] = mN["getY"](mX)), (TE["z"] = mN["getZ"](mX)), TE["normalize"](), mN["setXYZ"](mX, TE["x"], TE["y"], TE["z"]);
                },
                toNonIndexed: function () {
                    function mN(mh, mS) {
                        for (var mg = mh["array"], mW = mh["itemSize"], mH = mh["normalized"], mx = new mg["constructor"](mS["length"] * mW), mK = 0x0, mV = 0x0, mJ = 0x0, mG = mS["length"]; mJ < mG; mJ++) {
                            mK = mS[mJ] * mW;
                            for (var mL = 0x0; mL < mW; mL++) mx[mV++] = mg[mK++];
                        }
                        return new Rx(mx, mW, mH);
                    }
                    if (null === this["index"]) return console["warn"]("THREE.BufferGeometry.toNonIndexed():\x20Geometry\x20is\x20already\x20non-indexed."), this;
                    var mX = new TR(),
                        mf = this["index"]["array"],
                        mP = this["attributes"];
                    for (var mI in mP) {
                        var mA = mN(mP[mI], mf);
                        mX["setAttribute"](mI, mA);
                    }
                    var mM = this["morphAttributes"];
                    for (mI in mM) {
                        for (var mp = [], mk = mM[mI], mU = 0x0, mq = mk["length"]; mU < mq; mU++) {
                            (mA = mN(mk[mU], mf)), mp["push"](mA);
                        }
                        mX["morphAttributes"][mI] = mp;
                    }
                    mX["morphTargetsRelative"] = this["morphTargetsRelative"];
                    for (var mw = this["groups"], mO = ((mU = 0x0), mw["length"]); mU < mO; mU++) {
                        var mj = mw[mU];
                        mX["addGroup"](mj["start"], mj["count"], mj["materialIndex"]);
                    }
                    return mX;
                },
                toJSON: function () {
                    var mN = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                    if (
                        ((mN["uuid"] = this["uuid"]),
                        (mN["type"] = this["type"]),
                        "" !== this["name"] && (mN["name"] = this["name"]),
                        Object["keys"](this["userData"])["length"] > 0x0 && (mN["userData"] = this["userData"]),
                        void 0x0 !== this["parameters"])
                    ) {
                        var mX = this["parameters"];
                        for (var mf in mX) void 0x0 !== mX[mf] && (mN[mf] = mX[mf]);
                        return mN;
                    }
                    mN["data"] = { attributes: {} };
                    var mP = this["index"];
                    null !== mP && (mN["data"]["index"] = { type: mP["array"]["constructor"]["name"], array: Array["prototype"]["slice"]["call"](mP["array"]) });
                    var mI = this["attributes"];
                    for (var mf in mI) {
                        var mA = (mO = mI[mf])["toJSON"]();
                        "" !== mO["name"] && (mA["name"] = mO["name"]), (mN["data"]["attributes"][mf] = mA);
                    }
                    var mM = {},
                        mp = !0x1;
                    for (var mf in this["morphAttributes"]) {
                        for (var mk = this["morphAttributes"][mf], mU = [], mq = 0x0, mw = mk["length"]; mq < mw; mq++) {
                            var mO;
                            (mA = (mO = mk[mq])["toJSON"]()), ("" !== mO["name"] && (mA["name"] = mO["name"]), mU["push"](mA));
                        }
                        mU["length"] > 0x0 && ((mM[mf] = mU), (mp = !0x0));
                    }
                    mp && ((mN["data"]["morphAttributes"] = mM), (mN["data"]["morphTargetsRelative"] = this["morphTargetsRelative"]));
                    var mj = this["groups"];
                    mj["length"] > 0x0 && (mN["data"]["groups"] = JSON["parse"](JSON["stringify"](mj)));
                    var mh = this["boundingSphere"];
                    return null !== mh && (mN["data"]["boundingSphere"] = { center: mh["center"]["toArray"](), radius: mh["radius"] }), mN;
                },
                clone: function () {
                    return new TR()["copy"](this);
                },
                copy: function (mN) {
                    var mX, mf, mP;
                    (this["index"] = null), (this["attributes"] = {}), (this["morphAttributes"] = {}), (this["groups"] = []), (this["boundingBox"] = null), (this["boundingSphere"] = null), (this["name"] = mN["name"]);
                    var mI = mN["index"];
                    null !== mI && this["setIndex"](mI["clone"]());
                    var mA = mN["attributes"];
                    for (mX in mA) {
                        var mM = mA[mX];
                        this["setAttribute"](mX, mM["clone"]());
                    }
                    var mp = mN["morphAttributes"];
                    for (mX in mp) {
                        var mk = [],
                            mU = mp[mX];
                        for (mf = 0x0, mP = mU["length"]; mf < mP; mf++) mk["push"](mU[mf]["clone"]());
                        this["morphAttributes"][mX] = mk;
                    }
                    this["morphTargetsRelative"] = mN["morphTargetsRelative"];
                    var mq = mN["groups"];
                    for (mf = 0x0, mP = mq["length"]; mf < mP; mf++) {
                        var mw = mq[mf];
                        this["addGroup"](mw["start"], mw["count"], mw["materialIndex"]);
                    }
                    var mO = mN["boundingBox"];
                    null !== mO && (this["boundingBox"] = mO["clone"]());
                    var mj = mN["boundingSphere"];
                    return null !== mj && (this["boundingSphere"] = mj["clone"]()), (this["drawRange"]["start"] = mN["drawRange"]["start"]), (this["drawRange"]["count"] = mN["drawRange"]["count"]), (this["userData"] = mN["userData"]), this;
                },
                dispose: function () {
                    this["dispatchEvent"]({ type: "dispose" });
                },
            });
            var TT = new Ey(),
                TC = new RY(),
                Td = new R7(),
                TY = new Ed(),
                TB = new Ed(),
                TF = new Ed(),
                Tb = new Ed(),
                TZ = new Ed(),
                Tm = new Ed(),
                Tv = new Ed(),
                Ty = new Ed(),
                TD = new Ed(),
                TN = new E3(),
                TX = new E3(),
                Tf = new E3(),
                TP = new Ed(),
                TI = new Ed();
            function TA(mN, mX) {
                Eg["call"](this), (this["type"] = "Mesh"), (this["geometry"] = void 0x0 !== mN ? mN : new TR()), (this["material"] = void 0x0 !== mX ? mX : new RW()), this["updateMorphTargets"]();
            }
            function TM(mN, mX, mf, mP, mI, mA, mM, mp) {
                if (null === (0x1 === mX["side"] ? mP["intersectTriangle"](mM, mA, mI, !0x0, mp) : mP["intersectTriangle"](mI, mA, mM, mX["side"] !== r6, mp))) return null;
                TI["copy"](mp), TI["applyMatrix4"](mN["matrixWorld"]);
                var mk = mf["ray"]["origin"]["distanceTo"](TI);
                return mk < mf["near"] || mk > mf["far"] ? null : { distance: mk, point: TI["clone"](), object: mN };
            }
            function Tp(mN, mX, mf, mP, mI, mA, mM, mp, mk, mU, mq, mw) {
                TY["fromBufferAttribute"](mI, mU), TB["fromBufferAttribute"](mI, mq), TF["fromBufferAttribute"](mI, mw);
                var mO = mN["morphTargetInfluences"];
                if (mX["morphTargets"] && mA && mO) {
                    Tv["set"](0x0, 0x0, 0x0), Ty["set"](0x0, 0x0, 0x0), TD["set"](0x0, 0x0, 0x0);
                    for (var mj = 0x0, mh = mA["length"]; mj < mh; mj++) {
                        var mS = mO[mj],
                            mg = mA[mj];
                        0x0 !== mS &&
                            (Tb["fromBufferAttribute"](mg, mU),
                            TZ["fromBufferAttribute"](mg, mq),
                            Tm["fromBufferAttribute"](mg, mw),
                            mM
                                ? (Tv["addScaledVector"](Tb, mS), Ty["addScaledVector"](TZ, mS), TD["addScaledVector"](Tm, mS))
                                : (Tv["addScaledVector"](Tb["sub"](TY), mS), Ty["addScaledVector"](TZ["sub"](TB), mS), TD["addScaledVector"](Tm["sub"](TF), mS)));
                    }
                    TY["add"](Tv), TB["add"](Ty), TF["add"](TD);
                }
                mN["isSkinnedMesh"] && (mN["boneTransform"](mU, TY), mN["boneTransform"](mq, TB), mN["boneTransform"](mw, TF));
                var mW = TM(mN, mX, mf, mP, TY, TB, TF, TP);
                if (mW) {
                    mp && (TN["fromBufferAttribute"](mp, mU), TX["fromBufferAttribute"](mp, mq), Tf["fromBufferAttribute"](mp, mw), (mW["uv"] = RM["getUV"](TP, TY, TB, TF, TN, TX, Tf, new E3()))),
                        mk && (TN["fromBufferAttribute"](mk, mU), TX["fromBufferAttribute"](mk, mq), Tf["fromBufferAttribute"](mk, mw), (mW["uv2"] = RM["getUV"](TP, TY, TB, TF, TN, TX, Tf, new E3())));
                    var mH = new Rh(mU, mq, mw);
                    RM["getNormal"](TY, TB, TF, mH["normal"]), (mW["face"] = mH);
                }
                return mW;
            }
            TA["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                constructor: TA,
                isMesh: !0x0,
                copy: function (mN) {
                    return (
                        Eg["prototype"]["copy"]["call"](this, mN),
                        void 0x0 !== mN["morphTargetInfluences"] && (this["morphTargetInfluences"] = mN["morphTargetInfluences"]["slice"]()),
                        void 0x0 !== mN["morphTargetDictionary"] && (this["morphTargetDictionary"] = Object["assign"]({}, mN["morphTargetDictionary"])),
                        this
                    );
                },
                updateMorphTargets: function () {
                    var mN,
                        mX,
                        mf,
                        mP = this["geometry"];
                    if (mP["isBufferGeometry"]) {
                        var mI = mP["morphAttributes"],
                            mA = Object["keys"](mI);
                        if (mA["length"] > 0x0) {
                            var mM = mI[mA[0x0]];
                            if (void 0x0 !== mM) {
                                for (this["morphTargetInfluences"] = [], this["morphTargetDictionary"] = {}, mN = 0x0, mX = mM["length"]; mN < mX; mN++)
                                    (mf = mM[mN]["name"] || String(mN)), this["morphTargetInfluences"]["push"](0x0), (this["morphTargetDictionary"][mf] = mN);
                            }
                        }
                    } else {
                        var mp = mP["morphTargets"];
                        void 0x0 !== mp && mp["length"] > 0x0 && console["error"]("THREE.Mesh.updateMorphTargets()\x20no\x20longer\x20supports\x20THREE.Geometry.\x20Use\x20THREE.BufferGeometry\x20instead.");
                    }
                },
                raycast: function (mN, mX) {
                    var mf,
                        mP = this["geometry"],
                        mI = this["material"],
                        mA = this["matrixWorld"];
                    if (
                        void 0x0 !== mI &&
                        (null === mP["boundingSphere"] && mP["computeBoundingSphere"](),
                        Td["copy"](mP["boundingSphere"]),
                        Td["applyMatrix4"](mA),
                        !0x1 !== mN["ray"]["intersectsSphere"](Td) && (TT["getInverse"](mA), TC["copy"](mN["ray"])["applyMatrix4"](TT), null === mP["boundingBox"] || !0x1 !== TC["intersectsBox"](mP["boundingBox"])))
                    ) {
                        if (mP["isBufferGeometry"]) {
                            var mM,
                                mp,
                                mk,
                                mU,
                                mq,
                                mw,
                                mO,
                                mj,
                                mh,
                                mS = mP["index"],
                                mg = mP["attributes"]["position"],
                                mW = mP["morphAttributes"]["position"],
                                mH = mP["morphTargetsRelative"],
                                mx = mP["attributes"]["uv"],
                                mK = mP["attributes"]["uv2"],
                                mV = mP["groups"],
                                mJ = mP["drawRange"];
                            if (null !== mS) {
                                if (Array["isArray"](mI)) {
                                    for (mU = 0x0, mw = mV["length"]; mU < mw; mU++)
                                        for (mh = mI[(mj = mV[mU])["materialIndex"]], mq = Math["max"](mj["start"], mJ["start"]), mO = Math["min"](mj["start"] + mj["count"], mJ["start"] + mJ["count"]); mq < mO; mq += 0x3)
                                            (mM = mS["getX"](mq)),
                                                (mp = mS["getX"](mq + 0x1)),
                                                (mk = mS["getX"](mq + 0x2)),
                                                (mf = Tp(this, mh, mN, TC, mg, mW, mH, mx, mK, mM, mp, mk)) && ((mf["faceIndex"] = Math["floor"](mq / 0x3)), (mf["face"]["materialIndex"] = mj["materialIndex"]), mX["push"](mf));
                                } else {
                                    for (mU = Math["max"](0x0, mJ["start"]), mw = Math["min"](mS["count"], mJ["start"] + mJ["count"]); mU < mw; mU += 0x3)
                                        (mM = mS["getX"](mU)),
                                            (mp = mS["getX"](mU + 0x1)),
                                            (mk = mS["getX"](mU + 0x2)),
                                            (mf = Tp(this, mI, mN, TC, mg, mW, mH, mx, mK, mM, mp, mk)) && ((mf["faceIndex"] = Math["floor"](mU / 0x3)), mX["push"](mf));
                                }
                            } else {
                                if (void 0x0 !== mg) {
                                    if (Array["isArray"](mI)) {
                                        for (mU = 0x0, mw = mV["length"]; mU < mw; mU++)
                                            for (mh = mI[(mj = mV[mU])["materialIndex"]], mq = Math["max"](mj["start"], mJ["start"]), mO = Math["min"](mj["start"] + mj["count"], mJ["start"] + mJ["count"]); mq < mO; mq += 0x3)
                                                (mf = Tp(this, mh, mN, TC, mg, mW, mH, mx, mK, (mM = mq), (mp = mq + 0x1), (mk = mq + 0x2))) &&
                                                    ((mf["faceIndex"] = Math["floor"](mq / 0x3)), (mf["face"]["materialIndex"] = mj["materialIndex"]), mX["push"](mf));
                                    } else {
                                        for (mU = Math["max"](0x0, mJ["start"]), mw = Math["min"](mg["count"], mJ["start"] + mJ["count"]); mU < mw; mU += 0x3)
                                            (mf = Tp(this, mI, mN, TC, mg, mW, mH, mx, mK, (mM = mU), (mp = mU + 0x1), (mk = mU + 0x2))) && ((mf["faceIndex"] = Math["floor"](mU / 0x3)), mX["push"](mf));
                                    }
                                }
                            }
                        } else {
                            if (mP["isGeometry"]) {
                                var mG,
                                    mL,
                                    mQ,
                                    mz,
                                    v0 = Array["isArray"](mI),
                                    v1 = mP["vertices"],
                                    v2 = mP["faces"],
                                    v3 = mP["faceVertexUvs"][0x0];
                                v3["length"] > 0x0 && (mz = v3);
                                for (var v4 = 0x0, v5 = v2["length"]; v4 < v5; v4++) {
                                    var v6 = v2[v4],
                                        v7 = v0 ? mI[v6["materialIndex"]] : mI;
                                    if (void 0x0 !== v7 && ((mG = v1[v6["a"]]), (mL = v1[v6["b"]]), (mQ = v1[v6["c"]]), (mf = TM(this, v7, mN, TC, mG, mL, mQ, TP)))) {
                                        if (mz && mz[v4]) {
                                            var v8 = mz[v4];
                                            TN["copy"](v8[0x0]), TX["copy"](v8[0x1]), Tf["copy"](v8[0x2]), (mf["uv"] = RM["getUV"](TP, mG, mL, mQ, TN, TX, Tf, new E3()));
                                        }
                                        (mf["face"] = v6), (mf["faceIndex"] = v4), mX["push"](mf);
                                    }
                                }
                            }
                        }
                    }
                },
                clone: function () {
                    return new this["constructor"](this["geometry"], this["material"])["copy"](this);
                },
            });
            var Tk = 0x0,
                TU = new Ey(),
                Tq = new Eg(),
                Tw = new Ed();
            function TO() {
                Object["defineProperty"](this, "id", { value: (Tk += 0x2) }),
                    (this["uuid"] = E2["generateUUID"]()),
                    (this["name"] = ""),
                    (this["type"] = "Geometry"),
                    (this["vertices"] = []),
                    (this["colors"] = []),
                    (this["faces"] = []),
                    (this["faceVertexUvs"] = [[]]),
                    (this["morphTargets"] = []),
                    (this["morphNormals"] = []),
                    (this["skinWeights"] = []),
                    (this["skinIndices"] = []),
                    (this["lineDistances"] = []),
                    (this["boundingBox"] = null),
                    (this["boundingSphere"] = null),
                    (this["elementsNeedUpdate"] = !0x1),
                    (this["verticesNeedUpdate"] = !0x1),
                    (this["uvsNeedUpdate"] = !0x1),
                    (this["normalsNeedUpdate"] = !0x1),
                    (this["colorsNeedUpdate"] = !0x1),
                    (this["lineDistancesNeedUpdate"] = !0x1),
                    (this["groupsNeedUpdate"] = !0x1);
            }
            TO["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                constructor: TO,
                isGeometry: !0x0,
                applyMatrix4: function (mN) {
                    for (var mX = new E4()["getNormalMatrix"](mN), mf = 0x0, mP = this["vertices"]["length"]; mf < mP; mf++) {
                        this["vertices"][mf]["applyMatrix4"](mN);
                    }
                    for (mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++) {
                        var mI = this["faces"][mf];
                        mI["normal"]["applyMatrix3"](mX)["normalize"]();
                        for (var mA = 0x0, mM = mI["vertexNormals"]["length"]; mA < mM; mA++) mI["vertexNormals"][mA]["applyMatrix3"](mX)["normalize"]();
                    }
                    return null !== this["boundingBox"] && this["computeBoundingBox"](), null !== this["boundingSphere"] && this["computeBoundingSphere"](), (this["verticesNeedUpdate"] = !0x0), (this["normalsNeedUpdate"] = !0x0), this;
                },
                rotateX: function (mN) {
                    return TU["makeRotationX"](mN), this["applyMatrix4"](TU), this;
                },
                rotateY: function (mN) {
                    return TU["makeRotationY"](mN), this["applyMatrix4"](TU), this;
                },
                rotateZ: function (mN) {
                    return TU["makeRotationZ"](mN), this["applyMatrix4"](TU), this;
                },
                translate: function (mN, mX, mf) {
                    return TU["makeTranslation"](mN, mX, mf), this["applyMatrix4"](TU), this;
                },
                scale: function (mN, mX, mf) {
                    return TU["makeScale"](mN, mX, mf), this["applyMatrix4"](TU), this;
                },
                lookAt: function (mN) {
                    return Tq["lookAt"](mN), Tq["updateMatrix"](), this["applyMatrix4"](Tq["matrix"]), this;
                },
                fromBufferGeometry: function (mN) {
                    var mX = this,
                        mf = null !== mN["index"] ? mN["index"]["array"] : void 0x0,
                        mP = mN["attributes"];
                    if (void 0x0 === mP["position"]) return console["error"]("THREE.Geometry.fromBufferGeometry():\x20Position\x20attribute\x20required\x20for\x20conversion."), this;
                    var mI = mP["position"]["array"],
                        mA = void 0x0 !== mP["normal"] ? mP["normal"]["array"] : void 0x0,
                        mM = void 0x0 !== mP["color"] ? mP["color"]["array"] : void 0x0,
                        mp = void 0x0 !== mP["uv"] ? mP["uv"]["array"] : void 0x0,
                        mk = void 0x0 !== mP["uv2"] ? mP["uv2"]["array"] : void 0x0;
                    void 0x0 !== mk && (this["faceVertexUvs"][0x1] = []);
                    for (var mU = 0x0; mU < mI["length"]; mU += 0x3) mX["vertices"]["push"](new Ed()["fromArray"](mI, mU)), void 0x0 !== mM && mX["colors"]["push"](new Rq()["fromArray"](mM, mU));
                    function mq(mg, mW, mH, mx) {
                        var mK = void 0x0 === mM ? [] : [mX["colors"][mg]["clone"](), mX["colors"][mW]["clone"](), mX["colors"][mH]["clone"]()],
                            mV = new Rh(mg, mW, mH, void 0x0 === mA ? [] : [new Ed()["fromArray"](mA, 0x3 * mg), new Ed()["fromArray"](mA, 0x3 * mW), new Ed()["fromArray"](mA, 0x3 * mH)], mK, mx);
                        mX["faces"]["push"](mV),
                            void 0x0 !== mp && mX["faceVertexUvs"][0x0]["push"]([new E3()["fromArray"](mp, 0x2 * mg), new E3()["fromArray"](mp, 0x2 * mW), new E3()["fromArray"](mp, 0x2 * mH)]),
                            void 0x0 !== mk && mX["faceVertexUvs"][0x1]["push"]([new E3()["fromArray"](mk, 0x2 * mg), new E3()["fromArray"](mk, 0x2 * mW), new E3()["fromArray"](mk, 0x2 * mH)]);
                    }
                    var mw = mN["groups"];
                    if (mw["length"] > 0x0) {
                        for (mU = 0x0; mU < mw["length"]; mU++)
                            for (var mO = mw[mU], mj = mO["start"], mh = mj, mS = mj + mO["count"]; mh < mS; mh += 0x3)
                                void 0x0 !== mf ? mq(mf[mh], mf[mh + 0x1], mf[mh + 0x2], mO["materialIndex"]) : mq(mh, mh + 0x1, mh + 0x2, mO["materialIndex"]);
                    } else {
                        if (void 0x0 !== mf) {
                            for (mU = 0x0; mU < mf["length"]; mU += 0x3) mq(mf[mU], mf[mU + 0x1], mf[mU + 0x2]);
                        } else {
                            for (mU = 0x0; mU < mI["length"] / 0x3; mU += 0x3) mq(mU, mU + 0x1, mU + 0x2);
                        }
                    }
                    return this["computeFaceNormals"](), null !== mN["boundingBox"] && (this["boundingBox"] = mN["boundingBox"]["clone"]()), null !== mN["boundingSphere"] && (this["boundingSphere"] = mN["boundingSphere"]["clone"]()), this;
                },
                center: function () {
                    return this["computeBoundingBox"](), this["boundingBox"]["getCenter"](Tw)["negate"](), this["translate"](Tw["x"], Tw["y"], Tw["z"]), this;
                },
                normalize: function () {
                    this["computeBoundingSphere"]();
                    var mN = this["boundingSphere"]["center"],
                        mX = this["boundingSphere"]["radius"],
                        mf = 0x0 === mX ? 0x1 : 0x1 / mX,
                        mP = new Ey();
                    return mP["set"](mf, 0x0, 0x0, -mf * mN["x"], 0x0, mf, 0x0, -mf * mN["y"], 0x0, 0x0, mf, -mf * mN["z"], 0x0, 0x0, 0x0, 0x1), this["applyMatrix4"](mP), this;
                },
                computeFaceNormals: function () {
                    for (var mN = new Ed(), mX = new Ed(), mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++) {
                        var mI = this["faces"][mf],
                            mA = this["vertices"][mI["a"]],
                            mM = this["vertices"][mI["b"]],
                            mp = this["vertices"][mI["c"]];
                        mN["subVectors"](mp, mM), mX["subVectors"](mA, mM), mN["cross"](mX), mN["normalize"](), mI["normal"]["copy"](mN);
                    }
                },
                computeVertexNormals: function (mN) {
                    var mX, mf, mP, mI, mA, mM;
                    for (void 0x0 === mN && (mN = !0x0), mM = new Array(this["vertices"]["length"]), mX = 0x0, mf = this["vertices"]["length"]; mX < mf; mX++) mM[mX] = new Ed();
                    if (mN) {
                        var mp,
                            mk,
                            mU,
                            mq = new Ed(),
                            mw = new Ed();
                        for (mP = 0x0, mI = this["faces"]["length"]; mP < mI; mP++)
                            (mA = this["faces"][mP]),
                                (mp = this["vertices"][mA["a"]]),
                                (mk = this["vertices"][mA["b"]]),
                                (mU = this["vertices"][mA["c"]]),
                                mq["subVectors"](mU, mk),
                                mw["subVectors"](mp, mk),
                                mq["cross"](mw),
                                mM[mA["a"]]["add"](mq),
                                mM[mA["b"]]["add"](mq),
                                mM[mA["c"]]["add"](mq);
                    } else {
                        for (this["computeFaceNormals"](), mP = 0x0, mI = this["faces"]["length"]; mP < mI; mP++) mM[(mA = this["faces"][mP])["a"]]["add"](mA["normal"]), mM[mA["b"]]["add"](mA["normal"]), mM[mA["c"]]["add"](mA["normal"]);
                    }
                    for (mX = 0x0, mf = this["vertices"]["length"]; mX < mf; mX++) mM[mX]["normalize"]();
                    for (mP = 0x0, mI = this["faces"]["length"]; mP < mI; mP++) {
                        var mO = (mA = this["faces"][mP])["vertexNormals"];
                        0x3 === mO["length"]
                            ? (mO[0x0]["copy"](mM[mA["a"]]), mO[0x1]["copy"](mM[mA["b"]]), mO[0x2]["copy"](mM[mA["c"]]))
                            : ((mO[0x0] = mM[mA["a"]]["clone"]()), (mO[0x1] = mM[mA["b"]]["clone"]()), (mO[0x2] = mM[mA["c"]]["clone"]()));
                    }
                    this["faces"]["length"] > 0x0 && (this["normalsNeedUpdate"] = !0x0);
                },
                computeFlatVertexNormals: function () {
                    var mN, mX, mf;
                    for (this["computeFaceNormals"](), mN = 0x0, mX = this["faces"]["length"]; mN < mX; mN++) {
                        var mP = (mf = this["faces"][mN])["vertexNormals"];
                        0x3 === mP["length"]
                            ? (mP[0x0]["copy"](mf["normal"]), mP[0x1]["copy"](mf["normal"]), mP[0x2]["copy"](mf["normal"]))
                            : ((mP[0x0] = mf["normal"]["clone"]()), (mP[0x1] = mf["normal"]["clone"]()), (mP[0x2] = mf["normal"]["clone"]()));
                    }
                    this["faces"]["length"] > 0x0 && (this["normalsNeedUpdate"] = !0x0);
                },
                computeMorphNormals: function () {
                    var mN, mX, mf, mP, mI;
                    for (mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++)
                        for (
                            (mI = this["faces"][mf])["__originalFaceNormal"] ? mI["__originalFaceNormal"]["copy"](mI["normal"]) : (mI["__originalFaceNormal"] = mI["normal"]["clone"]()),
                                mI["__originalVertexNormals"] || (mI["__originalVertexNormals"] = []),
                                mN = 0x0,
                                mX = mI["vertexNormals"]["length"];
                            mN < mX;
                            mN++
                        )
                            mI["__originalVertexNormals"][mN] ? mI["__originalVertexNormals"][mN]["copy"](mI["vertexNormals"][mN]) : (mI["__originalVertexNormals"][mN] = mI["vertexNormals"][mN]["clone"]());
                    var mA = new TO();
                    for (mA["faces"] = this["faces"], mN = 0x0, mX = this["morphTargets"]["length"]; mN < mX; mN++) {
                        if (!this["morphNormals"][mN]) {
                            (this["morphNormals"][mN] = {}), (this["morphNormals"][mN]["faceNormals"] = []), (this["morphNormals"][mN]["vertexNormals"] = []);
                            var mM = this["morphNormals"][mN]["faceNormals"],
                                mp = this["morphNormals"][mN]["vertexNormals"];
                            for (mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++) (mk = new Ed()), (mU = { a: new Ed(), b: new Ed(), c: new Ed() }), mM["push"](mk), mp["push"](mU);
                        }
                        var mk,
                            mU,
                            mq = this["morphNormals"][mN];
                        for (mA["vertices"] = this["morphTargets"][mN]["vertices"], mA["computeFaceNormals"](), mA["computeVertexNormals"](), mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++)
                            (mI = this["faces"][mf]),
                                (mk = mq["faceNormals"][mf]),
                                (mU = mq["vertexNormals"][mf]),
                                mk["copy"](mI["normal"]),
                                mU["a"]["copy"](mI["vertexNormals"][0x0]),
                                mU["b"]["copy"](mI["vertexNormals"][0x1]),
                                mU["c"]["copy"](mI["vertexNormals"][0x2]);
                    }
                    for (mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++) ((mI = this["faces"][mf])["normal"] = mI["__originalFaceNormal"]), (mI["vertexNormals"] = mI["__originalVertexNormals"]);
                },
                computeBoundingBox: function () {
                    null === this["boundingBox"] && (this["boundingBox"] = new R4()), this["boundingBox"]["setFromPoints"](this["vertices"]);
                },
                computeBoundingSphere: function () {
                    null === this["boundingSphere"] && (this["boundingSphere"] = new R7()), this["boundingSphere"]["setFromPoints"](this["vertices"]);
                },
                merge: function (mN, mX, mf) {
                    if (mN && mN["isGeometry"]) {
                        var mP,
                            mI = this["vertices"]["length"],
                            mA = this["vertices"],
                            mM = mN["vertices"],
                            mp = this["faces"],
                            mk = mN["faces"],
                            mU = this["colors"],
                            mq = mN["colors"];
                        void 0x0 === mf && (mf = 0x0), void 0x0 !== mX && (mP = new E4()["getNormalMatrix"](mX));
                        for (var mw = 0x0, mO = mM["length"]; mw < mO; mw++) {
                            var mj = mM[mw]["clone"]();
                            void 0x0 !== mX && mj["applyMatrix4"](mX), mA["push"](mj);
                        }
                        for (mw = 0x0, mO = mq["length"]; mw < mO; mw++) mU["push"](mq[mw]["clone"]());
                        for (mw = 0x0, mO = mk["length"]; mw < mO; mw++) {
                            var mh,
                                mS,
                                mg,
                                mW = mk[mw],
                                mH = mW["vertexNormals"],
                                mx = mW["vertexColors"];
                            (mh = new Rh(mW["a"] + mI, mW["b"] + mI, mW["c"] + mI))["normal"]["copy"](mW["normal"]), void 0x0 !== mP && mh["normal"]["applyMatrix3"](mP)["normalize"]();
                            for (var mK = 0x0, mV = mH["length"]; mK < mV; mK++) (mS = mH[mK]["clone"]()), void 0x0 !== mP && mS["applyMatrix3"](mP)["normalize"](), mh["vertexNormals"]["push"](mS);
                            mh["color"]["copy"](mW["color"]);
                            for (mK = 0x0, mV = mx["length"]; mK < mV; mK++) (mg = mx[mK]), mh["vertexColors"]["push"](mg["clone"]());
                            (mh["materialIndex"] = mW["materialIndex"] + mf), mp["push"](mh);
                        }
                        for (mw = 0x0, mO = mN["faceVertexUvs"]["length"]; mw < mO; mw++) {
                            var mJ = mN["faceVertexUvs"][mw];
                            void 0x0 === this["faceVertexUvs"][mw] && (this["faceVertexUvs"][mw] = []);
                            for (mK = 0x0, mV = mJ["length"]; mK < mV; mK++) {
                                for (var mG = mJ[mK], mL = [], mQ = 0x0, mz = mG["length"]; mQ < mz; mQ++) mL["push"](mG[mQ]["clone"]());
                                this["faceVertexUvs"][mw]["push"](mL);
                            }
                        }
                    } else console["error"]("THREE.Geometry.merge():\x20geometry\x20not\x20an\x20instance\x20of\x20THREE.Geometry.", mN);
                },
                mergeMesh: function (mN) {
                    mN && mN["isMesh"]
                        ? (mN["matrixAutoUpdate"] && mN["updateMatrix"](), this["merge"](mN["geometry"], mN["matrix"]))
                        : console["error"]("THREE.Geometry.mergeMesh():\x20mesh\x20not\x20an\x20instance\x20of\x20THREE.Mesh.", mN);
                },
                mergeVertices: function () {
                    var mN,
                        mX,
                        mf,
                        mP,
                        mI,
                        mA,
                        mM,
                        mp,
                        mk = {},
                        mU = [],
                        mq = [],
                        mw = Math["pow"](0xa, 0x4);
                    for (mf = 0x0, mP = this["vertices"]["length"]; mf < mP; mf++)
                        (mN = this["vertices"][mf]),
                            void 0x0 === mk[(mX = Math["round"](mN["x"] * mw) + "_" + Math["round"](mN["y"] * mw) + "_" + Math["round"](mN["z"] * mw))]
                                ? ((mk[mX] = mf), mU["push"](this["vertices"][mf]), (mq[mf] = mU["length"] - 0x1))
                                : (mq[mf] = mq[mk[mX]]);
                    var mO = [];
                    for (mf = 0x0, mP = this["faces"]["length"]; mf < mP; mf++) {
                        ((mI = this["faces"][mf])["a"] = mq[mI["a"]]), (mI["b"] = mq[mI["b"]]), (mI["c"] = mq[mI["c"]]), (mA = [mI["a"], mI["b"], mI["c"]]);
                        for (var mj = 0x0; mj < 0x3; mj++)
                            if (mA[mj] === mA[(mj + 0x1) % 0x3]) {
                                mO["push"](mf);
                                break;
                            }
                    }
                    for (mf = mO["length"] - 0x1; mf >= 0x0; mf--) {
                        var mh = mO[mf];
                        for (this["faces"]["splice"](mh, 0x1), mM = 0x0, mp = this["faceVertexUvs"]["length"]; mM < mp; mM++) this["faceVertexUvs"][mM]["splice"](mh, 0x1);
                    }
                    var mS = this["vertices"]["length"] - mU["length"];
                    return (this["vertices"] = mU), mS;
                },
                setFromPoints: function (mN) {
                    this["vertices"] = [];
                    for (var mX = 0x0, mf = mN["length"]; mX < mf; mX++) {
                        var mP = mN[mX];
                        this["vertices"]["push"](new Ed(mP["x"], mP["y"], mP["z"] || 0x0));
                    }
                    return this;
                },
                sortFacesByMaterialIndex: function () {
                    for (var mN = this["faces"], mX = mN["length"], mf = 0x0; mf < mX; mf++) mN[mf]["_id"] = mf;
                    mN["sort"](function (mk, mU) {
                        return mk["materialIndex"] - mU["materialIndex"];
                    });
                    var mP,
                        mI,
                        mA = this["faceVertexUvs"][0x0],
                        mM = this["faceVertexUvs"][0x1];
                    mA && mA["length"] === mX && (mP = []), mM && mM["length"] === mX && (mI = []);
                    for (mf = 0x0; mf < mX; mf++) {
                        var mp = mN[mf]["_id"];
                        mP && mP["push"](mA[mp]), mI && mI["push"](mM[mp]);
                    }
                    mP && (this["faceVertexUvs"][0x0] = mP), mI && (this["faceVertexUvs"][0x1] = mI);
                },
                toJSON: function () {
                    var mN = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
                    if (((mN["uuid"] = this["uuid"]), (mN["type"] = this["type"]), "" !== this["name"] && (mN["name"] = this["name"]), void 0x0 !== this["parameters"])) {
                        var mX = this["parameters"];
                        for (var mf in mX) void 0x0 !== mX[mf] && (mN[mf] = mX[mf]);
                        return mN;
                    }
                    for (var mP = [], mI = 0x0; mI < this["vertices"]["length"]; mI++) {
                        var mA = this["vertices"][mI];
                        mP["push"](mA["x"], mA["y"], mA["z"]);
                    }
                    var mM = [],
                        mp = [],
                        mk = {},
                        mU = [],
                        mq = {},
                        mw = [],
                        mO = {};
                    for (mI = 0x0; mI < this["faces"]["length"]; mI++) {
                        var mj = this["faces"][mI],
                            mh = void 0x0 !== this["faceVertexUvs"][0x0][mI],
                            mS = mj["normal"]["length"]() > 0x0,
                            mg = mj["vertexNormals"]["length"] > 0x0,
                            mW = 0x1 !== mj["color"]["r"] || 0x1 !== mj["color"]["g"] || 0x1 !== mj["color"]["b"],
                            mH = mj["vertexColors"]["length"] > 0x0,
                            mx = 0x0;
                        if (
                            ((mx = mG(mx, 0x0, 0x0)),
                            (mx = mG(mx, 0x1, !0x0)),
                            (mx = mG(mx, 0x2, !0x1)),
                            (mx = mG(mx, 0x3, mh)),
                            (mx = mG(mx, 0x4, mS)),
                            (mx = mG(mx, 0x5, mg)),
                            (mx = mG(mx, 0x6, mW)),
                            (mx = mG(mx, 0x7, mH)),
                            mM["push"](mx),
                            mM["push"](mj["a"], mj["b"], mj["c"]),
                            mM["push"](mj["materialIndex"]),
                            mh)
                        ) {
                            var mK = this["faceVertexUvs"][0x0][mI];
                            mM["push"](mz(mK[0x0]), mz(mK[0x1]), mz(mK[0x2]));
                        }
                        if ((mS && mM["push"](mL(mj["normal"])), mg)) {
                            var mV = mj["vertexNormals"];
                            mM["push"](mL(mV[0x0]), mL(mV[0x1]), mL(mV[0x2]));
                        }
                        if ((mW && mM["push"](mQ(mj["color"])), mH)) {
                            var mJ = mj["vertexColors"];
                            mM["push"](mQ(mJ[0x0]), mQ(mJ[0x1]), mQ(mJ[0x2]));
                        }
                    }
                    function mG(v0, v1, v2) {
                        return v2 ? v0 | (0x1 << v1) : v0 & ~(0x1 << v1);
                    }
                    function mL(v0) {
                        var v1 = v0["x"]["toString"]() + v0["y"]["toString"]() + v0["z"]["toString"]();
                        return void 0x0 !== mk[v1] || ((mk[v1] = mp["length"] / 0x3), mp["push"](v0["x"], v0["y"], v0["z"])), mk[v1];
                    }
                    function mQ(v0) {
                        var v1 = v0["r"]["toString"]() + v0["g"]["toString"]() + v0["b"]["toString"]();
                        return void 0x0 !== mq[v1] || ((mq[v1] = mU["length"]), mU["push"](v0["getHex"]())), mq[v1];
                    }
                    function mz(v0) {
                        var v1 = v0["x"]["toString"]() + v0["y"]["toString"]();
                        return void 0x0 !== mO[v1] || ((mO[v1] = mw["length"] / 0x2), mw["push"](v0["x"], v0["y"])), mO[v1];
                    }
                    return (mN["data"] = {}), (mN["data"]["vertices"] = mP), (mN["data"]["normals"] = mp), mU["length"] > 0x0 && (mN["data"]["colors"] = mU), mw["length"] > 0x0 && (mN["data"]["uvs"] = [mw]), (mN["data"]["faces"] = mM), mN;
                },
                clone: function () {
                    return new TO()["copy"](this);
                },
                copy: function (mN) {
                    var mX, mf, mP, mI, mA, mM;
                    (this["vertices"] = []),
                        (this["colors"] = []),
                        (this["faces"] = []),
                        (this["faceVertexUvs"] = [[]]),
                        (this["morphTargets"] = []),
                        (this["morphNormals"] = []),
                        (this["skinWeights"] = []),
                        (this["skinIndices"] = []),
                        (this["lineDistances"] = []),
                        (this["boundingBox"] = null),
                        (this["boundingSphere"] = null),
                        (this["name"] = mN["name"]);
                    var mp = mN["vertices"];
                    for (mX = 0x0, mf = mp["length"]; mX < mf; mX++) this["vertices"]["push"](mp[mX]["clone"]());
                    var mk = mN["colors"];
                    for (mX = 0x0, mf = mk["length"]; mX < mf; mX++) this["colors"]["push"](mk[mX]["clone"]());
                    var mU = mN["faces"];
                    for (mX = 0x0, mf = mU["length"]; mX < mf; mX++) this["faces"]["push"](mU[mX]["clone"]());
                    for (mX = 0x0, mf = mN["faceVertexUvs"]["length"]; mX < mf; mX++) {
                        var mq = mN["faceVertexUvs"][mX];
                        for (void 0x0 === this["faceVertexUvs"][mX] && (this["faceVertexUvs"][mX] = []), mP = 0x0, mI = mq["length"]; mP < mI; mP++) {
                            var mw = mq[mP],
                                mO = [];
                            for (mA = 0x0, mM = mw["length"]; mA < mM; mA++) {
                                var mj = mw[mA];
                                mO["push"](mj["clone"]());
                            }
                            this["faceVertexUvs"][mX]["push"](mO);
                        }
                    }
                    var mh = mN["morphTargets"];
                    for (mX = 0x0, mf = mh["length"]; mX < mf; mX++) {
                        var mS = {};
                        if (((mS["name"] = mh[mX]["name"]), void 0x0 !== mh[mX]["vertices"])) {
                            for (mS["vertices"] = [], mP = 0x0, mI = mh[mX]["vertices"]["length"]; mP < mI; mP++) mS["vertices"]["push"](mh[mX]["vertices"][mP]["clone"]());
                        }
                        if (void 0x0 !== mh[mX]["normals"]) {
                            for (mS["normals"] = [], mP = 0x0, mI = mh[mX]["normals"]["length"]; mP < mI; mP++) mS["normals"]["push"](mh[mX]["normals"][mP]["clone"]());
                        }
                        this["morphTargets"]["push"](mS);
                    }
                    var mg = mN["morphNormals"];
                    for (mX = 0x0, mf = mg["length"]; mX < mf; mX++) {
                        var mW = {};
                        if (void 0x0 !== mg[mX]["vertexNormals"])
                            for (mW["vertexNormals"] = [], mP = 0x0, mI = mg[mX]["vertexNormals"]["length"]; mP < mI; mP++) {
                                var mH = mg[mX]["vertexNormals"][mP],
                                    mx = {};
                                (mx["a"] = mH["a"]["clone"]()), (mx["b"] = mH["b"]["clone"]()), (mx["c"] = mH["c"]["clone"]()), mW["vertexNormals"]["push"](mx);
                            }
                        if (void 0x0 !== mg[mX]["faceNormals"]) {
                            for (mW["faceNormals"] = [], mP = 0x0, mI = mg[mX]["faceNormals"]["length"]; mP < mI; mP++) mW["faceNormals"]["push"](mg[mX]["faceNormals"][mP]["clone"]());
                        }
                        this["morphNormals"]["push"](mW);
                    }
                    var mK = mN["skinWeights"];
                    for (mX = 0x0, mf = mK["length"]; mX < mf; mX++) this["skinWeights"]["push"](mK[mX]["clone"]());
                    var mV = mN["skinIndices"];
                    for (mX = 0x0, mf = mV["length"]; mX < mf; mX++) this["skinIndices"]["push"](mV[mX]["clone"]());
                    var mJ = mN["lineDistances"];
                    for (mX = 0x0, mf = mJ["length"]; mX < mf; mX++) this["lineDistances"]["push"](mJ[mX]);
                    var mG = mN["boundingBox"];
                    null !== mG && (this["boundingBox"] = mG["clone"]());
                    var mL = mN["boundingSphere"];
                    return (
                        null !== mL && (this["boundingSphere"] = mL["clone"]()),
                        (this["elementsNeedUpdate"] = mN["elementsNeedUpdate"]),
                        (this["verticesNeedUpdate"] = mN["verticesNeedUpdate"]),
                        (this["uvsNeedUpdate"] = mN["uvsNeedUpdate"]),
                        (this["normalsNeedUpdate"] = mN["normalsNeedUpdate"]),
                        (this["colorsNeedUpdate"] = mN["colorsNeedUpdate"]),
                        (this["lineDistancesNeedUpdate"] = mN["lineDistancesNeedUpdate"]),
                        (this["groupsNeedUpdate"] = mN["groupsNeedUpdate"]),
                        this
                    );
                },
                dispose: function () {
                    this["dispatchEvent"]({ type: "dispose" });
                },
            });
            class Tj extends TR {
                constructor(mN, mX, mf, mP, mI, mA) {
                    super(), (this["type"] = "BoxBufferGeometry"), (this["parameters"] = { width: mN, height: mX, depth: mf, widthSegments: mP, heightSegments: mI, depthSegments: mA });
                    const mM = this;
                    (mN = mN || 0x1), (mX = mX || 0x1), (mf = mf || 0x1), (mP = Math["floor"](mP) || 0x1), (mI = Math["floor"](mI) || 0x1), (mA = Math["floor"](mA) || 0x1);
                    const mp = [],
                        mk = [],
                        mU = [],
                        mq = [];
                    let mw = 0x0,
                        mO = 0x0;
                    function mj(mh, mS, mg, mW, mH, mx, mK, mV, mJ, mG, mL) {
                        const mQ = mx / mJ,
                            mz = mK / mG,
                            v0 = mx / 0x2,
                            v1 = mK / 0x2,
                            v2 = mV / 0x2,
                            v3 = mJ + 0x1,
                            v4 = mG + 0x1;
                        let v5 = 0x0,
                            v6 = 0x0;
                        const v7 = new Ed();
                        for (let v8 = 0x0; v8 < v4; v8++) {
                            const v9 = v8 * mz - v1;
                            for (let vE = 0x0; vE < v3; vE++) {
                                const vR = vE * mQ - v0;
                                (v7[mh] = vR * mW),
                                    (v7[mS] = v9 * mH),
                                    (v7[mg] = v2),
                                    mk["push"](v7["x"], v7["y"], v7["z"]),
                                    (v7[mh] = 0x0),
                                    (v7[mS] = 0x0),
                                    (v7[mg] = mV > 0x0 ? 0x1 : -0x1),
                                    mU["push"](v7["x"], v7["y"], v7["z"]),
                                    mq["push"](vE / mJ),
                                    mq["push"](0x1 - v8 / mG),
                                    (v5 += 0x1);
                            }
                        }
                        for (let vT = 0x0; vT < mG; vT++)
                            for (let vC = 0x0; vC < mJ; vC++) {
                                const vd = mw + vC + v3 * vT,
                                    vY = mw + vC + v3 * (vT + 0x1),
                                    vB = mw + (vC + 0x1) + v3 * (vT + 0x1),
                                    vF = mw + (vC + 0x1) + v3 * vT;
                                mp["push"](vd, vY, vF), mp["push"](vY, vB, vF), (v6 += 0x6);
                            }
                        mM["addGroup"](mO, v6, mL), (mO += v6), (mw += v5);
                    }
                    mj("z", "y", "x", -0x1, -0x1, mf, mX, mN, mA, mI, 0x0),
                        mj("z", "y", "x", 0x1, -0x1, mf, mX, -mN, mA, mI, 0x1),
                        mj("x", "z", "y", 0x1, 0x1, mN, mf, mX, mP, mA, 0x2),
                        mj("x", "z", "y", 0x1, -0x1, mN, mf, -mX, mP, mA, 0x3),
                        mj("x", "y", "z", 0x1, -0x1, mN, mX, mf, mP, mI, 0x4),
                        mj("x", "y", "z", -0x1, -0x1, mN, mX, -mf, mP, mI, 0x5),
                        this["setIndex"](mp),
                        this["setAttribute"]("position", new T0(mk, 0x3)),
                        this["setAttribute"]("normal", new T0(mU, 0x3)),
                        this["setAttribute"]("uv", new T0(mq, 0x2));
                }
            }
            function Th(mN) {
                var mX = {};
                for (var mf in mN)
                    for (var mP in ((mX[mf] = {}), mN[mf])) {
                        var mI = mN[mf][mP];
                        mI && (mI["isColor"] || mI["isMatrix3"] || mI["isMatrix4"] || mI["isVector2"] || mI["isVector3"] || mI["isVector4"] || mI["isTexture"])
                            ? (mX[mf][mP] = mI["clone"]())
                            : Array["isArray"](mI)
                            ? (mX[mf][mP] = mI["slice"]())
                            : (mX[mf][mP] = mI);
                    }
                return mX;
            }
            function TS(mN) {
                for (var mX = {}, mf = 0x0; mf < mN["length"]; mf++) {
                    var mP = Th(mN[mf]);
                    for (var mI in mP) mX[mI] = mP[mI];
                }
                return mX;
            }
            var Tg = { clone: Th, merge: TS };
            function TW(mN) {
                Rg["call"](this),
                    (this["type"] = "ShaderMaterial"),
                    (this["defines"] = {}),
                    (this["uniforms"] = {}),
                    (this["vertexShader"] = "void\x20main()\x20{\x0a\x09gl_Position\x20=\x20projectionMatrix\x20*\x20modelViewMatrix\x20*\x20vec4(\x20position,\x201.0\x20);\x0a}"),
                    (this["fragmentShader"] = "void\x20main()\x20{\x0a\x09gl_FragColor\x20=\x20vec4(\x201.0,\x200.0,\x200.0,\x201.0\x20);\x0a}"),
                    (this["linewidth"] = 0x1),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["fog"] = !0x1),
                    (this["lights"] = !0x1),
                    (this["clipping"] = !0x1),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    (this["extensions"] = { derivatives: !0x1, fragDepth: !0x1, drawBuffers: !0x1, shaderTextureLOD: !0x1 }),
                    (this["defaultAttributeValues"] = { color: [0x1, 0x1, 0x1], uv: [0x0, 0x0], uv2: [0x0, 0x0] }),
                    (this["index0AttributeName"] = void 0x0),
                    (this["uniformsNeedUpdate"] = !0x1),
                    void 0x0 !== mN && (void 0x0 !== mN["attributes"] && console["error"]("THREE.ShaderMaterial:\x20attributes\x20should\x20now\x20be\x20defined\x20in\x20THREE.BufferGeometry\x20instead."), this["setValues"](mN));
            }
            function TH() {
                Eg["call"](this), (this["type"] = "Camera"), (this["matrixWorldInverse"] = new Ey()), (this["projectionMatrix"] = new Ey()), (this["projectionMatrixInverse"] = new Ey());
            }
            function Tx(mN, mX, mf, mP) {
                TH["call"](this),
                    (this["type"] = "PerspectiveCamera"),
                    (this["fov"] = void 0x0 !== mN ? mN : 0x32),
                    (this["zoom"] = 0x1),
                    (this["near"] = void 0x0 !== mf ? mf : 0.1),
                    (this["far"] = void 0x0 !== mP ? mP : 0x7d0),
                    (this["focus"] = 0xa),
                    (this["aspect"] = void 0x0 !== mX ? mX : 0x1),
                    (this["view"] = null),
                    (this["filmGauge"] = 0x23),
                    (this["filmOffset"] = 0x0),
                    this["updateProjectionMatrix"]();
            }
            (TW["prototype"] = Object["create"](Rg["prototype"])),
                (TW["prototype"]["constructor"] = TW),
                (TW["prototype"]["isShaderMaterial"] = !0x0),
                (TW["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        (this["fragmentShader"] = mN["fragmentShader"]),
                        (this["vertexShader"] = mN["vertexShader"]),
                        (this["uniforms"] = Th(mN["uniforms"])),
                        (this["defines"] = Object["assign"]({}, mN["defines"])),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["lights"] = mN["lights"]),
                        (this["clipping"] = mN["clipping"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        (this["extensions"] = Object["assign"]({}, mN["extensions"])),
                        this
                    );
                }),
                (TW["prototype"]["toJSON"] = function (mN) {
                    var mX = Rg["prototype"]["toJSON"]["call"](this, mN);
                    for (var mf in ((mX["uniforms"] = {}), this["uniforms"])) {
                        var mP = this["uniforms"][mf]["value"];
                        mP && mP["isTexture"]
                            ? (mX["uniforms"][mf] = { type: "t", value: mP["toJSON"](mN)["uuid"] })
                            : mP && mP["isColor"]
                            ? (mX["uniforms"][mf] = { type: "c", value: mP["getHex"]() })
                            : mP && mP["isVector2"]
                            ? (mX["uniforms"][mf] = { type: "v2", value: mP["toArray"]() })
                            : mP && mP["isVector3"]
                            ? (mX["uniforms"][mf] = { type: "v3", value: mP["toArray"]() })
                            : mP && mP["isVector4"]
                            ? (mX["uniforms"][mf] = { type: "v4", value: mP["toArray"]() })
                            : mP && mP["isMatrix3"]
                            ? (mX["uniforms"][mf] = { type: "m3", value: mP["toArray"]() })
                            : mP && mP["isMatrix4"]
                            ? (mX["uniforms"][mf] = { type: "m4", value: mP["toArray"]() })
                            : (mX["uniforms"][mf] = { value: mP });
                    }
                    Object["keys"](this["defines"])["length"] > 0x0 && (mX["defines"] = this["defines"]), (mX["vertexShader"] = this["vertexShader"]), (mX["fragmentShader"] = this["fragmentShader"]);
                    var mI = {};
                    for (var mA in this["extensions"]) !0x0 === this["extensions"][mA] && (mI[mA] = !0x0);
                    return Object["keys"](mI)["length"] > 0x0 && (mX["extensions"] = mI), mX;
                }),
                (TH["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                    constructor: TH,
                    isCamera: !0x0,
                    copy: function (mN, mX) {
                        return (
                            Eg["prototype"]["copy"]["call"](this, mN, mX),
                            this["matrixWorldInverse"]["copy"](mN["matrixWorldInverse"]),
                            this["projectionMatrix"]["copy"](mN["projectionMatrix"]),
                            this["projectionMatrixInverse"]["copy"](mN["projectionMatrixInverse"]),
                            this
                        );
                    },
                    getWorldDirection: function (mN) {
                        void 0x0 === mN && (console["warn"]("THREE.Camera:\x20.getWorldDirection()\x20target\x20is\x20now\x20required"), (mN = new Ed())), this["updateMatrixWorld"](!0x0);
                        var mX = this["matrixWorld"]["elements"];
                        return mN["set"](-mX[0x8], -mX[0x9], -mX[0xa])["normalize"]();
                    },
                    updateMatrixWorld: function (mN) {
                        Eg["prototype"]["updateMatrixWorld"]["call"](this, mN), this["matrixWorldInverse"]["getInverse"](this["matrixWorld"]);
                    },
                    updateWorldMatrix: function (mN, mX) {
                        Eg["prototype"]["updateWorldMatrix"]["call"](this, mN, mX), this["matrixWorldInverse"]["getInverse"](this["matrixWorld"]);
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                })),
                (Tx["prototype"] = Object["assign"](Object["create"](TH["prototype"]), {
                    constructor: Tx,
                    isPerspectiveCamera: !0x0,
                    copy: function (mN, mX) {
                        return (
                            TH["prototype"]["copy"]["call"](this, mN, mX),
                            (this["fov"] = mN["fov"]),
                            (this["zoom"] = mN["zoom"]),
                            (this["near"] = mN["near"]),
                            (this["far"] = mN["far"]),
                            (this["focus"] = mN["focus"]),
                            (this["aspect"] = mN["aspect"]),
                            (this["view"] = null === mN["view"] ? null : Object["assign"]({}, mN["view"])),
                            (this["filmGauge"] = mN["filmGauge"]),
                            (this["filmOffset"] = mN["filmOffset"]),
                            this
                        );
                    },
                    setFocalLength: function (mN) {
                        var mX = (0.5 * this["getFilmHeight"]()) / mN;
                        (this["fov"] = 0x2 * E2["RAD2DEG"] * Math["atan"](mX)), this["updateProjectionMatrix"]();
                    },
                    getFocalLength: function () {
                        var mN = Math["tan"](0.5 * E2["DEG2RAD"] * this["fov"]);
                        return (0.5 * this["getFilmHeight"]()) / mN;
                    },
                    getEffectiveFOV: function () {
                        return 0x2 * E2["RAD2DEG"] * Math["atan"](Math["tan"](0.5 * E2["DEG2RAD"] * this["fov"]) / this["zoom"]);
                    },
                    getFilmWidth: function () {
                        return this["filmGauge"] * Math["min"](this["aspect"], 0x1);
                    },
                    getFilmHeight: function () {
                        return this["filmGauge"] / Math["max"](this["aspect"], 0x1);
                    },
                    setViewOffset: function (mN, mX, mf, mP, mI, mA) {
                        (this["aspect"] = mN / mX),
                            null === this["view"] && (this["view"] = { enabled: !0x0, fullWidth: 0x1, fullHeight: 0x1, offsetX: 0x0, offsetY: 0x0, width: 0x1, height: 0x1 }),
                            (this["view"]["enabled"] = !0x0),
                            (this["view"]["fullWidth"] = mN),
                            (this["view"]["fullHeight"] = mX),
                            (this["view"]["offsetX"] = mf),
                            (this["view"]["offsetY"] = mP),
                            (this["view"]["width"] = mI),
                            (this["view"]["height"] = mA),
                            this["updateProjectionMatrix"]();
                    },
                    clearViewOffset: function () {
                        null !== this["view"] && (this["view"]["enabled"] = !0x1), this["updateProjectionMatrix"]();
                    },
                    updateProjectionMatrix: function () {
                        var mN = this["near"],
                            mX = (mN * Math["tan"](0.5 * E2["DEG2RAD"] * this["fov"])) / this["zoom"],
                            mf = 0x2 * mX,
                            mP = this["aspect"] * mf,
                            mI = -0.5 * mP,
                            mA = this["view"];
                        if (null !== this["view"] && this["view"]["enabled"]) {
                            var mM = mA["fullWidth"],
                                mp = mA["fullHeight"];
                            (mI += (mA["offsetX"] * mP) / mM), (mX -= (mA["offsetY"] * mf) / mp), (mP *= mA["width"] / mM), (mf *= mA["height"] / mp);
                        }
                        var mk = this["filmOffset"];
                        0x0 !== mk && (mI += (mN * mk) / this["getFilmWidth"]()),
                            this["projectionMatrix"]["makePerspective"](mI, mI + mP, mX, mX - mf, mN, this["far"]),
                            this["projectionMatrixInverse"]["getInverse"](this["projectionMatrix"]);
                    },
                    toJSON: function (mN) {
                        var mX = Eg["prototype"]["toJSON"]["call"](this, mN);
                        return (
                            (mX["object"]["fov"] = this["fov"]),
                            (mX["object"]["zoom"] = this["zoom"]),
                            (mX["object"]["near"] = this["near"]),
                            (mX["object"]["far"] = this["far"]),
                            (mX["object"]["focus"] = this["focus"]),
                            (mX["object"]["aspect"] = this["aspect"]),
                            null !== this["view"] && (mX["object"]["view"] = Object["assign"]({}, this["view"])),
                            (mX["object"]["filmGauge"] = this["filmGauge"]),
                            (mX["object"]["filmOffset"] = this["filmOffset"]),
                            mX
                        );
                    },
                }));
            var TK = 0x5a;
            function TV(mN, mX, mf) {
                if ((Eg["call"](this), (this["type"] = "CubeCamera"), !0x0 === mf["isWebGLCubeRenderTarget"])) {
                    this["renderTarget"] = mf;
                    var mP = new Tx(TK, 0x1, mN, mX);
                    (mP["layers"] = this["layers"]), mP["up"]["set"](0x0, -0x1, 0x0), mP["lookAt"](new Ed(0x1, 0x0, 0x0)), this["add"](mP);
                    var mI = new Tx(TK, 0x1, mN, mX);
                    (mI["layers"] = this["layers"]), mI["up"]["set"](0x0, -0x1, 0x0), mI["lookAt"](new Ed(-0x1, 0x0, 0x0)), this["add"](mI);
                    var mA = new Tx(TK, 0x1, mN, mX);
                    (mA["layers"] = this["layers"]), mA["up"]["set"](0x0, 0x0, 0x1), mA["lookAt"](new Ed(0x0, 0x1, 0x0)), this["add"](mA);
                    var mM = new Tx(TK, 0x1, mN, mX);
                    (mM["layers"] = this["layers"]), mM["up"]["set"](0x0, 0x0, -0x1), mM["lookAt"](new Ed(0x0, -0x1, 0x0)), this["add"](mM);
                    var mp = new Tx(TK, 0x1, mN, mX);
                    (mp["layers"] = this["layers"]), mp["up"]["set"](0x0, -0x1, 0x0), mp["lookAt"](new Ed(0x0, 0x0, 0x1)), this["add"](mp);
                    var mk = new Tx(TK, 0x1, mN, mX);
                    (mk["layers"] = this["layers"]),
                        mk["up"]["set"](0x0, -0x1, 0x0),
                        mk["lookAt"](new Ed(0x0, 0x0, -0x1)),
                        this["add"](mk),
                        (this["update"] = function (mU, mq) {
                            null === this["parent"] && this["updateMatrixWorld"]();
                            var mw = mU["xr"]["enabled"],
                                mO = mU["getRenderTarget"]();
                            mU["xr"]["enabled"] = !0x1;
                            var mj = mf["texture"]["generateMipmaps"];
                            (mf["texture"]["generateMipmaps"] = !0x1),
                                mU["setRenderTarget"](mf, 0x0),
                                mU["render"](mq, mP),
                                mU["setRenderTarget"](mf, 0x1),
                                mU["render"](mq, mI),
                                mU["setRenderTarget"](mf, 0x2),
                                mU["render"](mq, mA),
                                mU["setRenderTarget"](mf, 0x3),
                                mU["render"](mq, mM),
                                mU["setRenderTarget"](mf, 0x4),
                                mU["render"](mq, mp),
                                (mf["texture"]["generateMipmaps"] = mj),
                                mU["setRenderTarget"](mf, 0x5),
                                mU["render"](mq, mk),
                                mU["setRenderTarget"](mO),
                                (mU["xr"]["enabled"] = mw);
                        }),
                        (this["clear"] = function (mU, mq, mw, mO) {
                            for (var mj = mU["getRenderTarget"](), mh = 0x0; mh < 0x6; mh++) mU["setRenderTarget"](mf, mh), mU["clear"](mq, mw, mO);
                            mU["setRenderTarget"](mj);
                        });
                } else console["error"]("THREE.CubeCamera:\x20The\x20constructor\x20now\x20expects\x20an\x20instance\x20of\x20WebGLCubeRenderTarget\x20as\x20third\x20parameter.");
            }
            function TJ(mN, mX, mf) {
                Number["isInteger"](mX) && (console["warn"]("THREE.WebGLCubeRenderTarget:\x20constructor\x20signature\x20is\x20now\x20WebGLCubeRenderTarget(\x20size,\x20options\x20)"), (mX = mf)), E9["call"](this, mN, mN, mX);
            }
            function TG(mN, mX, mf, mP, mI, mA, mM, mp, mk, mU, mq, mw) {
                E7["call"](this, null, mA, mM, mp, mk, mU, mP, mI, mq, mw),
                    (this["image"] = { data: mN || null, width: mX || 0x1, height: mf || 0x1 }),
                    (this["magFilter"] = void 0x0 !== mk ? mk : rC),
                    (this["minFilter"] = void 0x0 !== mU ? mU : rC),
                    (this["generateMipmaps"] = !0x1),
                    (this["flipY"] = !0x1),
                    (this["unpackAlignment"] = 0x1),
                    (this["needsUpdate"] = !0x0);
            }
            (TV["prototype"] = Object["create"](Eg["prototype"])),
                (TV["prototype"]["constructor"] = TV),
                (TJ["prototype"] = Object["create"](E9["prototype"])),
                (TJ["prototype"]["constructor"] = TJ),
                (TJ["prototype"]["isWebGLCubeRenderTarget"] = !0x0),
                (TJ["prototype"]["fromEquirectangularTexture"] = function (mN, mX) {
                    (this["texture"]["type"] = mX["type"]), (this["texture"]["format"] = mX["format"]), (this["texture"]["encoding"] = mX["encoding"]);
                    var mf = new EW(),
                        mP = {
                            uniforms: { tEquirect: { value: null } },
                            vertexShader: [
                                "varying\x20vec3\x20vWorldDirection;",
                                "vec3\x20transformDirection(\x20in\x20vec3\x20dir,\x20in\x20mat4\x20matrix\x20)\x20{",
                                "\x09return\x20normalize(\x20(\x20matrix\x20*\x20vec4(\x20dir,\x200.0\x20)\x20).xyz\x20);",
                                "}",
                                "void\x20main()\x20{",
                                "\x09vWorldDirection\x20=\x20transformDirection(\x20position,\x20modelMatrix\x20);",
                                "\x09#include\x20<begin_vertex>",
                                "\x09#include\x20<project_vertex>",
                                "}",
                            ]["join"]("\x0a"),
                            fragmentShader: [
                                "uniform\x20sampler2D\x20tEquirect;",
                                "varying\x20vec3\x20vWorldDirection;",
                                "#include\x20<common>",
                                "void\x20main()\x20{",
                                "\x09vec3\x20direction\x20=\x20normalize(\x20vWorldDirection\x20);",
                                "\x09vec2\x20sampleUV\x20=\x20equirectUv(\x20direction\x20);",
                                "\x09gl_FragColor\x20=\x20texture2D(\x20tEquirect,\x20sampleUV\x20);",
                                "}",
                            ]["join"]("\x0a"),
                        },
                        mI = new TW({ type: "CubemapFromEquirect", uniforms: Th(mP["uniforms"]), vertexShader: mP["vertexShader"], fragmentShader: mP["fragmentShader"], side: 0x1, blending: 0x0 });
                    mI["uniforms"]["tEquirect"]["value"] = mX;
                    var mA = new TA(new Tj(0x5, 0x5, 0x5), mI);
                    return mf["add"](mA), new TV(0x1, 0xa, this)["update"](mN, mf), mA["geometry"]["dispose"](), mA["material"]["dispose"](), this;
                }),
                (TG["prototype"] = Object["create"](E7["prototype"])),
                (TG["prototype"]["constructor"] = TG),
                (TG["prototype"]["isDataTexture"] = !0x0);
            var TL = new R7(),
                TQ = new Ed();
            function Tz(mN, mX, mf, mP, mI, mA) {
                this["planes"] = [void 0x0 !== mN ? mN : new RZ(), void 0x0 !== mX ? mX : new RZ(), void 0x0 !== mf ? mf : new RZ(), void 0x0 !== mP ? mP : new RZ(), void 0x0 !== mI ? mI : new RZ(), void 0x0 !== mA ? mA : new RZ()];
            }
            Object["assign"](Tz["prototype"], {
                set: function (mN, mX, mf, mP, mI, mA) {
                    var mM = this["planes"];
                    return mM[0x0]["copy"](mN), mM[0x1]["copy"](mX), mM[0x2]["copy"](mf), mM[0x3]["copy"](mP), mM[0x4]["copy"](mI), mM[0x5]["copy"](mA), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    for (var mX = this["planes"], mf = 0x0; mf < 0x6; mf++) mX[mf]["copy"](mN["planes"][mf]);
                    return this;
                },
                setFromProjectionMatrix: function (mN) {
                    var mX = this["planes"],
                        mf = mN["elements"],
                        mP = mf[0x0],
                        mI = mf[0x1],
                        mA = mf[0x2],
                        mM = mf[0x3],
                        mp = mf[0x4],
                        mk = mf[0x5],
                        mU = mf[0x6],
                        mq = mf[0x7],
                        mw = mf[0x8],
                        mO = mf[0x9],
                        mj = mf[0xa],
                        mh = mf[0xb],
                        mS = mf[0xc],
                        mg = mf[0xd],
                        mW = mf[0xe],
                        mH = mf[0xf];
                    return (
                        mX[0x0]["setComponents"](mM - mP, mq - mp, mh - mw, mH - mS)["normalize"](),
                        mX[0x1]["setComponents"](mM + mP, mq + mp, mh + mw, mH + mS)["normalize"](),
                        mX[0x2]["setComponents"](mM + mI, mq + mk, mh + mO, mH + mg)["normalize"](),
                        mX[0x3]["setComponents"](mM - mI, mq - mk, mh - mO, mH - mg)["normalize"](),
                        mX[0x4]["setComponents"](mM - mA, mq - mU, mh - mj, mH - mW)["normalize"](),
                        mX[0x5]["setComponents"](mM + mA, mq + mU, mh + mj, mH + mW)["normalize"](),
                        this
                    );
                },
                intersectsObject: function (mN) {
                    var mX = mN["geometry"];
                    return null === mX["boundingSphere"] && mX["computeBoundingSphere"](), TL["copy"](mX["boundingSphere"])["applyMatrix4"](mN["matrixWorld"]), this["intersectsSphere"](TL);
                },
                intersectsSprite: function (mN) {
                    return TL["center"]["set"](0x0, 0x0, 0x0), (TL["radius"] = 0.7071067811865476), TL["applyMatrix4"](mN["matrixWorld"]), this["intersectsSphere"](TL);
                },
                intersectsSphere: function (mN) {
                    for (var mX = this["planes"], mf = mN["center"], mP = -mN["radius"], mI = 0x0; mI < 0x6; mI++) {
                        if (mX[mI]["distanceToPoint"](mf) < mP) return !0x1;
                    }
                    return !0x0;
                },
                intersectsBox: function (mN) {
                    for (var mX = this["planes"], mf = 0x0; mf < 0x6; mf++) {
                        var mP = mX[mf];
                        if (
                            ((TQ["x"] = mP["normal"]["x"] > 0x0 ? mN["max"]["x"] : mN["min"]["x"]),
                            (TQ["y"] = mP["normal"]["y"] > 0x0 ? mN["max"]["y"] : mN["min"]["y"]),
                            (TQ["z"] = mP["normal"]["z"] > 0x0 ? mN["max"]["z"] : mN["min"]["z"]),
                            mP["distanceToPoint"](TQ) < 0x0)
                        )
                            return !0x1;
                    }
                    return !0x0;
                },
                containsPoint: function (mN) {
                    for (var mX = this["planes"], mf = 0x0; mf < 0x6; mf++) if (mX[mf]["distanceToPoint"](mN) < 0x0) return !0x1;
                    return !0x0;
                },
            });
            var C0 = {
                common: { diffuse: { value: new Rq(0xeeeeee) }, opacity: { value: 0x1 }, map: { value: null }, uvTransform: { value: new E4() }, uv2Transform: { value: new E4() }, alphaMap: { value: null } },
                specularmap: { specularMap: { value: null } },
                envmap: { envMap: { value: null }, flipEnvMap: { value: -0x1 }, reflectivity: { value: 0x1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0x0 } },
                aomap: { aoMap: { value: null }, aoMapIntensity: { value: 0x1 } },
                lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 0x1 } },
                emissivemap: { emissiveMap: { value: null } },
                bumpmap: { bumpMap: { value: null }, bumpScale: { value: 0x1 } },
                normalmap: { normalMap: { value: null }, normalScale: { value: new E3(0x1, 0x1) } },
                displacementmap: { displacementMap: { value: null }, displacementScale: { value: 0x1 }, displacementBias: { value: 0x0 } },
                roughnessmap: { roughnessMap: { value: null } },
                metalnessmap: { metalnessMap: { value: null } },
                gradientmap: { gradientMap: { value: null } },
                fog: { fogDensity: { value: 0.00025 }, fogNear: { value: 0x1 }, fogFar: { value: 0x7d0 }, fogColor: { value: new Rq(0xffffff) } },
                lights: {
                    ambientLightColor: { value: [] },
                    lightProbe: { value: [] },
                    directionalLights: { value: [], properties: { direction: {}, color: {} } },
                    directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } },
                    directionalShadowMap: { value: [] },
                    directionalShadowMatrix: { value: [] },
                    spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } },
                    spotLightShadows: { value: [], properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } },
                    spotShadowMap: { value: [] },
                    spotShadowMatrix: { value: [] },
                    pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
                    pointLightShadows: { value: [], properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
                    pointShadowMap: { value: [] },
                    pointShadowMatrix: { value: [] },
                    hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
                    rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
                },
                points: { diffuse: { value: new Rq(0xeeeeee) }, opacity: { value: 0x1 }, size: { value: 0x1 }, scale: { value: 0x1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new E4() } },
                sprite: { diffuse: { value: new Rq(0xeeeeee) }, opacity: { value: 0x1 }, center: { value: new E3(0.5, 0.5) }, rotation: { value: 0x0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new E4() } },
            };
            function C1() {
                var mN = null,
                    mX = !0x1,
                    mf = null;
                function mP(mI, mA) {
                    !0x1 !== mX && (mf(mI, mA), mN["requestAnimationFrame"](mP));
                }
                return {
                    start: function () {
                        !0x0 !== mX && null !== mf && (mN["requestAnimationFrame"](mP), (mX = !0x0));
                    },
                    stop: function () {
                        mX = !0x1;
                    },
                    setAnimationLoop: function (mI) {
                        mf = mI;
                    },
                    setContext: function (mI) {
                        mN = mI;
                    },
                };
            }
            function C2(mN, mX) {
                var mf = mX["isWebGL2"],
                    mP = new WeakMap();
                return {
                    get: function (mI) {
                        return mI["isInterleavedBufferAttribute"] && (mI = mI["data"]), mP["get"](mI);
                    },
                    remove: function (mI) {
                        mI["isInterleavedBufferAttribute"] && (mI = mI["data"]);
                        var mA = mP["get"](mI);
                        mA && (mN["deleteBuffer"](mA["buffer"]), mP["delete"](mI));
                    },
                    update: function (mI, mA) {
                        mI["isInterleavedBufferAttribute"] && (mI = mI["data"]);
                        var mM = mP["get"](mI);
                        void 0x0 === mM
                            ? mP["set"](
                                  mI,
                                  (function (mp, mk) {
                                      var mU = mp["array"],
                                          mq = mp["usage"],
                                          mw = mN["createBuffer"]();
                                      mN["bindBuffer"](mk, mw), mN["bufferData"](mk, mU, mq), mp["onUploadCallback"]();
                                      var mO = 0x1406;
                                      return (
                                          mU instanceof Float32Array
                                              ? (mO = 0x1406)
                                              : mU instanceof Float64Array
                                              ? console["warn"]("THREE.WebGLAttributes:\x20Unsupported\x20data\x20buffer\x20format:\x20Float64Array.")
                                              : mU instanceof Uint16Array
                                              ? (mO = 0x1403)
                                              : mU instanceof Int16Array
                                              ? (mO = 0x1402)
                                              : mU instanceof Uint32Array
                                              ? (mO = 0x1405)
                                              : mU instanceof Int32Array
                                              ? (mO = 0x1404)
                                              : mU instanceof Int8Array
                                              ? (mO = 0x1400)
                                              : mU instanceof Uint8Array && (mO = 0x1401),
                                          { buffer: mw, type: mO, bytesPerElement: mU["BYTES_PER_ELEMENT"], version: mp["version"] }
                                      );
                                  })(mI, mA)
                              )
                            : mM["version"] < mI["version"] &&
                              (!(function (mp, mk, mU) {
                                  var mq = mk["array"],
                                      mw = mk["updateRange"];
                                  mN["bindBuffer"](mU, mp),
                                      -0x1 === mw["count"]
                                          ? mN["bufferSubData"](mU, 0x0, mq)
                                          : (mf
                                                ? mN["bufferSubData"](mU, mw["offset"] * mq["BYTES_PER_ELEMENT"], mq, mw["offset"], mw["count"])
                                                : mN["bufferSubData"](mU, mw["offset"] * mq["BYTES_PER_ELEMENT"], mq["subarray"](mw["offset"], mw["offset"] + mw["count"])),
                                            (mw["count"] = -0x1));
                              })(mM["buffer"], mI, mA),
                              (mM["version"] = mI["version"]));
                    },
                };
            }
            function C3(mN, mX, mf, mP) {
                TO["call"](this), (this["type"] = "PlaneGeometry"), (this["parameters"] = { width: mN, height: mX, widthSegments: mf, heightSegments: mP }), this["fromBufferGeometry"](new C4(mN, mX, mf, mP)), this["mergeVertices"]();
            }
            function C4(mN, mX, mf, mP) {
                TR["call"](this), (this["type"] = "PlaneBufferGeometry"), (this["parameters"] = { width: mN, height: mX, widthSegments: mf, heightSegments: mP });
                var mI,
                    mA,
                    mM = (mN = mN || 0x1) / 0x2,
                    mp = (mX = mX || 0x1) / 0x2,
                    mk = Math["floor"](mf) || 0x1,
                    mU = Math["floor"](mP) || 0x1,
                    mq = mk + 0x1,
                    mw = mU + 0x1,
                    mO = mN / mk,
                    mj = mX / mU,
                    mh = [],
                    mS = [],
                    mg = [],
                    mW = [];
                for (mA = 0x0; mA < mw; mA++) {
                    var mH = mA * mj - mp;
                    for (mI = 0x0; mI < mq; mI++) {
                        var mx = mI * mO - mM;
                        mS["push"](mx, -mH, 0x0), mg["push"](0x0, 0x0, 0x1), mW["push"](mI / mk), mW["push"](0x1 - mA / mU);
                    }
                }
                for (mA = 0x0; mA < mU; mA++)
                    for (mI = 0x0; mI < mk; mI++) {
                        var mK = mI + mq * mA,
                            mV = mI + mq * (mA + 0x1),
                            mJ = mI + 0x1 + mq * (mA + 0x1),
                            mG = mI + 0x1 + mq * mA;
                        mh["push"](mK, mV, mG), mh["push"](mV, mJ, mG);
                    }
                this["setIndex"](mh), this["setAttribute"]("position", new T0(mS, 0x3)), this["setAttribute"]("normal", new T0(mg, 0x3)), this["setAttribute"]("uv", new T0(mW, 0x2));
            }
            (C3["prototype"] = Object["create"](TO["prototype"])), (C3["prototype"]["constructor"] = C3), (C4["prototype"] = Object["create"](TR["prototype"])), (C4["prototype"]["constructor"] = C4);
            var C5 = {
                    alphamap_fragment: "#ifdef\x20USE_ALPHAMAP\x0a\x09diffuseColor.a\x20*=\x20texture2D(\x20alphaMap,\x20vUv\x20).g;\x0a#endif",
                    alphamap_pars_fragment: "#ifdef\x20USE_ALPHAMAP\x0a\x09uniform\x20sampler2D\x20alphaMap;\x0a#endif",
                    alphatest_fragment: "#ifdef\x20ALPHATEST\x0a\x09if\x20(\x20diffuseColor.a\x20<\x20ALPHATEST\x20)\x20discard;\x0a#endif",
                    aomap_fragment:
                        "#ifdef\x20USE_AOMAP\x0a\x09float\x20ambientOcclusion\x20=\x20(\x20texture2D(\x20aoMap,\x20vUv2\x20).r\x20-\x201.0\x20)\x20*\x20aoMapIntensity\x20+\x201.0;\x0a\x09reflectedLight.indirectDiffuse\x20*=\x20ambientOcclusion;\x0a\x09#if\x20defined(\x20USE_ENVMAP\x20)\x20&&\x20defined(\x20STANDARD\x20)\x0a\x09\x09float\x20dotNV\x20=\x20saturate(\x20dot(\x20geometry.normal,\x20geometry.viewDir\x20)\x20);\x0a\x09\x09reflectedLight.indirectSpecular\x20*=\x20computeSpecularOcclusion(\x20dotNV,\x20ambientOcclusion,\x20material.specularRoughness\x20);\x0a\x09#endif\x0a#endif",
                    aomap_pars_fragment: "#ifdef\x20USE_AOMAP\x0a\x09uniform\x20sampler2D\x20aoMap;\x0a\x09uniform\x20float\x20aoMapIntensity;\x0a#endif",
                    begin_vertex: "vec3\x20transformed\x20=\x20vec3(\x20position\x20);",
                    beginnormal_vertex: "vec3\x20objectNormal\x20=\x20vec3(\x20normal\x20);\x0a#ifdef\x20USE_TANGENT\x0a\x09vec3\x20objectTangent\x20=\x20vec3(\x20tangent.xyz\x20);\x0a#endif",
                    bsdfs:
                        "vec2\x20integrateSpecularBRDF(\x20const\x20in\x20float\x20dotNV,\x20const\x20in\x20float\x20roughness\x20)\x20{\x0a\x09const\x20vec4\x20c0\x20=\x20vec4(\x20-\x201,\x20-\x200.0275,\x20-\x200.572,\x200.022\x20);\x0a\x09const\x20vec4\x20c1\x20=\x20vec4(\x201,\x200.0425,\x201.04,\x20-\x200.04\x20);\x0a\x09vec4\x20r\x20=\x20roughness\x20*\x20c0\x20+\x20c1;\x0a\x09float\x20a004\x20=\x20min(\x20r.x\x20*\x20r.x,\x20exp2(\x20-\x209.28\x20*\x20dotNV\x20)\x20)\x20*\x20r.x\x20+\x20r.y;\x0a\x09return\x20vec2(\x20-1.04,\x201.04\x20)\x20*\x20a004\x20+\x20r.zw;\x0a}\x0afloat\x20punctualLightIntensityToIrradianceFactor(\x20const\x20in\x20float\x20lightDistance,\x20const\x20in\x20float\x20cutoffDistance,\x20const\x20in\x20float\x20decayExponent\x20)\x20{\x0a#if\x20defined\x20(\x20PHYSICALLY_CORRECT_LIGHTS\x20)\x0a\x09float\x20distanceFalloff\x20=\x201.0\x20/\x20max(\x20pow(\x20lightDistance,\x20decayExponent\x20),\x200.01\x20);\x0a\x09if(\x20cutoffDistance\x20>\x200.0\x20)\x20{\x0a\x09\x09distanceFalloff\x20*=\x20pow2(\x20saturate(\x201.0\x20-\x20pow4(\x20lightDistance\x20/\x20cutoffDistance\x20)\x20)\x20);\x0a\x09}\x0a\x09return\x20distanceFalloff;\x0a#else\x0a\x09if(\x20cutoffDistance\x20>\x200.0\x20&&\x20decayExponent\x20>\x200.0\x20)\x20{\x0a\x09\x09return\x20pow(\x20saturate(\x20-lightDistance\x20/\x20cutoffDistance\x20+\x201.0\x20),\x20decayExponent\x20);\x0a\x09}\x0a\x09return\x201.0;\x0a#endif\x0a}\x0avec3\x20BRDF_Diffuse_Lambert(\x20const\x20in\x20vec3\x20diffuseColor\x20)\x20{\x0a\x09return\x20RECIPROCAL_PI\x20*\x20diffuseColor;\x0a}\x0avec3\x20F_Schlick(\x20const\x20in\x20vec3\x20specularColor,\x20const\x20in\x20float\x20dotLH\x20)\x20{\x0a\x09float\x20fresnel\x20=\x20exp2(\x20(\x20-5.55473\x20*\x20dotLH\x20-\x206.98316\x20)\x20*\x20dotLH\x20);\x0a\x09return\x20(\x201.0\x20-\x20specularColor\x20)\x20*\x20fresnel\x20+\x20specularColor;\x0a}\x0avec3\x20F_Schlick_RoughnessDependent(\x20const\x20in\x20vec3\x20F0,\x20const\x20in\x20float\x20dotNV,\x20const\x20in\x20float\x20roughness\x20)\x20{\x0a\x09float\x20fresnel\x20=\x20exp2(\x20(\x20-5.55473\x20*\x20dotNV\x20-\x206.98316\x20)\x20*\x20dotNV\x20);\x0a\x09vec3\x20Fr\x20=\x20max(\x20vec3(\x201.0\x20-\x20roughness\x20),\x20F0\x20)\x20-\x20F0;\x0a\x09return\x20Fr\x20*\x20fresnel\x20+\x20F0;\x0a}\x0afloat\x20G_GGX_Smith(\x20const\x20in\x20float\x20alpha,\x20const\x20in\x20float\x20dotNL,\x20const\x20in\x20float\x20dotNV\x20)\x20{\x0a\x09float\x20a2\x20=\x20pow2(\x20alpha\x20);\x0a\x09float\x20gl\x20=\x20dotNL\x20+\x20sqrt(\x20a2\x20+\x20(\x201.0\x20-\x20a2\x20)\x20*\x20pow2(\x20dotNL\x20)\x20);\x0a\x09float\x20gv\x20=\x20dotNV\x20+\x20sqrt(\x20a2\x20+\x20(\x201.0\x20-\x20a2\x20)\x20*\x20pow2(\x20dotNV\x20)\x20);\x0a\x09return\x201.0\x20/\x20(\x20gl\x20*\x20gv\x20);\x0a}\x0afloat\x20G_GGX_SmithCorrelated(\x20const\x20in\x20float\x20alpha,\x20const\x20in\x20float\x20dotNL,\x20const\x20in\x20float\x20dotNV\x20)\x20{\x0a\x09float\x20a2\x20=\x20pow2(\x20alpha\x20);\x0a\x09float\x20gv\x20=\x20dotNL\x20*\x20sqrt(\x20a2\x20+\x20(\x201.0\x20-\x20a2\x20)\x20*\x20pow2(\x20dotNV\x20)\x20);\x0a\x09float\x20gl\x20=\x20dotNV\x20*\x20sqrt(\x20a2\x20+\x20(\x201.0\x20-\x20a2\x20)\x20*\x20pow2(\x20dotNL\x20)\x20);\x0a\x09return\x200.5\x20/\x20max(\x20gv\x20+\x20gl,\x20EPSILON\x20);\x0a}\x0afloat\x20D_GGX(\x20const\x20in\x20float\x20alpha,\x20const\x20in\x20float\x20dotNH\x20)\x20{\x0a\x09float\x20a2\x20=\x20pow2(\x20alpha\x20);\x0a\x09float\x20denom\x20=\x20pow2(\x20dotNH\x20)\x20*\x20(\x20a2\x20-\x201.0\x20)\x20+\x201.0;\x0a\x09return\x20RECIPROCAL_PI\x20*\x20a2\x20/\x20pow2(\x20denom\x20);\x0a}\x0avec3\x20BRDF_Specular_GGX(\x20const\x20in\x20IncidentLight\x20incidentLight,\x20const\x20in\x20vec3\x20viewDir,\x20const\x20in\x20vec3\x20normal,\x20const\x20in\x20vec3\x20specularColor,\x20const\x20in\x20float\x20roughness\x20)\x20{\x0a\x09float\x20alpha\x20=\x20pow2(\x20roughness\x20);\x0a\x09vec3\x20halfDir\x20=\x20normalize(\x20incidentLight.direction\x20+\x20viewDir\x20);\x0a\x09float\x20dotNL\x20=\x20saturate(\x20dot(\x20normal,\x20incidentLight.direction\x20)\x20);\x0a\x09float\x20dotNV\x20=\x20saturate(\x20dot(\x20normal,\x20viewDir\x20)\x20);\x0a\x09float\x20dotNH\x20=\x20saturate(\x20dot(\x20normal,\x20halfDir\x20)\x20);\x0a\x09float\x20dotLH\x20=\x20saturate(\x20dot(\x20incidentLight.direction,\x20halfDir\x20)\x20);\x0a\x09vec3\x20F\x20=\x20F_Schlick(\x20specularColor,\x20dotLH\x20);\x0a\x09float\x20G\x20=\x20G_GGX_SmithCorrelated(\x20alpha,\x20dotNL,\x20dotNV\x20);\x0a\x09float\x20D\x20=\x20D_GGX(\x20alpha,\x20dotNH\x20);\x0a\x09return\x20F\x20*\x20(\x20G\x20*\x20D\x20);\x0a}\x0avec2\x20LTC_Uv(\x20const\x20in\x20vec3\x20N,\x20const\x20in\x20vec3\x20V,\x20const\x20in\x20float\x20roughness\x20)\x20{\x0a\x09const\x20float\x20LUT_SIZE\x20\x20=\x2064.0;\x0a\x09const\x20float\x20LUT_SCALE\x20=\x20(\x20LUT_SIZE\x20-\x201.0\x20)\x20/\x20LUT_SIZE;\x0a\x09const\x20float\x20LUT_BIAS\x20\x20=\x200.5\x20/\x20LUT_SIZE;\x0a\x09float\x20dotNV\x20=\x20saturate(\x20dot(\x20N,\x20V\x20)\x20);\x0a\x09vec2\x20uv\x20=\x20vec2(\x20roughness,\x20sqrt(\x201.0\x20-\x20dotNV\x20)\x20);\x0a\x09uv\x20=\x20uv\x20*\x20LUT_SCALE\x20+\x20LUT_BIAS;\x0a\x09return\x20uv;\x0a}\x0afloat\x20LTC_ClippedSphereFormFactor(\x20const\x20in\x20vec3\x20f\x20)\x20{\x0a\x09float\x20l\x20=\x20length(\x20f\x20);\x0a\x09return\x20max(\x20(\x20l\x20*\x20l\x20+\x20f.z\x20)\x20/\x20(\x20l\x20+\x201.0\x20),\x200.0\x20);\x0a}\x0avec3\x20LTC_EdgeVectorFormFactor(\x20const\x20in\x20vec3\x20v1,\x20const\x20in\x20vec3\x20v2\x20)\x20{\x0a\x09float\x20x\x20=\x20dot(\x20v1,\x20v2\x20);\x0a\x09float\x20y\x20=\x20abs(\x20x\x20);\x0a\x09float\x20a\x20=\x200.8543985\x20+\x20(\x200.4965155\x20+\x200.0145206\x20*\x20y\x20)\x20*\x20y;\x0a\x09float\x20b\x20=\x203.4175940\x20+\x20(\x204.1616724\x20+\x20y\x20)\x20*\x20y;\x0a\x09float\x20v\x20=\x20a\x20/\x20b;\x0a\x09float\x20theta_sintheta\x20=\x20(\x20x\x20>\x200.0\x20)\x20?\x20v\x20:\x200.5\x20*\x20inversesqrt(\x20max(\x201.0\x20-\x20x\x20*\x20x,\x201e-7\x20)\x20)\x20-\x20v;\x0a\x09return\x20cross(\x20v1,\x20v2\x20)\x20*\x20theta_sintheta;\x0a}\x0avec3\x20LTC_Evaluate(\x20const\x20in\x20vec3\x20N,\x20const\x20in\x20vec3\x20V,\x20const\x20in\x20vec3\x20P,\x20const\x20in\x20mat3\x20mInv,\x20const\x20in\x20vec3\x20rectCoords[\x204\x20]\x20)\x20{\x0a\x09vec3\x20v1\x20=\x20rectCoords[\x201\x20]\x20-\x20rectCoords[\x200\x20];\x0a\x09vec3\x20v2\x20=\x20rectCoords[\x203\x20]\x20-\x20rectCoords[\x200\x20];\x0a\x09vec3\x20lightNormal\x20=\x20cross(\x20v1,\x20v2\x20);\x0a\x09if(\x20dot(\x20lightNormal,\x20P\x20-\x20rectCoords[\x200\x20]\x20)\x20<\x200.0\x20)\x20return\x20vec3(\x200.0\x20);\x0a\x09vec3\x20T1,\x20T2;\x0a\x09T1\x20=\x20normalize(\x20V\x20-\x20N\x20*\x20dot(\x20V,\x20N\x20)\x20);\x0a\x09T2\x20=\x20-\x20cross(\x20N,\x20T1\x20);\x0a\x09mat3\x20mat\x20=\x20mInv\x20*\x20transposeMat3(\x20mat3(\x20T1,\x20T2,\x20N\x20)\x20);\x0a\x09vec3\x20coords[\x204\x20];\x0a\x09coords[\x200\x20]\x20=\x20mat\x20*\x20(\x20rectCoords[\x200\x20]\x20-\x20P\x20);\x0a\x09coords[\x201\x20]\x20=\x20mat\x20*\x20(\x20rectCoords[\x201\x20]\x20-\x20P\x20);\x0a\x09coords[\x202\x20]\x20=\x20mat\x20*\x20(\x20rectCoords[\x202\x20]\x20-\x20P\x20);\x0a\x09coords[\x203\x20]\x20=\x20mat\x20*\x20(\x20rectCoords[\x203\x20]\x20-\x20P\x20);\x0a\x09coords[\x200\x20]\x20=\x20normalize(\x20coords[\x200\x20]\x20);\x0a\x09coords[\x201\x20]\x20=\x20normalize(\x20coords[\x201\x20]\x20);\x0a\x09coords[\x202\x20]\x20=\x20normalize(\x20coords[\x202\x20]\x20);\x0a\x09coords[\x203\x20]\x20=\x20normalize(\x20coords[\x203\x20]\x20);\x0a\x09vec3\x20vectorFormFactor\x20=\x20vec3(\x200.0\x20);\x0a\x09vectorFormFactor\x20+=\x20LTC_EdgeVectorFormFactor(\x20coords[\x200\x20],\x20coords[\x201\x20]\x20);\x0a\x09vectorFormFactor\x20+=\x20LTC_EdgeVectorFormFactor(\x20coords[\x201\x20],\x20coords[\x202\x20]\x20);\x0a\x09vectorFormFactor\x20+=\x20LTC_EdgeVectorFormFactor(\x20coords[\x202\x20],\x20coords[\x203\x20]\x20);\x0a\x09vectorFormFactor\x20+=\x20LTC_EdgeVectorFormFactor(\x20coords[\x203\x20],\x20coords[\x200\x20]\x20);\x0a\x09float\x20result\x20=\x20LTC_ClippedSphereFormFactor(\x20vectorFormFactor\x20);\x0a\x09return\x20vec3(\x20result\x20);\x0a}\x0avec3\x20BRDF_Specular_GGX_Environment(\x20const\x20in\x20vec3\x20viewDir,\x20const\x20in\x20vec3\x20normal,\x20const\x20in\x20vec3\x20specularColor,\x20const\x20in\x20float\x20roughness\x20)\x20{\x0a\x09float\x20dotNV\x20=\x20saturate(\x20dot(\x20normal,\x20viewDir\x20)\x20);\x0a\x09vec2\x20brdf\x20=\x20integrateSpecularBRDF(\x20dotNV,\x20roughness\x20);\x0a\x09return\x20specularColor\x20*\x20brdf.x\x20+\x20brdf.y;\x0a}\x0avoid\x20BRDF_Specular_Multiscattering_Environment(\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20vec3\x20specularColor,\x20const\x20in\x20float\x20roughness,\x20inout\x20vec3\x20singleScatter,\x20inout\x20vec3\x20multiScatter\x20)\x20{\x0a\x09float\x20dotNV\x20=\x20saturate(\x20dot(\x20geometry.normal,\x20geometry.viewDir\x20)\x20);\x0a\x09vec3\x20F\x20=\x20F_Schlick_RoughnessDependent(\x20specularColor,\x20dotNV,\x20roughness\x20);\x0a\x09vec2\x20brdf\x20=\x20integrateSpecularBRDF(\x20dotNV,\x20roughness\x20);\x0a\x09vec3\x20FssEss\x20=\x20F\x20*\x20brdf.x\x20+\x20brdf.y;\x0a\x09float\x20Ess\x20=\x20brdf.x\x20+\x20brdf.y;\x0a\x09float\x20Ems\x20=\x201.0\x20-\x20Ess;\x0a\x09vec3\x20Favg\x20=\x20specularColor\x20+\x20(\x201.0\x20-\x20specularColor\x20)\x20*\x200.047619;\x09vec3\x20Fms\x20=\x20FssEss\x20*\x20Favg\x20/\x20(\x201.0\x20-\x20Ems\x20*\x20Favg\x20);\x0a\x09singleScatter\x20+=\x20FssEss;\x0a\x09multiScatter\x20+=\x20Fms\x20*\x20Ems;\x0a}\x0afloat\x20G_BlinnPhong_Implicit(\x20)\x20{\x0a\x09return\x200.25;\x0a}\x0afloat\x20D_BlinnPhong(\x20const\x20in\x20float\x20shininess,\x20const\x20in\x20float\x20dotNH\x20)\x20{\x0a\x09return\x20RECIPROCAL_PI\x20*\x20(\x20shininess\x20*\x200.5\x20+\x201.0\x20)\x20*\x20pow(\x20dotNH,\x20shininess\x20);\x0a}\x0avec3\x20BRDF_Specular_BlinnPhong(\x20const\x20in\x20IncidentLight\x20incidentLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20vec3\x20specularColor,\x20const\x20in\x20float\x20shininess\x20)\x20{\x0a\x09vec3\x20halfDir\x20=\x20normalize(\x20incidentLight.direction\x20+\x20geometry.viewDir\x20);\x0a\x09float\x20dotNH\x20=\x20saturate(\x20dot(\x20geometry.normal,\x20halfDir\x20)\x20);\x0a\x09float\x20dotLH\x20=\x20saturate(\x20dot(\x20incidentLight.direction,\x20halfDir\x20)\x20);\x0a\x09vec3\x20F\x20=\x20F_Schlick(\x20specularColor,\x20dotLH\x20);\x0a\x09float\x20G\x20=\x20G_BlinnPhong_Implicit(\x20);\x0a\x09float\x20D\x20=\x20D_BlinnPhong(\x20shininess,\x20dotNH\x20);\x0a\x09return\x20F\x20*\x20(\x20G\x20*\x20D\x20);\x0a}\x0afloat\x20GGXRoughnessToBlinnExponent(\x20const\x20in\x20float\x20ggxRoughness\x20)\x20{\x0a\x09return\x20(\x202.0\x20/\x20pow2(\x20ggxRoughness\x20+\x200.0001\x20)\x20-\x202.0\x20);\x0a}\x0afloat\x20BlinnExponentToGGXRoughness(\x20const\x20in\x20float\x20blinnExponent\x20)\x20{\x0a\x09return\x20sqrt(\x202.0\x20/\x20(\x20blinnExponent\x20+\x202.0\x20)\x20);\x0a}\x0a#if\x20defined(\x20USE_SHEEN\x20)\x0afloat\x20D_Charlie(float\x20roughness,\x20float\x20NoH)\x20{\x0a\x09float\x20invAlpha\x20\x20=\x201.0\x20/\x20roughness;\x0a\x09float\x20cos2h\x20=\x20NoH\x20*\x20NoH;\x0a\x09float\x20sin2h\x20=\x20max(1.0\x20-\x20cos2h,\x200.0078125);\x09return\x20(2.0\x20+\x20invAlpha)\x20*\x20pow(sin2h,\x20invAlpha\x20*\x200.5)\x20/\x20(2.0\x20*\x20PI);\x0a}\x0afloat\x20V_Neubelt(float\x20NoV,\x20float\x20NoL)\x20{\x0a\x09return\x20saturate(1.0\x20/\x20(4.0\x20*\x20(NoL\x20+\x20NoV\x20-\x20NoL\x20*\x20NoV)));\x0a}\x0avec3\x20BRDF_Specular_Sheen(\x20const\x20in\x20float\x20roughness,\x20const\x20in\x20vec3\x20L,\x20const\x20in\x20GeometricContext\x20geometry,\x20vec3\x20specularColor\x20)\x20{\x0a\x09vec3\x20N\x20=\x20geometry.normal;\x0a\x09vec3\x20V\x20=\x20geometry.viewDir;\x0a\x09vec3\x20H\x20=\x20normalize(\x20V\x20+\x20L\x20);\x0a\x09float\x20dotNH\x20=\x20saturate(\x20dot(\x20N,\x20H\x20)\x20);\x0a\x09return\x20specularColor\x20*\x20D_Charlie(\x20roughness,\x20dotNH\x20)\x20*\x20V_Neubelt(\x20dot(N,\x20V),\x20dot(N,\x20L)\x20);\x0a}\x0a#endif",
                    bumpmap_pars_fragment:
                        "#ifdef\x20USE_BUMPMAP\x0a\x09uniform\x20sampler2D\x20bumpMap;\x0a\x09uniform\x20float\x20bumpScale;\x0a\x09vec2\x20dHdxy_fwd()\x20{\x0a\x09\x09vec2\x20dSTdx\x20=\x20dFdx(\x20vUv\x20);\x0a\x09\x09vec2\x20dSTdy\x20=\x20dFdy(\x20vUv\x20);\x0a\x09\x09float\x20Hll\x20=\x20bumpScale\x20*\x20texture2D(\x20bumpMap,\x20vUv\x20).x;\x0a\x09\x09float\x20dBx\x20=\x20bumpScale\x20*\x20texture2D(\x20bumpMap,\x20vUv\x20+\x20dSTdx\x20).x\x20-\x20Hll;\x0a\x09\x09float\x20dBy\x20=\x20bumpScale\x20*\x20texture2D(\x20bumpMap,\x20vUv\x20+\x20dSTdy\x20).x\x20-\x20Hll;\x0a\x09\x09return\x20vec2(\x20dBx,\x20dBy\x20);\x0a\x09}\x0a\x09vec3\x20perturbNormalArb(\x20vec3\x20surf_pos,\x20vec3\x20surf_norm,\x20vec2\x20dHdxy\x20)\x20{\x0a\x09\x09vec3\x20vSigmaX\x20=\x20vec3(\x20dFdx(\x20surf_pos.x\x20),\x20dFdx(\x20surf_pos.y\x20),\x20dFdx(\x20surf_pos.z\x20)\x20);\x0a\x09\x09vec3\x20vSigmaY\x20=\x20vec3(\x20dFdy(\x20surf_pos.x\x20),\x20dFdy(\x20surf_pos.y\x20),\x20dFdy(\x20surf_pos.z\x20)\x20);\x0a\x09\x09vec3\x20vN\x20=\x20surf_norm;\x0a\x09\x09vec3\x20R1\x20=\x20cross(\x20vSigmaY,\x20vN\x20);\x0a\x09\x09vec3\x20R2\x20=\x20cross(\x20vN,\x20vSigmaX\x20);\x0a\x09\x09float\x20fDet\x20=\x20dot(\x20vSigmaX,\x20R1\x20);\x0a\x09\x09fDet\x20*=\x20(\x20float(\x20gl_FrontFacing\x20)\x20*\x202.0\x20-\x201.0\x20);\x0a\x09\x09vec3\x20vGrad\x20=\x20sign(\x20fDet\x20)\x20*\x20(\x20dHdxy.x\x20*\x20R1\x20+\x20dHdxy.y\x20*\x20R2\x20);\x0a\x09\x09return\x20normalize(\x20abs(\x20fDet\x20)\x20*\x20surf_norm\x20-\x20vGrad\x20);\x0a\x09}\x0a#endif",
                    clipping_planes_fragment:
                        "#if\x20NUM_CLIPPING_PLANES\x20>\x200\x0a\x09vec4\x20plane;\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20UNION_CLIPPING_PLANES;\x20i\x20++\x20)\x20{\x0a\x09\x09plane\x20=\x20clippingPlanes[\x20i\x20];\x0a\x09\x09if\x20(\x20dot(\x20vClipPosition,\x20plane.xyz\x20)\x20>\x20plane.w\x20)\x20discard;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#if\x20UNION_CLIPPING_PLANES\x20<\x20NUM_CLIPPING_PLANES\x0a\x09\x09bool\x20clipped\x20=\x20true;\x0a\x09\x09#pragma\x20unroll_loop_start\x0a\x09\x09for\x20(\x20int\x20i\x20=\x20UNION_CLIPPING_PLANES;\x20i\x20<\x20NUM_CLIPPING_PLANES;\x20i\x20++\x20)\x20{\x0a\x09\x09\x09plane\x20=\x20clippingPlanes[\x20i\x20];\x0a\x09\x09\x09clipped\x20=\x20(\x20dot(\x20vClipPosition,\x20plane.xyz\x20)\x20>\x20plane.w\x20)\x20&&\x20clipped;\x0a\x09\x09}\x0a\x09\x09#pragma\x20unroll_loop_end\x0a\x09\x09if\x20(\x20clipped\x20)\x20discard;\x0a\x09#endif\x0a#endif",
                    clipping_planes_pars_fragment: "#if\x20NUM_CLIPPING_PLANES\x20>\x200\x0a\x09varying\x20vec3\x20vClipPosition;\x0a\x09uniform\x20vec4\x20clippingPlanes[\x20NUM_CLIPPING_PLANES\x20];\x0a#endif",
                    clipping_planes_pars_vertex: "#if\x20NUM_CLIPPING_PLANES\x20>\x200\x0a\x09varying\x20vec3\x20vClipPosition;\x0a#endif",
                    clipping_planes_vertex: "#if\x20NUM_CLIPPING_PLANES\x20>\x200\x0a\x09vClipPosition\x20=\x20-\x20mvPosition.xyz;\x0a#endif",
                    color_fragment: "#ifdef\x20USE_COLOR\x0a\x09diffuseColor.rgb\x20*=\x20vColor;\x0a#endif",
                    color_pars_fragment: "#ifdef\x20USE_COLOR\x0a\x09varying\x20vec3\x20vColor;\x0a#endif",
                    color_pars_vertex: "#ifdef\x20USE_COLOR\x0a\x09varying\x20vec3\x20vColor;\x0a#endif",
                    color_vertex: "#ifdef\x20USE_COLOR\x0a\x09vColor.xyz\x20=\x20color.xyz;\x0a#endif",
                    common:
                        "#define\x20PI\x203.14159265359\x0a#define\x20PI2\x206.28318530718\x0a#define\x20PI_HALF\x201.5707963267949\x0a#define\x20RECIPROCAL_PI\x200.31830988618\x0a#define\x20RECIPROCAL_PI2\x200.15915494\x0a#define\x20LOG2\x201.442695\x0a#define\x20EPSILON\x201e-6\x0a#ifndef\x20saturate\x0a#define\x20saturate(a)\x20clamp(\x20a,\x200.0,\x201.0\x20)\x0a#endif\x0a#define\x20whiteComplement(a)\x20(\x201.0\x20-\x20saturate(\x20a\x20)\x20)\x0afloat\x20pow2(\x20const\x20in\x20float\x20x\x20)\x20{\x20return\x20x*x;\x20}\x0afloat\x20pow3(\x20const\x20in\x20float\x20x\x20)\x20{\x20return\x20x*x*x;\x20}\x0afloat\x20pow4(\x20const\x20in\x20float\x20x\x20)\x20{\x20float\x20x2\x20=\x20x*x;\x20return\x20x2*x2;\x20}\x0afloat\x20average(\x20const\x20in\x20vec3\x20color\x20)\x20{\x20return\x20dot(\x20color,\x20vec3(\x200.3333\x20)\x20);\x20}\x0ahighp\x20float\x20rand(\x20const\x20in\x20vec2\x20uv\x20)\x20{\x0a\x09const\x20highp\x20float\x20a\x20=\x2012.9898,\x20b\x20=\x2078.233,\x20c\x20=\x2043758.5453;\x0a\x09highp\x20float\x20dt\x20=\x20dot(\x20uv.xy,\x20vec2(\x20a,b\x20)\x20),\x20sn\x20=\x20mod(\x20dt,\x20PI\x20);\x0a\x09return\x20fract(sin(sn)\x20*\x20c);\x0a}\x0a#ifdef\x20HIGH_PRECISION\x0a\x09float\x20precisionSafeLength(\x20vec3\x20v\x20)\x20{\x20return\x20length(\x20v\x20);\x20}\x0a#else\x0a\x09float\x20max3(\x20vec3\x20v\x20)\x20{\x20return\x20max(\x20max(\x20v.x,\x20v.y\x20),\x20v.z\x20);\x20}\x0a\x09float\x20precisionSafeLength(\x20vec3\x20v\x20)\x20{\x0a\x09\x09float\x20maxComponent\x20=\x20max3(\x20abs(\x20v\x20)\x20);\x0a\x09\x09return\x20length(\x20v\x20/\x20maxComponent\x20)\x20*\x20maxComponent;\x0a\x09}\x0a#endif\x0astruct\x20IncidentLight\x20{\x0a\x09vec3\x20color;\x0a\x09vec3\x20direction;\x0a\x09bool\x20visible;\x0a};\x0astruct\x20ReflectedLight\x20{\x0a\x09vec3\x20directDiffuse;\x0a\x09vec3\x20directSpecular;\x0a\x09vec3\x20indirectDiffuse;\x0a\x09vec3\x20indirectSpecular;\x0a};\x0astruct\x20GeometricContext\x20{\x0a\x09vec3\x20position;\x0a\x09vec3\x20normal;\x0a\x09vec3\x20viewDir;\x0a#ifdef\x20CLEARCOAT\x0a\x09vec3\x20clearcoatNormal;\x0a#endif\x0a};\x0avec3\x20transformDirection(\x20in\x20vec3\x20dir,\x20in\x20mat4\x20matrix\x20)\x20{\x0a\x09return\x20normalize(\x20(\x20matrix\x20*\x20vec4(\x20dir,\x200.0\x20)\x20).xyz\x20);\x0a}\x0avec3\x20inverseTransformDirection(\x20in\x20vec3\x20dir,\x20in\x20mat4\x20matrix\x20)\x20{\x0a\x09return\x20normalize(\x20(\x20vec4(\x20dir,\x200.0\x20)\x20*\x20matrix\x20).xyz\x20);\x0a}\x0avec3\x20projectOnPlane(in\x20vec3\x20point,\x20in\x20vec3\x20pointOnPlane,\x20in\x20vec3\x20planeNormal\x20)\x20{\x0a\x09float\x20distance\x20=\x20dot(\x20planeNormal,\x20point\x20-\x20pointOnPlane\x20);\x0a\x09return\x20-\x20distance\x20*\x20planeNormal\x20+\x20point;\x0a}\x0afloat\x20sideOfPlane(\x20in\x20vec3\x20point,\x20in\x20vec3\x20pointOnPlane,\x20in\x20vec3\x20planeNormal\x20)\x20{\x0a\x09return\x20sign(\x20dot(\x20point\x20-\x20pointOnPlane,\x20planeNormal\x20)\x20);\x0a}\x0avec3\x20linePlaneIntersect(\x20in\x20vec3\x20pointOnLine,\x20in\x20vec3\x20lineDirection,\x20in\x20vec3\x20pointOnPlane,\x20in\x20vec3\x20planeNormal\x20)\x20{\x0a\x09return\x20lineDirection\x20*\x20(\x20dot(\x20planeNormal,\x20pointOnPlane\x20-\x20pointOnLine\x20)\x20/\x20dot(\x20planeNormal,\x20lineDirection\x20)\x20)\x20+\x20pointOnLine;\x0a}\x0amat3\x20transposeMat3(\x20const\x20in\x20mat3\x20m\x20)\x20{\x0a\x09mat3\x20tmp;\x0a\x09tmp[\x200\x20]\x20=\x20vec3(\x20m[\x200\x20].x,\x20m[\x201\x20].x,\x20m[\x202\x20].x\x20);\x0a\x09tmp[\x201\x20]\x20=\x20vec3(\x20m[\x200\x20].y,\x20m[\x201\x20].y,\x20m[\x202\x20].y\x20);\x0a\x09tmp[\x202\x20]\x20=\x20vec3(\x20m[\x200\x20].z,\x20m[\x201\x20].z,\x20m[\x202\x20].z\x20);\x0a\x09return\x20tmp;\x0a}\x0afloat\x20linearToRelativeLuminance(\x20const\x20in\x20vec3\x20color\x20)\x20{\x0a\x09vec3\x20weights\x20=\x20vec3(\x200.2126,\x200.7152,\x200.0722\x20);\x0a\x09return\x20dot(\x20weights,\x20color.rgb\x20);\x0a}\x0abool\x20isPerspectiveMatrix(\x20mat4\x20m\x20)\x20{\x0a\x20\x20return\x20m[\x202\x20][\x203\x20]\x20==\x20-\x201.0;\x0a}\x0avec2\x20equirectUv(\x20in\x20vec3\x20dir\x20)\x20{\x0a\x09float\x20u\x20=\x20atan(\x20dir.z,\x20dir.x\x20)\x20*\x20RECIPROCAL_PI2\x20+\x200.5;\x0a\x09float\x20v\x20=\x20asin(\x20clamp(\x20dir.y,\x20-\x201.0,\x201.0\x20)\x20)\x20*\x20RECIPROCAL_PI\x20+\x200.5;\x0a\x09return\x20vec2(\x20u,\x20v\x20);\x0a}",
                    cube_uv_reflection_fragment:
                        "#ifdef\x20ENVMAP_TYPE_CUBE_UV\x0a#define\x20cubeUV_maxMipLevel\x208.0\x0a#define\x20cubeUV_minMipLevel\x204.0\x0a#define\x20cubeUV_maxTileSize\x20256.0\x0a#define\x20cubeUV_minTileSize\x2016.0\x0afloat\x20getFace(vec3\x20direction)\x20{\x0a\x20\x20\x20\x20vec3\x20absDirection\x20=\x20abs(direction);\x0a\x20\x20\x20\x20float\x20face\x20=\x20-1.0;\x0a\x20\x20\x20\x20if\x20(absDirection.x\x20>\x20absDirection.z)\x20{\x0a\x20\x20\x20\x20\x20\x20if\x20(absDirection.x\x20>\x20absDirection.y)\x0a\x20\x20\x20\x20\x20\x20\x20\x20face\x20=\x20direction.x\x20>\x200.0\x20?\x200.0\x20:\x203.0;\x0a\x20\x20\x20\x20\x20\x20else\x0a\x20\x20\x20\x20\x20\x20\x20\x20face\x20=\x20direction.y\x20>\x200.0\x20?\x201.0\x20:\x204.0;\x0a\x20\x20\x20\x20}\x20else\x20{\x0a\x20\x20\x20\x20\x20\x20if\x20(absDirection.z\x20>\x20absDirection.y)\x0a\x20\x20\x20\x20\x20\x20\x20\x20face\x20=\x20direction.z\x20>\x200.0\x20?\x202.0\x20:\x205.0;\x0a\x20\x20\x20\x20\x20\x20else\x0a\x20\x20\x20\x20\x20\x20\x20\x20face\x20=\x20direction.y\x20>\x200.0\x20?\x201.0\x20:\x204.0;\x0a\x20\x20\x20\x20}\x0a\x20\x20\x20\x20return\x20face;\x0a}\x0avec2\x20getUV(vec3\x20direction,\x20float\x20face)\x20{\x0a\x20\x20\x20\x20vec2\x20uv;\x0a\x20\x20\x20\x20if\x20(face\x20==\x200.0)\x20{\x0a\x20\x20\x20\x20\x20\x20uv\x20=\x20vec2(direction.z,\x20direction.y)\x20/\x20abs(direction.x);\x20\x20\x20\x20}\x20else\x20if\x20(face\x20==\x201.0)\x20{\x0a\x20\x20\x20\x20\x20\x20uv\x20=\x20vec2(-direction.x,\x20-direction.z)\x20/\x20abs(direction.y);\x20\x20\x20\x20}\x20else\x20if\x20(face\x20==\x202.0)\x20{\x0a\x20\x20\x20\x20\x20\x20uv\x20=\x20vec2(-direction.x,\x20direction.y)\x20/\x20abs(direction.z);\x20\x20\x20\x20}\x20else\x20if\x20(face\x20==\x203.0)\x20{\x0a\x20\x20\x20\x20\x20\x20uv\x20=\x20vec2(-direction.z,\x20direction.y)\x20/\x20abs(direction.x);\x20\x20\x20\x20}\x20else\x20if\x20(face\x20==\x204.0)\x20{\x0a\x20\x20\x20\x20\x20\x20uv\x20=\x20vec2(-direction.x,\x20direction.z)\x20/\x20abs(direction.y);\x20\x20\x20\x20}\x20else\x20{\x0a\x20\x20\x20\x20\x20\x20uv\x20=\x20vec2(direction.x,\x20direction.y)\x20/\x20abs(direction.z);\x20\x20\x20\x20}\x0a\x20\x20\x20\x20return\x200.5\x20*\x20(uv\x20+\x201.0);\x0a}\x0avec3\x20bilinearCubeUV(sampler2D\x20envMap,\x20vec3\x20direction,\x20float\x20mipInt)\x20{\x0a\x20\x20float\x20face\x20=\x20getFace(direction);\x0a\x20\x20float\x20filterInt\x20=\x20max(cubeUV_minMipLevel\x20-\x20mipInt,\x200.0);\x0a\x20\x20mipInt\x20=\x20max(mipInt,\x20cubeUV_minMipLevel);\x0a\x20\x20float\x20faceSize\x20=\x20exp2(mipInt);\x0a\x20\x20float\x20texelSize\x20=\x201.0\x20/\x20(3.0\x20*\x20cubeUV_maxTileSize);\x0a\x20\x20vec2\x20uv\x20=\x20getUV(direction,\x20face)\x20*\x20(faceSize\x20-\x201.0);\x0a\x20\x20vec2\x20f\x20=\x20fract(uv);\x0a\x20\x20uv\x20+=\x200.5\x20-\x20f;\x0a\x20\x20if\x20(face\x20>\x202.0)\x20{\x0a\x20\x20\x20\x20uv.y\x20+=\x20faceSize;\x0a\x20\x20\x20\x20face\x20-=\x203.0;\x0a\x20\x20}\x0a\x20\x20uv.x\x20+=\x20face\x20*\x20faceSize;\x0a\x20\x20if(mipInt\x20<\x20cubeUV_maxMipLevel){\x0a\x20\x20\x20\x20uv.y\x20+=\x202.0\x20*\x20cubeUV_maxTileSize;\x0a\x20\x20}\x0a\x20\x20uv.y\x20+=\x20filterInt\x20*\x202.0\x20*\x20cubeUV_minTileSize;\x0a\x20\x20uv.x\x20+=\x203.0\x20*\x20max(0.0,\x20cubeUV_maxTileSize\x20-\x202.0\x20*\x20faceSize);\x0a\x20\x20uv\x20*=\x20texelSize;\x0a\x20\x20vec3\x20tl\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x20\x20uv.x\x20+=\x20texelSize;\x0a\x20\x20vec3\x20tr\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x20\x20uv.y\x20+=\x20texelSize;\x0a\x20\x20vec3\x20br\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x20\x20uv.x\x20-=\x20texelSize;\x0a\x20\x20vec3\x20bl\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x20\x20vec3\x20tm\x20=\x20mix(tl,\x20tr,\x20f.x);\x0a\x20\x20vec3\x20bm\x20=\x20mix(bl,\x20br,\x20f.x);\x0a\x20\x20return\x20mix(tm,\x20bm,\x20f.y);\x0a}\x0a#define\x20r0\x201.0\x0a#define\x20v0\x200.339\x0a#define\x20m0\x20-2.0\x0a#define\x20r1\x200.8\x0a#define\x20v1\x200.276\x0a#define\x20m1\x20-1.0\x0a#define\x20r4\x200.4\x0a#define\x20v4\x200.046\x0a#define\x20m4\x202.0\x0a#define\x20r5\x200.305\x0a#define\x20v5\x200.016\x0a#define\x20m5\x203.0\x0a#define\x20r6\x200.21\x0a#define\x20v6\x200.0038\x0a#define\x20m6\x204.0\x0afloat\x20roughnessToMip(float\x20roughness)\x20{\x0a\x20\x20float\x20mip\x20=\x200.0;\x0a\x20\x20if\x20(roughness\x20>=\x20r1)\x20{\x0a\x20\x20\x20\x20mip\x20=\x20(r0\x20-\x20roughness)\x20*\x20(m1\x20-\x20m0)\x20/\x20(r0\x20-\x20r1)\x20+\x20m0;\x0a\x20\x20}\x20else\x20if\x20(roughness\x20>=\x20r4)\x20{\x0a\x20\x20\x20\x20mip\x20=\x20(r1\x20-\x20roughness)\x20*\x20(m4\x20-\x20m1)\x20/\x20(r1\x20-\x20r4)\x20+\x20m1;\x0a\x20\x20}\x20else\x20if\x20(roughness\x20>=\x20r5)\x20{\x0a\x20\x20\x20\x20mip\x20=\x20(r4\x20-\x20roughness)\x20*\x20(m5\x20-\x20m4)\x20/\x20(r4\x20-\x20r5)\x20+\x20m4;\x0a\x20\x20}\x20else\x20if\x20(roughness\x20>=\x20r6)\x20{\x0a\x20\x20\x20\x20mip\x20=\x20(r5\x20-\x20roughness)\x20*\x20(m6\x20-\x20m5)\x20/\x20(r5\x20-\x20r6)\x20+\x20m5;\x0a\x20\x20}\x20else\x20{\x0a\x20\x20\x20\x20mip\x20=\x20-2.0\x20*\x20log2(1.16\x20*\x20roughness);\x20\x20}\x0a\x20\x20return\x20mip;\x0a}\x0avec4\x20textureCubeUV(sampler2D\x20envMap,\x20vec3\x20sampleDir,\x20float\x20roughness)\x20{\x0a\x20\x20float\x20mip\x20=\x20clamp(roughnessToMip(roughness),\x20m0,\x20cubeUV_maxMipLevel);\x0a\x20\x20float\x20mipF\x20=\x20fract(mip);\x0a\x20\x20float\x20mipInt\x20=\x20floor(mip);\x0a\x20\x20vec3\x20color0\x20=\x20bilinearCubeUV(envMap,\x20sampleDir,\x20mipInt);\x0a\x20\x20if\x20(mipF\x20==\x200.0)\x20{\x0a\x20\x20\x20\x20return\x20vec4(color0,\x201.0);\x0a\x20\x20}\x20else\x20{\x0a\x20\x20\x20\x20vec3\x20color1\x20=\x20bilinearCubeUV(envMap,\x20sampleDir,\x20mipInt\x20+\x201.0);\x0a\x20\x20\x20\x20return\x20vec4(mix(color0,\x20color1,\x20mipF),\x201.0);\x0a\x20\x20}\x0a}\x0a#endif",
                    defaultnormal_vertex:
                        "vec3\x20transformedNormal\x20=\x20objectNormal;\x0a#ifdef\x20USE_INSTANCING\x0a\x09mat3\x20m\x20=\x20mat3(\x20instanceMatrix\x20);\x0a\x09transformedNormal\x20/=\x20vec3(\x20dot(\x20m[\x200\x20],\x20m[\x200\x20]\x20),\x20dot(\x20m[\x201\x20],\x20m[\x201\x20]\x20),\x20dot(\x20m[\x202\x20],\x20m[\x202\x20]\x20)\x20);\x0a\x09transformedNormal\x20=\x20m\x20*\x20transformedNormal;\x0a#endif\x0atransformedNormal\x20=\x20normalMatrix\x20*\x20transformedNormal;\x0a#ifdef\x20FLIP_SIDED\x0a\x09transformedNormal\x20=\x20-\x20transformedNormal;\x0a#endif\x0a#ifdef\x20USE_TANGENT\x0a\x09vec3\x20transformedTangent\x20=\x20(\x20modelViewMatrix\x20*\x20vec4(\x20objectTangent,\x200.0\x20)\x20).xyz;\x0a\x09#ifdef\x20FLIP_SIDED\x0a\x09\x09transformedTangent\x20=\x20-\x20transformedTangent;\x0a\x09#endif\x0a#endif",
                    displacementmap_pars_vertex: "#ifdef\x20USE_DISPLACEMENTMAP\x0a\x09uniform\x20sampler2D\x20displacementMap;\x0a\x09uniform\x20float\x20displacementScale;\x0a\x09uniform\x20float\x20displacementBias;\x0a#endif",
                    displacementmap_vertex:
                        "#ifdef\x20USE_DISPLACEMENTMAP\x0a\x09transformed\x20+=\x20normalize(\x20objectNormal\x20)\x20*\x20(\x20texture2D(\x20displacementMap,\x20vUv\x20).x\x20*\x20displacementScale\x20+\x20displacementBias\x20);\x0a#endif",
                    emissivemap_fragment:
                        "#ifdef\x20USE_EMISSIVEMAP\x0a\x09vec4\x20emissiveColor\x20=\x20texture2D(\x20emissiveMap,\x20vUv\x20);\x0a\x09emissiveColor.rgb\x20=\x20emissiveMapTexelToLinear(\x20emissiveColor\x20).rgb;\x0a\x09totalEmissiveRadiance\x20*=\x20emissiveColor.rgb;\x0a#endif",
                    emissivemap_pars_fragment: "#ifdef\x20USE_EMISSIVEMAP\x0a\x09uniform\x20sampler2D\x20emissiveMap;\x0a#endif",
                    encodings_fragment: "gl_FragColor\x20=\x20linearToOutputTexel(\x20gl_FragColor\x20);",
                    encodings_pars_fragment:
                        "\x0avec4\x20LinearToLinear(\x20in\x20vec4\x20value\x20)\x20{\x0a\x09return\x20value;\x0a}\x0avec4\x20GammaToLinear(\x20in\x20vec4\x20value,\x20in\x20float\x20gammaFactor\x20)\x20{\x0a\x09return\x20vec4(\x20pow(\x20value.rgb,\x20vec3(\x20gammaFactor\x20)\x20),\x20value.a\x20);\x0a}\x0avec4\x20LinearToGamma(\x20in\x20vec4\x20value,\x20in\x20float\x20gammaFactor\x20)\x20{\x0a\x09return\x20vec4(\x20pow(\x20value.rgb,\x20vec3(\x201.0\x20/\x20gammaFactor\x20)\x20),\x20value.a\x20);\x0a}\x0avec4\x20sRGBToLinear(\x20in\x20vec4\x20value\x20)\x20{\x0a\x09return\x20vec4(\x20mix(\x20pow(\x20value.rgb\x20*\x200.9478672986\x20+\x20vec3(\x200.0521327014\x20),\x20vec3(\x202.4\x20)\x20),\x20value.rgb\x20*\x200.0773993808,\x20vec3(\x20lessThanEqual(\x20value.rgb,\x20vec3(\x200.04045\x20)\x20)\x20)\x20),\x20value.a\x20);\x0a}\x0avec4\x20LinearTosRGB(\x20in\x20vec4\x20value\x20)\x20{\x0a\x09return\x20vec4(\x20mix(\x20pow(\x20value.rgb,\x20vec3(\x200.41666\x20)\x20)\x20*\x201.055\x20-\x20vec3(\x200.055\x20),\x20value.rgb\x20*\x2012.92,\x20vec3(\x20lessThanEqual(\x20value.rgb,\x20vec3(\x200.0031308\x20)\x20)\x20)\x20),\x20value.a\x20);\x0a}\x0avec4\x20RGBEToLinear(\x20in\x20vec4\x20value\x20)\x20{\x0a\x09return\x20vec4(\x20value.rgb\x20*\x20exp2(\x20value.a\x20*\x20255.0\x20-\x20128.0\x20),\x201.0\x20);\x0a}\x0avec4\x20LinearToRGBE(\x20in\x20vec4\x20value\x20)\x20{\x0a\x09float\x20maxComponent\x20=\x20max(\x20max(\x20value.r,\x20value.g\x20),\x20value.b\x20);\x0a\x09float\x20fExp\x20=\x20clamp(\x20ceil(\x20log2(\x20maxComponent\x20)\x20),\x20-128.0,\x20127.0\x20);\x0a\x09return\x20vec4(\x20value.rgb\x20/\x20exp2(\x20fExp\x20),\x20(\x20fExp\x20+\x20128.0\x20)\x20/\x20255.0\x20);\x0a}\x0avec4\x20RGBMToLinear(\x20in\x20vec4\x20value,\x20in\x20float\x20maxRange\x20)\x20{\x0a\x09return\x20vec4(\x20value.rgb\x20*\x20value.a\x20*\x20maxRange,\x201.0\x20);\x0a}\x0avec4\x20LinearToRGBM(\x20in\x20vec4\x20value,\x20in\x20float\x20maxRange\x20)\x20{\x0a\x09float\x20maxRGB\x20=\x20max(\x20value.r,\x20max(\x20value.g,\x20value.b\x20)\x20);\x0a\x09float\x20M\x20=\x20clamp(\x20maxRGB\x20/\x20maxRange,\x200.0,\x201.0\x20);\x0a\x09M\x20=\x20ceil(\x20M\x20*\x20255.0\x20)\x20/\x20255.0;\x0a\x09return\x20vec4(\x20value.rgb\x20/\x20(\x20M\x20*\x20maxRange\x20),\x20M\x20);\x0a}\x0avec4\x20RGBDToLinear(\x20in\x20vec4\x20value,\x20in\x20float\x20maxRange\x20)\x20{\x0a\x09return\x20vec4(\x20value.rgb\x20*\x20(\x20(\x20maxRange\x20/\x20255.0\x20)\x20/\x20value.a\x20),\x201.0\x20);\x0a}\x0avec4\x20LinearToRGBD(\x20in\x20vec4\x20value,\x20in\x20float\x20maxRange\x20)\x20{\x0a\x09float\x20maxRGB\x20=\x20max(\x20value.r,\x20max(\x20value.g,\x20value.b\x20)\x20);\x0a\x09float\x20D\x20=\x20max(\x20maxRange\x20/\x20maxRGB,\x201.0\x20);\x0a\x09D\x20=\x20clamp(\x20floor(\x20D\x20)\x20/\x20255.0,\x200.0,\x201.0\x20);\x0a\x09return\x20vec4(\x20value.rgb\x20*\x20(\x20D\x20*\x20(\x20255.0\x20/\x20maxRange\x20)\x20),\x20D\x20);\x0a}\x0aconst\x20mat3\x20cLogLuvM\x20=\x20mat3(\x200.2209,\x200.3390,\x200.4184,\x200.1138,\x200.6780,\x200.7319,\x200.0102,\x200.1130,\x200.2969\x20);\x0avec4\x20LinearToLogLuv(\x20in\x20vec4\x20value\x20)\x20\x20{\x0a\x09vec3\x20Xp_Y_XYZp\x20=\x20cLogLuvM\x20*\x20value.rgb;\x0a\x09Xp_Y_XYZp\x20=\x20max(\x20Xp_Y_XYZp,\x20vec3(\x201e-6,\x201e-6,\x201e-6\x20)\x20);\x0a\x09vec4\x20vResult;\x0a\x09vResult.xy\x20=\x20Xp_Y_XYZp.xy\x20/\x20Xp_Y_XYZp.z;\x0a\x09float\x20Le\x20=\x202.0\x20*\x20log2(Xp_Y_XYZp.y)\x20+\x20127.0;\x0a\x09vResult.w\x20=\x20fract(\x20Le\x20);\x0a\x09vResult.z\x20=\x20(\x20Le\x20-\x20(\x20floor(\x20vResult.w\x20*\x20255.0\x20)\x20)\x20/\x20255.0\x20)\x20/\x20255.0;\x0a\x09return\x20vResult;\x0a}\x0aconst\x20mat3\x20cLogLuvInverseM\x20=\x20mat3(\x206.0014,\x20-2.7008,\x20-1.7996,\x20-1.3320,\x203.1029,\x20-5.7721,\x200.3008,\x20-1.0882,\x205.6268\x20);\x0avec4\x20LogLuvToLinear(\x20in\x20vec4\x20value\x20)\x20{\x0a\x09float\x20Le\x20=\x20value.z\x20*\x20255.0\x20+\x20value.w;\x0a\x09vec3\x20Xp_Y_XYZp;\x0a\x09Xp_Y_XYZp.y\x20=\x20exp2(\x20(\x20Le\x20-\x20127.0\x20)\x20/\x202.0\x20);\x0a\x09Xp_Y_XYZp.z\x20=\x20Xp_Y_XYZp.y\x20/\x20value.y;\x0a\x09Xp_Y_XYZp.x\x20=\x20value.x\x20*\x20Xp_Y_XYZp.z;\x0a\x09vec3\x20vRGB\x20=\x20cLogLuvInverseM\x20*\x20Xp_Y_XYZp.rgb;\x0a\x09return\x20vec4(\x20max(\x20vRGB,\x200.0\x20),\x201.0\x20);\x0a}",
                    envmap_fragment:
                        "#ifdef\x20USE_ENVMAP\x0a\x09#ifdef\x20ENV_WORLDPOS\x0a\x09\x09vec3\x20cameraToFrag;\x0a\x09\x09\x0a\x09\x09if\x20(\x20isOrthographic\x20)\x20{\x0a\x09\x09\x09cameraToFrag\x20=\x20normalize(\x20vec3(\x20-\x20viewMatrix[\x200\x20][\x202\x20],\x20-\x20viewMatrix[\x201\x20][\x202\x20],\x20-\x20viewMatrix[\x202\x20][\x202\x20]\x20)\x20);\x0a\x09\x09}\x20\x20else\x20{\x0a\x09\x09\x09cameraToFrag\x20=\x20normalize(\x20vWorldPosition\x20-\x20cameraPosition\x20);\x0a\x09\x09}\x0a\x09\x09vec3\x20worldNormal\x20=\x20inverseTransformDirection(\x20normal,\x20viewMatrix\x20);\x0a\x09\x09#ifdef\x20ENVMAP_MODE_REFLECTION\x0a\x09\x09\x09vec3\x20reflectVec\x20=\x20reflect(\x20cameraToFrag,\x20worldNormal\x20);\x0a\x09\x09#else\x0a\x09\x09\x09vec3\x20reflectVec\x20=\x20refract(\x20cameraToFrag,\x20worldNormal,\x20refractionRatio\x20);\x0a\x09\x09#endif\x0a\x09#else\x0a\x09\x09vec3\x20reflectVec\x20=\x20vReflect;\x0a\x09#endif\x0a\x09#ifdef\x20ENVMAP_TYPE_CUBE\x0a\x09\x09vec4\x20envColor\x20=\x20textureCube(\x20envMap,\x20vec3(\x20flipEnvMap\x20*\x20reflectVec.x,\x20reflectVec.yz\x20)\x20);\x0a\x09#elif\x20defined(\x20ENVMAP_TYPE_CUBE_UV\x20)\x0a\x09\x09vec4\x20envColor\x20=\x20textureCubeUV(\x20envMap,\x20reflectVec,\x200.0\x20);\x0a\x09#elif\x20defined(\x20ENVMAP_TYPE_EQUIREC\x20)\x0a\x09\x09reflectVec\x20=\x20normalize(\x20reflectVec\x20);\x0a\x09\x09vec2\x20sampleUV\x20=\x20equirectUv(\x20reflectVec\x20);\x0a\x09\x09vec4\x20envColor\x20=\x20texture2D(\x20envMap,\x20sampleUV\x20);\x0a\x09#elif\x20defined(\x20ENVMAP_TYPE_SPHERE\x20)\x0a\x09\x09reflectVec\x20=\x20normalize(\x20reflectVec\x20);\x0a\x09\x09vec3\x20reflectView\x20=\x20normalize(\x20(\x20viewMatrix\x20*\x20vec4(\x20reflectVec,\x200.0\x20)\x20).xyz\x20+\x20vec3(\x200.0,\x200.0,\x201.0\x20)\x20);\x0a\x09\x09vec4\x20envColor\x20=\x20texture2D(\x20envMap,\x20reflectView.xy\x20*\x200.5\x20+\x200.5\x20);\x0a\x09#else\x0a\x09\x09vec4\x20envColor\x20=\x20vec4(\x200.0\x20);\x0a\x09#endif\x0a\x09#ifndef\x20ENVMAP_TYPE_CUBE_UV\x0a\x09\x09envColor\x20=\x20envMapTexelToLinear(\x20envColor\x20);\x0a\x09#endif\x0a\x09#ifdef\x20ENVMAP_BLENDING_MULTIPLY\x0a\x09\x09outgoingLight\x20=\x20mix(\x20outgoingLight,\x20outgoingLight\x20*\x20envColor.xyz,\x20specularStrength\x20*\x20reflectivity\x20);\x0a\x09#elif\x20defined(\x20ENVMAP_BLENDING_MIX\x20)\x0a\x09\x09outgoingLight\x20=\x20mix(\x20outgoingLight,\x20envColor.xyz,\x20specularStrength\x20*\x20reflectivity\x20);\x0a\x09#elif\x20defined(\x20ENVMAP_BLENDING_ADD\x20)\x0a\x09\x09outgoingLight\x20+=\x20envColor.xyz\x20*\x20specularStrength\x20*\x20reflectivity;\x0a\x09#endif\x0a#endif",
                    envmap_common_pars_fragment:
                        "#ifdef\x20USE_ENVMAP\x0a\x09uniform\x20float\x20envMapIntensity;\x0a\x09uniform\x20float\x20flipEnvMap;\x0a\x09uniform\x20int\x20maxMipLevel;\x0a\x09#ifdef\x20ENVMAP_TYPE_CUBE\x0a\x09\x09uniform\x20samplerCube\x20envMap;\x0a\x09#else\x0a\x09\x09uniform\x20sampler2D\x20envMap;\x0a\x09#endif\x0a\x09\x0a#endif",
                    envmap_pars_fragment:
                        "#ifdef\x20USE_ENVMAP\x0a\x09uniform\x20float\x20reflectivity;\x0a\x09#if\x20defined(\x20USE_BUMPMAP\x20)\x20||\x20defined(\x20USE_NORMALMAP\x20)\x20||\x20defined(\x20PHONG\x20)\x0a\x09\x09#define\x20ENV_WORLDPOS\x0a\x09#endif\x0a\x09#ifdef\x20ENV_WORLDPOS\x0a\x09\x09varying\x20vec3\x20vWorldPosition;\x0a\x09\x09uniform\x20float\x20refractionRatio;\x0a\x09#else\x0a\x09\x09varying\x20vec3\x20vReflect;\x0a\x09#endif\x0a#endif",
                    envmap_pars_vertex:
                        "#ifdef\x20USE_ENVMAP\x0a\x09#if\x20defined(\x20USE_BUMPMAP\x20)\x20||\x20defined(\x20USE_NORMALMAP\x20)\x20||defined(\x20PHONG\x20)\x0a\x09\x09#define\x20ENV_WORLDPOS\x0a\x09#endif\x0a\x09#ifdef\x20ENV_WORLDPOS\x0a\x09\x09\x0a\x09\x09varying\x20vec3\x20vWorldPosition;\x0a\x09#else\x0a\x09\x09varying\x20vec3\x20vReflect;\x0a\x09\x09uniform\x20float\x20refractionRatio;\x0a\x09#endif\x0a#endif",
                    envmap_physical_pars_fragment:
                        "#if\x20defined(\x20USE_ENVMAP\x20)\x0a\x09#ifdef\x20ENVMAP_MODE_REFRACTION\x0a\x09\x09uniform\x20float\x20refractionRatio;\x0a\x09#endif\x0a\x09vec3\x20getLightProbeIndirectIrradiance(\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20int\x20maxMIPLevel\x20)\x20{\x0a\x09\x09vec3\x20worldNormal\x20=\x20inverseTransformDirection(\x20geometry.normal,\x20viewMatrix\x20);\x0a\x09\x09#ifdef\x20ENVMAP_TYPE_CUBE\x0a\x09\x09\x09vec3\x20queryVec\x20=\x20vec3(\x20flipEnvMap\x20*\x20worldNormal.x,\x20worldNormal.yz\x20);\x0a\x09\x09\x09#ifdef\x20TEXTURE_LOD_EXT\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20textureCubeLodEXT(\x20envMap,\x20queryVec,\x20float(\x20maxMIPLevel\x20)\x20);\x0a\x09\x09\x09#else\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20textureCube(\x20envMap,\x20queryVec,\x20float(\x20maxMIPLevel\x20)\x20);\x0a\x09\x09\x09#endif\x0a\x09\x09\x09envMapColor.rgb\x20=\x20envMapTexelToLinear(\x20envMapColor\x20).rgb;\x0a\x09\x09#elif\x20defined(\x20ENVMAP_TYPE_CUBE_UV\x20)\x0a\x09\x09\x09vec4\x20envMapColor\x20=\x20textureCubeUV(\x20envMap,\x20worldNormal,\x201.0\x20);\x0a\x09\x09#else\x0a\x09\x09\x09vec4\x20envMapColor\x20=\x20vec4(\x200.0\x20);\x0a\x09\x09#endif\x0a\x09\x09return\x20PI\x20*\x20envMapColor.rgb\x20*\x20envMapIntensity;\x0a\x09}\x0a\x09float\x20getSpecularMIPLevel(\x20const\x20in\x20float\x20roughness,\x20const\x20in\x20int\x20maxMIPLevel\x20)\x20{\x0a\x09\x09float\x20maxMIPLevelScalar\x20=\x20float(\x20maxMIPLevel\x20);\x0a\x09\x09float\x20sigma\x20=\x20PI\x20*\x20roughness\x20*\x20roughness\x20/\x20(\x201.0\x20+\x20roughness\x20);\x0a\x09\x09float\x20desiredMIPLevel\x20=\x20maxMIPLevelScalar\x20+\x20log2(\x20sigma\x20);\x0a\x09\x09return\x20clamp(\x20desiredMIPLevel,\x200.0,\x20maxMIPLevelScalar\x20);\x0a\x09}\x0a\x09vec3\x20getLightProbeIndirectRadiance(\x20const\x20in\x20vec3\x20viewDir,\x20const\x20in\x20vec3\x20normal,\x20const\x20in\x20float\x20roughness,\x20const\x20in\x20int\x20maxMIPLevel\x20)\x20{\x0a\x09\x09#ifdef\x20ENVMAP_MODE_REFLECTION\x0a\x09\x09\x20\x20vec3\x20reflectVec\x20=\x20reflect(\x20-viewDir,\x20normal\x20);\x0a\x09\x09\x20\x20reflectVec\x20=\x20normalize(\x20mix(\x20reflectVec,\x20normal,\x20roughness\x20*\x20roughness)\x20);\x0a\x09\x09#else\x0a\x09\x09\x20\x20vec3\x20reflectVec\x20=\x20refract(\x20-viewDir,\x20normal,\x20refractionRatio\x20);\x0a\x09\x09#endif\x0a\x09\x09reflectVec\x20=\x20inverseTransformDirection(\x20reflectVec,\x20viewMatrix\x20);\x0a\x09\x09float\x20specularMIPLevel\x20=\x20getSpecularMIPLevel(\x20roughness,\x20maxMIPLevel\x20);\x0a\x09\x09#ifdef\x20ENVMAP_TYPE_CUBE\x0a\x09\x09\x09vec3\x20queryReflectVec\x20=\x20vec3(\x20flipEnvMap\x20*\x20reflectVec.x,\x20reflectVec.yz\x20);\x0a\x09\x09\x09#ifdef\x20TEXTURE_LOD_EXT\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20textureCubeLodEXT(\x20envMap,\x20queryReflectVec,\x20specularMIPLevel\x20);\x0a\x09\x09\x09#else\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20textureCube(\x20envMap,\x20queryReflectVec,\x20specularMIPLevel\x20);\x0a\x09\x09\x09#endif\x0a\x09\x09\x09envMapColor.rgb\x20=\x20envMapTexelToLinear(\x20envMapColor\x20).rgb;\x0a\x09\x09#elif\x20defined(\x20ENVMAP_TYPE_CUBE_UV\x20)\x0a\x09\x09\x09vec4\x20envMapColor\x20=\x20textureCubeUV(\x20envMap,\x20reflectVec,\x20roughness\x20);\x0a\x09\x09#elif\x20defined(\x20ENVMAP_TYPE_EQUIREC\x20)\x0a\x09\x09\x09vec2\x20sampleUV\x20=\x20equirectUv(\x20reflectVec\x20);\x0a\x09\x09\x09#ifdef\x20TEXTURE_LOD_EXT\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20texture2DLodEXT(\x20envMap,\x20sampleUV,\x20specularMIPLevel\x20);\x0a\x09\x09\x09#else\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20texture2D(\x20envMap,\x20sampleUV,\x20specularMIPLevel\x20);\x0a\x09\x09\x09#endif\x0a\x09\x09\x09envMapColor.rgb\x20=\x20envMapTexelToLinear(\x20envMapColor\x20).rgb;\x0a\x09\x09#elif\x20defined(\x20ENVMAP_TYPE_SPHERE\x20)\x0a\x09\x09\x09vec3\x20reflectView\x20=\x20normalize(\x20(\x20viewMatrix\x20*\x20vec4(\x20reflectVec,\x200.0\x20)\x20).xyz\x20+\x20vec3(\x200.0,0.0,1.0\x20)\x20);\x0a\x09\x09\x09#ifdef\x20TEXTURE_LOD_EXT\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20texture2DLodEXT(\x20envMap,\x20reflectView.xy\x20*\x200.5\x20+\x200.5,\x20specularMIPLevel\x20);\x0a\x09\x09\x09#else\x0a\x09\x09\x09\x09vec4\x20envMapColor\x20=\x20texture2D(\x20envMap,\x20reflectView.xy\x20*\x200.5\x20+\x200.5,\x20specularMIPLevel\x20);\x0a\x09\x09\x09#endif\x0a\x09\x09\x09envMapColor.rgb\x20=\x20envMapTexelToLinear(\x20envMapColor\x20).rgb;\x0a\x09\x09#endif\x0a\x09\x09return\x20envMapColor.rgb\x20*\x20envMapIntensity;\x0a\x09}\x0a#endif",
                    envmap_vertex:
                        "#ifdef\x20USE_ENVMAP\x0a\x09#ifdef\x20ENV_WORLDPOS\x0a\x09\x09vWorldPosition\x20=\x20worldPosition.xyz;\x0a\x09#else\x0a\x09\x09vec3\x20cameraToVertex;\x0a\x09\x09if\x20(\x20isOrthographic\x20)\x20{\x20\x0a\x09\x09\x09cameraToVertex\x20=\x20normalize(\x20vec3(\x20-\x20viewMatrix[\x200\x20][\x202\x20],\x20-\x20viewMatrix[\x201\x20][\x202\x20],\x20-\x20viewMatrix[\x202\x20][\x202\x20]\x20)\x20);\x0a\x09\x09}\x20else\x20{\x0a\x09\x09\x09cameraToVertex\x20=\x20normalize(\x20worldPosition.xyz\x20-\x20cameraPosition\x20);\x0a\x09\x09}\x0a\x09\x09vec3\x20worldNormal\x20=\x20inverseTransformDirection(\x20transformedNormal,\x20viewMatrix\x20);\x0a\x09\x09#ifdef\x20ENVMAP_MODE_REFLECTION\x0a\x09\x09\x09vReflect\x20=\x20reflect(\x20cameraToVertex,\x20worldNormal\x20);\x0a\x09\x09#else\x0a\x09\x09\x09vReflect\x20=\x20refract(\x20cameraToVertex,\x20worldNormal,\x20refractionRatio\x20);\x0a\x09\x09#endif\x0a\x09#endif\x0a#endif",
                    fog_vertex: "#ifdef\x20USE_FOG\x0a\x09fogDepth\x20=\x20-mvPosition.z;\x0a#endif",
                    fog_pars_vertex: "#ifdef\x20USE_FOG\x0a\x09varying\x20float\x20fogDepth;\x0a#endif",
                    fog_fragment:
                        "#ifdef\x20USE_FOG\x0a\x09#ifdef\x20FOG_EXP2\x0a\x09\x09float\x20fogFactor\x20=\x201.0\x20-\x20exp(\x20-\x20fogDensity\x20*\x20fogDensity\x20*\x20fogDepth\x20*\x20fogDepth\x20);\x0a\x09#else\x0a\x09\x09float\x20fogFactor\x20=\x20smoothstep(\x20fogNear,\x20fogFar,\x20fogDepth\x20);\x0a\x09#endif\x0a\x09gl_FragColor.rgb\x20=\x20mix(\x20gl_FragColor.rgb,\x20fogColor,\x20fogFactor\x20);\x0a#endif",
                    fog_pars_fragment:
                        "#ifdef\x20USE_FOG\x0a\x09uniform\x20vec3\x20fogColor;\x0a\x09varying\x20float\x20fogDepth;\x0a\x09#ifdef\x20FOG_EXP2\x0a\x09\x09uniform\x20float\x20fogDensity;\x0a\x09#else\x0a\x09\x09uniform\x20float\x20fogNear;\x0a\x09\x09uniform\x20float\x20fogFar;\x0a\x09#endif\x0a#endif",
                    gradientmap_pars_fragment:
                        "#ifdef\x20USE_GRADIENTMAP\x0a\x09uniform\x20sampler2D\x20gradientMap;\x0a#endif\x0avec3\x20getGradientIrradiance(\x20vec3\x20normal,\x20vec3\x20lightDirection\x20)\x20{\x0a\x09float\x20dotNL\x20=\x20dot(\x20normal,\x20lightDirection\x20);\x0a\x09vec2\x20coord\x20=\x20vec2(\x20dotNL\x20*\x200.5\x20+\x200.5,\x200.0\x20);\x0a\x09#ifdef\x20USE_GRADIENTMAP\x0a\x09\x09return\x20texture2D(\x20gradientMap,\x20coord\x20).rgb;\x0a\x09#else\x0a\x09\x09return\x20(\x20coord.x\x20<\x200.7\x20)\x20?\x20vec3(\x200.7\x20)\x20:\x20vec3(\x201.0\x20);\x0a\x09#endif\x0a}",
                    lightmap_fragment:
                        "#ifdef\x20USE_LIGHTMAP\x0a\x09vec4\x20lightMapTexel=\x20texture2D(\x20lightMap,\x20vUv2\x20);\x0a\x09reflectedLight.indirectDiffuse\x20+=\x20PI\x20*\x20lightMapTexelToLinear(\x20lightMapTexel\x20).rgb\x20*\x20lightMapIntensity;\x0a#endif",
                    lightmap_pars_fragment: "#ifdef\x20USE_LIGHTMAP\x0a\x09uniform\x20sampler2D\x20lightMap;\x0a\x09uniform\x20float\x20lightMapIntensity;\x0a#endif",
                    lights_lambert_vertex:
                        "vec3\x20diffuse\x20=\x20vec3(\x201.0\x20);\x0aGeometricContext\x20geometry;\x0ageometry.position\x20=\x20mvPosition.xyz;\x0ageometry.normal\x20=\x20normalize(\x20transformedNormal\x20);\x0ageometry.viewDir\x20=\x20(\x20isOrthographic\x20)\x20?\x20vec3(\x200,\x200,\x201\x20)\x20:\x20normalize(\x20-mvPosition.xyz\x20);\x0aGeometricContext\x20backGeometry;\x0abackGeometry.position\x20=\x20geometry.position;\x0abackGeometry.normal\x20=\x20-geometry.normal;\x0abackGeometry.viewDir\x20=\x20geometry.viewDir;\x0avLightFront\x20=\x20vec3(\x200.0\x20);\x0avIndirectFront\x20=\x20vec3(\x200.0\x20);\x0a#ifdef\x20DOUBLE_SIDED\x0a\x09vLightBack\x20=\x20vec3(\x200.0\x20);\x0a\x09vIndirectBack\x20=\x20vec3(\x200.0\x20);\x0a#endif\x0aIncidentLight\x20directLight;\x0afloat\x20dotNL;\x0avec3\x20directLightColor_Diffuse;\x0avIndirectFront\x20+=\x20getAmbientLightIrradiance(\x20ambientLightColor\x20);\x0avIndirectFront\x20+=\x20getLightProbeIrradiance(\x20lightProbe,\x20geometry\x20);\x0a#ifdef\x20DOUBLE_SIDED\x0a\x09vIndirectBack\x20+=\x20getAmbientLightIrradiance(\x20ambientLightColor\x20);\x0a\x09vIndirectBack\x20+=\x20getLightProbeIrradiance(\x20lightProbe,\x20backGeometry\x20);\x0a#endif\x0a#if\x20NUM_POINT_LIGHTS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_POINT_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09getPointDirectLightIrradiance(\x20pointLights[\x20i\x20],\x20geometry,\x20directLight\x20);\x0a\x09\x09dotNL\x20=\x20dot(\x20geometry.normal,\x20directLight.direction\x20);\x0a\x09\x09directLightColor_Diffuse\x20=\x20PI\x20*\x20directLight.color;\x0a\x09\x09vLightFront\x20+=\x20saturate(\x20dotNL\x20)\x20*\x20directLightColor_Diffuse;\x0a\x09\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09\x09vLightBack\x20+=\x20saturate(\x20-dotNL\x20)\x20*\x20directLightColor_Diffuse;\x0a\x09\x09#endif\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20NUM_SPOT_LIGHTS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_SPOT_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09getSpotDirectLightIrradiance(\x20spotLights[\x20i\x20],\x20geometry,\x20directLight\x20);\x0a\x09\x09dotNL\x20=\x20dot(\x20geometry.normal,\x20directLight.direction\x20);\x0a\x09\x09directLightColor_Diffuse\x20=\x20PI\x20*\x20directLight.color;\x0a\x09\x09vLightFront\x20+=\x20saturate(\x20dotNL\x20)\x20*\x20directLightColor_Diffuse;\x0a\x09\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09\x09vLightBack\x20+=\x20saturate(\x20-dotNL\x20)\x20*\x20directLightColor_Diffuse;\x0a\x09\x09#endif\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20NUM_DIR_LIGHTS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_DIR_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09getDirectionalDirectLightIrradiance(\x20directionalLights[\x20i\x20],\x20geometry,\x20directLight\x20);\x0a\x09\x09dotNL\x20=\x20dot(\x20geometry.normal,\x20directLight.direction\x20);\x0a\x09\x09directLightColor_Diffuse\x20=\x20PI\x20*\x20directLight.color;\x0a\x09\x09vLightFront\x20+=\x20saturate(\x20dotNL\x20)\x20*\x20directLightColor_Diffuse;\x0a\x09\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09\x09vLightBack\x20+=\x20saturate(\x20-dotNL\x20)\x20*\x20directLightColor_Diffuse;\x0a\x09\x09#endif\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20NUM_HEMI_LIGHTS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_HEMI_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09vIndirectFront\x20+=\x20getHemisphereLightIrradiance(\x20hemisphereLights[\x20i\x20],\x20geometry\x20);\x0a\x09\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09\x09vIndirectBack\x20+=\x20getHemisphereLightIrradiance(\x20hemisphereLights[\x20i\x20],\x20backGeometry\x20);\x0a\x09\x09#endif\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif",
                    lights_pars_begin:
                        "uniform\x20bool\x20receiveShadow;\x0auniform\x20vec3\x20ambientLightColor;\x0auniform\x20vec3\x20lightProbe[\x209\x20];\x0avec3\x20shGetIrradianceAt(\x20in\x20vec3\x20normal,\x20in\x20vec3\x20shCoefficients[\x209\x20]\x20)\x20{\x0a\x09float\x20x\x20=\x20normal.x,\x20y\x20=\x20normal.y,\x20z\x20=\x20normal.z;\x0a\x09vec3\x20result\x20=\x20shCoefficients[\x200\x20]\x20*\x200.886227;\x0a\x09result\x20+=\x20shCoefficients[\x201\x20]\x20*\x202.0\x20*\x200.511664\x20*\x20y;\x0a\x09result\x20+=\x20shCoefficients[\x202\x20]\x20*\x202.0\x20*\x200.511664\x20*\x20z;\x0a\x09result\x20+=\x20shCoefficients[\x203\x20]\x20*\x202.0\x20*\x200.511664\x20*\x20x;\x0a\x09result\x20+=\x20shCoefficients[\x204\x20]\x20*\x202.0\x20*\x200.429043\x20*\x20x\x20*\x20y;\x0a\x09result\x20+=\x20shCoefficients[\x205\x20]\x20*\x202.0\x20*\x200.429043\x20*\x20y\x20*\x20z;\x0a\x09result\x20+=\x20shCoefficients[\x206\x20]\x20*\x20(\x200.743125\x20*\x20z\x20*\x20z\x20-\x200.247708\x20);\x0a\x09result\x20+=\x20shCoefficients[\x207\x20]\x20*\x202.0\x20*\x200.429043\x20*\x20x\x20*\x20z;\x0a\x09result\x20+=\x20shCoefficients[\x208\x20]\x20*\x200.429043\x20*\x20(\x20x\x20*\x20x\x20-\x20y\x20*\x20y\x20);\x0a\x09return\x20result;\x0a}\x0avec3\x20getLightProbeIrradiance(\x20const\x20in\x20vec3\x20lightProbe[\x209\x20],\x20const\x20in\x20GeometricContext\x20geometry\x20)\x20{\x0a\x09vec3\x20worldNormal\x20=\x20inverseTransformDirection(\x20geometry.normal,\x20viewMatrix\x20);\x0a\x09vec3\x20irradiance\x20=\x20shGetIrradianceAt(\x20worldNormal,\x20lightProbe\x20);\x0a\x09return\x20irradiance;\x0a}\x0avec3\x20getAmbientLightIrradiance(\x20const\x20in\x20vec3\x20ambientLightColor\x20)\x20{\x0a\x09vec3\x20irradiance\x20=\x20ambientLightColor;\x0a\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09irradiance\x20*=\x20PI;\x0a\x09#endif\x0a\x09return\x20irradiance;\x0a}\x0a#if\x20NUM_DIR_LIGHTS\x20>\x200\x0a\x09struct\x20DirectionalLight\x20{\x0a\x09\x09vec3\x20direction;\x0a\x09\x09vec3\x20color;\x0a\x09};\x0a\x09uniform\x20DirectionalLight\x20directionalLights[\x20NUM_DIR_LIGHTS\x20];\x0a\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20NUM_DIR_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09struct\x20DirectionalLightShadow\x20{\x0a\x09\x09\x09float\x20shadowBias;\x0a\x09\x09\x09float\x20shadowRadius;\x0a\x09\x09\x09vec2\x20shadowMapSize;\x0a\x09\x09};\x0a\x09\x09uniform\x20DirectionalLightShadow\x20directionalLightShadows[\x20NUM_DIR_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09void\x20getDirectionalDirectLightIrradiance(\x20const\x20in\x20DirectionalLight\x20directionalLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20out\x20IncidentLight\x20directLight\x20)\x20{\x0a\x09\x09directLight.color\x20=\x20directionalLight.color;\x0a\x09\x09directLight.direction\x20=\x20directionalLight.direction;\x0a\x09\x09directLight.visible\x20=\x20true;\x0a\x09}\x0a#endif\x0a#if\x20NUM_POINT_LIGHTS\x20>\x200\x0a\x09struct\x20PointLight\x20{\x0a\x09\x09vec3\x20position;\x0a\x09\x09vec3\x20color;\x0a\x09\x09float\x20distance;\x0a\x09\x09float\x20decay;\x0a\x09};\x0a\x09uniform\x20PointLight\x20pointLights[\x20NUM_POINT_LIGHTS\x20];\x0a\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20NUM_POINT_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09struct\x20PointLightShadow\x20{\x0a\x09\x09\x09float\x20shadowBias;\x0a\x09\x09\x09float\x20shadowRadius;\x0a\x09\x09\x09vec2\x20shadowMapSize;\x0a\x09\x09\x09float\x20shadowCameraNear;\x0a\x09\x09\x09float\x20shadowCameraFar;\x0a\x09\x09};\x0a\x09\x09uniform\x20PointLightShadow\x20pointLightShadows[\x20NUM_POINT_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09void\x20getPointDirectLightIrradiance(\x20const\x20in\x20PointLight\x20pointLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20out\x20IncidentLight\x20directLight\x20)\x20{\x0a\x09\x09vec3\x20lVector\x20=\x20pointLight.position\x20-\x20geometry.position;\x0a\x09\x09directLight.direction\x20=\x20normalize(\x20lVector\x20);\x0a\x09\x09float\x20lightDistance\x20=\x20length(\x20lVector\x20);\x0a\x09\x09directLight.color\x20=\x20pointLight.color;\x0a\x09\x09directLight.color\x20*=\x20punctualLightIntensityToIrradianceFactor(\x20lightDistance,\x20pointLight.distance,\x20pointLight.decay\x20);\x0a\x09\x09directLight.visible\x20=\x20(\x20directLight.color\x20!=\x20vec3(\x200.0\x20)\x20);\x0a\x09}\x0a#endif\x0a#if\x20NUM_SPOT_LIGHTS\x20>\x200\x0a\x09struct\x20SpotLight\x20{\x0a\x09\x09vec3\x20position;\x0a\x09\x09vec3\x20direction;\x0a\x09\x09vec3\x20color;\x0a\x09\x09float\x20distance;\x0a\x09\x09float\x20decay;\x0a\x09\x09float\x20coneCos;\x0a\x09\x09float\x20penumbraCos;\x0a\x09};\x0a\x09uniform\x20SpotLight\x20spotLights[\x20NUM_SPOT_LIGHTS\x20];\x0a\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20NUM_SPOT_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09struct\x20SpotLightShadow\x20{\x0a\x09\x09\x09float\x20shadowBias;\x0a\x09\x09\x09float\x20shadowRadius;\x0a\x09\x09\x09vec2\x20shadowMapSize;\x0a\x09\x09};\x0a\x09\x09uniform\x20SpotLightShadow\x20spotLightShadows[\x20NUM_SPOT_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09void\x20getSpotDirectLightIrradiance(\x20const\x20in\x20SpotLight\x20spotLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20out\x20IncidentLight\x20directLight\x20\x20)\x20{\x0a\x09\x09vec3\x20lVector\x20=\x20spotLight.position\x20-\x20geometry.position;\x0a\x09\x09directLight.direction\x20=\x20normalize(\x20lVector\x20);\x0a\x09\x09float\x20lightDistance\x20=\x20length(\x20lVector\x20);\x0a\x09\x09float\x20angleCos\x20=\x20dot(\x20directLight.direction,\x20spotLight.direction\x20);\x0a\x09\x09if\x20(\x20angleCos\x20>\x20spotLight.coneCos\x20)\x20{\x0a\x09\x09\x09float\x20spotEffect\x20=\x20smoothstep(\x20spotLight.coneCos,\x20spotLight.penumbraCos,\x20angleCos\x20);\x0a\x09\x09\x09directLight.color\x20=\x20spotLight.color;\x0a\x09\x09\x09directLight.color\x20*=\x20spotEffect\x20*\x20punctualLightIntensityToIrradianceFactor(\x20lightDistance,\x20spotLight.distance,\x20spotLight.decay\x20);\x0a\x09\x09\x09directLight.visible\x20=\x20true;\x0a\x09\x09}\x20else\x20{\x0a\x09\x09\x09directLight.color\x20=\x20vec3(\x200.0\x20);\x0a\x09\x09\x09directLight.visible\x20=\x20false;\x0a\x09\x09}\x0a\x09}\x0a#endif\x0a#if\x20NUM_RECT_AREA_LIGHTS\x20>\x200\x0a\x09struct\x20RectAreaLight\x20{\x0a\x09\x09vec3\x20color;\x0a\x09\x09vec3\x20position;\x0a\x09\x09vec3\x20halfWidth;\x0a\x09\x09vec3\x20halfHeight;\x0a\x09};\x0a\x09uniform\x20sampler2D\x20ltc_1;\x09uniform\x20sampler2D\x20ltc_2;\x0a\x09uniform\x20RectAreaLight\x20rectAreaLights[\x20NUM_RECT_AREA_LIGHTS\x20];\x0a#endif\x0a#if\x20NUM_HEMI_LIGHTS\x20>\x200\x0a\x09struct\x20HemisphereLight\x20{\x0a\x09\x09vec3\x20direction;\x0a\x09\x09vec3\x20skyColor;\x0a\x09\x09vec3\x20groundColor;\x0a\x09};\x0a\x09uniform\x20HemisphereLight\x20hemisphereLights[\x20NUM_HEMI_LIGHTS\x20];\x0a\x09vec3\x20getHemisphereLightIrradiance(\x20const\x20in\x20HemisphereLight\x20hemiLight,\x20const\x20in\x20GeometricContext\x20geometry\x20)\x20{\x0a\x09\x09float\x20dotNL\x20=\x20dot(\x20geometry.normal,\x20hemiLight.direction\x20);\x0a\x09\x09float\x20hemiDiffuseWeight\x20=\x200.5\x20*\x20dotNL\x20+\x200.5;\x0a\x09\x09vec3\x20irradiance\x20=\x20mix(\x20hemiLight.groundColor,\x20hemiLight.skyColor,\x20hemiDiffuseWeight\x20);\x0a\x09\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09\x09irradiance\x20*=\x20PI;\x0a\x09\x09#endif\x0a\x09\x09return\x20irradiance;\x0a\x09}\x0a#endif",
                    lights_toon_fragment:
                        "ToonMaterial\x20material;\x0amaterial.diffuseColor\x20=\x20diffuseColor.rgb;\x0amaterial.specularColor\x20=\x20specular;\x0amaterial.specularShininess\x20=\x20shininess;\x0amaterial.specularStrength\x20=\x20specularStrength;",
                    lights_toon_pars_fragment:
                        "varying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0astruct\x20ToonMaterial\x20{\x0a\x09vec3\x09diffuseColor;\x0a\x09vec3\x09specularColor;\x0a\x09float\x09specularShininess;\x0a\x09float\x09specularStrength;\x0a};\x0avoid\x20RE_Direct_Toon(\x20const\x20in\x20IncidentLight\x20directLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20ToonMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09vec3\x20irradiance\x20=\x20getGradientIrradiance(\x20geometry.normal,\x20directLight.direction\x20)\x20*\x20directLight.color;\x0a\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09irradiance\x20*=\x20PI;\x0a\x09#endif\x0a\x09reflectedLight.directDiffuse\x20+=\x20irradiance\x20*\x20BRDF_Diffuse_Lambert(\x20material.diffuseColor\x20);\x0a\x09reflectedLight.directSpecular\x20+=\x20irradiance\x20*\x20BRDF_Specular_BlinnPhong(\x20directLight,\x20geometry,\x20material.specularColor,\x20material.specularShininess\x20)\x20*\x20material.specularStrength;\x0a}\x0avoid\x20RE_IndirectDiffuse_Toon(\x20const\x20in\x20vec3\x20irradiance,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20ToonMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09reflectedLight.indirectDiffuse\x20+=\x20irradiance\x20*\x20BRDF_Diffuse_Lambert(\x20material.diffuseColor\x20);\x0a}\x0a#define\x20RE_Direct\x09\x09\x09\x09RE_Direct_Toon\x0a#define\x20RE_IndirectDiffuse\x09\x09RE_IndirectDiffuse_Toon\x0a#define\x20Material_LightProbeLOD(\x20material\x20)\x09(0)",
                    lights_phong_fragment:
                        "BlinnPhongMaterial\x20material;\x0amaterial.diffuseColor\x20=\x20diffuseColor.rgb;\x0amaterial.specularColor\x20=\x20specular;\x0amaterial.specularShininess\x20=\x20shininess;\x0amaterial.specularStrength\x20=\x20specularStrength;",
                    lights_phong_pars_fragment:
                        "varying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0astruct\x20BlinnPhongMaterial\x20{\x0a\x09vec3\x09diffuseColor;\x0a\x09vec3\x09specularColor;\x0a\x09float\x09specularShininess;\x0a\x09float\x09specularStrength;\x0a};\x0avoid\x20RE_Direct_BlinnPhong(\x20const\x20in\x20IncidentLight\x20directLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20BlinnPhongMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09float\x20dotNL\x20=\x20saturate(\x20dot(\x20geometry.normal,\x20directLight.direction\x20)\x20);\x0a\x09vec3\x20irradiance\x20=\x20dotNL\x20*\x20directLight.color;\x0a\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09irradiance\x20*=\x20PI;\x0a\x09#endif\x0a\x09reflectedLight.directDiffuse\x20+=\x20irradiance\x20*\x20BRDF_Diffuse_Lambert(\x20material.diffuseColor\x20);\x0a\x09reflectedLight.directSpecular\x20+=\x20irradiance\x20*\x20BRDF_Specular_BlinnPhong(\x20directLight,\x20geometry,\x20material.specularColor,\x20material.specularShininess\x20)\x20*\x20material.specularStrength;\x0a}\x0avoid\x20RE_IndirectDiffuse_BlinnPhong(\x20const\x20in\x20vec3\x20irradiance,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20BlinnPhongMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09reflectedLight.indirectDiffuse\x20+=\x20irradiance\x20*\x20BRDF_Diffuse_Lambert(\x20material.diffuseColor\x20);\x0a}\x0a#define\x20RE_Direct\x09\x09\x09\x09RE_Direct_BlinnPhong\x0a#define\x20RE_IndirectDiffuse\x09\x09RE_IndirectDiffuse_BlinnPhong\x0a#define\x20Material_LightProbeLOD(\x20material\x20)\x09(0)",
                    lights_physical_fragment:
                        "PhysicalMaterial\x20material;\x0amaterial.diffuseColor\x20=\x20diffuseColor.rgb\x20*\x20(\x201.0\x20-\x20metalnessFactor\x20);\x0avec3\x20dxy\x20=\x20max(\x20abs(\x20dFdx(\x20geometryNormal\x20)\x20),\x20abs(\x20dFdy(\x20geometryNormal\x20)\x20)\x20);\x0afloat\x20geometryRoughness\x20=\x20max(\x20max(\x20dxy.x,\x20dxy.y\x20),\x20dxy.z\x20);\x0amaterial.specularRoughness\x20=\x20max(\x20roughnessFactor,\x200.0525\x20);material.specularRoughness\x20+=\x20geometryRoughness;\x0amaterial.specularRoughness\x20=\x20min(\x20material.specularRoughness,\x201.0\x20);\x0a#ifdef\x20REFLECTIVITY\x0a\x09material.specularColor\x20=\x20mix(\x20vec3(\x20MAXIMUM_SPECULAR_COEFFICIENT\x20*\x20pow2(\x20reflectivity\x20)\x20),\x20diffuseColor.rgb,\x20metalnessFactor\x20);\x0a#else\x0a\x09material.specularColor\x20=\x20mix(\x20vec3(\x20DEFAULT_SPECULAR_COEFFICIENT\x20),\x20diffuseColor.rgb,\x20metalnessFactor\x20);\x0a#endif\x0a#ifdef\x20CLEARCOAT\x0a\x09material.clearcoat\x20=\x20clearcoat;\x0a\x09material.clearcoatRoughness\x20=\x20clearcoatRoughness;\x0a\x09#ifdef\x20USE_CLEARCOATMAP\x0a\x09\x09material.clearcoat\x20*=\x20texture2D(\x20clearcoatMap,\x20vUv\x20).x;\x0a\x09#endif\x0a\x09#ifdef\x20USE_CLEARCOAT_ROUGHNESSMAP\x0a\x09\x09material.clearcoatRoughness\x20*=\x20texture2D(\x20clearcoatRoughnessMap,\x20vUv\x20).y;\x0a\x09#endif\x0a\x09material.clearcoat\x20=\x20saturate(\x20material.clearcoat\x20);\x09material.clearcoatRoughness\x20=\x20max(\x20material.clearcoatRoughness,\x200.0525\x20);\x0a\x09material.clearcoatRoughness\x20+=\x20geometryRoughness;\x0a\x09material.clearcoatRoughness\x20=\x20min(\x20material.clearcoatRoughness,\x201.0\x20);\x0a#endif\x0a#ifdef\x20USE_SHEEN\x0a\x09material.sheenColor\x20=\x20sheen;\x0a#endif",
                    lights_physical_pars_fragment:
                        "struct\x20PhysicalMaterial\x20{\x0a\x09vec3\x09diffuseColor;\x0a\x09float\x09specularRoughness;\x0a\x09vec3\x09specularColor;\x0a#ifdef\x20CLEARCOAT\x0a\x09float\x20clearcoat;\x0a\x09float\x20clearcoatRoughness;\x0a#endif\x0a#ifdef\x20USE_SHEEN\x0a\x09vec3\x20sheenColor;\x0a#endif\x0a};\x0a#define\x20MAXIMUM_SPECULAR_COEFFICIENT\x200.16\x0a#define\x20DEFAULT_SPECULAR_COEFFICIENT\x200.04\x0afloat\x20clearcoatDHRApprox(\x20const\x20in\x20float\x20roughness,\x20const\x20in\x20float\x20dotNL\x20)\x20{\x0a\x09return\x20DEFAULT_SPECULAR_COEFFICIENT\x20+\x20(\x201.0\x20-\x20DEFAULT_SPECULAR_COEFFICIENT\x20)\x20*\x20(\x20pow(\x201.0\x20-\x20dotNL,\x205.0\x20)\x20*\x20pow(\x201.0\x20-\x20roughness,\x202.0\x20)\x20);\x0a}\x0a#if\x20NUM_RECT_AREA_LIGHTS\x20>\x200\x0a\x09void\x20RE_Direct_RectArea_Physical(\x20const\x20in\x20RectAreaLight\x20rectAreaLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20PhysicalMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09\x09vec3\x20normal\x20=\x20geometry.normal;\x0a\x09\x09vec3\x20viewDir\x20=\x20geometry.viewDir;\x0a\x09\x09vec3\x20position\x20=\x20geometry.position;\x0a\x09\x09vec3\x20lightPos\x20=\x20rectAreaLight.position;\x0a\x09\x09vec3\x20halfWidth\x20=\x20rectAreaLight.halfWidth;\x0a\x09\x09vec3\x20halfHeight\x20=\x20rectAreaLight.halfHeight;\x0a\x09\x09vec3\x20lightColor\x20=\x20rectAreaLight.color;\x0a\x09\x09float\x20roughness\x20=\x20material.specularRoughness;\x0a\x09\x09vec3\x20rectCoords[\x204\x20];\x0a\x09\x09rectCoords[\x200\x20]\x20=\x20lightPos\x20+\x20halfWidth\x20-\x20halfHeight;\x09\x09rectCoords[\x201\x20]\x20=\x20lightPos\x20-\x20halfWidth\x20-\x20halfHeight;\x0a\x09\x09rectCoords[\x202\x20]\x20=\x20lightPos\x20-\x20halfWidth\x20+\x20halfHeight;\x0a\x09\x09rectCoords[\x203\x20]\x20=\x20lightPos\x20+\x20halfWidth\x20+\x20halfHeight;\x0a\x09\x09vec2\x20uv\x20=\x20LTC_Uv(\x20normal,\x20viewDir,\x20roughness\x20);\x0a\x09\x09vec4\x20t1\x20=\x20texture2D(\x20ltc_1,\x20uv\x20);\x0a\x09\x09vec4\x20t2\x20=\x20texture2D(\x20ltc_2,\x20uv\x20);\x0a\x09\x09mat3\x20mInv\x20=\x20mat3(\x0a\x09\x09\x09vec3(\x20t1.x,\x200,\x20t1.y\x20),\x0a\x09\x09\x09vec3(\x20\x20\x20\x200,\x201,\x20\x20\x20\x200\x20),\x0a\x09\x09\x09vec3(\x20t1.z,\x200,\x20t1.w\x20)\x0a\x09\x09);\x0a\x09\x09vec3\x20fresnel\x20=\x20(\x20material.specularColor\x20*\x20t2.x\x20+\x20(\x20vec3(\x201.0\x20)\x20-\x20material.specularColor\x20)\x20*\x20t2.y\x20);\x0a\x09\x09reflectedLight.directSpecular\x20+=\x20lightColor\x20*\x20fresnel\x20*\x20LTC_Evaluate(\x20normal,\x20viewDir,\x20position,\x20mInv,\x20rectCoords\x20);\x0a\x09\x09reflectedLight.directDiffuse\x20+=\x20lightColor\x20*\x20material.diffuseColor\x20*\x20LTC_Evaluate(\x20normal,\x20viewDir,\x20position,\x20mat3(\x201.0\x20),\x20rectCoords\x20);\x0a\x09}\x0a#endif\x0avoid\x20RE_Direct_Physical(\x20const\x20in\x20IncidentLight\x20directLight,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20PhysicalMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09float\x20dotNL\x20=\x20saturate(\x20dot(\x20geometry.normal,\x20directLight.direction\x20)\x20);\x0a\x09vec3\x20irradiance\x20=\x20dotNL\x20*\x20directLight.color;\x0a\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09irradiance\x20*=\x20PI;\x0a\x09#endif\x0a\x09#ifdef\x20CLEARCOAT\x0a\x09\x09float\x20ccDotNL\x20=\x20saturate(\x20dot(\x20geometry.clearcoatNormal,\x20directLight.direction\x20)\x20);\x0a\x09\x09vec3\x20ccIrradiance\x20=\x20ccDotNL\x20*\x20directLight.color;\x0a\x09\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09\x09ccIrradiance\x20*=\x20PI;\x0a\x09\x09#endif\x0a\x09\x09float\x20clearcoatDHR\x20=\x20material.clearcoat\x20*\x20clearcoatDHRApprox(\x20material.clearcoatRoughness,\x20ccDotNL\x20);\x0a\x09\x09reflectedLight.directSpecular\x20+=\x20ccIrradiance\x20*\x20material.clearcoat\x20*\x20BRDF_Specular_GGX(\x20directLight,\x20geometry.viewDir,\x20geometry.clearcoatNormal,\x20vec3(\x20DEFAULT_SPECULAR_COEFFICIENT\x20),\x20material.clearcoatRoughness\x20);\x0a\x09#else\x0a\x09\x09float\x20clearcoatDHR\x20=\x200.0;\x0a\x09#endif\x0a\x09#ifdef\x20USE_SHEEN\x0a\x09\x09reflectedLight.directSpecular\x20+=\x20(\x201.0\x20-\x20clearcoatDHR\x20)\x20*\x20irradiance\x20*\x20BRDF_Specular_Sheen(\x0a\x09\x09\x09material.specularRoughness,\x0a\x09\x09\x09directLight.direction,\x0a\x09\x09\x09geometry,\x0a\x09\x09\x09material.sheenColor\x0a\x09\x09);\x0a\x09#else\x0a\x09\x09reflectedLight.directSpecular\x20+=\x20(\x201.0\x20-\x20clearcoatDHR\x20)\x20*\x20irradiance\x20*\x20BRDF_Specular_GGX(\x20directLight,\x20geometry.viewDir,\x20geometry.normal,\x20material.specularColor,\x20material.specularRoughness);\x0a\x09#endif\x0a\x09reflectedLight.directDiffuse\x20+=\x20(\x201.0\x20-\x20clearcoatDHR\x20)\x20*\x20irradiance\x20*\x20BRDF_Diffuse_Lambert(\x20material.diffuseColor\x20);\x0a}\x0avoid\x20RE_IndirectDiffuse_Physical(\x20const\x20in\x20vec3\x20irradiance,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20PhysicalMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight\x20)\x20{\x0a\x09reflectedLight.indirectDiffuse\x20+=\x20irradiance\x20*\x20BRDF_Diffuse_Lambert(\x20material.diffuseColor\x20);\x0a}\x0avoid\x20RE_IndirectSpecular_Physical(\x20const\x20in\x20vec3\x20radiance,\x20const\x20in\x20vec3\x20irradiance,\x20const\x20in\x20vec3\x20clearcoatRadiance,\x20const\x20in\x20GeometricContext\x20geometry,\x20const\x20in\x20PhysicalMaterial\x20material,\x20inout\x20ReflectedLight\x20reflectedLight)\x20{\x0a\x09#ifdef\x20CLEARCOAT\x0a\x09\x09float\x20ccDotNV\x20=\x20saturate(\x20dot(\x20geometry.clearcoatNormal,\x20geometry.viewDir\x20)\x20);\x0a\x09\x09reflectedLight.indirectSpecular\x20+=\x20clearcoatRadiance\x20*\x20material.clearcoat\x20*\x20BRDF_Specular_GGX_Environment(\x20geometry.viewDir,\x20geometry.clearcoatNormal,\x20vec3(\x20DEFAULT_SPECULAR_COEFFICIENT\x20),\x20material.clearcoatRoughness\x20);\x0a\x09\x09float\x20ccDotNL\x20=\x20ccDotNV;\x0a\x09\x09float\x20clearcoatDHR\x20=\x20material.clearcoat\x20*\x20clearcoatDHRApprox(\x20material.clearcoatRoughness,\x20ccDotNL\x20);\x0a\x09#else\x0a\x09\x09float\x20clearcoatDHR\x20=\x200.0;\x0a\x09#endif\x0a\x09float\x20clearcoatInv\x20=\x201.0\x20-\x20clearcoatDHR;\x0a\x09vec3\x20singleScattering\x20=\x20vec3(\x200.0\x20);\x0a\x09vec3\x20multiScattering\x20=\x20vec3(\x200.0\x20);\x0a\x09vec3\x20cosineWeightedIrradiance\x20=\x20irradiance\x20*\x20RECIPROCAL_PI;\x0a\x09BRDF_Specular_Multiscattering_Environment(\x20geometry,\x20material.specularColor,\x20material.specularRoughness,\x20singleScattering,\x20multiScattering\x20);\x0a\x09vec3\x20diffuse\x20=\x20material.diffuseColor\x20*\x20(\x201.0\x20-\x20(\x20singleScattering\x20+\x20multiScattering\x20)\x20);\x0a\x09reflectedLight.indirectSpecular\x20+=\x20clearcoatInv\x20*\x20radiance\x20*\x20singleScattering;\x0a\x09reflectedLight.indirectSpecular\x20+=\x20multiScattering\x20*\x20cosineWeightedIrradiance;\x0a\x09reflectedLight.indirectDiffuse\x20+=\x20diffuse\x20*\x20cosineWeightedIrradiance;\x0a}\x0a#define\x20RE_Direct\x09\x09\x09\x09RE_Direct_Physical\x0a#define\x20RE_Direct_RectArea\x09\x09RE_Direct_RectArea_Physical\x0a#define\x20RE_IndirectDiffuse\x09\x09RE_IndirectDiffuse_Physical\x0a#define\x20RE_IndirectSpecular\x09\x09RE_IndirectSpecular_Physical\x0afloat\x20computeSpecularOcclusion(\x20const\x20in\x20float\x20dotNV,\x20const\x20in\x20float\x20ambientOcclusion,\x20const\x20in\x20float\x20roughness\x20)\x20{\x0a\x09return\x20saturate(\x20pow(\x20dotNV\x20+\x20ambientOcclusion,\x20exp2(\x20-\x2016.0\x20*\x20roughness\x20-\x201.0\x20)\x20)\x20-\x201.0\x20+\x20ambientOcclusion\x20);\x0a}",
                    lights_fragment_begin:
                        "\x0aGeometricContext\x20geometry;\x0ageometry.position\x20=\x20-\x20vViewPosition;\x0ageometry.normal\x20=\x20normal;\x0ageometry.viewDir\x20=\x20(\x20isOrthographic\x20)\x20?\x20vec3(\x200,\x200,\x201\x20)\x20:\x20normalize(\x20vViewPosition\x20);\x0a#ifdef\x20CLEARCOAT\x0a\x09geometry.clearcoatNormal\x20=\x20clearcoatNormal;\x0a#endif\x0aIncidentLight\x20directLight;\x0a#if\x20(\x20NUM_POINT_LIGHTS\x20>\x200\x20)\x20&&\x20defined(\x20RE_Direct\x20)\x0a\x09PointLight\x20pointLight;\x0a\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20NUM_POINT_LIGHT_SHADOWS\x20>\x200\x0a\x09PointLightShadow\x20pointLightShadow;\x0a\x09#endif\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_POINT_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09pointLight\x20=\x20pointLights[\x20i\x20];\x0a\x09\x09getPointDirectLightIrradiance(\x20pointLight,\x20geometry,\x20directLight\x20);\x0a\x09\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20(\x20UNROLLED_LOOP_INDEX\x20<\x20NUM_POINT_LIGHT_SHADOWS\x20)\x0a\x09\x09pointLightShadow\x20=\x20pointLightShadows[\x20i\x20];\x0a\x09\x09directLight.color\x20*=\x20all(\x20bvec2(\x20directLight.visible,\x20receiveShadow\x20)\x20)\x20?\x20getPointShadow(\x20pointShadowMap[\x20i\x20],\x20pointLightShadow.shadowMapSize,\x20pointLightShadow.shadowBias,\x20pointLightShadow.shadowRadius,\x20vPointShadowCoord[\x20i\x20],\x20pointLightShadow.shadowCameraNear,\x20pointLightShadow.shadowCameraFar\x20)\x20:\x201.0;\x0a\x09\x09#endif\x0a\x09\x09RE_Direct(\x20directLight,\x20geometry,\x20material,\x20reflectedLight\x20);\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20(\x20NUM_SPOT_LIGHTS\x20>\x200\x20)\x20&&\x20defined(\x20RE_Direct\x20)\x0a\x09SpotLight\x20spotLight;\x0a\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20NUM_SPOT_LIGHT_SHADOWS\x20>\x200\x0a\x09SpotLightShadow\x20spotLightShadow;\x0a\x09#endif\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_SPOT_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09spotLight\x20=\x20spotLights[\x20i\x20];\x0a\x09\x09getSpotDirectLightIrradiance(\x20spotLight,\x20geometry,\x20directLight\x20);\x0a\x09\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20(\x20UNROLLED_LOOP_INDEX\x20<\x20NUM_SPOT_LIGHT_SHADOWS\x20)\x0a\x09\x09spotLightShadow\x20=\x20spotLightShadows[\x20i\x20];\x0a\x09\x09directLight.color\x20*=\x20all(\x20bvec2(\x20directLight.visible,\x20receiveShadow\x20)\x20)\x20?\x20getShadow(\x20spotShadowMap[\x20i\x20],\x20spotLightShadow.shadowMapSize,\x20spotLightShadow.shadowBias,\x20spotLightShadow.shadowRadius,\x20vSpotShadowCoord[\x20i\x20]\x20)\x20:\x201.0;\x0a\x09\x09#endif\x0a\x09\x09RE_Direct(\x20directLight,\x20geometry,\x20material,\x20reflectedLight\x20);\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20(\x20NUM_DIR_LIGHTS\x20>\x200\x20)\x20&&\x20defined(\x20RE_Direct\x20)\x0a\x09DirectionalLight\x20directionalLight;\x0a\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20NUM_DIR_LIGHT_SHADOWS\x20>\x200\x0a\x09DirectionalLightShadow\x20directionalLightShadow;\x0a\x09#endif\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_DIR_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09directionalLight\x20=\x20directionalLights[\x20i\x20];\x0a\x09\x09getDirectionalDirectLightIrradiance(\x20directionalLight,\x20geometry,\x20directLight\x20);\x0a\x09\x09#if\x20defined(\x20USE_SHADOWMAP\x20)\x20&&\x20(\x20UNROLLED_LOOP_INDEX\x20<\x20NUM_DIR_LIGHT_SHADOWS\x20)\x0a\x09\x09directionalLightShadow\x20=\x20directionalLightShadows[\x20i\x20];\x0a\x09\x09directLight.color\x20*=\x20all(\x20bvec2(\x20directLight.visible,\x20receiveShadow\x20)\x20)\x20?\x20getShadow(\x20directionalShadowMap[\x20i\x20],\x20directionalLightShadow.shadowMapSize,\x20directionalLightShadow.shadowBias,\x20directionalLightShadow.shadowRadius,\x20vDirectionalShadowCoord[\x20i\x20]\x20)\x20:\x201.0;\x0a\x09\x09#endif\x0a\x09\x09RE_Direct(\x20directLight,\x20geometry,\x20material,\x20reflectedLight\x20);\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20(\x20NUM_RECT_AREA_LIGHTS\x20>\x200\x20)\x20&&\x20defined(\x20RE_Direct_RectArea\x20)\x0a\x09RectAreaLight\x20rectAreaLight;\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_RECT_AREA_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09rectAreaLight\x20=\x20rectAreaLights[\x20i\x20];\x0a\x09\x09RE_Direct_RectArea(\x20rectAreaLight,\x20geometry,\x20material,\x20reflectedLight\x20);\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a#endif\x0a#if\x20defined(\x20RE_IndirectDiffuse\x20)\x0a\x09vec3\x20iblIrradiance\x20=\x20vec3(\x200.0\x20);\x0a\x09vec3\x20irradiance\x20=\x20getAmbientLightIrradiance(\x20ambientLightColor\x20);\x0a\x09irradiance\x20+=\x20getLightProbeIrradiance(\x20lightProbe,\x20geometry\x20);\x0a\x09#if\x20(\x20NUM_HEMI_LIGHTS\x20>\x200\x20)\x0a\x09\x09#pragma\x20unroll_loop_start\x0a\x09\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_HEMI_LIGHTS;\x20i\x20++\x20)\x20{\x0a\x09\x09\x09irradiance\x20+=\x20getHemisphereLightIrradiance(\x20hemisphereLights[\x20i\x20],\x20geometry\x20);\x0a\x09\x09}\x0a\x09\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a#endif\x0a#if\x20defined(\x20RE_IndirectSpecular\x20)\x0a\x09vec3\x20radiance\x20=\x20vec3(\x200.0\x20);\x0a\x09vec3\x20clearcoatRadiance\x20=\x20vec3(\x200.0\x20);\x0a#endif",
                    lights_fragment_maps:
                        "#if\x20defined(\x20RE_IndirectDiffuse\x20)\x0a\x09#ifdef\x20USE_LIGHTMAP\x0a\x09\x09vec4\x20lightMapTexel=\x20texture2D(\x20lightMap,\x20vUv2\x20);\x0a\x09\x09vec3\x20lightMapIrradiance\x20=\x20lightMapTexelToLinear(\x20lightMapTexel\x20).rgb\x20*\x20lightMapIntensity;\x0a\x09\x09#ifndef\x20PHYSICALLY_CORRECT_LIGHTS\x0a\x09\x09\x09lightMapIrradiance\x20*=\x20PI;\x0a\x09\x09#endif\x0a\x09\x09irradiance\x20+=\x20lightMapIrradiance;\x0a\x09#endif\x0a\x09#if\x20defined(\x20USE_ENVMAP\x20)\x20&&\x20defined(\x20STANDARD\x20)\x20&&\x20defined(\x20ENVMAP_TYPE_CUBE_UV\x20)\x0a\x09\x09iblIrradiance\x20+=\x20getLightProbeIndirectIrradiance(\x20geometry,\x20maxMipLevel\x20);\x0a\x09#endif\x0a#endif\x0a#if\x20defined(\x20USE_ENVMAP\x20)\x20&&\x20defined(\x20RE_IndirectSpecular\x20)\x0a\x09radiance\x20+=\x20getLightProbeIndirectRadiance(\x20geometry.viewDir,\x20geometry.normal,\x20material.specularRoughness,\x20maxMipLevel\x20);\x0a\x09#ifdef\x20CLEARCOAT\x0a\x09\x09clearcoatRadiance\x20+=\x20getLightProbeIndirectRadiance(\x20geometry.viewDir,\x20geometry.clearcoatNormal,\x20material.clearcoatRoughness,\x20maxMipLevel\x20);\x0a\x09#endif\x0a#endif",
                    lights_fragment_end:
                        "#if\x20defined(\x20RE_IndirectDiffuse\x20)\x0a\x09RE_IndirectDiffuse(\x20irradiance,\x20geometry,\x20material,\x20reflectedLight\x20);\x0a#endif\x0a#if\x20defined(\x20RE_IndirectSpecular\x20)\x0a\x09RE_IndirectSpecular(\x20radiance,\x20iblIrradiance,\x20clearcoatRadiance,\x20geometry,\x20material,\x20reflectedLight\x20);\x0a#endif",
                    logdepthbuf_fragment:
                        "#if\x20defined(\x20USE_LOGDEPTHBUF\x20)\x20&&\x20defined(\x20USE_LOGDEPTHBUF_EXT\x20)\x0a\x09gl_FragDepthEXT\x20=\x20vIsPerspective\x20==\x200.0\x20?\x20gl_FragCoord.z\x20:\x20log2(\x20vFragDepth\x20)\x20*\x20logDepthBufFC\x20*\x200.5;\x0a#endif",
                    logdepthbuf_pars_fragment:
                        "#if\x20defined(\x20USE_LOGDEPTHBUF\x20)\x20&&\x20defined(\x20USE_LOGDEPTHBUF_EXT\x20)\x0a\x09uniform\x20float\x20logDepthBufFC;\x0a\x09varying\x20float\x20vFragDepth;\x0a\x09varying\x20float\x20vIsPerspective;\x0a#endif",
                    logdepthbuf_pars_vertex:
                        "#ifdef\x20USE_LOGDEPTHBUF\x0a\x09#ifdef\x20USE_LOGDEPTHBUF_EXT\x0a\x09\x09varying\x20float\x20vFragDepth;\x0a\x09\x09varying\x20float\x20vIsPerspective;\x0a\x09#else\x0a\x09\x09uniform\x20float\x20logDepthBufFC;\x0a\x09#endif\x0a#endif",
                    logdepthbuf_vertex:
                        "#ifdef\x20USE_LOGDEPTHBUF\x0a\x09#ifdef\x20USE_LOGDEPTHBUF_EXT\x0a\x09\x09vFragDepth\x20=\x201.0\x20+\x20gl_Position.w;\x0a\x09\x09vIsPerspective\x20=\x20float(\x20isPerspectiveMatrix(\x20projectionMatrix\x20)\x20);\x0a\x09#else\x0a\x09\x09if\x20(\x20isPerspectiveMatrix(\x20projectionMatrix\x20)\x20)\x20{\x0a\x09\x09\x09gl_Position.z\x20=\x20log2(\x20max(\x20EPSILON,\x20gl_Position.w\x20+\x201.0\x20)\x20)\x20*\x20logDepthBufFC\x20-\x201.0;\x0a\x09\x09\x09gl_Position.z\x20*=\x20gl_Position.w;\x0a\x09\x09}\x0a\x09#endif\x0a#endif",
                    map_fragment: "#ifdef\x20USE_MAP\x0a\x09vec4\x20texelColor\x20=\x20texture2D(\x20map,\x20vUv\x20);\x0a\x09texelColor\x20=\x20mapTexelToLinear(\x20texelColor\x20);\x0a\x09diffuseColor\x20*=\x20texelColor;\x0a#endif",
                    map_pars_fragment: "#ifdef\x20USE_MAP\x0a\x09uniform\x20sampler2D\x20map;\x0a#endif",
                    map_particle_fragment:
                        "#if\x20defined(\x20USE_MAP\x20)\x20||\x20defined(\x20USE_ALPHAMAP\x20)\x0a\x09vec2\x20uv\x20=\x20(\x20uvTransform\x20*\x20vec3(\x20gl_PointCoord.x,\x201.0\x20-\x20gl_PointCoord.y,\x201\x20)\x20).xy;\x0a#endif\x0a#ifdef\x20USE_MAP\x0a\x09vec4\x20mapTexel\x20=\x20texture2D(\x20map,\x20uv\x20);\x0a\x09diffuseColor\x20*=\x20mapTexelToLinear(\x20mapTexel\x20);\x0a#endif\x0a#ifdef\x20USE_ALPHAMAP\x0a\x09diffuseColor.a\x20*=\x20texture2D(\x20alphaMap,\x20uv\x20).g;\x0a#endif",
                    map_particle_pars_fragment:
                        "#if\x20defined(\x20USE_MAP\x20)\x20||\x20defined(\x20USE_ALPHAMAP\x20)\x0a\x09uniform\x20mat3\x20uvTransform;\x0a#endif\x0a#ifdef\x20USE_MAP\x0a\x09uniform\x20sampler2D\x20map;\x0a#endif\x0a#ifdef\x20USE_ALPHAMAP\x0a\x09uniform\x20sampler2D\x20alphaMap;\x0a#endif",
                    metalnessmap_fragment:
                        "float\x20metalnessFactor\x20=\x20metalness;\x0a#ifdef\x20USE_METALNESSMAP\x0a\x09vec4\x20texelMetalness\x20=\x20texture2D(\x20metalnessMap,\x20vUv\x20);\x0a\x09metalnessFactor\x20*=\x20texelMetalness.b;\x0a#endif",
                    metalnessmap_pars_fragment: "#ifdef\x20USE_METALNESSMAP\x0a\x09uniform\x20sampler2D\x20metalnessMap;\x0a#endif",
                    morphnormal_vertex:
                        "#ifdef\x20USE_MORPHNORMALS\x0a\x09objectNormal\x20*=\x20morphTargetBaseInfluence;\x0a\x09objectNormal\x20+=\x20morphNormal0\x20*\x20morphTargetInfluences[\x200\x20];\x0a\x09objectNormal\x20+=\x20morphNormal1\x20*\x20morphTargetInfluences[\x201\x20];\x0a\x09objectNormal\x20+=\x20morphNormal2\x20*\x20morphTargetInfluences[\x202\x20];\x0a\x09objectNormal\x20+=\x20morphNormal3\x20*\x20morphTargetInfluences[\x203\x20];\x0a#endif",
                    morphtarget_pars_vertex:
                        "#ifdef\x20USE_MORPHTARGETS\x0a\x09uniform\x20float\x20morphTargetBaseInfluence;\x0a\x09#ifndef\x20USE_MORPHNORMALS\x0a\x09uniform\x20float\x20morphTargetInfluences[\x208\x20];\x0a\x09#else\x0a\x09uniform\x20float\x20morphTargetInfluences[\x204\x20];\x0a\x09#endif\x0a#endif",
                    morphtarget_vertex:
                        "#ifdef\x20USE_MORPHTARGETS\x0a\x09transformed\x20*=\x20morphTargetBaseInfluence;\x0a\x09transformed\x20+=\x20morphTarget0\x20*\x20morphTargetInfluences[\x200\x20];\x0a\x09transformed\x20+=\x20morphTarget1\x20*\x20morphTargetInfluences[\x201\x20];\x0a\x09transformed\x20+=\x20morphTarget2\x20*\x20morphTargetInfluences[\x202\x20];\x0a\x09transformed\x20+=\x20morphTarget3\x20*\x20morphTargetInfluences[\x203\x20];\x0a\x09#ifndef\x20USE_MORPHNORMALS\x0a\x09transformed\x20+=\x20morphTarget4\x20*\x20morphTargetInfluences[\x204\x20];\x0a\x09transformed\x20+=\x20morphTarget5\x20*\x20morphTargetInfluences[\x205\x20];\x0a\x09transformed\x20+=\x20morphTarget6\x20*\x20morphTargetInfluences[\x206\x20];\x0a\x09transformed\x20+=\x20morphTarget7\x20*\x20morphTargetInfluences[\x207\x20];\x0a\x09#endif\x0a#endif",
                    normal_fragment_begin:
                        "#ifdef\x20FLAT_SHADED\x0a\x09vec3\x20fdx\x20=\x20vec3(\x20dFdx(\x20vViewPosition.x\x20),\x20dFdx(\x20vViewPosition.y\x20),\x20dFdx(\x20vViewPosition.z\x20)\x20);\x0a\x09vec3\x20fdy\x20=\x20vec3(\x20dFdy(\x20vViewPosition.x\x20),\x20dFdy(\x20vViewPosition.y\x20),\x20dFdy(\x20vViewPosition.z\x20)\x20);\x0a\x09vec3\x20normal\x20=\x20normalize(\x20cross(\x20fdx,\x20fdy\x20)\x20);\x0a#else\x0a\x09vec3\x20normal\x20=\x20normalize(\x20vNormal\x20);\x0a\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09normal\x20=\x20normal\x20*\x20(\x20float(\x20gl_FrontFacing\x20)\x20*\x202.0\x20-\x201.0\x20);\x0a\x09#endif\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09vec3\x20tangent\x20=\x20normalize(\x20vTangent\x20);\x0a\x09\x09vec3\x20bitangent\x20=\x20normalize(\x20vBitangent\x20);\x0a\x09\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09\x09tangent\x20=\x20tangent\x20*\x20(\x20float(\x20gl_FrontFacing\x20)\x20*\x202.0\x20-\x201.0\x20);\x0a\x09\x09\x09bitangent\x20=\x20bitangent\x20*\x20(\x20float(\x20gl_FrontFacing\x20)\x20*\x202.0\x20-\x201.0\x20);\x0a\x09\x09#endif\x0a\x09\x09#if\x20defined(\x20TANGENTSPACE_NORMALMAP\x20)\x20||\x20defined(\x20USE_CLEARCOAT_NORMALMAP\x20)\x0a\x09\x09\x09mat3\x20vTBN\x20=\x20mat3(\x20tangent,\x20bitangent,\x20normal\x20);\x0a\x09\x09#endif\x0a\x09#endif\x0a#endif\x0avec3\x20geometryNormal\x20=\x20normal;",
                    normal_fragment_maps:
                        "#ifdef\x20OBJECTSPACE_NORMALMAP\x0a\x09normal\x20=\x20texture2D(\x20normalMap,\x20vUv\x20).xyz\x20*\x202.0\x20-\x201.0;\x0a\x09#ifdef\x20FLIP_SIDED\x0a\x09\x09normal\x20=\x20-\x20normal;\x0a\x09#endif\x0a\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09normal\x20=\x20normal\x20*\x20(\x20float(\x20gl_FrontFacing\x20)\x20*\x202.0\x20-\x201.0\x20);\x0a\x09#endif\x0a\x09normal\x20=\x20normalize(\x20normalMatrix\x20*\x20normal\x20);\x0a#elif\x20defined(\x20TANGENTSPACE_NORMALMAP\x20)\x0a\x09vec3\x20mapN\x20=\x20texture2D(\x20normalMap,\x20vUv\x20).xyz\x20*\x202.0\x20-\x201.0;\x0a\x09mapN.xy\x20*=\x20normalScale;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09normal\x20=\x20normalize(\x20vTBN\x20*\x20mapN\x20);\x0a\x09#else\x0a\x09\x09normal\x20=\x20perturbNormal2Arb(\x20-vViewPosition,\x20normal,\x20mapN\x20);\x0a\x09#endif\x0a#elif\x20defined(\x20USE_BUMPMAP\x20)\x0a\x09normal\x20=\x20perturbNormalArb(\x20-vViewPosition,\x20normal,\x20dHdxy_fwd()\x20);\x0a#endif",
                    normalmap_pars_fragment:
                        "#ifdef\x20USE_NORMALMAP\x0a\x09uniform\x20sampler2D\x20normalMap;\x0a\x09uniform\x20vec2\x20normalScale;\x0a#endif\x0a#ifdef\x20OBJECTSPACE_NORMALMAP\x0a\x09uniform\x20mat3\x20normalMatrix;\x0a#endif\x0a#if\x20!\x20defined\x20(\x20USE_TANGENT\x20)\x20&&\x20(\x20defined\x20(\x20TANGENTSPACE_NORMALMAP\x20)\x20||\x20defined\x20(\x20USE_CLEARCOAT_NORMALMAP\x20)\x20)\x0a\x09vec3\x20perturbNormal2Arb(\x20vec3\x20eye_pos,\x20vec3\x20surf_norm,\x20vec3\x20mapN\x20)\x20{\x0a\x09\x09vec3\x20q0\x20=\x20vec3(\x20dFdx(\x20eye_pos.x\x20),\x20dFdx(\x20eye_pos.y\x20),\x20dFdx(\x20eye_pos.z\x20)\x20);\x0a\x09\x09vec3\x20q1\x20=\x20vec3(\x20dFdy(\x20eye_pos.x\x20),\x20dFdy(\x20eye_pos.y\x20),\x20dFdy(\x20eye_pos.z\x20)\x20);\x0a\x09\x09vec2\x20st0\x20=\x20dFdx(\x20vUv.st\x20);\x0a\x09\x09vec2\x20st1\x20=\x20dFdy(\x20vUv.st\x20);\x0a\x09\x09float\x20scale\x20=\x20sign(\x20st1.t\x20*\x20st0.s\x20-\x20st0.t\x20*\x20st1.s\x20);\x0a\x09\x09vec3\x20S\x20=\x20normalize(\x20(\x20q0\x20*\x20st1.t\x20-\x20q1\x20*\x20st0.t\x20)\x20*\x20scale\x20);\x0a\x09\x09vec3\x20T\x20=\x20normalize(\x20(\x20-\x20q0\x20*\x20st1.s\x20+\x20q1\x20*\x20st0.s\x20)\x20*\x20scale\x20);\x0a\x09\x09vec3\x20N\x20=\x20normalize(\x20surf_norm\x20);\x0a\x09\x09mat3\x20tsn\x20=\x20mat3(\x20S,\x20T,\x20N\x20);\x0a\x09\x09mapN.xy\x20*=\x20(\x20float(\x20gl_FrontFacing\x20)\x20*\x202.0\x20-\x201.0\x20);\x0a\x09\x09return\x20normalize(\x20tsn\x20*\x20mapN\x20);\x0a\x09}\x0a#endif",
                    clearcoat_normal_fragment_begin: "#ifdef\x20CLEARCOAT\x0a\x09vec3\x20clearcoatNormal\x20=\x20geometryNormal;\x0a#endif",
                    clearcoat_normal_fragment_maps:
                        "#ifdef\x20USE_CLEARCOAT_NORMALMAP\x0a\x09vec3\x20clearcoatMapN\x20=\x20texture2D(\x20clearcoatNormalMap,\x20vUv\x20).xyz\x20*\x202.0\x20-\x201.0;\x0a\x09clearcoatMapN.xy\x20*=\x20clearcoatNormalScale;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09clearcoatNormal\x20=\x20normalize(\x20vTBN\x20*\x20clearcoatMapN\x20);\x0a\x09#else\x0a\x09\x09clearcoatNormal\x20=\x20perturbNormal2Arb(\x20-\x20vViewPosition,\x20clearcoatNormal,\x20clearcoatMapN\x20);\x0a\x09#endif\x0a#endif",
                    clearcoat_pars_fragment:
                        "#ifdef\x20USE_CLEARCOATMAP\x0a\x09uniform\x20sampler2D\x20clearcoatMap;\x0a#endif\x0a#ifdef\x20USE_CLEARCOAT_ROUGHNESSMAP\x0a\x09uniform\x20sampler2D\x20clearcoatRoughnessMap;\x0a#endif\x0a#ifdef\x20USE_CLEARCOAT_NORMALMAP\x0a\x09uniform\x20sampler2D\x20clearcoatNormalMap;\x0a\x09uniform\x20vec2\x20clearcoatNormalScale;\x0a#endif",
                    packing:
                        "vec3\x20packNormalToRGB(\x20const\x20in\x20vec3\x20normal\x20)\x20{\x0a\x09return\x20normalize(\x20normal\x20)\x20*\x200.5\x20+\x200.5;\x0a}\x0avec3\x20unpackRGBToNormal(\x20const\x20in\x20vec3\x20rgb\x20)\x20{\x0a\x09return\x202.0\x20*\x20rgb.xyz\x20-\x201.0;\x0a}\x0aconst\x20float\x20PackUpscale\x20=\x20256.\x20/\x20255.;const\x20float\x20UnpackDownscale\x20=\x20255.\x20/\x20256.;\x0aconst\x20vec3\x20PackFactors\x20=\x20vec3(\x20256.\x20*\x20256.\x20*\x20256.,\x20256.\x20*\x20256.,\x20\x20256.\x20);\x0aconst\x20vec4\x20UnpackFactors\x20=\x20UnpackDownscale\x20/\x20vec4(\x20PackFactors,\x201.\x20);\x0aconst\x20float\x20ShiftRight8\x20=\x201.\x20/\x20256.;\x0avec4\x20packDepthToRGBA(\x20const\x20in\x20float\x20v\x20)\x20{\x0a\x09vec4\x20r\x20=\x20vec4(\x20fract(\x20v\x20*\x20PackFactors\x20),\x20v\x20);\x0a\x09r.yzw\x20-=\x20r.xyz\x20*\x20ShiftRight8;\x09return\x20r\x20*\x20PackUpscale;\x0a}\x0afloat\x20unpackRGBAToDepth(\x20const\x20in\x20vec4\x20v\x20)\x20{\x0a\x09return\x20dot(\x20v,\x20UnpackFactors\x20);\x0a}\x0avec4\x20pack2HalfToRGBA(\x20vec2\x20v\x20)\x20{\x0a\x09vec4\x20r\x20=\x20vec4(\x20v.x,\x20fract(\x20v.x\x20*\x20255.0\x20),\x20v.y,\x20fract(\x20v.y\x20*\x20255.0\x20));\x0a\x09return\x20vec4(\x20r.x\x20-\x20r.y\x20/\x20255.0,\x20r.y,\x20r.z\x20-\x20r.w\x20/\x20255.0,\x20r.w);\x0a}\x0avec2\x20unpackRGBATo2Half(\x20vec4\x20v\x20)\x20{\x0a\x09return\x20vec2(\x20v.x\x20+\x20(\x20v.y\x20/\x20255.0\x20),\x20v.z\x20+\x20(\x20v.w\x20/\x20255.0\x20)\x20);\x0a}\x0afloat\x20viewZToOrthographicDepth(\x20const\x20in\x20float\x20viewZ,\x20const\x20in\x20float\x20near,\x20const\x20in\x20float\x20far\x20)\x20{\x0a\x09return\x20(\x20viewZ\x20+\x20near\x20)\x20/\x20(\x20near\x20-\x20far\x20);\x0a}\x0afloat\x20orthographicDepthToViewZ(\x20const\x20in\x20float\x20linearClipZ,\x20const\x20in\x20float\x20near,\x20const\x20in\x20float\x20far\x20)\x20{\x0a\x09return\x20linearClipZ\x20*\x20(\x20near\x20-\x20far\x20)\x20-\x20near;\x0a}\x0afloat\x20viewZToPerspectiveDepth(\x20const\x20in\x20float\x20viewZ,\x20const\x20in\x20float\x20near,\x20const\x20in\x20float\x20far\x20)\x20{\x0a\x09return\x20((\x20near\x20+\x20viewZ\x20)\x20*\x20far\x20)\x20/\x20((\x20far\x20-\x20near\x20)\x20*\x20viewZ\x20);\x0a}\x0afloat\x20perspectiveDepthToViewZ(\x20const\x20in\x20float\x20invClipZ,\x20const\x20in\x20float\x20near,\x20const\x20in\x20float\x20far\x20)\x20{\x0a\x09return\x20(\x20near\x20*\x20far\x20)\x20/\x20(\x20(\x20far\x20-\x20near\x20)\x20*\x20invClipZ\x20-\x20far\x20);\x0a}",
                    premultiplied_alpha_fragment: "#ifdef\x20PREMULTIPLIED_ALPHA\x0a\x09gl_FragColor.rgb\x20*=\x20gl_FragColor.a;\x0a#endif",
                    project_vertex:
                        "vec4\x20mvPosition\x20=\x20vec4(\x20transformed,\x201.0\x20);\x0a#ifdef\x20USE_INSTANCING\x0a\x09mvPosition\x20=\x20instanceMatrix\x20*\x20mvPosition;\x0a#endif\x0amvPosition\x20=\x20modelViewMatrix\x20*\x20mvPosition;\x0agl_Position\x20=\x20projectionMatrix\x20*\x20mvPosition;",
                    dithering_fragment: "#ifdef\x20DITHERING\x0a\x09gl_FragColor.rgb\x20=\x20dithering(\x20gl_FragColor.rgb\x20);\x0a#endif",
                    dithering_pars_fragment:
                        "#ifdef\x20DITHERING\x0a\x09vec3\x20dithering(\x20vec3\x20color\x20)\x20{\x0a\x09\x09float\x20grid_position\x20=\x20rand(\x20gl_FragCoord.xy\x20);\x0a\x09\x09vec3\x20dither_shift_RGB\x20=\x20vec3(\x200.25\x20/\x20255.0,\x20-0.25\x20/\x20255.0,\x200.25\x20/\x20255.0\x20);\x0a\x09\x09dither_shift_RGB\x20=\x20mix(\x202.0\x20*\x20dither_shift_RGB,\x20-2.0\x20*\x20dither_shift_RGB,\x20grid_position\x20);\x0a\x09\x09return\x20color\x20+\x20dither_shift_RGB;\x0a\x09}\x0a#endif",
                    roughnessmap_fragment:
                        "float\x20roughnessFactor\x20=\x20roughness;\x0a#ifdef\x20USE_ROUGHNESSMAP\x0a\x09vec4\x20texelRoughness\x20=\x20texture2D(\x20roughnessMap,\x20vUv\x20);\x0a\x09roughnessFactor\x20*=\x20texelRoughness.g;\x0a#endif",
                    roughnessmap_pars_fragment: "#ifdef\x20USE_ROUGHNESSMAP\x0a\x09uniform\x20sampler2D\x20roughnessMap;\x0a#endif",
                    shadowmap_pars_fragment:
                        "#ifdef\x20USE_SHADOWMAP\x0a\x09#if\x20NUM_DIR_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09uniform\x20sampler2D\x20directionalShadowMap[\x20NUM_DIR_LIGHT_SHADOWS\x20];\x0a\x09\x09varying\x20vec4\x20vDirectionalShadowCoord[\x20NUM_DIR_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09#if\x20NUM_SPOT_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09uniform\x20sampler2D\x20spotShadowMap[\x20NUM_SPOT_LIGHT_SHADOWS\x20];\x0a\x09\x09varying\x20vec4\x20vSpotShadowCoord[\x20NUM_SPOT_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09#if\x20NUM_POINT_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09uniform\x20sampler2D\x20pointShadowMap[\x20NUM_POINT_LIGHT_SHADOWS\x20];\x0a\x09\x09varying\x20vec4\x20vPointShadowCoord[\x20NUM_POINT_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09float\x20texture2DCompare(\x20sampler2D\x20depths,\x20vec2\x20uv,\x20float\x20compare\x20)\x20{\x0a\x09\x09return\x20step(\x20compare,\x20unpackRGBAToDepth(\x20texture2D(\x20depths,\x20uv\x20)\x20)\x20);\x0a\x09}\x0a\x09vec2\x20texture2DDistribution(\x20sampler2D\x20shadow,\x20vec2\x20uv\x20)\x20{\x0a\x09\x09return\x20unpackRGBATo2Half(\x20texture2D(\x20shadow,\x20uv\x20)\x20);\x0a\x09}\x0a\x09float\x20VSMShadow\x20(sampler2D\x20shadow,\x20vec2\x20uv,\x20float\x20compare\x20){\x0a\x09\x09float\x20occlusion\x20=\x201.0;\x0a\x09\x09vec2\x20distribution\x20=\x20texture2DDistribution(\x20shadow,\x20uv\x20);\x0a\x09\x09float\x20hard_shadow\x20=\x20step(\x20compare\x20,\x20distribution.x\x20);\x0a\x09\x09if\x20(hard_shadow\x20!=\x201.0\x20)\x20{\x0a\x09\x09\x09float\x20distance\x20=\x20compare\x20-\x20distribution.x\x20;\x0a\x09\x09\x09float\x20variance\x20=\x20max(\x200.00000,\x20distribution.y\x20*\x20distribution.y\x20);\x0a\x09\x09\x09float\x20softness_probability\x20=\x20variance\x20/\x20(variance\x20+\x20distance\x20*\x20distance\x20);\x09\x09\x09softness_probability\x20=\x20clamp(\x20(\x20softness_probability\x20-\x200.3\x20)\x20/\x20(\x200.95\x20-\x200.3\x20),\x200.0,\x201.0\x20);\x09\x09\x09occlusion\x20=\x20clamp(\x20max(\x20hard_shadow,\x20softness_probability\x20),\x200.0,\x201.0\x20);\x0a\x09\x09}\x0a\x09\x09return\x20occlusion;\x0a\x09}\x0a\x09float\x20getShadow(\x20sampler2D\x20shadowMap,\x20vec2\x20shadowMapSize,\x20float\x20shadowBias,\x20float\x20shadowRadius,\x20vec4\x20shadowCoord\x20)\x20{\x0a\x09\x09float\x20shadow\x20=\x201.0;\x0a\x09\x09shadowCoord.xyz\x20/=\x20shadowCoord.w;\x0a\x09\x09shadowCoord.z\x20+=\x20shadowBias;\x0a\x09\x09bvec4\x20inFrustumVec\x20=\x20bvec4\x20(\x20shadowCoord.x\x20>=\x200.0,\x20shadowCoord.x\x20<=\x201.0,\x20shadowCoord.y\x20>=\x200.0,\x20shadowCoord.y\x20<=\x201.0\x20);\x0a\x09\x09bool\x20inFrustum\x20=\x20all(\x20inFrustumVec\x20);\x0a\x09\x09bvec2\x20frustumTestVec\x20=\x20bvec2(\x20inFrustum,\x20shadowCoord.z\x20<=\x201.0\x20);\x0a\x09\x09bool\x20frustumTest\x20=\x20all(\x20frustumTestVec\x20);\x0a\x09\x09if\x20(\x20frustumTest\x20)\x20{\x0a\x09\x09#if\x20defined(\x20SHADOWMAP_TYPE_PCF\x20)\x0a\x09\x09\x09vec2\x20texelSize\x20=\x20vec2(\x201.0\x20)\x20/\x20shadowMapSize;\x0a\x09\x09\x09float\x20dx0\x20=\x20-\x20texelSize.x\x20*\x20shadowRadius;\x0a\x09\x09\x09float\x20dy0\x20=\x20-\x20texelSize.y\x20*\x20shadowRadius;\x0a\x09\x09\x09float\x20dx1\x20=\x20+\x20texelSize.x\x20*\x20shadowRadius;\x0a\x09\x09\x09float\x20dy1\x20=\x20+\x20texelSize.y\x20*\x20shadowRadius;\x0a\x09\x09\x09float\x20dx2\x20=\x20dx0\x20/\x202.0;\x0a\x09\x09\x09float\x20dy2\x20=\x20dy0\x20/\x202.0;\x0a\x09\x09\x09float\x20dx3\x20=\x20dx1\x20/\x202.0;\x0a\x09\x09\x09float\x20dy3\x20=\x20dy1\x20/\x202.0;\x0a\x09\x09\x09shadow\x20=\x20(\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx0,\x20dy0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x200.0,\x20dy0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx1,\x20dy0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx2,\x20dy2\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x200.0,\x20dy2\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx3,\x20dy2\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx0,\x200.0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx2,\x200.0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy,\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx3,\x200.0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx1,\x200.0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx2,\x20dy3\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x200.0,\x20dy3\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx3,\x20dy3\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx0,\x20dy1\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x200.0,\x20dy1\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20shadowCoord.xy\x20+\x20vec2(\x20dx1,\x20dy1\x20),\x20shadowCoord.z\x20)\x0a\x09\x09\x09)\x20*\x20(\x201.0\x20/\x2017.0\x20);\x0a\x09\x09#elif\x20defined(\x20SHADOWMAP_TYPE_PCF_SOFT\x20)\x0a\x09\x09\x09vec2\x20texelSize\x20=\x20vec2(\x201.0\x20)\x20/\x20shadowMapSize;\x0a\x09\x09\x09float\x20dx\x20=\x20texelSize.x;\x0a\x09\x09\x09float\x20dy\x20=\x20texelSize.y;\x0a\x09\x09\x09vec2\x20uv\x20=\x20shadowCoord.xy;\x0a\x09\x09\x09vec2\x20f\x20=\x20fract(\x20uv\x20*\x20shadowMapSize\x20+\x200.5\x20);\x0a\x09\x09\x09uv\x20-=\x20f\x20*\x20texelSize;\x0a\x09\x09\x09shadow\x20=\x20(\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20uv,\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20dx,\x200.0\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x200.0,\x20dy\x20),\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20uv\x20+\x20texelSize,\x20shadowCoord.z\x20)\x20+\x0a\x09\x09\x09\x09mix(\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20-dx,\x200.0\x20),\x20shadowCoord.z\x20),\x20\x0a\x09\x09\x09\x09\x09\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x202.0\x20*\x20dx,\x200.0\x20),\x20shadowCoord.z\x20),\x0a\x09\x09\x09\x09\x09\x20f.x\x20)\x20+\x0a\x09\x09\x09\x09mix(\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20-dx,\x20dy\x20),\x20shadowCoord.z\x20),\x20\x0a\x09\x09\x09\x09\x09\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x202.0\x20*\x20dx,\x20dy\x20),\x20shadowCoord.z\x20),\x0a\x09\x09\x09\x09\x09\x20f.x\x20)\x20+\x0a\x09\x09\x09\x09mix(\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x200.0,\x20-dy\x20),\x20shadowCoord.z\x20),\x20\x0a\x09\x09\x09\x09\x09\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x200.0,\x202.0\x20*\x20dy\x20),\x20shadowCoord.z\x20),\x0a\x09\x09\x09\x09\x09\x20f.y\x20)\x20+\x0a\x09\x09\x09\x09mix(\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20dx,\x20-dy\x20),\x20shadowCoord.z\x20),\x20\x0a\x09\x09\x09\x09\x09\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20dx,\x202.0\x20*\x20dy\x20),\x20shadowCoord.z\x20),\x0a\x09\x09\x09\x09\x09\x20f.y\x20)\x20+\x0a\x09\x09\x09\x09mix(\x20mix(\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20-dx,\x20-dy\x20),\x20shadowCoord.z\x20),\x20\x0a\x09\x09\x09\x09\x09\x09\x20\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x202.0\x20*\x20dx,\x20-dy\x20),\x20shadowCoord.z\x20),\x0a\x09\x09\x09\x09\x09\x09\x20\x20f.x\x20),\x0a\x09\x09\x09\x09\x09\x20mix(\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x20-dx,\x202.0\x20*\x20dy\x20),\x20shadowCoord.z\x20),\x20\x0a\x09\x09\x09\x09\x09\x09\x20\x20texture2DCompare(\x20shadowMap,\x20uv\x20+\x20vec2(\x202.0\x20*\x20dx,\x202.0\x20*\x20dy\x20),\x20shadowCoord.z\x20),\x0a\x09\x09\x09\x09\x09\x09\x20\x20f.x\x20),\x0a\x09\x09\x09\x09\x09\x20f.y\x20)\x0a\x09\x09\x09)\x20*\x20(\x201.0\x20/\x209.0\x20);\x0a\x09\x09#elif\x20defined(\x20SHADOWMAP_TYPE_VSM\x20)\x0a\x09\x09\x09shadow\x20=\x20VSMShadow(\x20shadowMap,\x20shadowCoord.xy,\x20shadowCoord.z\x20);\x0a\x09\x09#else\x0a\x09\x09\x09shadow\x20=\x20texture2DCompare(\x20shadowMap,\x20shadowCoord.xy,\x20shadowCoord.z\x20);\x0a\x09\x09#endif\x0a\x09\x09}\x0a\x09\x09return\x20shadow;\x0a\x09}\x0a\x09vec2\x20cubeToUV(\x20vec3\x20v,\x20float\x20texelSizeY\x20)\x20{\x0a\x09\x09vec3\x20absV\x20=\x20abs(\x20v\x20);\x0a\x09\x09float\x20scaleToCube\x20=\x201.0\x20/\x20max(\x20absV.x,\x20max(\x20absV.y,\x20absV.z\x20)\x20);\x0a\x09\x09absV\x20*=\x20scaleToCube;\x0a\x09\x09v\x20*=\x20scaleToCube\x20*\x20(\x201.0\x20-\x202.0\x20*\x20texelSizeY\x20);\x0a\x09\x09vec2\x20planar\x20=\x20v.xy;\x0a\x09\x09float\x20almostATexel\x20=\x201.5\x20*\x20texelSizeY;\x0a\x09\x09float\x20almostOne\x20=\x201.0\x20-\x20almostATexel;\x0a\x09\x09if\x20(\x20absV.z\x20>=\x20almostOne\x20)\x20{\x0a\x09\x09\x09if\x20(\x20v.z\x20>\x200.0\x20)\x0a\x09\x09\x09\x09planar.x\x20=\x204.0\x20-\x20v.x;\x0a\x09\x09}\x20else\x20if\x20(\x20absV.x\x20>=\x20almostOne\x20)\x20{\x0a\x09\x09\x09float\x20signX\x20=\x20sign(\x20v.x\x20);\x0a\x09\x09\x09planar.x\x20=\x20v.z\x20*\x20signX\x20+\x202.0\x20*\x20signX;\x0a\x09\x09}\x20else\x20if\x20(\x20absV.y\x20>=\x20almostOne\x20)\x20{\x0a\x09\x09\x09float\x20signY\x20=\x20sign(\x20v.y\x20);\x0a\x09\x09\x09planar.x\x20=\x20v.x\x20+\x202.0\x20*\x20signY\x20+\x202.0;\x0a\x09\x09\x09planar.y\x20=\x20v.z\x20*\x20signY\x20-\x202.0;\x0a\x09\x09}\x0a\x09\x09return\x20vec2(\x200.125,\x200.25\x20)\x20*\x20planar\x20+\x20vec2(\x200.375,\x200.75\x20);\x0a\x09}\x0a\x09float\x20getPointShadow(\x20sampler2D\x20shadowMap,\x20vec2\x20shadowMapSize,\x20float\x20shadowBias,\x20float\x20shadowRadius,\x20vec4\x20shadowCoord,\x20float\x20shadowCameraNear,\x20float\x20shadowCameraFar\x20)\x20{\x0a\x09\x09vec2\x20texelSize\x20=\x20vec2(\x201.0\x20)\x20/\x20(\x20shadowMapSize\x20*\x20vec2(\x204.0,\x202.0\x20)\x20);\x0a\x09\x09vec3\x20lightToPosition\x20=\x20shadowCoord.xyz;\x0a\x09\x09float\x20dp\x20=\x20(\x20length(\x20lightToPosition\x20)\x20-\x20shadowCameraNear\x20)\x20/\x20(\x20shadowCameraFar\x20-\x20shadowCameraNear\x20);\x09\x09dp\x20+=\x20shadowBias;\x0a\x09\x09vec3\x20bd3D\x20=\x20normalize(\x20lightToPosition\x20);\x0a\x09\x09#if\x20defined(\x20SHADOWMAP_TYPE_PCF\x20)\x20||\x20defined(\x20SHADOWMAP_TYPE_PCF_SOFT\x20)\x20||\x20defined(\x20SHADOWMAP_TYPE_VSM\x20)\x0a\x09\x09\x09vec2\x20offset\x20=\x20vec2(\x20-\x201,\x201\x20)\x20*\x20shadowRadius\x20*\x20texelSize.y;\x0a\x09\x09\x09return\x20(\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.xyy,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.yyy,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.xyx,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.yyx,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.xxy,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.yxy,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.xxx,\x20texelSize.y\x20),\x20dp\x20)\x20+\x0a\x09\x09\x09\x09texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D\x20+\x20offset.yxx,\x20texelSize.y\x20),\x20dp\x20)\x0a\x09\x09\x09)\x20*\x20(\x201.0\x20/\x209.0\x20);\x0a\x09\x09#else\x0a\x09\x09\x09return\x20texture2DCompare(\x20shadowMap,\x20cubeToUV(\x20bd3D,\x20texelSize.y\x20),\x20dp\x20);\x0a\x09\x09#endif\x0a\x09}\x0a#endif",
                    shadowmap_pars_vertex:
                        "#ifdef\x20USE_SHADOWMAP\x0a\x09#if\x20NUM_DIR_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09uniform\x20mat4\x20directionalShadowMatrix[\x20NUM_DIR_LIGHT_SHADOWS\x20];\x0a\x09\x09varying\x20vec4\x20vDirectionalShadowCoord[\x20NUM_DIR_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09#if\x20NUM_SPOT_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09uniform\x20mat4\x20spotShadowMatrix[\x20NUM_SPOT_LIGHT_SHADOWS\x20];\x0a\x09\x09varying\x20vec4\x20vSpotShadowCoord[\x20NUM_SPOT_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a\x09#if\x20NUM_POINT_LIGHT_SHADOWS\x20>\x200\x0a\x09\x09uniform\x20mat4\x20pointShadowMatrix[\x20NUM_POINT_LIGHT_SHADOWS\x20];\x0a\x09\x09varying\x20vec4\x20vPointShadowCoord[\x20NUM_POINT_LIGHT_SHADOWS\x20];\x0a\x09#endif\x0a#endif",
                    shadowmap_vertex:
                        "#ifdef\x20USE_SHADOWMAP\x0a\x09#if\x20NUM_DIR_LIGHT_SHADOWS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_DIR_LIGHT_SHADOWS;\x20i\x20++\x20)\x20{\x0a\x09\x09vDirectionalShadowCoord[\x20i\x20]\x20=\x20directionalShadowMatrix[\x20i\x20]\x20*\x20worldPosition;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a\x09#if\x20NUM_SPOT_LIGHT_SHADOWS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_SPOT_LIGHT_SHADOWS;\x20i\x20++\x20)\x20{\x0a\x09\x09vSpotShadowCoord[\x20i\x20]\x20=\x20spotShadowMatrix[\x20i\x20]\x20*\x20worldPosition;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a\x09#if\x20NUM_POINT_LIGHT_SHADOWS\x20>\x200\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_POINT_LIGHT_SHADOWS;\x20i\x20++\x20)\x20{\x0a\x09\x09vPointShadowCoord[\x20i\x20]\x20=\x20pointShadowMatrix[\x20i\x20]\x20*\x20worldPosition;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a#endif",
                    shadowmask_pars_fragment:
                        "float\x20getShadowMask()\x20{\x0a\x09float\x20shadow\x20=\x201.0;\x0a\x09#ifdef\x20USE_SHADOWMAP\x0a\x09#if\x20NUM_DIR_LIGHT_SHADOWS\x20>\x200\x0a\x09DirectionalLightShadow\x20directionalLight;\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_DIR_LIGHT_SHADOWS;\x20i\x20++\x20)\x20{\x0a\x09\x09directionalLight\x20=\x20directionalLightShadows[\x20i\x20];\x0a\x09\x09shadow\x20*=\x20receiveShadow\x20?\x20getShadow(\x20directionalShadowMap[\x20i\x20],\x20directionalLight.shadowMapSize,\x20directionalLight.shadowBias,\x20directionalLight.shadowRadius,\x20vDirectionalShadowCoord[\x20i\x20]\x20)\x20:\x201.0;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a\x09#if\x20NUM_SPOT_LIGHT_SHADOWS\x20>\x200\x0a\x09SpotLightShadow\x20spotLight;\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_SPOT_LIGHT_SHADOWS;\x20i\x20++\x20)\x20{\x0a\x09\x09spotLight\x20=\x20spotLightShadows[\x20i\x20];\x0a\x09\x09shadow\x20*=\x20receiveShadow\x20?\x20getShadow(\x20spotShadowMap[\x20i\x20],\x20spotLight.shadowMapSize,\x20spotLight.shadowBias,\x20spotLight.shadowRadius,\x20vSpotShadowCoord[\x20i\x20]\x20)\x20:\x201.0;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a\x09#if\x20NUM_POINT_LIGHT_SHADOWS\x20>\x200\x0a\x09PointLightShadow\x20pointLight;\x0a\x09#pragma\x20unroll_loop_start\x0a\x09for\x20(\x20int\x20i\x20=\x200;\x20i\x20<\x20NUM_POINT_LIGHT_SHADOWS;\x20i\x20++\x20)\x20{\x0a\x09\x09pointLight\x20=\x20pointLightShadows[\x20i\x20];\x0a\x09\x09shadow\x20*=\x20receiveShadow\x20?\x20getPointShadow(\x20pointShadowMap[\x20i\x20],\x20pointLight.shadowMapSize,\x20pointLight.shadowBias,\x20pointLight.shadowRadius,\x20vPointShadowCoord[\x20i\x20],\x20pointLight.shadowCameraNear,\x20pointLight.shadowCameraFar\x20)\x20:\x201.0;\x0a\x09}\x0a\x09#pragma\x20unroll_loop_end\x0a\x09#endif\x0a\x09#endif\x0a\x09return\x20shadow;\x0a}",
                    skinbase_vertex:
                        "#ifdef\x20USE_SKINNING\x0a\x09mat4\x20boneMatX\x20=\x20getBoneMatrix(\x20skinIndex.x\x20);\x0a\x09mat4\x20boneMatY\x20=\x20getBoneMatrix(\x20skinIndex.y\x20);\x0a\x09mat4\x20boneMatZ\x20=\x20getBoneMatrix(\x20skinIndex.z\x20);\x0a\x09mat4\x20boneMatW\x20=\x20getBoneMatrix(\x20skinIndex.w\x20);\x0a#endif",
                    skinning_pars_vertex:
                        "#ifdef\x20USE_SKINNING\x0a\x09uniform\x20mat4\x20bindMatrix;\x0a\x09uniform\x20mat4\x20bindMatrixInverse;\x0a\x09#ifdef\x20BONE_TEXTURE\x0a\x09\x09uniform\x20highp\x20sampler2D\x20boneTexture;\x0a\x09\x09uniform\x20int\x20boneTextureSize;\x0a\x09\x09mat4\x20getBoneMatrix(\x20const\x20in\x20float\x20i\x20)\x20{\x0a\x09\x09\x09float\x20j\x20=\x20i\x20*\x204.0;\x0a\x09\x09\x09float\x20x\x20=\x20mod(\x20j,\x20float(\x20boneTextureSize\x20)\x20);\x0a\x09\x09\x09float\x20y\x20=\x20floor(\x20j\x20/\x20float(\x20boneTextureSize\x20)\x20);\x0a\x09\x09\x09float\x20dx\x20=\x201.0\x20/\x20float(\x20boneTextureSize\x20);\x0a\x09\x09\x09float\x20dy\x20=\x201.0\x20/\x20float(\x20boneTextureSize\x20);\x0a\x09\x09\x09y\x20=\x20dy\x20*\x20(\x20y\x20+\x200.5\x20);\x0a\x09\x09\x09vec4\x20v1\x20=\x20texture2D(\x20boneTexture,\x20vec2(\x20dx\x20*\x20(\x20x\x20+\x200.5\x20),\x20y\x20)\x20);\x0a\x09\x09\x09vec4\x20v2\x20=\x20texture2D(\x20boneTexture,\x20vec2(\x20dx\x20*\x20(\x20x\x20+\x201.5\x20),\x20y\x20)\x20);\x0a\x09\x09\x09vec4\x20v3\x20=\x20texture2D(\x20boneTexture,\x20vec2(\x20dx\x20*\x20(\x20x\x20+\x202.5\x20),\x20y\x20)\x20);\x0a\x09\x09\x09vec4\x20v4\x20=\x20texture2D(\x20boneTexture,\x20vec2(\x20dx\x20*\x20(\x20x\x20+\x203.5\x20),\x20y\x20)\x20);\x0a\x09\x09\x09mat4\x20bone\x20=\x20mat4(\x20v1,\x20v2,\x20v3,\x20v4\x20);\x0a\x09\x09\x09return\x20bone;\x0a\x09\x09}\x0a\x09#else\x0a\x09\x09uniform\x20mat4\x20boneMatrices[\x20MAX_BONES\x20];\x0a\x09\x09mat4\x20getBoneMatrix(\x20const\x20in\x20float\x20i\x20)\x20{\x0a\x09\x09\x09mat4\x20bone\x20=\x20boneMatrices[\x20int(i)\x20];\x0a\x09\x09\x09return\x20bone;\x0a\x09\x09}\x0a\x09#endif\x0a#endif",
                    skinning_vertex:
                        "#ifdef\x20USE_SKINNING\x0a\x09vec4\x20skinVertex\x20=\x20bindMatrix\x20*\x20vec4(\x20transformed,\x201.0\x20);\x0a\x09vec4\x20skinned\x20=\x20vec4(\x200.0\x20);\x0a\x09skinned\x20+=\x20boneMatX\x20*\x20skinVertex\x20*\x20skinWeight.x;\x0a\x09skinned\x20+=\x20boneMatY\x20*\x20skinVertex\x20*\x20skinWeight.y;\x0a\x09skinned\x20+=\x20boneMatZ\x20*\x20skinVertex\x20*\x20skinWeight.z;\x0a\x09skinned\x20+=\x20boneMatW\x20*\x20skinVertex\x20*\x20skinWeight.w;\x0a\x09transformed\x20=\x20(\x20bindMatrixInverse\x20*\x20skinned\x20).xyz;\x0a#endif",
                    skinnormal_vertex:
                        "#ifdef\x20USE_SKINNING\x0a\x09mat4\x20skinMatrix\x20=\x20mat4(\x200.0\x20);\x0a\x09skinMatrix\x20+=\x20skinWeight.x\x20*\x20boneMatX;\x0a\x09skinMatrix\x20+=\x20skinWeight.y\x20*\x20boneMatY;\x0a\x09skinMatrix\x20+=\x20skinWeight.z\x20*\x20boneMatZ;\x0a\x09skinMatrix\x20+=\x20skinWeight.w\x20*\x20boneMatW;\x0a\x09skinMatrix\x20\x20=\x20bindMatrixInverse\x20*\x20skinMatrix\x20*\x20bindMatrix;\x0a\x09objectNormal\x20=\x20vec4(\x20skinMatrix\x20*\x20vec4(\x20objectNormal,\x200.0\x20)\x20).xyz;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09objectTangent\x20=\x20vec4(\x20skinMatrix\x20*\x20vec4(\x20objectTangent,\x200.0\x20)\x20).xyz;\x0a\x09#endif\x0a#endif",
                    specularmap_fragment:
                        "float\x20specularStrength;\x0a#ifdef\x20USE_SPECULARMAP\x0a\x09vec4\x20texelSpecular\x20=\x20texture2D(\x20specularMap,\x20vUv\x20);\x0a\x09specularStrength\x20=\x20texelSpecular.r;\x0a#else\x0a\x09specularStrength\x20=\x201.0;\x0a#endif",
                    specularmap_pars_fragment: "#ifdef\x20USE_SPECULARMAP\x0a\x09uniform\x20sampler2D\x20specularMap;\x0a#endif",
                    tonemapping_fragment: "#if\x20defined(\x20TONE_MAPPING\x20)\x0a\x09gl_FragColor.rgb\x20=\x20toneMapping(\x20gl_FragColor.rgb\x20);\x0a#endif",
                    tonemapping_pars_fragment:
                        "#ifndef\x20saturate\x0a#define\x20saturate(a)\x20clamp(\x20a,\x200.0,\x201.0\x20)\x0a#endif\x0auniform\x20float\x20toneMappingExposure;\x0auniform\x20float\x20toneMappingWhitePoint;\x0avec3\x20LinearToneMapping(\x20vec3\x20color\x20)\x20{\x0a\x09return\x20toneMappingExposure\x20*\x20color;\x0a}\x0avec3\x20ReinhardToneMapping(\x20vec3\x20color\x20)\x20{\x0a\x09color\x20*=\x20toneMappingExposure;\x0a\x09return\x20saturate(\x20color\x20/\x20(\x20vec3(\x201.0\x20)\x20+\x20color\x20)\x20);\x0a}\x0a#define\x20Uncharted2Helper(\x20x\x20)\x20max(\x20(\x20(\x20x\x20*\x20(\x200.15\x20*\x20x\x20+\x200.10\x20*\x200.50\x20)\x20+\x200.20\x20*\x200.02\x20)\x20/\x20(\x20x\x20*\x20(\x200.15\x20*\x20x\x20+\x200.50\x20)\x20+\x200.20\x20*\x200.30\x20)\x20)\x20-\x200.02\x20/\x200.30,\x20vec3(\x200.0\x20)\x20)\x0avec3\x20Uncharted2ToneMapping(\x20vec3\x20color\x20)\x20{\x0a\x09color\x20*=\x20toneMappingExposure;\x0a\x09return\x20saturate(\x20Uncharted2Helper(\x20color\x20)\x20/\x20Uncharted2Helper(\x20vec3(\x20toneMappingWhitePoint\x20)\x20)\x20);\x0a}\x0avec3\x20OptimizedCineonToneMapping(\x20vec3\x20color\x20)\x20{\x0a\x09color\x20*=\x20toneMappingExposure;\x0a\x09color\x20=\x20max(\x20vec3(\x200.0\x20),\x20color\x20-\x200.004\x20);\x0a\x09return\x20pow(\x20(\x20color\x20*\x20(\x206.2\x20*\x20color\x20+\x200.5\x20)\x20)\x20/\x20(\x20color\x20*\x20(\x206.2\x20*\x20color\x20+\x201.7\x20)\x20+\x200.06\x20),\x20vec3(\x202.2\x20)\x20);\x0a}\x0avec3\x20ACESFilmicToneMapping(\x20vec3\x20color\x20)\x20{\x0a\x09color\x20*=\x20toneMappingExposure;\x0a\x09return\x20saturate(\x20(\x20color\x20*\x20(\x202.51\x20*\x20color\x20+\x200.03\x20)\x20)\x20/\x20(\x20color\x20*\x20(\x202.43\x20*\x20color\x20+\x200.59\x20)\x20+\x200.14\x20)\x20);\x0a}",
                    uv_pars_fragment: "#if\x20(\x20defined(\x20USE_UV\x20)\x20&&\x20!\x20defined(\x20UVS_VERTEX_ONLY\x20)\x20)\x0a\x09varying\x20vec2\x20vUv;\x0a#endif",
                    uv_pars_vertex: "#ifdef\x20USE_UV\x0a\x09#ifdef\x20UVS_VERTEX_ONLY\x0a\x09\x09vec2\x20vUv;\x0a\x09#else\x0a\x09\x09varying\x20vec2\x20vUv;\x0a\x09#endif\x0a\x09uniform\x20mat3\x20uvTransform;\x0a#endif",
                    uv_vertex: "#ifdef\x20USE_UV\x0a\x09vUv\x20=\x20(\x20uvTransform\x20*\x20vec3(\x20uv,\x201\x20)\x20).xy;\x0a#endif",
                    uv2_pars_fragment: "#if\x20defined(\x20USE_LIGHTMAP\x20)\x20||\x20defined(\x20USE_AOMAP\x20)\x0a\x09varying\x20vec2\x20vUv2;\x0a#endif",
                    uv2_pars_vertex: "#if\x20defined(\x20USE_LIGHTMAP\x20)\x20||\x20defined(\x20USE_AOMAP\x20)\x0a\x09attribute\x20vec2\x20uv2;\x0a\x09varying\x20vec2\x20vUv2;\x0a\x09uniform\x20mat3\x20uv2Transform;\x0a#endif",
                    uv2_vertex: "#if\x20defined(\x20USE_LIGHTMAP\x20)\x20||\x20defined(\x20USE_AOMAP\x20)\x0a\x09vUv2\x20=\x20(\x20uv2Transform\x20*\x20vec3(\x20uv2,\x201\x20)\x20).xy;\x0a#endif",
                    worldpos_vertex:
                        "#if\x20defined(\x20USE_ENVMAP\x20)\x20||\x20defined(\x20DISTANCE\x20)\x20||\x20defined\x20(\x20USE_SHADOWMAP\x20)\x0a\x09vec4\x20worldPosition\x20=\x20vec4(\x20transformed,\x201.0\x20);\x0a\x09#ifdef\x20USE_INSTANCING\x0a\x09\x09worldPosition\x20=\x20instanceMatrix\x20*\x20worldPosition;\x0a\x09#endif\x0a\x09worldPosition\x20=\x20modelMatrix\x20*\x20worldPosition;\x0a#endif",
                    background_frag:
                        "uniform\x20sampler2D\x20t2D;\x0avarying\x20vec2\x20vUv;\x0avoid\x20main()\x20{\x0a\x09vec4\x20texColor\x20=\x20texture2D(\x20t2D,\x20vUv\x20);\x0a\x09gl_FragColor\x20=\x20mapTexelToLinear(\x20texColor\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a}",
                    background_vert:
                        "varying\x20vec2\x20vUv;\x0auniform\x20mat3\x20uvTransform;\x0avoid\x20main()\x20{\x0a\x09vUv\x20=\x20(\x20uvTransform\x20*\x20vec3(\x20uv,\x201\x20)\x20).xy;\x0a\x09gl_Position\x20=\x20vec4(\x20position.xy,\x201.0,\x201.0\x20);\x0a}",
                    cube_frag:
                        "#include\x20<envmap_common_pars_fragment>\x0auniform\x20float\x20opacity;\x0avarying\x20vec3\x20vWorldDirection;\x0a#include\x20<cube_uv_reflection_fragment>\x0avoid\x20main()\x20{\x0a\x09vec3\x20vReflect\x20=\x20vWorldDirection;\x0a\x09#include\x20<envmap_fragment>\x0a\x09gl_FragColor\x20=\x20envColor;\x0a\x09gl_FragColor.a\x20*=\x20opacity;\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a}",
                    cube_vert:
                        "varying\x20vec3\x20vWorldDirection;\x0a#include\x20<common>\x0avoid\x20main()\x20{\x0a\x09vWorldDirection\x20=\x20transformDirection(\x20position,\x20modelMatrix\x20);\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09gl_Position.z\x20=\x20gl_Position.w;\x0a}",
                    depth_frag:
                        "#if\x20DEPTH_PACKING\x20==\x203200\x0a\x09uniform\x20float\x20opacity;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avarying\x20vec2\x20vHighPrecisionZW;\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x201.0\x20);\x0a\x09#if\x20DEPTH_PACKING\x20==\x203200\x0a\x09\x09diffuseColor.a\x20=\x20opacity;\x0a\x09#endif\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09float\x20fragCoordZ\x20=\x200.5\x20*\x20vHighPrecisionZW[0]\x20/\x20vHighPrecisionZW[1]\x20+\x200.5;\x0a\x09#if\x20DEPTH_PACKING\x20==\x203200\x0a\x09\x09gl_FragColor\x20=\x20vec4(\x20vec3(\x201.0\x20-\x20fragCoordZ\x20),\x20opacity\x20);\x0a\x09#elif\x20DEPTH_PACKING\x20==\x203201\x0a\x09\x09gl_FragColor\x20=\x20packDepthToRGBA(\x20fragCoordZ\x20);\x0a\x09#endif\x0a}",
                    depth_vert:
                        "#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avarying\x20vec2\x20vHighPrecisionZW;\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#ifdef\x20USE_DISPLACEMENTMAP\x0a\x09\x09#include\x20<beginnormal_vertex>\x0a\x09\x09#include\x20<morphnormal_vertex>\x0a\x09\x09#include\x20<skinnormal_vertex>\x0a\x09#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09vHighPrecisionZW\x20=\x20gl_Position.zw;\x0a}",
                    distanceRGBA_frag:
                        "#define\x20DISTANCE\x0auniform\x20vec3\x20referencePosition;\x0auniform\x20float\x20nearDistance;\x0auniform\x20float\x20farDistance;\x0avarying\x20vec3\x20vWorldPosition;\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main\x20()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x201.0\x20);\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09float\x20dist\x20=\x20length(\x20vWorldPosition\x20-\x20referencePosition\x20);\x0a\x09dist\x20=\x20(\x20dist\x20-\x20nearDistance\x20)\x20/\x20(\x20farDistance\x20-\x20nearDistance\x20);\x0a\x09dist\x20=\x20saturate(\x20dist\x20);\x0a\x09gl_FragColor\x20=\x20packDepthToRGBA(\x20dist\x20);\x0a}",
                    distanceRGBA_vert:
                        "#define\x20DISTANCE\x0avarying\x20vec3\x20vWorldPosition;\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#ifdef\x20USE_DISPLACEMENTMAP\x0a\x09\x09#include\x20<beginnormal_vertex>\x0a\x09\x09#include\x20<morphnormal_vertex>\x0a\x09\x09#include\x20<skinnormal_vertex>\x0a\x09#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09vWorldPosition\x20=\x20worldPosition.xyz;\x0a}",
                    equirect_frag:
                        "uniform\x20sampler2D\x20tEquirect;\x0avarying\x20vec3\x20vWorldDirection;\x0a#include\x20<common>\x0avoid\x20main()\x20{\x0a\x09vec3\x20direction\x20=\x20normalize(\x20vWorldDirection\x20);\x0a\x09vec2\x20sampleUV\x20=\x20equirectUv(\x20direction\x20);\x0a\x09vec4\x20texColor\x20=\x20texture2D(\x20tEquirect,\x20sampleUV\x20);\x0a\x09gl_FragColor\x20=\x20mapTexelToLinear(\x20texColor\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a}",
                    equirect_vert:
                        "varying\x20vec3\x20vWorldDirection;\x0a#include\x20<common>\x0avoid\x20main()\x20{\x0a\x09vWorldDirection\x20=\x20transformDirection(\x20position,\x20modelMatrix\x20);\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<project_vertex>\x0a}",
                    linedashed_frag:
                        "uniform\x20vec3\x20diffuse;\x0auniform\x20float\x20opacity;\x0auniform\x20float\x20dashSize;\x0auniform\x20float\x20totalSize;\x0avarying\x20float\x20vLineDistance;\x0a#include\x20<common>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09if\x20(\x20mod(\x20vLineDistance,\x20totalSize\x20)\x20>\x20dashSize\x20)\x20{\x0a\x09\x09discard;\x0a\x09}\x0a\x09vec3\x20outgoingLight\x20=\x20vec3(\x200.0\x20);\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09outgoingLight\x20=\x20diffuseColor.rgb;\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a}",
                    linedashed_vert:
                        "uniform\x20float\x20scale;\x0aattribute\x20float\x20lineDistance;\x0avarying\x20float\x20vLineDistance;\x0a#include\x20<common>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09vLineDistance\x20=\x20scale\x20*\x20lineDistance;\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    meshbasic_frag:
                        "uniform\x20vec3\x20diffuse;\x0auniform\x20float\x20opacity;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<dithering_pars_fragment>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<uv2_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<aomap_pars_fragment>\x0a#include\x20<lightmap_pars_fragment>\x0a#include\x20<envmap_common_pars_fragment>\x0a#include\x20<envmap_pars_fragment>\x0a#include\x20<cube_uv_reflection_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<specularmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<specularmap_fragment>\x0a\x09ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x09#ifdef\x20USE_LIGHTMAP\x0a\x09\x0a\x09\x09vec4\x20lightMapTexel=\x20texture2D(\x20lightMap,\x20vUv2\x20);\x0a\x09\x09reflectedLight.indirectDiffuse\x20+=\x20lightMapTexelToLinear(\x20lightMapTexel\x20).rgb\x20*\x20lightMapIntensity;\x0a\x09#else\x0a\x09\x09reflectedLight.indirectDiffuse\x20+=\x20vec3(\x201.0\x20);\x0a\x09#endif\x0a\x09#include\x20<aomap_fragment>\x0a\x09reflectedLight.indirectDiffuse\x20*=\x20diffuseColor.rgb;\x0a\x09vec3\x20outgoingLight\x20=\x20reflectedLight.indirectDiffuse;\x0a\x09#include\x20<envmap_fragment>\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a\x09#include\x20<dithering_fragment>\x0a}",
                    meshbasic_vert:
                        "#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<uv2_pars_vertex>\x0a#include\x20<envmap_pars_vertex>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<uv2_vertex>\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#ifdef\x20USE_ENVMAP\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a\x09#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09#include\x20<envmap_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    meshlambert_frag:
                        "uniform\x20vec3\x20diffuse;\x0auniform\x20vec3\x20emissive;\x0auniform\x20float\x20opacity;\x0avarying\x20vec3\x20vLightFront;\x0avarying\x20vec3\x20vIndirectFront;\x0a#ifdef\x20DOUBLE_SIDED\x0a\x09varying\x20vec3\x20vLightBack;\x0a\x09varying\x20vec3\x20vIndirectBack;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<dithering_pars_fragment>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<uv2_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<aomap_pars_fragment>\x0a#include\x20<lightmap_pars_fragment>\x0a#include\x20<emissivemap_pars_fragment>\x0a#include\x20<envmap_common_pars_fragment>\x0a#include\x20<envmap_pars_fragment>\x0a#include\x20<cube_uv_reflection_fragment>\x0a#include\x20<bsdfs>\x0a#include\x20<lights_pars_begin>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<shadowmap_pars_fragment>\x0a#include\x20<shadowmask_pars_fragment>\x0a#include\x20<specularmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x09vec3\x20totalEmissiveRadiance\x20=\x20emissive;\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<specularmap_fragment>\x0a\x09#include\x20<emissivemap_fragment>\x0a\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09reflectedLight.indirectDiffuse\x20+=\x20(\x20gl_FrontFacing\x20)\x20?\x20vIndirectFront\x20:\x20vIndirectBack;\x0a\x09#else\x0a\x09\x09reflectedLight.indirectDiffuse\x20+=\x20vIndirectFront;\x0a\x09#endif\x0a\x09#include\x20<lightmap_fragment>\x0a\x09reflectedLight.indirectDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20);\x0a\x09#ifdef\x20DOUBLE_SIDED\x0a\x09\x09reflectedLight.directDiffuse\x20=\x20(\x20gl_FrontFacing\x20)\x20?\x20vLightFront\x20:\x20vLightBack;\x0a\x09#else\x0a\x09\x09reflectedLight.directDiffuse\x20=\x20vLightFront;\x0a\x09#endif\x0a\x09reflectedLight.directDiffuse\x20*=\x20BRDF_Diffuse_Lambert(\x20diffuseColor.rgb\x20)\x20*\x20getShadowMask();\x0a\x09#include\x20<aomap_fragment>\x0a\x09vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse\x20+\x20totalEmissiveRadiance;\x0a\x09#include\x20<envmap_fragment>\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a\x09#include\x20<dithering_fragment>\x0a}",
                    meshlambert_vert:
                        "#define\x20LAMBERT\x0avarying\x20vec3\x20vLightFront;\x0avarying\x20vec3\x20vIndirectFront;\x0a#ifdef\x20DOUBLE_SIDED\x0a\x09varying\x20vec3\x20vLightBack;\x0a\x09varying\x20vec3\x20vIndirectBack;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<uv2_pars_vertex>\x0a#include\x20<envmap_pars_vertex>\x0a#include\x20<bsdfs>\x0a#include\x20<lights_pars_begin>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<shadowmap_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<uv2_vertex>\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<envmap_vertex>\x0a\x09#include\x20<lights_lambert_vertex>\x0a\x09#include\x20<shadowmap_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    meshmatcap_frag:
                        "#define\x20MATCAP\x0auniform\x20vec3\x20diffuse;\x0auniform\x20float\x20opacity;\x0auniform\x20sampler2D\x20matcap;\x0avarying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<dithering_pars_fragment>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<bumpmap_pars_fragment>\x0a#include\x20<normalmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<normal_fragment_begin>\x0a\x09#include\x20<normal_fragment_maps>\x0a\x09vec3\x20viewDir\x20=\x20normalize(\x20vViewPosition\x20);\x0a\x09vec3\x20x\x20=\x20normalize(\x20vec3(\x20viewDir.z,\x200.0,\x20-\x20viewDir.x\x20)\x20);\x0a\x09vec3\x20y\x20=\x20cross(\x20viewDir,\x20x\x20);\x0a\x09vec2\x20uv\x20=\x20vec2(\x20dot(\x20x,\x20normal\x20),\x20dot(\x20y,\x20normal\x20)\x20)\x20*\x200.495\x20+\x200.5;\x0a\x09#ifdef\x20USE_MATCAP\x0a\x09\x09vec4\x20matcapColor\x20=\x20texture2D(\x20matcap,\x20uv\x20);\x0a\x09\x09matcapColor\x20=\x20matcapTexelToLinear(\x20matcapColor\x20);\x0a\x09#else\x0a\x09\x09vec4\x20matcapColor\x20=\x20vec4(\x201.0\x20);\x0a\x09#endif\x0a\x09vec3\x20outgoingLight\x20=\x20diffuseColor.rgb\x20*\x20matcapColor.rgb;\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a\x09#include\x20<dithering_fragment>\x0a}",
                    meshmatcap_vert:
                        "#define\x20MATCAP\x0avarying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a\x09#ifndef\x20FLAT_SHADED\x0a\x09\x09vNormal\x20=\x20normalize(\x20transformedNormal\x20);\x0a\x09#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09#include\x20<fog_vertex>\x0a\x09vViewPosition\x20=\x20-\x20mvPosition.xyz;\x0a}",
                    meshtoon_frag:
                        "#define\x20TOON\x0auniform\x20vec3\x20diffuse;\x0auniform\x20vec3\x20emissive;\x0auniform\x20vec3\x20specular;\x0auniform\x20float\x20shininess;\x0auniform\x20float\x20opacity;\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<dithering_pars_fragment>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<uv2_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<aomap_pars_fragment>\x0a#include\x20<lightmap_pars_fragment>\x0a#include\x20<emissivemap_pars_fragment>\x0a#include\x20<gradientmap_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<bsdfs>\x0a#include\x20<lights_pars_begin>\x0a#include\x20<lights_toon_pars_fragment>\x0a#include\x20<shadowmap_pars_fragment>\x0a#include\x20<bumpmap_pars_fragment>\x0a#include\x20<normalmap_pars_fragment>\x0a#include\x20<specularmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x09vec3\x20totalEmissiveRadiance\x20=\x20emissive;\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<specularmap_fragment>\x0a\x09#include\x20<normal_fragment_begin>\x0a\x09#include\x20<normal_fragment_maps>\x0a\x09#include\x20<emissivemap_fragment>\x0a\x09#include\x20<lights_toon_fragment>\x0a\x09#include\x20<lights_fragment_begin>\x0a\x09#include\x20<lights_fragment_maps>\x0a\x09#include\x20<lights_fragment_end>\x0a\x09#include\x20<aomap_fragment>\x0a\x09vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse\x20+\x20reflectedLight.directSpecular\x20+\x20reflectedLight.indirectSpecular\x20+\x20totalEmissiveRadiance;\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a\x09#include\x20<dithering_fragment>\x0a}",
                    meshtoon_vert:
                        "#define\x20TOON\x0avarying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<uv2_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<shadowmap_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<uv2_vertex>\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a#ifndef\x20FLAT_SHADED\x0a\x09vNormal\x20=\x20normalize(\x20transformedNormal\x20);\x0a#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09vViewPosition\x20=\x20-\x20mvPosition.xyz;\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<shadowmap_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    meshphong_frag:
                        "#define\x20PHONG\x0auniform\x20vec3\x20diffuse;\x0auniform\x20vec3\x20emissive;\x0auniform\x20vec3\x20specular;\x0auniform\x20float\x20shininess;\x0auniform\x20float\x20opacity;\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<dithering_pars_fragment>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<uv2_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<aomap_pars_fragment>\x0a#include\x20<lightmap_pars_fragment>\x0a#include\x20<emissivemap_pars_fragment>\x0a#include\x20<envmap_common_pars_fragment>\x0a#include\x20<envmap_pars_fragment>\x0a#include\x20<cube_uv_reflection_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<bsdfs>\x0a#include\x20<lights_pars_begin>\x0a#include\x20<lights_phong_pars_fragment>\x0a#include\x20<shadowmap_pars_fragment>\x0a#include\x20<bumpmap_pars_fragment>\x0a#include\x20<normalmap_pars_fragment>\x0a#include\x20<specularmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x09vec3\x20totalEmissiveRadiance\x20=\x20emissive;\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<specularmap_fragment>\x0a\x09#include\x20<normal_fragment_begin>\x0a\x09#include\x20<normal_fragment_maps>\x0a\x09#include\x20<emissivemap_fragment>\x0a\x09#include\x20<lights_phong_fragment>\x0a\x09#include\x20<lights_fragment_begin>\x0a\x09#include\x20<lights_fragment_maps>\x0a\x09#include\x20<lights_fragment_end>\x0a\x09#include\x20<aomap_fragment>\x0a\x09vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse\x20+\x20reflectedLight.directSpecular\x20+\x20reflectedLight.indirectSpecular\x20+\x20totalEmissiveRadiance;\x0a\x09#include\x20<envmap_fragment>\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a\x09#include\x20<dithering_fragment>\x0a}",
                    meshphong_vert:
                        "#define\x20PHONG\x0avarying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a#endif\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<uv2_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<envmap_pars_vertex>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<shadowmap_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<uv2_vertex>\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a#ifndef\x20FLAT_SHADED\x0a\x09vNormal\x20=\x20normalize(\x20transformedNormal\x20);\x0a#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09vViewPosition\x20=\x20-\x20mvPosition.xyz;\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<envmap_vertex>\x0a\x09#include\x20<shadowmap_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    meshphysical_frag:
                        "#define\x20STANDARD\x0a#ifdef\x20PHYSICAL\x0a\x09#define\x20REFLECTIVITY\x0a\x09#define\x20CLEARCOAT\x0a\x09#define\x20TRANSPARENCY\x0a#endif\x0auniform\x20vec3\x20diffuse;\x0auniform\x20vec3\x20emissive;\x0auniform\x20float\x20roughness;\x0auniform\x20float\x20metalness;\x0auniform\x20float\x20opacity;\x0a#ifdef\x20TRANSPARENCY\x0a\x09uniform\x20float\x20transparency;\x0a#endif\x0a#ifdef\x20REFLECTIVITY\x0a\x09uniform\x20float\x20reflectivity;\x0a#endif\x0a#ifdef\x20CLEARCOAT\x0a\x09uniform\x20float\x20clearcoat;\x0a\x09uniform\x20float\x20clearcoatRoughness;\x0a#endif\x0a#ifdef\x20USE_SHEEN\x0a\x09uniform\x20vec3\x20sheen;\x0a#endif\x0avarying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09varying\x20vec3\x20vTangent;\x0a\x09\x09varying\x20vec3\x20vBitangent;\x0a\x09#endif\x0a#endif\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<dithering_pars_fragment>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<uv2_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<aomap_pars_fragment>\x0a#include\x20<lightmap_pars_fragment>\x0a#include\x20<emissivemap_pars_fragment>\x0a#include\x20<bsdfs>\x0a#include\x20<cube_uv_reflection_fragment>\x0a#include\x20<envmap_common_pars_fragment>\x0a#include\x20<envmap_physical_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<lights_pars_begin>\x0a#include\x20<lights_physical_pars_fragment>\x0a#include\x20<shadowmap_pars_fragment>\x0a#include\x20<bumpmap_pars_fragment>\x0a#include\x20<normalmap_pars_fragment>\x0a#include\x20<clearcoat_pars_fragment>\x0a#include\x20<roughnessmap_pars_fragment>\x0a#include\x20<metalnessmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09ReflectedLight\x20reflectedLight\x20=\x20ReflectedLight(\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20),\x20vec3(\x200.0\x20)\x20);\x0a\x09vec3\x20totalEmissiveRadiance\x20=\x20emissive;\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09#include\x20<roughnessmap_fragment>\x0a\x09#include\x20<metalnessmap_fragment>\x0a\x09#include\x20<normal_fragment_begin>\x0a\x09#include\x20<normal_fragment_maps>\x0a\x09#include\x20<clearcoat_normal_fragment_begin>\x0a\x09#include\x20<clearcoat_normal_fragment_maps>\x0a\x09#include\x20<emissivemap_fragment>\x0a\x09#include\x20<lights_physical_fragment>\x0a\x09#include\x20<lights_fragment_begin>\x0a\x09#include\x20<lights_fragment_maps>\x0a\x09#include\x20<lights_fragment_end>\x0a\x09#include\x20<aomap_fragment>\x0a\x09vec3\x20outgoingLight\x20=\x20reflectedLight.directDiffuse\x20+\x20reflectedLight.indirectDiffuse\x20+\x20reflectedLight.directSpecular\x20+\x20reflectedLight.indirectSpecular\x20+\x20totalEmissiveRadiance;\x0a\x09#ifdef\x20TRANSPARENCY\x0a\x09\x09diffuseColor.a\x20*=\x20saturate(\x201.\x20-\x20transparency\x20+\x20linearToRelativeLuminance(\x20reflectedLight.directSpecular\x20+\x20reflectedLight.indirectSpecular\x20)\x20);\x0a\x09#endif\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a\x09#include\x20<dithering_fragment>\x0a}",
                    meshphysical_vert:
                        "#define\x20STANDARD\x0avarying\x20vec3\x20vViewPosition;\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09varying\x20vec3\x20vTangent;\x0a\x09\x09varying\x20vec3\x20vBitangent;\x0a\x09#endif\x0a#endif\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<uv2_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<shadowmap_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<uv2_vertex>\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a#ifndef\x20FLAT_SHADED\x0a\x09vNormal\x20=\x20normalize(\x20transformedNormal\x20);\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09vTangent\x20=\x20normalize(\x20transformedTangent\x20);\x0a\x09\x09vBitangent\x20=\x20normalize(\x20cross(\x20vNormal,\x20vTangent\x20)\x20*\x20tangent.w\x20);\x0a\x09#endif\x0a#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09vViewPosition\x20=\x20-\x20mvPosition.xyz;\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<shadowmap_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    normal_frag:
                        "#define\x20NORMAL\x0auniform\x20float\x20opacity;\x0a#if\x20defined(\x20FLAT_SHADED\x20)\x20||\x20defined(\x20USE_BUMPMAP\x20)\x20||\x20defined(\x20TANGENTSPACE_NORMALMAP\x20)\x0a\x09varying\x20vec3\x20vViewPosition;\x0a#endif\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09varying\x20vec3\x20vTangent;\x0a\x09\x09varying\x20vec3\x20vBitangent;\x0a\x09#endif\x0a#endif\x0a#include\x20<packing>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<bumpmap_pars_fragment>\x0a#include\x20<normalmap_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<normal_fragment_begin>\x0a\x09#include\x20<normal_fragment_maps>\x0a\x09gl_FragColor\x20=\x20vec4(\x20packNormalToRGB(\x20normal\x20),\x20opacity\x20);\x0a}",
                    normal_vert:
                        "#define\x20NORMAL\x0a#if\x20defined(\x20FLAT_SHADED\x20)\x20||\x20defined(\x20USE_BUMPMAP\x20)\x20||\x20defined(\x20TANGENTSPACE_NORMALMAP\x20)\x0a\x09varying\x20vec3\x20vViewPosition;\x0a#endif\x0a#ifndef\x20FLAT_SHADED\x0a\x09varying\x20vec3\x20vNormal;\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09varying\x20vec3\x20vTangent;\x0a\x09\x09varying\x20vec3\x20vBitangent;\x0a\x09#endif\x0a#endif\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<displacementmap_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<skinning_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09#include\x20<beginnormal_vertex>\x0a\x09#include\x20<morphnormal_vertex>\x0a\x09#include\x20<skinbase_vertex>\x0a\x09#include\x20<skinnormal_vertex>\x0a\x09#include\x20<defaultnormal_vertex>\x0a#ifndef\x20FLAT_SHADED\x0a\x09vNormal\x20=\x20normalize(\x20transformedNormal\x20);\x0a\x09#ifdef\x20USE_TANGENT\x0a\x09\x09vTangent\x20=\x20normalize(\x20transformedTangent\x20);\x0a\x09\x09vBitangent\x20=\x20normalize(\x20cross(\x20vNormal,\x20vTangent\x20)\x20*\x20tangent.w\x20);\x0a\x09#endif\x0a#endif\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<skinning_vertex>\x0a\x09#include\x20<displacementmap_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a#if\x20defined(\x20FLAT_SHADED\x20)\x20||\x20defined(\x20USE_BUMPMAP\x20)\x20||\x20defined(\x20TANGENTSPACE_NORMALMAP\x20)\x0a\x09vViewPosition\x20=\x20-\x20mvPosition.xyz;\x0a#endif\x0a}",
                    points_frag:
                        "uniform\x20vec3\x20diffuse;\x0auniform\x20float\x20opacity;\x0a#include\x20<common>\x0a#include\x20<color_pars_fragment>\x0a#include\x20<map_particle_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec3\x20outgoingLight\x20=\x20vec3(\x200.0\x20);\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_particle_fragment>\x0a\x09#include\x20<color_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09outgoingLight\x20=\x20diffuseColor.rgb;\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a\x09#include\x20<premultiplied_alpha_fragment>\x0a}",
                    points_vert:
                        "uniform\x20float\x20size;\x0auniform\x20float\x20scale;\x0a#include\x20<common>\x0a#include\x20<color_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<morphtarget_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<color_vertex>\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<morphtarget_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09gl_PointSize\x20=\x20size;\x0a\x09#ifdef\x20USE_SIZEATTENUATION\x0a\x09\x09bool\x20isPerspective\x20=\x20isPerspectiveMatrix(\x20projectionMatrix\x20);\x0a\x09\x09if\x20(\x20isPerspective\x20)\x20gl_PointSize\x20*=\x20(\x20scale\x20/\x20-\x20mvPosition.z\x20);\x0a\x09#endif\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    shadow_frag:
                        "uniform\x20vec3\x20color;\x0auniform\x20float\x20opacity;\x0a#include\x20<common>\x0a#include\x20<packing>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<bsdfs>\x0a#include\x20<lights_pars_begin>\x0a#include\x20<shadowmap_pars_fragment>\x0a#include\x20<shadowmask_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09gl_FragColor\x20=\x20vec4(\x20color,\x20opacity\x20*\x20(\x201.0\x20-\x20getShadowMask()\x20)\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a}",
                    shadow_vert:
                        "#include\x20<fog_pars_vertex>\x0a#include\x20<shadowmap_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<begin_vertex>\x0a\x09#include\x20<project_vertex>\x0a\x09#include\x20<worldpos_vertex>\x0a\x09#include\x20<shadowmap_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                    sprite_frag:
                        "uniform\x20vec3\x20diffuse;\x0auniform\x20float\x20opacity;\x0a#include\x20<common>\x0a#include\x20<uv_pars_fragment>\x0a#include\x20<map_pars_fragment>\x0a#include\x20<alphamap_pars_fragment>\x0a#include\x20<fog_pars_fragment>\x0a#include\x20<logdepthbuf_pars_fragment>\x0a#include\x20<clipping_planes_pars_fragment>\x0avoid\x20main()\x20{\x0a\x09#include\x20<clipping_planes_fragment>\x0a\x09vec3\x20outgoingLight\x20=\x20vec3(\x200.0\x20);\x0a\x09vec4\x20diffuseColor\x20=\x20vec4(\x20diffuse,\x20opacity\x20);\x0a\x09#include\x20<logdepthbuf_fragment>\x0a\x09#include\x20<map_fragment>\x0a\x09#include\x20<alphamap_fragment>\x0a\x09#include\x20<alphatest_fragment>\x0a\x09outgoingLight\x20=\x20diffuseColor.rgb;\x0a\x09gl_FragColor\x20=\x20vec4(\x20outgoingLight,\x20diffuseColor.a\x20);\x0a\x09#include\x20<tonemapping_fragment>\x0a\x09#include\x20<encodings_fragment>\x0a\x09#include\x20<fog_fragment>\x0a}",
                    sprite_vert:
                        "uniform\x20float\x20rotation;\x0auniform\x20vec2\x20center;\x0a#include\x20<common>\x0a#include\x20<uv_pars_vertex>\x0a#include\x20<fog_pars_vertex>\x0a#include\x20<logdepthbuf_pars_vertex>\x0a#include\x20<clipping_planes_pars_vertex>\x0avoid\x20main()\x20{\x0a\x09#include\x20<uv_vertex>\x0a\x09vec4\x20mvPosition\x20=\x20modelViewMatrix\x20*\x20vec4(\x200.0,\x200.0,\x200.0,\x201.0\x20);\x0a\x09vec2\x20scale;\x0a\x09scale.x\x20=\x20length(\x20vec3(\x20modelMatrix[\x200\x20].x,\x20modelMatrix[\x200\x20].y,\x20modelMatrix[\x200\x20].z\x20)\x20);\x0a\x09scale.y\x20=\x20length(\x20vec3(\x20modelMatrix[\x201\x20].x,\x20modelMatrix[\x201\x20].y,\x20modelMatrix[\x201\x20].z\x20)\x20);\x0a\x09#ifndef\x20USE_SIZEATTENUATION\x0a\x09\x09bool\x20isPerspective\x20=\x20isPerspectiveMatrix(\x20projectionMatrix\x20);\x0a\x09\x09if\x20(\x20isPerspective\x20)\x20scale\x20*=\x20-\x20mvPosition.z;\x0a\x09#endif\x0a\x09vec2\x20alignedPosition\x20=\x20(\x20position.xy\x20-\x20(\x20center\x20-\x20vec2(\x200.5\x20)\x20)\x20)\x20*\x20scale;\x0a\x09vec2\x20rotatedPosition;\x0a\x09rotatedPosition.x\x20=\x20cos(\x20rotation\x20)\x20*\x20alignedPosition.x\x20-\x20sin(\x20rotation\x20)\x20*\x20alignedPosition.y;\x0a\x09rotatedPosition.y\x20=\x20sin(\x20rotation\x20)\x20*\x20alignedPosition.x\x20+\x20cos(\x20rotation\x20)\x20*\x20alignedPosition.y;\x0a\x09mvPosition.xy\x20+=\x20rotatedPosition;\x0a\x09gl_Position\x20=\x20projectionMatrix\x20*\x20mvPosition;\x0a\x09#include\x20<logdepthbuf_vertex>\x0a\x09#include\x20<clipping_planes_vertex>\x0a\x09#include\x20<fog_vertex>\x0a}",
                },
                C6 = {
                    basic: { uniforms: TS([C0["common"], C0["specularmap"], C0["envmap"], C0["aomap"], C0["lightmap"], C0["fog"]]), vertexShader: C5["meshbasic_vert"], fragmentShader: C5["meshbasic_frag"] },
                    lambert: {
                        uniforms: TS([C0["common"], C0["specularmap"], C0["envmap"], C0["aomap"], C0["lightmap"], C0["emissivemap"], C0["fog"], C0["lights"], { emissive: { value: new Rq(0x0) } }]),
                        vertexShader: C5["meshlambert_vert"],
                        fragmentShader: C5["meshlambert_frag"],
                    },
                    phong: {
                        uniforms: TS([
                            C0["common"],
                            C0["specularmap"],
                            C0["envmap"],
                            C0["aomap"],
                            C0["lightmap"],
                            C0["emissivemap"],
                            C0["bumpmap"],
                            C0["normalmap"],
                            C0["displacementmap"],
                            C0["fog"],
                            C0["lights"],
                            { emissive: { value: new Rq(0x0) }, specular: { value: new Rq(0x111111) }, shininess: { value: 0x1e } },
                        ]),
                        vertexShader: C5["meshphong_vert"],
                        fragmentShader: C5["meshphong_frag"],
                    },
                    standard: {
                        uniforms: TS([
                            C0["common"],
                            C0["envmap"],
                            C0["aomap"],
                            C0["lightmap"],
                            C0["emissivemap"],
                            C0["bumpmap"],
                            C0["normalmap"],
                            C0["displacementmap"],
                            C0["roughnessmap"],
                            C0["metalnessmap"],
                            C0["fog"],
                            C0["lights"],
                            { emissive: { value: new Rq(0x0) }, roughness: { value: 0x1 }, metalness: { value: 0x0 }, envMapIntensity: { value: 0x1 } },
                        ]),
                        vertexShader: C5["meshphysical_vert"],
                        fragmentShader: C5["meshphysical_frag"],
                    },
                    toon: {
                        uniforms: TS([
                            C0["common"],
                            C0["specularmap"],
                            C0["aomap"],
                            C0["lightmap"],
                            C0["emissivemap"],
                            C0["bumpmap"],
                            C0["normalmap"],
                            C0["displacementmap"],
                            C0["gradientmap"],
                            C0["fog"],
                            C0["lights"],
                            { emissive: { value: new Rq(0x0) }, specular: { value: new Rq(0x111111) }, shininess: { value: 0x1e } },
                        ]),
                        vertexShader: C5["meshtoon_vert"],
                        fragmentShader: C5["meshtoon_frag"],
                    },
                    matcap: { uniforms: TS([C0["common"], C0["bumpmap"], C0["normalmap"], C0["displacementmap"], C0["fog"], { matcap: { value: null } }]), vertexShader: C5["meshmatcap_vert"], fragmentShader: C5["meshmatcap_frag"] },
                    points: { uniforms: TS([C0["points"], C0["fog"]]), vertexShader: C5["points_vert"], fragmentShader: C5["points_frag"] },
                    dashed: { uniforms: TS([C0["common"], C0["fog"], { scale: { value: 0x1 }, dashSize: { value: 0x1 }, totalSize: { value: 0x2 } }]), vertexShader: C5["linedashed_vert"], fragmentShader: C5["linedashed_frag"] },
                    depth: { uniforms: TS([C0["common"], C0["displacementmap"]]), vertexShader: C5["depth_vert"], fragmentShader: C5["depth_frag"] },
                    normal: { uniforms: TS([C0["common"], C0["bumpmap"], C0["normalmap"], C0["displacementmap"], { opacity: { value: 0x1 } }]), vertexShader: C5["normal_vert"], fragmentShader: C5["normal_frag"] },
                    sprite: { uniforms: TS([C0["sprite"], C0["fog"]]), vertexShader: C5["sprite_vert"], fragmentShader: C5["sprite_frag"] },
                    background: { uniforms: { uvTransform: { value: new E4() }, t2D: { value: null } }, vertexShader: C5["background_vert"], fragmentShader: C5["background_frag"] },
                    cube: { uniforms: TS([C0["envmap"], { opacity: { value: 0x1 } }]), vertexShader: C5["cube_vert"], fragmentShader: C5["cube_frag"] },
                    equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: C5["equirect_vert"], fragmentShader: C5["equirect_frag"] },
                    distanceRGBA: {
                        uniforms: TS([C0["common"], C0["displacementmap"], { referencePosition: { value: new Ed() }, nearDistance: { value: 0x1 }, farDistance: { value: 0x3e8 } }]),
                        vertexShader: C5["distanceRGBA_vert"],
                        fragmentShader: C5["distanceRGBA_frag"],
                    },
                    shadow: { uniforms: TS([C0["lights"], C0["fog"], { color: { value: new Rq(0x0) }, opacity: { value: 0x1 } }]), vertexShader: C5["shadow_vert"], fragmentShader: C5["shadow_frag"] },
                };
            function C7(mN, mX, mf, mP) {
                var mI,
                    mA,
                    mM = new Rq(0x0),
                    mp = 0x0,
                    mk = null,
                    mU = 0x0,
                    mq = null;
                function mw(mO, mj) {
                    mX["buffers"]["color"]["setClear"](mO["r"], mO["g"], mO["b"], mj, mP);
                }
                return {
                    getClearColor: function () {
                        return mM;
                    },
                    setClearColor: function (mO, mj) {
                        mM["set"](mO), mw(mM, (mp = void 0x0 !== mj ? mj : 0x1));
                    },
                    getClearAlpha: function () {
                        return mp;
                    },
                    setClearAlpha: function (mO) {
                        mw(mM, (mp = mO));
                    },
                    render: function (mO, mj, mh, mS) {
                        var mg = mj["background"],
                            mW = mN["xr"],
                            mH = mW["getSession"] && mW["getSession"]();
                        if (
                            (mH && "additive" === mH["environmentBlendMode"] && (mg = null),
                            null === mg ? mw(mM, mp) : mg && mg["isColor"] && (mw(mg, 0x1), (mS = !0x0)),
                            (mN["autoClear"] || mS) && mN["clear"](mN["autoClearColor"], mN["autoClearDepth"], mN["autoClearStencil"]),
                            mg && (mg["isCubeTexture"] || mg["isWebGLCubeRenderTarget"] || mg["mapping"] === r9))
                        ) {
                            void 0x0 === mA &&
                                ((mA = new TA(
                                    new Tj(0x1, 0x1, 0x1),
                                    new TW({
                                        type: "BackgroundCubeMaterial",
                                        uniforms: Th(C6["cube"]["uniforms"]),
                                        vertexShader: C6["cube"]["vertexShader"],
                                        fragmentShader: C6["cube"]["fragmentShader"],
                                        side: 0x1,
                                        depthTest: !0x1,
                                        depthWrite: !0x1,
                                        fog: !0x1,
                                    })
                                ))["geometry"]["deleteAttribute"]("normal"),
                                mA["geometry"]["deleteAttribute"]("uv"),
                                (mA["onBeforeRender"] = function (mK, mV, mJ) {
                                    this["matrixWorld"]["copyPosition"](mJ["matrixWorld"]);
                                }),
                                Object["defineProperty"](mA["material"], "envMap", {
                                    get: function () {
                                        return this["uniforms"]["envMap"]["value"];
                                    },
                                }),
                                mf["update"](mA));
                            var mx = mg["isWebGLCubeRenderTarget"] ? mg["texture"] : mg;
                            (mA["material"]["uniforms"]["envMap"]["value"] = mx),
                                (mA["material"]["uniforms"]["flipEnvMap"]["value"] = mx["isCubeTexture"] ? -0x1 : 0x1),
                                (mk === mg && mU === mx["version"] && mq === mN["toneMapping"]) || ((mA["material"]["needsUpdate"] = !0x0), (mk = mg), (mU = mx["version"]), (mq = mN["toneMapping"])),
                                mO["unshift"](mA, mA["geometry"], mA["material"], 0x0, 0x0, null);
                        } else
                            mg &&
                                mg["isTexture"] &&
                                (void 0x0 === mI &&
                                    ((mI = new TA(
                                        new C4(0x2, 0x2),
                                        new TW({
                                            type: "BackgroundMaterial",
                                            uniforms: Th(C6["background"]["uniforms"]),
                                            vertexShader: C6["background"]["vertexShader"],
                                            fragmentShader: C6["background"]["fragmentShader"],
                                            side: r5,
                                            depthTest: !0x1,
                                            depthWrite: !0x1,
                                            fog: !0x1,
                                        })
                                    ))["geometry"]["deleteAttribute"]("normal"),
                                    Object["defineProperty"](mI["material"], "map", {
                                        get: function () {
                                            return this["uniforms"]["t2D"]["value"];
                                        },
                                    }),
                                    mf["update"](mI)),
                                (mI["material"]["uniforms"]["t2D"]["value"] = mg),
                                !0x0 === mg["matrixAutoUpdate"] && mg["updateMatrix"](),
                                mI["material"]["uniforms"]["uvTransform"]["value"]["copy"](mg["matrix"]),
                                (mk === mg && mU === mg["version"] && mq === mN["toneMapping"]) || ((mI["material"]["needsUpdate"] = !0x0), (mk = mg), (mU = mg["version"]), (mq = mN["toneMapping"])),
                                mO["unshift"](mI, mI["geometry"], mI["material"], 0x0, 0x0, null));
                    },
                };
            }
            function C8(mN, mX, mf, mP) {
                var mI,
                    mA = mP["isWebGL2"];
                (this["setMode"] = function (mM) {
                    mI = mM;
                }),
                    (this["render"] = function (mM, mp) {
                        mN["drawArrays"](mI, mM, mp), mf["update"](mp, mI);
                    }),
                    (this["renderInstances"] = function (mM, mp, mk, mU) {
                        if (0x0 !== mU) {
                            var mq, mw;
                            if (mA) (mq = mN), (mw = "drawArraysInstanced");
                            else {
                                if (((mw = "drawArraysInstancedANGLE"), null === (mq = mX["get"]("ANGLE_instanced_arrays"))))
                                    return void console["error"]("THREE.WebGLBufferRenderer:\x20using\x20THREE.InstancedBufferGeometry\x20but\x20hardware\x20does\x20not\x20support\x20extension\x20ANGLE_instanced_arrays.");
                            }
                            mq[mw](mI, mp, mk, mU), mf["update"](mk, mI, mU);
                        }
                    });
            }
            function C9(mN, mX, mf) {
                var mP;
                function mI(mx) {
                    if ("highp" === mx) {
                        if (mN["getShaderPrecisionFormat"](0x8b31, 0x8df2)["precision"] > 0x0 && mN["getShaderPrecisionFormat"](0x8b30, 0x8df2)["precision"] > 0x0) return "highp";
                        mx = "mediump";
                    }
                    return "mediump" === mx && mN["getShaderPrecisionFormat"](0x8b31, 0x8df1)["precision"] > 0x0 && mN["getShaderPrecisionFormat"](0x8b30, 0x8df1)["precision"] > 0x0 ? "mediump" : "lowp";
                }
                var mA = ("undefined" != typeof WebGL2RenderingContext && mN instanceof WebGL2RenderingContext) || ("undefined" != typeof WebGL2ComputeRenderingContext && mN instanceof WebGL2ComputeRenderingContext),
                    mM = void 0x0 !== mf["precision"] ? mf["precision"] : "highp",
                    mp = mI(mM);
                mp !== mM && (console["warn"]("THREE.WebGLRenderer:", mM, "not\x20supported,\x20using", mp, "instead."), (mM = mp));
                var mk = !0x0 === mf["logarithmicDepthBuffer"],
                    mU = mN["getParameter"](0x8872),
                    mq = mN["getParameter"](0x8b4c),
                    mw = mN["getParameter"](0xd33),
                    mO = mN["getParameter"](0x851c),
                    mj = mN["getParameter"](0x8869),
                    mh = mN["getParameter"](0x8dfb),
                    mS = mN["getParameter"](0x8dfc),
                    mg = mN["getParameter"](0x8dfd),
                    mW = mq > 0x0,
                    mH = mA || !!mX["get"]("OES_texture_float");
                return {
                    isWebGL2: mA,
                    getMaxAnisotropy: function () {
                        if (void 0x0 !== mP) return mP;
                        var mx = mX["get"]("EXT_texture_filter_anisotropic");
                        return (mP = null !== mx ? mN["getParameter"](mx["MAX_TEXTURE_MAX_ANISOTROPY_EXT"]) : 0x0);
                    },
                    getMaxPrecision: mI,
                    precision: mM,
                    logarithmicDepthBuffer: mk,
                    maxTextures: mU,
                    maxVertexTextures: mq,
                    maxTextureSize: mw,
                    maxCubemapSize: mO,
                    maxAttributes: mj,
                    maxVertexUniforms: mh,
                    maxVaryings: mS,
                    maxFragmentUniforms: mg,
                    vertexTextures: mW,
                    floatFragmentTextures: mH,
                    floatVertexTextures: mW && mH,
                    maxSamples: mA ? mN["getParameter"](0x8d57) : 0x0,
                };
            }
            function CE() {
                var mN = this,
                    mX = null,
                    mf = 0x0,
                    mP = !0x1,
                    mI = !0x1,
                    mA = new RZ(),
                    mM = new E4(),
                    mp = { value: null, needsUpdate: !0x1 };
                function mk() {
                    mp["value"] !== mX && ((mp["value"] = mX), (mp["needsUpdate"] = mf > 0x0)), (mN["numPlanes"] = mf), (mN["numIntersection"] = 0x0);
                }
                function mU(mq, mw, mO, mj) {
                    var mh = null !== mq ? mq["length"] : 0x0,
                        mS = null;
                    if (0x0 !== mh) {
                        if (((mS = mp["value"]), !0x0 !== mj || null === mS)) {
                            var mg = mO + 0x4 * mh,
                                mW = mw["matrixWorldInverse"];
                            mM["getNormalMatrix"](mW), (null === mS || mS["length"] < mg) && (mS = new Float32Array(mg));
                            for (var mH = 0x0, mx = mO; mH !== mh; ++mH, mx += 0x4) mA["copy"](mq[mH])["applyMatrix4"](mW, mM), mA["normal"]["toArray"](mS, mx), (mS[mx + 0x3] = mA["constant"]);
                        }
                        (mp["value"] = mS), (mp["needsUpdate"] = !0x0);
                    }
                    return (mN["numPlanes"] = mh), (mN["numIntersection"] = 0x0), mS;
                }
                (this["uniform"] = mp),
                    (this["numPlanes"] = 0x0),
                    (this["numIntersection"] = 0x0),
                    (this["init"] = function (mq, mw, mO) {
                        var mj = 0x0 !== mq["length"] || mw || 0x0 !== mf || mP;
                        return (mP = mw), (mX = mU(mq, mO, 0x0)), (mf = mq["length"]), mj;
                    }),
                    (this["beginShadows"] = function () {
                        (mI = !0x0), mU(null);
                    }),
                    (this["endShadows"] = function () {
                        (mI = !0x1), mk();
                    }),
                    (this["setState"] = function (mq, mw, mO, mj, mh, mS) {
                        if (!mP || null === mq || 0x0 === mq["length"] || (mI && !mO)) mI ? mU(null) : mk();
                        else {
                            var mg = mI ? 0x0 : mf,
                                mW = 0x4 * mg,
                                mH = mh["clippingState"] || null;
                            (mp["value"] = mH), (mH = mU(mq, mj, mW, mS));
                            for (var mx = 0x0; mx !== mW; ++mx) mH[mx] = mX[mx];
                            (mh["clippingState"] = mH), (this["numIntersection"] = mw ? this["numPlanes"] : 0x0), (this["numPlanes"] += mg);
                        }
                    });
            }
            function CR(mN) {
                var mX = {};
                return {
                    get: function (mf) {
                        if (void 0x0 !== mX[mf]) return mX[mf];
                        var mP;
                        switch (mf) {
                            case "WEBGL_depth_texture":
                                mP = mN["getExtension"]("WEBGL_depth_texture") || mN["getExtension"]("MOZ_WEBGL_depth_texture") || mN["getExtension"]("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                mP = mN["getExtension"]("EXT_texture_filter_anisotropic") || mN["getExtension"]("MOZ_EXT_texture_filter_anisotropic") || mN["getExtension"]("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                mP = mN["getExtension"]("WEBGL_compressed_texture_s3tc") || mN["getExtension"]("MOZ_WEBGL_compressed_texture_s3tc") || mN["getExtension"]("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                mP = mN["getExtension"]("WEBGL_compressed_texture_pvrtc") || mN["getExtension"]("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                mP = mN["getExtension"](mf);
                        }
                        return null === mP && console["warn"]("THREE.WebGLRenderer:\x20" + mf + "\x20extension\x20not\x20supported."), (mX[mf] = mP), mP;
                    },
                };
            }
            function CT(mN, mX, mf) {
                var mP = new WeakMap(),
                    mI = new WeakMap();
                function mA(mp) {
                    var mk = mp["target"],
                        mU = mP["get"](mk);
                    for (var mq in (null !== mU["index"] && mX["remove"](mU["index"]), mU["attributes"])) mX["remove"](mU["attributes"][mq]);
                    mk["removeEventListener"]("dispose", mA), mP["delete"](mk);
                    var mw = mI["get"](mU);
                    mw && (mX["remove"](mw), mI["delete"](mU)), mf["memory"]["geometries"]--;
                }
                function mM(mp) {
                    var mk = [],
                        mU = mp["index"],
                        mq = mp["attributes"]["position"],
                        mw = 0x0;
                    if (null !== mU) {
                        var mO = mU["array"];
                        mw = mU["version"];
                        for (var mj = 0x0, mh = mO["length"]; mj < mh; mj += 0x3) {
                            var mS = mO[mj + 0x0],
                                mg = mO[mj + 0x1],
                                mW = mO[mj + 0x2];
                            mk["push"](mS, mg, mg, mW, mW, mS);
                        }
                    } else {
                        (mO = mq["array"]), (mw = mq["version"]);
                        for (mj = 0x0, mh = mO["length"] / 0x3 - 0x1; mj < mh; mj += 0x3) {
                            (mS = mj + 0x0), (mg = mj + 0x1), (mW = mj + 0x2), mk["push"](mS, mg, mg, mW, mW, mS);
                        }
                    }
                    var mH = new (T3(mk) > 0xffff ? Rz : RL)(mk, 0x1);
                    (mH["version"] = mw), mX["update"](mH, 0x8893);
                    var mx = mI["get"](mp);
                    mx && mX["remove"](mx), mI["set"](mp, mH);
                }
                return {
                    get: function (mp, mk) {
                        var mU = mP["get"](mk);
                        return (
                            mU ||
                            (mk["addEventListener"]("dispose", mA),
                            mk["isBufferGeometry"] ? (mU = mk) : mk["isGeometry"] && (void 0x0 === mk["_bufferGeometry"] && (mk["_bufferGeometry"] = new TR()["setFromObject"](mp)), (mU = mk["_bufferGeometry"])),
                            mP["set"](mk, mU),
                            mf["memory"]["geometries"]++,
                            mU)
                        );
                    },
                    update: function (mp) {
                        var mk = mp["index"],
                            mU = mp["attributes"];
                        for (var mq in (null !== mk && mX["update"](mk, 0x8893), mU)) mX["update"](mU[mq], 0x8892);
                        var mw = mp["morphAttributes"];
                        for (var mq in mw) for (var mO = mw[mq], mj = 0x0, mh = mO["length"]; mj < mh; mj++) mX["update"](mO[mj], 0x8892);
                    },
                    getWireframeAttribute: function (mp) {
                        var mk = mI["get"](mp);
                        if (mk) {
                            var mU = mp["index"];
                            null !== mU && mk["version"] < mU["version"] && mM(mp);
                        } else mM(mp);
                        return mI["get"](mp);
                    },
                };
            }
            function CC(mN, mX, mf, mP) {
                var mI,
                    mA,
                    mM,
                    mp = mP["isWebGL2"];
                (this["setMode"] = function (mk) {
                    mI = mk;
                }),
                    (this["setIndex"] = function (mk) {
                        (mA = mk["type"]), (mM = mk["bytesPerElement"]);
                    }),
                    (this["render"] = function (mk, mU) {
                        mN["drawElements"](mI, mU, mA, mk * mM), mf["update"](mU, mI);
                    }),
                    (this["renderInstances"] = function (mk, mU, mq, mw) {
                        if (0x0 !== mw) {
                            var mO, mj;
                            if (mp) (mO = mN), (mj = "drawElementsInstanced");
                            else {
                                if (((mj = "drawElementsInstancedANGLE"), null === (mO = mX["get"]("ANGLE_instanced_arrays"))))
                                    return void console["error"]("THREE.WebGLIndexedBufferRenderer:\x20using\x20THREE.InstancedBufferGeometry\x20but\x20hardware\x20does\x20not\x20support\x20extension\x20ANGLE_instanced_arrays.");
                            }
                            mO[mj](mI, mq, mA, mU * mM, mw), mf["update"](mq, mI, mw);
                        }
                    });
            }
            function Cd(mN) {
                var mX = { frame: 0x0, calls: 0x0, triangles: 0x0, points: 0x0, lines: 0x0 };
                return {
                    memory: { geometries: 0x0, textures: 0x0 },
                    render: mX,
                    programs: null,
                    autoReset: !0x0,
                    reset: function () {
                        mX["frame"]++, (mX["calls"] = 0x0), (mX["triangles"] = 0x0), (mX["points"] = 0x0), (mX["lines"] = 0x0);
                    },
                    update: function (mf, mP, mI) {
                        switch (((mI = mI || 0x1), mX["calls"]++, mP)) {
                            case 0x4:
                                mX["triangles"] += mI * (mf / 0x3);
                                break;
                            case 0x1:
                                mX["lines"] += mI * (mf / 0x2);
                                break;
                            case 0x3:
                                mX["lines"] += mI * (mf - 0x1);
                                break;
                            case 0x2:
                                mX["lines"] += mI * mf;
                                break;
                            case 0x0:
                                mX["points"] += mI * mf;
                                break;
                            default:
                                console["error"]("THREE.WebGLInfo:\x20Unknown\x20draw\x20mode:", mP);
                        }
                    },
                };
            }
            function CY(mN, mX) {
                return Math["abs"](mX[0x1]) - Math["abs"](mN[0x1]);
            }
            function CB(mN) {
                var mX = {},
                    mf = new Float32Array(0x8);
                return {
                    update: function (mP, mI, mA, mM) {
                        var mp = mP["morphTargetInfluences"],
                            mk = void 0x0 === mp ? 0x0 : mp["length"],
                            mU = mX[mI["id"]];
                        if (void 0x0 === mU) {
                            mU = [];
                            for (var mq = 0x0; mq < mk; mq++) mU[mq] = [mq, 0x0];
                            mX[mI["id"]] = mU;
                        }
                        var mw = mA["morphTargets"] && mI["morphAttributes"]["position"],
                            mO = mA["morphNormals"] && mI["morphAttributes"]["normal"];
                        for (mq = 0x0; mq < mk; mq++) {
                            0x0 !== (mh = mU[mq])[0x1] && (mw && mI["deleteAttribute"]("morphTarget" + mq), mO && mI["deleteAttribute"]("morphNormal" + mq));
                        }
                        for (mq = 0x0; mq < mk; mq++) {
                            ((mh = mU[mq])[0x0] = mq), (mh[0x1] = mp[mq]);
                        }
                        mU["sort"](CY);
                        var mj = 0x0;
                        for (mq = 0x0; mq < 0x8; mq++) {
                            var mh;
                            if ((mh = mU[mq])) {
                                var mS = mh[0x0],
                                    mg = mh[0x1];
                                if (mg) {
                                    mw && mI["setAttribute"]("morphTarget" + mq, mw[mS]), mO && mI["setAttribute"]("morphNormal" + mq, mO[mS]), (mf[mq] = mg), (mj += mg);
                                    continue;
                                }
                            }
                            mf[mq] = 0x0;
                        }
                        var mW = mI["morphTargetsRelative"] ? 0x1 : 0x1 - mj;
                        mM["getUniforms"]()["setValue"](mN, "morphTargetBaseInfluence", mW), mM["getUniforms"]()["setValue"](mN, "morphTargetInfluences", mf);
                    },
                };
            }
            function CF(mN, mX, mf, mP) {
                var mI = new WeakMap();
                return {
                    update: function (mA) {
                        var mM = mP["render"]["frame"],
                            mp = mA["geometry"],
                            mk = mX["get"](mA, mp);
                        return mI["get"](mk) !== mM && (mp["isGeometry"] && mk["updateFromObject"](mA), mX["update"](mk), mI["set"](mk, mM)), mA["isInstancedMesh"] && mf["update"](mA["instanceMatrix"], 0x8892), mk;
                    },
                    dispose: function () {
                        mI = new WeakMap();
                    },
                };
            }
            function Cb(mN, mX, mf, mP, mI, mA, mM, mp, mk, mU) {
                (mN = void 0x0 !== mN ? mN : []), (mX = void 0x0 !== mX ? mX : 0x12d), (mM = void 0x0 !== mM ? mM : rX), E7["call"](this, mN, mX, mf, mP, mI, mA, mM, mp, mk, mU), (this["flipY"] = !0x1);
            }
            function CZ(mN, mX, mf, mP) {
                E7["call"](this, null),
                    (this["image"] = { data: mN || null, width: mX || 0x1, height: mf || 0x1, depth: mP || 0x1 }),
                    (this["magFilter"] = rC),
                    (this["minFilter"] = rC),
                    (this["wrapR"] = rR),
                    (this["generateMipmaps"] = !0x1),
                    (this["flipY"] = !0x1),
                    (this["needsUpdate"] = !0x0);
            }
            function Cm(mN, mX, mf, mP) {
                E7["call"](this, null),
                    (this["image"] = { data: mN || null, width: mX || 0x1, height: mf || 0x1, depth: mP || 0x1 }),
                    (this["magFilter"] = rC),
                    (this["minFilter"] = rC),
                    (this["wrapR"] = rR),
                    (this["generateMipmaps"] = !0x1),
                    (this["flipY"] = !0x1),
                    (this["needsUpdate"] = !0x0);
            }
            (C6["physical"] = {
                uniforms: TS([
                    C6["standard"]["uniforms"],
                    {
                        clearcoat: { value: 0x0 },
                        clearcoatMap: { value: null },
                        clearcoatRoughness: { value: 0x0 },
                        clearcoatRoughnessMap: { value: null },
                        clearcoatNormalScale: { value: new E3(0x1, 0x1) },
                        clearcoatNormalMap: { value: null },
                        sheen: { value: new Rq(0x0) },
                        transparency: { value: 0x0 },
                    },
                ]),
                vertexShader: C5["meshphysical_vert"],
                fragmentShader: C5["meshphysical_frag"],
            }),
                (Cb["prototype"] = Object["create"](E7["prototype"])),
                (Cb["prototype"]["constructor"] = Cb),
                (Cb["prototype"]["isCubeTexture"] = !0x0),
                Object["defineProperty"](Cb["prototype"], "images", {
                    get: function () {
                        return this["image"];
                    },
                    set: function (mN) {
                        this["image"] = mN;
                    },
                }),
                (CZ["prototype"] = Object["create"](E7["prototype"])),
                (CZ["prototype"]["constructor"] = CZ),
                (CZ["prototype"]["isDataTexture2DArray"] = !0x0),
                (Cm["prototype"] = Object["create"](E7["prototype"])),
                (Cm["prototype"]["constructor"] = Cm),
                (Cm["prototype"]["isDataTexture3D"] = !0x0);
            var Cv = new E7(),
                Cy = new CZ(),
                CD = new Cm(),
                CN = new Cb(),
                CX = [],
                Cf = [],
                CP = new Float32Array(0x10),
                CI = new Float32Array(0x9),
                CA = new Float32Array(0x4);
            function CM(mN, mX, mf) {
                var mP = mN[0x0];
                if (mP <= 0x0 || mP > 0x0) return mN;
                var mI = mX * mf,
                    mA = CX[mI];
                if ((void 0x0 === mA && ((mA = new Float32Array(mI)), (CX[mI] = mA)), 0x0 !== mX)) {
                    mP["toArray"](mA, 0x0);
                    for (var mM = 0x1, mp = 0x0; mM !== mX; ++mM) (mp += mf), mN[mM]["toArray"](mA, mp);
                }
                return mA;
            }
            function Cp(mN, mX) {
                if (mN["length"] !== mX["length"]) return !0x1;
                for (var mf = 0x0, mP = mN["length"]; mf < mP; mf++) if (mN[mf] !== mX[mf]) return !0x1;
                return !0x0;
            }
            function Ck(mN, mX) {
                for (var mf = 0x0, mP = mX["length"]; mf < mP; mf++) mN[mf] = mX[mf];
            }
            function CU(mN, mX) {
                var mf = Cf[mX];
                void 0x0 === mf && ((mf = new Int32Array(mX)), (Cf[mX] = mf));
                for (var mP = 0x0; mP !== mX; ++mP) mf[mP] = mN["allocateTextureUnit"]();
                return mf;
            }
            function Cq(mN, mX) {
                var mf = this["cache"];
                mf[0x0] !== mX && (mN["uniform1f"](this["addr"], mX), (mf[0x0] = mX));
            }
            function Cw(mN, mX) {
                var mf = this["cache"];
                if (void 0x0 !== mX["x"]) (mf[0x0] === mX["x"] && mf[0x1] === mX["y"]) || (mN["uniform2f"](this["addr"], mX["x"], mX["y"]), (mf[0x0] = mX["x"]), (mf[0x1] = mX["y"]));
                else {
                    if (Cp(mf, mX)) return;
                    mN["uniform2fv"](this["addr"], mX), Ck(mf, mX);
                }
            }
            function CO(mN, mX) {
                var mf = this["cache"];
                if (void 0x0 !== mX["x"]) (mf[0x0] === mX["x"] && mf[0x1] === mX["y"] && mf[0x2] === mX["z"]) || (mN["uniform3f"](this["addr"], mX["x"], mX["y"], mX["z"]), (mf[0x0] = mX["x"]), (mf[0x1] = mX["y"]), (mf[0x2] = mX["z"]));
                else {
                    if (void 0x0 !== mX["r"]) (mf[0x0] === mX["r"] && mf[0x1] === mX["g"] && mf[0x2] === mX["b"]) || (mN["uniform3f"](this["addr"], mX["r"], mX["g"], mX["b"]), (mf[0x0] = mX["r"]), (mf[0x1] = mX["g"]), (mf[0x2] = mX["b"]));
                    else {
                        if (Cp(mf, mX)) return;
                        mN["uniform3fv"](this["addr"], mX), Ck(mf, mX);
                    }
                }
            }
            function Cj(mN, mX) {
                var mf = this["cache"];
                if (void 0x0 !== mX["x"])
                    (mf[0x0] === mX["x"] && mf[0x1] === mX["y"] && mf[0x2] === mX["z"] && mf[0x3] === mX["w"]) ||
                        (mN["uniform4f"](this["addr"], mX["x"], mX["y"], mX["z"], mX["w"]), (mf[0x0] = mX["x"]), (mf[0x1] = mX["y"]), (mf[0x2] = mX["z"]), (mf[0x3] = mX["w"]));
                else {
                    if (Cp(mf, mX)) return;
                    mN["uniform4fv"](this["addr"], mX), Ck(mf, mX);
                }
            }
            function Ch(mN, mX) {
                var mf = this["cache"],
                    mP = mX["elements"];
                if (void 0x0 === mP) {
                    if (Cp(mf, mX)) return;
                    mN["uniformMatrix2fv"](this["addr"], !0x1, mX), Ck(mf, mX);
                } else {
                    if (Cp(mf, mP)) return;
                    CA["set"](mP), mN["uniformMatrix2fv"](this["addr"], !0x1, CA), Ck(mf, mP);
                }
            }
            function CS(mN, mX) {
                var mf = this["cache"],
                    mP = mX["elements"];
                if (void 0x0 === mP) {
                    if (Cp(mf, mX)) return;
                    mN["uniformMatrix3fv"](this["addr"], !0x1, mX), Ck(mf, mX);
                } else {
                    if (Cp(mf, mP)) return;
                    CI["set"](mP), mN["uniformMatrix3fv"](this["addr"], !0x1, CI), Ck(mf, mP);
                }
            }
            function Cg(mN, mX) {
                var mf = this["cache"],
                    mP = mX["elements"];
                if (void 0x0 === mP) {
                    if (Cp(mf, mX)) return;
                    mN["uniformMatrix4fv"](this["addr"], !0x1, mX), Ck(mf, mX);
                } else {
                    if (Cp(mf, mP)) return;
                    CP["set"](mP), mN["uniformMatrix4fv"](this["addr"], !0x1, CP), Ck(mf, mP);
                }
            }
            function CW(mN, mX, mf) {
                var mP = this["cache"],
                    mI = mf["allocateTextureUnit"]();
                mP[0x0] !== mI && (mN["uniform1i"](this["addr"], mI), (mP[0x0] = mI)), mf["safeSetTexture2D"](mX || Cv, mI);
            }
            function CH(mN, mX, mf) {
                var mP = this["cache"],
                    mI = mf["allocateTextureUnit"]();
                mP[0x0] !== mI && (mN["uniform1i"](this["addr"], mI), (mP[0x0] = mI)), mf["setTexture2DArray"](mX || Cy, mI);
            }
            function Cx(mN, mX, mf) {
                var mP = this["cache"],
                    mI = mf["allocateTextureUnit"]();
                mP[0x0] !== mI && (mN["uniform1i"](this["addr"], mI), (mP[0x0] = mI)), mf["setTexture3D"](mX || CD, mI);
            }
            function CK(mN, mX, mf) {
                var mP = this["cache"],
                    mI = mf["allocateTextureUnit"]();
                mP[0x0] !== mI && (mN["uniform1i"](this["addr"], mI), (mP[0x0] = mI)), mf["safeSetTextureCube"](mX || CN, mI);
            }
            function CV(mN, mX) {
                var mf = this["cache"];
                mf[0x0] !== mX && (mN["uniform1i"](this["addr"], mX), (mf[0x0] = mX));
            }
            function CJ(mN, mX) {
                var mf = this["cache"];
                Cp(mf, mX) || (mN["uniform2iv"](this["addr"], mX), Ck(mf, mX));
            }
            function CG(mN, mX) {
                var mf = this["cache"];
                Cp(mf, mX) || (mN["uniform3iv"](this["addr"], mX), Ck(mf, mX));
            }
            function CL(mN, mX) {
                var mf = this["cache"];
                Cp(mf, mX) || (mN["uniform4iv"](this["addr"], mX), Ck(mf, mX));
            }
            function CQ(mN, mX) {
                var mf = this["cache"];
                mf[0x0] !== mX && (mN["uniform1ui"](this["addr"], mX), (mf[0x0] = mX));
            }
            function Cz(mN, mX) {
                mN["uniform1fv"](this["addr"], mX);
            }
            function d0(mN, mX) {
                mN["uniform1iv"](this["addr"], mX);
            }
            function d1(mN, mX) {
                mN["uniform2iv"](this["addr"], mX);
            }
            function d2(mN, mX) {
                mN["uniform3iv"](this["addr"], mX);
            }
            function d3(mN, mX) {
                mN["uniform4iv"](this["addr"], mX);
            }
            function d4(mN, mX) {
                var mf = CM(mX, this["size"], 0x2);
                mN["uniform2fv"](this["addr"], mf);
            }
            function d5(mN, mX) {
                var mf = CM(mX, this["size"], 0x3);
                mN["uniform3fv"](this["addr"], mf);
            }
            function d6(mN, mX) {
                var mf = CM(mX, this["size"], 0x4);
                mN["uniform4fv"](this["addr"], mf);
            }
            function d7(mN, mX) {
                var mf = CM(mX, this["size"], 0x4);
                mN["uniformMatrix2fv"](this["addr"], !0x1, mf);
            }
            function d8(mN, mX) {
                var mf = CM(mX, this["size"], 0x9);
                mN["uniformMatrix3fv"](this["addr"], !0x1, mf);
            }
            function d9(mN, mX) {
                var mf = CM(mX, this["size"], 0x10);
                mN["uniformMatrix4fv"](this["addr"], !0x1, mf);
            }
            function dE(mN, mX, mf) {
                var mP = mX["length"],
                    mI = CU(mf, mP);
                mN["uniform1iv"](this["addr"], mI);
                for (var mA = 0x0; mA !== mP; ++mA) mf["safeSetTexture2D"](mX[mA] || Cv, mI[mA]);
            }
            function dR(mN, mX, mf) {
                var mP = mX["length"],
                    mI = CU(mf, mP);
                mN["uniform1iv"](this["addr"], mI);
                for (var mA = 0x0; mA !== mP; ++mA) mf["safeSetTextureCube"](mX[mA] || CN, mI[mA]);
            }
            function dT(mN, mX, mf) {
                (this["id"] = mN),
                    (this["addr"] = mf),
                    (this["cache"] = []),
                    (this["setValue"] = (function (mP) {
                        switch (mP) {
                            case 0x1406:
                                return Cq;
                            case 0x8b50:
                                return Cw;
                            case 0x8b51:
                                return CO;
                            case 0x8b52:
                                return Cj;
                            case 0x8b5a:
                                return Ch;
                            case 0x8b5b:
                                return CS;
                            case 0x8b5c:
                                return Cg;
                            case 0x1404:
                            case 0x8b56:
                                return CV;
                            case 0x8b53:
                            case 0x8b57:
                                return CJ;
                            case 0x8b54:
                            case 0x8b58:
                                return CG;
                            case 0x8b55:
                            case 0x8b59:
                                return CL;
                            case 0x1405:
                                return CQ;
                            case 0x8b5e:
                            case 0x8d66:
                            case 0x8dca:
                            case 0x8dd2:
                            case 0x8b62:
                                return CW;
                            case 0x8b5f:
                            case 0x8dcb:
                            case 0x8dd3:
                                return Cx;
                            case 0x8b60:
                            case 0x8dcc:
                            case 0x8dd4:
                            case 0x8dc5:
                                return CK;
                            case 0x8dc1:
                            case 0x8dcf:
                            case 0x8dd7:
                            case 0x8dc4:
                                return CH;
                        }
                    })(mX["type"]));
            }
            function dC(mN, mX, mf) {
                (this["id"] = mN),
                    (this["addr"] = mf),
                    (this["cache"] = []),
                    (this["size"] = mX["size"]),
                    (this["setValue"] = (function (mP) {
                        switch (mP) {
                            case 0x1406:
                                return Cz;
                            case 0x8b50:
                                return d4;
                            case 0x8b51:
                                return d5;
                            case 0x8b52:
                                return d6;
                            case 0x8b5a:
                                return d7;
                            case 0x8b5b:
                                return d8;
                            case 0x8b5c:
                                return d9;
                            case 0x1404:
                            case 0x8b56:
                                return d0;
                            case 0x8b53:
                            case 0x8b57:
                                return d1;
                            case 0x8b54:
                            case 0x8b58:
                                return d2;
                            case 0x8b55:
                            case 0x8b59:
                                return d3;
                            case 0x8b5e:
                            case 0x8d66:
                            case 0x8dca:
                            case 0x8dd2:
                            case 0x8b62:
                                return dE;
                            case 0x8b60:
                            case 0x8dcc:
                            case 0x8dd4:
                            case 0x8dc5:
                                return dR;
                        }
                    })(mX["type"]));
            }
            function dd(mN) {
                (this["id"] = mN), (this["seq"] = []), (this["map"] = {});
            }
            (dC["prototype"]["updateCache"] = function (mN) {
                var mX = this["cache"];
                mN instanceof Float32Array && mX["length"] !== mN["length"] && (this["cache"] = new Float32Array(mN["length"])), Ck(mX, mN);
            }),
                (dd["prototype"]["setValue"] = function (mN, mX, mf) {
                    for (var mP = this["seq"], mI = 0x0, mA = mP["length"]; mI !== mA; ++mI) {
                        var mM = mP[mI];
                        mM["setValue"](mN, mX[mM["id"]], mf);
                    }
                });
            var dY = /([\w\d_]+)(\])?(\[|\.)?/g;
            function dB(mN, mX) {
                mN["seq"]["push"](mX), (mN["map"][mX["id"]] = mX);
            }
            function dF(mN, mX, mf) {
                var mP = mN["name"],
                    mI = mP["length"];
                for (dY["lastIndex"] = 0x0; ; ) {
                    var mA = dY["exec"](mP),
                        mM = dY["lastIndex"],
                        mp = mA[0x1],
                        mk = "]" === mA[0x2],
                        mU = mA[0x3];
                    if ((mk && (mp |= 0x0), void 0x0 === mU || ("[" === mU && mM + 0x2 === mI))) {
                        dB(mf, void 0x0 === mU ? new dT(mp, mN, mX) : new dC(mp, mN, mX));
                        break;
                    }
                    var mq = mf["map"][mp];
                    void 0x0 === mq && dB(mf, (mq = new dd(mp))), (mf = mq);
                }
            }
            function db(mN, mX) {
                (this["seq"] = []), (this["map"] = {});
                for (var mf = mN["getProgramParameter"](mX, 0x8b86), mP = 0x0; mP < mf; ++mP) {
                    var mI = mN["getActiveUniform"](mX, mP);
                    dF(mI, mN["getUniformLocation"](mX, mI["name"]), this);
                }
            }
            function dZ(mN, mX, mf) {
                var mP = mN["createShader"](mX);
                return mN["shaderSource"](mP, mf), mN["compileShader"](mP), mP;
            }
            (db["prototype"]["setValue"] = function (mN, mX, mf, mP) {
                var mI = this["map"][mX];
                void 0x0 !== mI && mI["setValue"](mN, mf, mP);
            }),
                (db["prototype"]["setOptional"] = function (mN, mX, mf) {
                    var mP = mX[mf];
                    void 0x0 !== mP && this["setValue"](mN, mf, mP);
                }),
                (db["upload"] = function (mN, mX, mf, mP) {
                    for (var mI = 0x0, mA = mX["length"]; mI !== mA; ++mI) {
                        var mM = mX[mI],
                            mp = mf[mM["id"]];
                        !0x1 !== mp["needsUpdate"] && mM["setValue"](mN, mp["value"], mP);
                    }
                }),
                (db["seqWithValue"] = function (mN, mX) {
                    for (var mf = [], mP = 0x0, mI = mN["length"]; mP !== mI; ++mP) {
                        var mA = mN[mP];
                        mA["id"] in mX && mf["push"](mA);
                    }
                    return mf;
                });
            var dm = 0x0;
            function dv(mN) {
                switch (mN) {
                    case rW:
                        return ["Linear", "(\x20value\x20)"];
                    case rH:
                        return ["sRGB", "(\x20value\x20)"];
                    case rK:
                        return ["RGBE", "(\x20value\x20)"];
                    case 0xbbc:
                        return ["RGBM", "(\x20value,\x207.0\x20)"];
                    case 0xbbd:
                        return ["RGBM", "(\x20value,\x2016.0\x20)"];
                    case 0xbbe:
                        return ["RGBD", "(\x20value,\x20256.0\x20)"];
                    case rx:
                        return ["Gamma", "(\x20value,\x20float(\x20GAMMA_FACTOR\x20)\x20)"];
                    case 0xbbb:
                        return ["LogLuv", "(\x20value\x20)"];
                    default:
                        throw new Error("unsupported\x20encoding:\x20" + mN);
                }
            }
            function dy(mN, mX, mf) {
                var mP = mN["getShaderParameter"](mX, 0x8b81),
                    mI = mN["getShaderInfoLog"](mX)["trim"]();
                return mP && "" === mI
                    ? ""
                    : "THREE.WebGLShader:\x20gl.getShaderInfoLog()\x20" +
                          mf +
                          "\x0a" +
                          mI +
                          (function (mA) {
                              for (var mM = mA["split"]("\x0a"), mp = 0x0; mp < mM["length"]; mp++) mM[mp] = mp + 0x1 + ":\x20" + mM[mp];
                              return mM["join"]("\x0a");
                          })(mN["getShaderSource"](mX));
            }
            function dD(mN, mX) {
                var mf = dv(mX);
                return "vec4\x20" + mN + "(\x20vec4\x20value\x20)\x20{\x20return\x20" + mf[0x0] + "ToLinear" + mf[0x1] + ";\x20}";
            }
            function dN(mN, mX) {
                var mf;
                switch (mX) {
                    case 0x1:
                        mf = "Linear";
                        break;
                    case 0x2:
                        mf = "Reinhard";
                        break;
                    case 0x3:
                        mf = "Uncharted2";
                        break;
                    case 0x4:
                        mf = "OptimizedCineon";
                        break;
                    case 0x5:
                        mf = "ACESFilmic";
                        break;
                    default:
                        throw new Error("unsupported\x20toneMapping:\x20" + mX);
                }
                return "vec3\x20" + mN + "(\x20vec3\x20color\x20)\x20{\x20return\x20" + mf + "ToneMapping(\x20color\x20);\x20}";
            }
            function dX(mN) {
                return "" !== mN;
            }
            function df(mN, mX) {
                return mN["replace"](/NUM_DIR_LIGHTS/g, mX["numDirLights"])
                    ["replace"](/NUM_SPOT_LIGHTS/g, mX["numSpotLights"])
                    ["replace"](/NUM_RECT_AREA_LIGHTS/g, mX["numRectAreaLights"])
                    ["replace"](/NUM_POINT_LIGHTS/g, mX["numPointLights"])
                    ["replace"](/NUM_HEMI_LIGHTS/g, mX["numHemiLights"])
                    ["replace"](/NUM_DIR_LIGHT_SHADOWS/g, mX["numDirLightShadows"])
                    ["replace"](/NUM_SPOT_LIGHT_SHADOWS/g, mX["numSpotLightShadows"])
                    ["replace"](/NUM_POINT_LIGHT_SHADOWS/g, mX["numPointLightShadows"]);
            }
            function dP(mN, mX) {
                return mN["replace"](/NUM_CLIPPING_PLANES/g, mX["numClippingPlanes"])["replace"](/UNION_CLIPPING_PLANES/g, mX["numClippingPlanes"] - mX["numClipIntersection"]);
            }
            var dI = /^[ \t]*#include +<([\w\d./]+)>/gm;
            function dA(mN) {
                return mN["replace"](dI, dM);
            }
            function dM(mN, mX) {
                var mf = C5[mX];
                if (void 0x0 === mf) throw new Error("Can\x20not\x20resolve\x20#include\x20<" + mX + ">");
                return dA(mf);
            }
            var dp = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                dk = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
            function dU(mN) {
                return mN["replace"](dk, dw)["replace"](dp, dq);
            }
            function dq(mN, mX, mf, mP) {
                return console["warn"]("WebGLProgram:\x20#pragma\x20unroll_loop\x20shader\x20syntax\x20is\x20deprecated.\x20Please\x20use\x20#pragma\x20unroll_loop_start\x20syntax\x20instead."), dw(mN, mX, mf, mP);
            }
            function dw(mN, mX, mf, mP) {
                for (var mI = "", mA = parseInt(mX); mA < parseInt(mf); mA++) mI += mP["replace"](/\[ i \]/g, "[\x20" + mA + "\x20]")["replace"](/UNROLLED_LOOP_INDEX/g, mA);
                return mI;
            }
            function dO(mN) {
                var mX = "precision\x20" + mN["precision"] + "\x20float;\x0aprecision\x20" + mN["precision"] + "\x20int;";
                return (
                    "highp" === mN["precision"] ? (mX += "\x0a#define\x20HIGH_PRECISION") : "mediump" === mN["precision"] ? (mX += "\x0a#define\x20MEDIUM_PRECISION") : "lowp" === mN["precision"] && (mX += "\x0a#define\x20LOW_PRECISION"), mX
                );
            }
            function dj(mN, mX, mf) {
                var mP,
                    mI,
                    mA,
                    mM,
                    mp,
                    mk = mN["getContext"](),
                    mU = mf["defines"],
                    mq = mf["vertexShader"],
                    mw = mf["fragmentShader"],
                    mO = (function (v7) {
                        var v8 = "SHADOWMAP_TYPE_BASIC";
                        return 0x1 === v7["shadowMapType"] ? (v8 = "SHADOWMAP_TYPE_PCF") : 0x2 === v7["shadowMapType"] ? (v8 = "SHADOWMAP_TYPE_PCF_SOFT") : 0x3 === v7["shadowMapType"] && (v8 = "SHADOWMAP_TYPE_VSM"), v8;
                    })(mf),
                    mj = (function (v7) {
                        var v8 = "ENVMAP_TYPE_CUBE";
                        if (v7["envMap"])
                            switch (v7["envMapMode"]) {
                                case 0x12d:
                                case 0x12e:
                                    v8 = "ENVMAP_TYPE_CUBE";
                                    break;
                                case r9:
                                case 0x133:
                                    v8 = "ENVMAP_TYPE_CUBE_UV";
                                    break;
                                case 0x12f:
                                case 0x130:
                                    v8 = "ENVMAP_TYPE_EQUIREC";
                                    break;
                                case 0x131:
                                    v8 = "ENVMAP_TYPE_SPHERE";
                            }
                        return v8;
                    })(mf),
                    mh = (function (v7) {
                        var v8 = "ENVMAP_MODE_REFLECTION";
                        if (v7["envMap"])
                            switch (v7["envMapMode"]) {
                                case 0x12e:
                                case 0x130:
                                    v8 = "ENVMAP_MODE_REFRACTION";
                            }
                        return v8;
                    })(mf),
                    mS = (function (v7) {
                        var v8 = "ENVMAP_BLENDING_NONE";
                        if (v7["envMap"])
                            switch (v7["combine"]) {
                                case 0x0:
                                    v8 = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case 0x1:
                                    v8 = "ENVMAP_BLENDING_MIX";
                                    break;
                                case 0x2:
                                    v8 = "ENVMAP_BLENDING_ADD";
                            }
                        return v8;
                    })(mf),
                    mg = mN["gammaFactor"] > 0x0 ? mN["gammaFactor"] : 0x1,
                    mW = mf["isWebGL2"]
                        ? ""
                        : (function (v7) {
                              return [
                                  v7["extensionDerivatives"] || v7["envMapCubeUV"] || v7["bumpMap"] || v7["tangentSpaceNormalMap"] || v7["clearcoatNormalMap"] || v7["flatShading"] || "physical" === v7["shaderID"]
                                      ? "#extension\x20GL_OES_standard_derivatives\x20:\x20enable"
                                      : "",
                                  (v7["extensionFragDepth"] || v7["logarithmicDepthBuffer"]) && v7["rendererExtensionFragDepth"] ? "#extension\x20GL_EXT_frag_depth\x20:\x20enable" : "",
                                  v7["extensionDrawBuffers"] && v7["rendererExtensionDrawBuffers"] ? "#extension\x20GL_EXT_draw_buffers\x20:\x20require" : "",
                                  (v7["extensionShaderTextureLOD"] || v7["envMap"]) && v7["rendererExtensionShaderTextureLod"] ? "#extension\x20GL_EXT_shader_texture_lod\x20:\x20enable" : "",
                              ]
                                  ["filter"](dX)
                                  ["join"]("\x0a");
                          })(mf),
                    mH = (function (v7) {
                        var v8 = [];
                        for (var v9 in v7) {
                            var vE = v7[v9];
                            !0x1 !== vE && v8["push"]("#define\x20" + v9 + "\x20" + vE);
                        }
                        return v8["join"]("\x0a");
                    })(mU),
                    mx = mk["createProgram"]();
                if (
                    (mf["isRawShaderMaterial"]
                        ? ((mP = [mH]["filter"](dX)["join"]("\x0a"))["length"] > 0x0 && (mP += "\x0a"), (mI = [mW, mH]["filter"](dX)["join"]("\x0a"))["length"] > 0x0 && (mI += "\x0a"))
                        : ((mP = [
                              dO(mf),
                              "#define\x20SHADER_NAME\x20" + mf["shaderName"],
                              mH,
                              mf["instancing"] ? "#define\x20USE_INSTANCING" : "",
                              mf["supportsVertexTextures"] ? "#define\x20VERTEX_TEXTURES" : "",
                              "#define\x20GAMMA_FACTOR\x20" + mg,
                              "#define\x20MAX_BONES\x20" + mf["maxBones"],
                              mf["useFog"] && mf["fog"] ? "#define\x20USE_FOG" : "",
                              mf["useFog"] && mf["fogExp2"] ? "#define\x20FOG_EXP2" : "",
                              mf["map"] ? "#define\x20USE_MAP" : "",
                              mf["envMap"] ? "#define\x20USE_ENVMAP" : "",
                              mf["envMap"] ? "#define\x20" + mh : "",
                              mf["lightMap"] ? "#define\x20USE_LIGHTMAP" : "",
                              mf["aoMap"] ? "#define\x20USE_AOMAP" : "",
                              mf["emissiveMap"] ? "#define\x20USE_EMISSIVEMAP" : "",
                              mf["bumpMap"] ? "#define\x20USE_BUMPMAP" : "",
                              mf["normalMap"] ? "#define\x20USE_NORMALMAP" : "",
                              mf["normalMap"] && mf["objectSpaceNormalMap"] ? "#define\x20OBJECTSPACE_NORMALMAP" : "",
                              mf["normalMap"] && mf["tangentSpaceNormalMap"] ? "#define\x20TANGENTSPACE_NORMALMAP" : "",
                              mf["clearcoatMap"] ? "#define\x20USE_CLEARCOATMAP" : "",
                              mf["clearcoatRoughnessMap"] ? "#define\x20USE_CLEARCOAT_ROUGHNESSMAP" : "",
                              mf["clearcoatNormalMap"] ? "#define\x20USE_CLEARCOAT_NORMALMAP" : "",
                              mf["displacementMap"] && mf["supportsVertexTextures"] ? "#define\x20USE_DISPLACEMENTMAP" : "",
                              mf["specularMap"] ? "#define\x20USE_SPECULARMAP" : "",
                              mf["roughnessMap"] ? "#define\x20USE_ROUGHNESSMAP" : "",
                              mf["metalnessMap"] ? "#define\x20USE_METALNESSMAP" : "",
                              mf["alphaMap"] ? "#define\x20USE_ALPHAMAP" : "",
                              mf["vertexTangents"] ? "#define\x20USE_TANGENT" : "",
                              mf["vertexColors"] ? "#define\x20USE_COLOR" : "",
                              mf["vertexUvs"] ? "#define\x20USE_UV" : "",
                              mf["uvsVertexOnly"] ? "#define\x20UVS_VERTEX_ONLY" : "",
                              mf["flatShading"] ? "#define\x20FLAT_SHADED" : "",
                              mf["skinning"] ? "#define\x20USE_SKINNING" : "",
                              mf["useVertexTexture"] ? "#define\x20BONE_TEXTURE" : "",
                              mf["morphTargets"] ? "#define\x20USE_MORPHTARGETS" : "",
                              mf["morphNormals"] && !0x1 === mf["flatShading"] ? "#define\x20USE_MORPHNORMALS" : "",
                              mf["doubleSided"] ? "#define\x20DOUBLE_SIDED" : "",
                              mf["flipSided"] ? "#define\x20FLIP_SIDED" : "",
                              mf["shadowMapEnabled"] ? "#define\x20USE_SHADOWMAP" : "",
                              mf["shadowMapEnabled"] ? "#define\x20" + mO : "",
                              mf["sizeAttenuation"] ? "#define\x20USE_SIZEATTENUATION" : "",
                              mf["logarithmicDepthBuffer"] ? "#define\x20USE_LOGDEPTHBUF" : "",
                              mf["logarithmicDepthBuffer"] && mf["rendererExtensionFragDepth"] ? "#define\x20USE_LOGDEPTHBUF_EXT" : "",
                              "uniform\x20mat4\x20modelMatrix;",
                              "uniform\x20mat4\x20modelViewMatrix;",
                              "uniform\x20mat4\x20projectionMatrix;",
                              "uniform\x20mat4\x20viewMatrix;",
                              "uniform\x20mat3\x20normalMatrix;",
                              "uniform\x20vec3\x20cameraPosition;",
                              "uniform\x20bool\x20isOrthographic;",
                              "#ifdef\x20USE_INSTANCING",
                              "\x20attribute\x20mat4\x20instanceMatrix;",
                              "#endif",
                              "attribute\x20vec3\x20position;",
                              "attribute\x20vec3\x20normal;",
                              "attribute\x20vec2\x20uv;",
                              "#ifdef\x20USE_TANGENT",
                              "\x09attribute\x20vec4\x20tangent;",
                              "#endif",
                              "#ifdef\x20USE_COLOR",
                              "\x09attribute\x20vec3\x20color;",
                              "#endif",
                              "#ifdef\x20USE_MORPHTARGETS",
                              "\x09attribute\x20vec3\x20morphTarget0;",
                              "\x09attribute\x20vec3\x20morphTarget1;",
                              "\x09attribute\x20vec3\x20morphTarget2;",
                              "\x09attribute\x20vec3\x20morphTarget3;",
                              "\x09#ifdef\x20USE_MORPHNORMALS",
                              "\x09\x09attribute\x20vec3\x20morphNormal0;",
                              "\x09\x09attribute\x20vec3\x20morphNormal1;",
                              "\x09\x09attribute\x20vec3\x20morphNormal2;",
                              "\x09\x09attribute\x20vec3\x20morphNormal3;",
                              "\x09#else",
                              "\x09\x09attribute\x20vec3\x20morphTarget4;",
                              "\x09\x09attribute\x20vec3\x20morphTarget5;",
                              "\x09\x09attribute\x20vec3\x20morphTarget6;",
                              "\x09\x09attribute\x20vec3\x20morphTarget7;",
                              "\x09#endif",
                              "#endif",
                              "#ifdef\x20USE_SKINNING",
                              "\x09attribute\x20vec4\x20skinIndex;",
                              "\x09attribute\x20vec4\x20skinWeight;",
                              "#endif",
                              "\x0a",
                          ]
                              ["filter"](dX)
                              ["join"]("\x0a")),
                          (mI = [
                              mW,
                              dO(mf),
                              "#define\x20SHADER_NAME\x20" + mf["shaderName"],
                              mH,
                              mf["alphaTest"] ? "#define\x20ALPHATEST\x20" + mf["alphaTest"] + (mf["alphaTest"] % 0x1 ? "" : ".0") : "",
                              "#define\x20GAMMA_FACTOR\x20" + mg,
                              mf["useFog"] && mf["fog"] ? "#define\x20USE_FOG" : "",
                              mf["useFog"] && mf["fogExp2"] ? "#define\x20FOG_EXP2" : "",
                              mf["map"] ? "#define\x20USE_MAP" : "",
                              mf["matcap"] ? "#define\x20USE_MATCAP" : "",
                              mf["envMap"] ? "#define\x20USE_ENVMAP" : "",
                              mf["envMap"] ? "#define\x20" + mj : "",
                              mf["envMap"] ? "#define\x20" + mh : "",
                              mf["envMap"] ? "#define\x20" + mS : "",
                              mf["lightMap"] ? "#define\x20USE_LIGHTMAP" : "",
                              mf["aoMap"] ? "#define\x20USE_AOMAP" : "",
                              mf["emissiveMap"] ? "#define\x20USE_EMISSIVEMAP" : "",
                              mf["bumpMap"] ? "#define\x20USE_BUMPMAP" : "",
                              mf["normalMap"] ? "#define\x20USE_NORMALMAP" : "",
                              mf["normalMap"] && mf["objectSpaceNormalMap"] ? "#define\x20OBJECTSPACE_NORMALMAP" : "",
                              mf["normalMap"] && mf["tangentSpaceNormalMap"] ? "#define\x20TANGENTSPACE_NORMALMAP" : "",
                              mf["clearcoatMap"] ? "#define\x20USE_CLEARCOATMAP" : "",
                              mf["clearcoatRoughnessMap"] ? "#define\x20USE_CLEARCOAT_ROUGHNESSMAP" : "",
                              mf["clearcoatNormalMap"] ? "#define\x20USE_CLEARCOAT_NORMALMAP" : "",
                              mf["specularMap"] ? "#define\x20USE_SPECULARMAP" : "",
                              mf["roughnessMap"] ? "#define\x20USE_ROUGHNESSMAP" : "",
                              mf["metalnessMap"] ? "#define\x20USE_METALNESSMAP" : "",
                              mf["alphaMap"] ? "#define\x20USE_ALPHAMAP" : "",
                              mf["sheen"] ? "#define\x20USE_SHEEN" : "",
                              mf["vertexTangents"] ? "#define\x20USE_TANGENT" : "",
                              mf["vertexColors"] ? "#define\x20USE_COLOR" : "",
                              mf["vertexUvs"] ? "#define\x20USE_UV" : "",
                              mf["uvsVertexOnly"] ? "#define\x20UVS_VERTEX_ONLY" : "",
                              mf["gradientMap"] ? "#define\x20USE_GRADIENTMAP" : "",
                              mf["flatShading"] ? "#define\x20FLAT_SHADED" : "",
                              mf["doubleSided"] ? "#define\x20DOUBLE_SIDED" : "",
                              mf["flipSided"] ? "#define\x20FLIP_SIDED" : "",
                              mf["shadowMapEnabled"] ? "#define\x20USE_SHADOWMAP" : "",
                              mf["shadowMapEnabled"] ? "#define\x20" + mO : "",
                              mf["premultipliedAlpha"] ? "#define\x20PREMULTIPLIED_ALPHA" : "",
                              mf["physicallyCorrectLights"] ? "#define\x20PHYSICALLY_CORRECT_LIGHTS" : "",
                              mf["logarithmicDepthBuffer"] ? "#define\x20USE_LOGDEPTHBUF" : "",
                              mf["logarithmicDepthBuffer"] && mf["rendererExtensionFragDepth"] ? "#define\x20USE_LOGDEPTHBUF_EXT" : "",
                              (mf["extensionShaderTextureLOD"] || mf["envMap"]) && mf["rendererExtensionShaderTextureLod"] ? "#define\x20TEXTURE_LOD_EXT" : "",
                              "uniform\x20mat4\x20viewMatrix;",
                              "uniform\x20vec3\x20cameraPosition;",
                              "uniform\x20bool\x20isOrthographic;",
                              0x0 !== mf["toneMapping"] ? "#define\x20TONE_MAPPING" : "",
                              0x0 !== mf["toneMapping"] ? C5["tonemapping_pars_fragment"] : "",
                              0x0 !== mf["toneMapping"] ? dN("toneMapping", mf["toneMapping"]) : "",
                              mf["dithering"] ? "#define\x20DITHERING" : "",
                              mf["outputEncoding"] || mf["mapEncoding"] || mf["matcapEncoding"] || mf["envMapEncoding"] || mf["emissiveMapEncoding"] || mf["lightMapEncoding"] ? C5["encodings_pars_fragment"] : "",
                              mf["mapEncoding"] ? dD("mapTexelToLinear", mf["mapEncoding"]) : "",
                              mf["matcapEncoding"] ? dD("matcapTexelToLinear", mf["matcapEncoding"]) : "",
                              mf["envMapEncoding"] ? dD("envMapTexelToLinear", mf["envMapEncoding"]) : "",
                              mf["emissiveMapEncoding"] ? dD("emissiveMapTexelToLinear", mf["emissiveMapEncoding"]) : "",
                              mf["lightMapEncoding"] ? dD("lightMapTexelToLinear", mf["lightMapEncoding"]) : "",
                              mf["outputEncoding"] ? ((mA = "linearToOutputTexel"), (mM = mf["outputEncoding"]), (mp = dv(mM)), "vec4\x20" + mA + "(\x20vec4\x20value\x20)\x20{\x20return\x20LinearTo" + mp[0x0] + mp[0x1] + ";\x20}") : "",
                              mf["depthPacking"] ? "#define\x20DEPTH_PACKING\x20" + mf["depthPacking"] : "",
                              "\x0a",
                          ]
                              ["filter"](dX)
                              ["join"]("\x0a"))),
                    (mq = dP((mq = df((mq = dA(mq)), mf)), mf)),
                    (mw = dP((mw = df((mw = dA(mw)), mf)), mf)),
                    (mq = dU(mq)),
                    (mw = dU(mw)),
                    mf["isWebGL2"] && !mf["isRawShaderMaterial"])
                ) {
                    var mK = !0x1,
                        mV = /^\s*#version\s+300\s+es\s*\n/;
                    mf["isShaderMaterial"] && null !== mq["match"](mV) && null !== mw["match"](mV) && ((mK = !0x0), (mq = mq["replace"](mV, "")), (mw = mw["replace"](mV, ""))),
                        (mP = ["#version\x20300\x20es\x0a", "#define\x20attribute\x20in", "#define\x20varying\x20out", "#define\x20texture2D\x20texture"]["join"]("\x0a") + "\x0a" + mP),
                        (mI =
                            [
                                "#version\x20300\x20es\x0a",
                                "#define\x20varying\x20in",
                                mK ? "" : "out\x20highp\x20vec4\x20pc_fragColor;",
                                mK ? "" : "#define\x20gl_FragColor\x20pc_fragColor",
                                "#define\x20gl_FragDepthEXT\x20gl_FragDepth",
                                "#define\x20texture2D\x20texture",
                                "#define\x20textureCube\x20texture",
                                "#define\x20texture2DProj\x20textureProj",
                                "#define\x20texture2DLodEXT\x20textureLod",
                                "#define\x20texture2DProjLodEXT\x20textureProjLod",
                                "#define\x20textureCubeLodEXT\x20textureLod",
                                "#define\x20texture2DGradEXT\x20textureGrad",
                                "#define\x20texture2DProjGradEXT\x20textureProjGrad",
                                "#define\x20textureCubeGradEXT\x20textureGrad",
                            ]["join"]("\x0a") +
                            "\x0a" +
                            mI);
                }
                var mJ,
                    mG,
                    mL = mI + mw,
                    mQ = dZ(mk, 0x8b31, mP + mq),
                    mz = dZ(mk, 0x8b30, mL);
                if (
                    (mk["attachShader"](mx, mQ),
                    mk["attachShader"](mx, mz),
                    void 0x0 !== mf["index0AttributeName"] ? mk["bindAttribLocation"](mx, 0x0, mf["index0AttributeName"]) : !0x0 === mf["morphTargets"] && mk["bindAttribLocation"](mx, 0x0, "position"),
                    mk["linkProgram"](mx),
                    mN["debug"]["checkShaderErrors"])
                ) {
                    var v0 = mk["getProgramInfoLog"](mx)["trim"](),
                        v1 = mk["getShaderInfoLog"](mQ)["trim"](),
                        v2 = mk["getShaderInfoLog"](mz)["trim"](),
                        v3 = !0x0,
                        v4 = !0x0;
                    if (!0x1 === mk["getProgramParameter"](mx, 0x8b82)) {
                        v3 = !0x1;
                        var v5 = dy(mk, mQ, "vertex"),
                            v6 = dy(mk, mz, "fragment");
                        console["error"]("THREE.WebGLProgram:\x20shader\x20error:\x20", mk["getError"](), "35715", mk["getProgramParameter"](mx, 0x8b83), "gl.getProgramInfoLog", v0, v5, v6);
                    } else "" !== v0 ? console["warn"]("THREE.WebGLProgram:\x20gl.getProgramInfoLog()", v0) : ("" !== v1 && "" !== v2) || (v4 = !0x1);
                    v4 && (this["diagnostics"] = { runnable: v3, programLog: v0, vertexShader: { log: v1, prefix: mP }, fragmentShader: { log: v2, prefix: mI } });
                }
                return (
                    mk["deleteShader"](mQ),
                    mk["deleteShader"](mz),
                    (this["getUniforms"] = function () {
                        return void 0x0 === mJ && (mJ = new db(mk, mx)), mJ;
                    }),
                    (this["getAttributes"] = function () {
                        return (
                            void 0x0 === mG &&
                                (mG = (function (v7, v8) {
                                    for (var v9 = {}, vE = v7["getProgramParameter"](v8, 0x8b89), vR = 0x0; vR < vE; vR++) {
                                        var vT = v7["getActiveAttrib"](v8, vR)["name"];
                                        v9[vT] = v7["getAttribLocation"](v8, vT);
                                    }
                                    return v9;
                                })(mk, mx)),
                            mG
                        );
                    }),
                    (this["destroy"] = function () {
                        mk["deleteProgram"](mx), (this["program"] = void 0x0);
                    }),
                    (this["name"] = mf["shaderName"]),
                    (this["id"] = dm++),
                    (this["cacheKey"] = mX),
                    (this["usedTimes"] = 0x1),
                    (this["program"] = mx),
                    (this["vertexShader"] = mQ),
                    (this["fragmentShader"] = mz),
                    this
                );
            }
            function dh(mN, mX, mf) {
                var mP = [],
                    mI = mf["isWebGL2"],
                    mA = mf["logarithmicDepthBuffer"],
                    mM = mf["floatVertexTextures"],
                    mp = mf["precision"],
                    mk = mf["maxVertexUniforms"],
                    mU = mf["vertexTextures"],
                    mq = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite",
                    },
                    mw = [
                        "precision",
                        "isWebGL2",
                        "supportsVertexTextures",
                        "outputEncoding",
                        "instancing",
                        "map",
                        "mapEncoding",
                        "matcap",
                        "matcapEncoding",
                        "envMap",
                        "envMapMode",
                        "envMapEncoding",
                        "envMapCubeUV",
                        "lightMap",
                        "lightMapEncoding",
                        "aoMap",
                        "emissiveMap",
                        "emissiveMapEncoding",
                        "bumpMap",
                        "normalMap",
                        "objectSpaceNormalMap",
                        "tangentSpaceNormalMap",
                        "clearcoatMap",
                        "clearcoatRoughnessMap",
                        "clearcoatNormalMap",
                        "displacementMap",
                        "specularMap",
                        "roughnessMap",
                        "metalnessMap",
                        "gradientMap",
                        "alphaMap",
                        "combine",
                        "vertexColors",
                        "vertexTangents",
                        "vertexUvs",
                        "uvsVertexOnly",
                        "fog",
                        "useFog",
                        "fogExp2",
                        "flatShading",
                        "sizeAttenuation",
                        "logarithmicDepthBuffer",
                        "skinning",
                        "maxBones",
                        "useVertexTexture",
                        "morphTargets",
                        "morphNormals",
                        "maxMorphTargets",
                        "maxMorphNormals",
                        "premultipliedAlpha",
                        "numDirLights",
                        "numPointLights",
                        "numSpotLights",
                        "numHemiLights",
                        "numRectAreaLights",
                        "numDirLightShadows",
                        "numPointLightShadows",
                        "numSpotLightShadows",
                        "shadowMapEnabled",
                        "shadowMapType",
                        "toneMapping",
                        "physicallyCorrectLights",
                        "alphaTest",
                        "doubleSided",
                        "flipSided",
                        "numClippingPlanes",
                        "numClipIntersection",
                        "depthPacking",
                        "dithering",
                        "sheen",
                    ];
                function mO(mj) {
                    var mh;
                    return (
                        mj
                            ? mj["isTexture"]
                                ? (mh = mj["encoding"])
                                : mj["isWebGLRenderTarget"] &&
                                  (console["warn"]("THREE.WebGLPrograms.getTextureEncodingFromMap:\x20don\x27t\x20use\x20render\x20targets\x20as\x20textures.\x20Use\x20their\x20.texture\x20property\x20instead."),
                                  (mh = mj["texture"]["encoding"]))
                            : (mh = rW),
                        mh
                    );
                }
                (this["getParameters"] = function (mj, mh, mS, mg, mW, mH, mx) {
                    var mK = mg["fog"],
                        mV = mj["isMeshStandardMaterial"] ? mg["environment"] : null,
                        mJ = mj["envMap"] || mV,
                        mG = mq[mj["type"]],
                        mL = mx["isSkinnedMesh"]
                            ? (function (v0) {
                                  var v1 = v0["skeleton"]["bones"];
                                  if (mM) return 0x400;
                                  var v2 = mk,
                                      v3 = Math["floor"]((v2 - 0x14) / 0x4),
                                      v4 = Math["min"](v3, v1["length"]);
                                  return v4 < v1["length"] ? (console["warn"]("THREE.WebGLRenderer:\x20Skeleton\x20has\x20" + v1["length"] + "\x20bones.\x20This\x20GPU\x20supports\x20" + v4 + "."), 0x0) : v4;
                              })(mx)
                            : 0x0;
                    null !== mj["precision"] && (mp = mf["getMaxPrecision"](mj["precision"])) !== mj["precision"] && console["warn"]("THREE.WebGLProgram.getParameters:", mj["precision"], "not\x20supported,\x20using", mp, "instead.");
                    var mQ = (function (v0, v1) {
                        var v2;
                        if (v1) {
                            var v3 = C6[v1];
                            v2 = { name: v0["type"], uniforms: Tg["clone"](v3["uniforms"]), vertexShader: v3["vertexShader"], fragmentShader: v3["fragmentShader"] };
                        } else v2 = { name: v0["type"], uniforms: v0["uniforms"], vertexShader: v0["vertexShader"], fragmentShader: v0["fragmentShader"] };
                        return v2;
                    })(mj, mG);
                    mj["onBeforeCompile"](mQ, mN);
                    var mz = mN["getRenderTarget"]();
                    return {
                        isWebGL2: mI,
                        shaderID: mG,
                        shaderName: mQ["name"],
                        uniforms: mQ["uniforms"],
                        vertexShader: mQ["vertexShader"],
                        fragmentShader: mQ["fragmentShader"],
                        defines: mj["defines"],
                        isRawShaderMaterial: mj["isRawShaderMaterial"],
                        isShaderMaterial: mj["isShaderMaterial"],
                        precision: mp,
                        instancing: !0x0 === mx["isInstancedMesh"],
                        supportsVertexTextures: mU,
                        outputEncoding: null !== mz ? mO(mz["texture"]) : mN["outputEncoding"],
                        map: !!mj["map"],
                        mapEncoding: mO(mj["map"]),
                        matcap: !!mj["matcap"],
                        matcapEncoding: mO(mj["matcap"]),
                        envMap: !!mJ,
                        envMapMode: mJ && mJ["mapping"],
                        envMapEncoding: mO(mJ),
                        envMapCubeUV: !!mJ && (mJ["mapping"] === r9 || 0x133 === mJ["mapping"]),
                        lightMap: !!mj["lightMap"],
                        lightMapEncoding: mO(mj["lightMap"]),
                        aoMap: !!mj["aoMap"],
                        emissiveMap: !!mj["emissiveMap"],
                        emissiveMapEncoding: mO(mj["emissiveMap"]),
                        bumpMap: !!mj["bumpMap"],
                        normalMap: !!mj["normalMap"],
                        objectSpaceNormalMap: 0x1 === mj["normalMapType"],
                        tangentSpaceNormalMap: mj["normalMapType"] === rV,
                        clearcoatMap: !!mj["clearcoatMap"],
                        clearcoatRoughnessMap: !!mj["clearcoatRoughnessMap"],
                        clearcoatNormalMap: !!mj["clearcoatNormalMap"],
                        displacementMap: !!mj["displacementMap"],
                        roughnessMap: !!mj["roughnessMap"],
                        metalnessMap: !!mj["metalnessMap"],
                        specularMap: !!mj["specularMap"],
                        alphaMap: !!mj["alphaMap"],
                        gradientMap: !!mj["gradientMap"],
                        sheen: !!mj["sheen"],
                        combine: mj["combine"],
                        vertexTangents: mj["normalMap"] && mj["vertexTangents"],
                        vertexColors: mj["vertexColors"],
                        vertexUvs: !!(
                            mj["map"] ||
                            mj["bumpMap"] ||
                            mj["normalMap"] ||
                            mj["specularMap"] ||
                            mj["alphaMap"] ||
                            mj["emissiveMap"] ||
                            mj["roughnessMap"] ||
                            mj["metalnessMap"] ||
                            mj["clearcoatMap"] ||
                            mj["clearcoatRoughnessMap"] ||
                            mj["clearcoatNormalMap"] ||
                            mj["displacementMap"]
                        ),
                        uvsVertexOnly: !(
                            mj["map"] ||
                            mj["bumpMap"] ||
                            mj["normalMap"] ||
                            mj["specularMap"] ||
                            mj["alphaMap"] ||
                            mj["emissiveMap"] ||
                            mj["roughnessMap"] ||
                            mj["metalnessMap"] ||
                            mj["clearcoatNormalMap"] ||
                            !mj["displacementMap"]
                        ),
                        fog: !!mK,
                        useFog: mj["fog"],
                        fogExp2: mK && mK["isFogExp2"],
                        flatShading: mj["flatShading"],
                        sizeAttenuation: mj["sizeAttenuation"],
                        logarithmicDepthBuffer: mA,
                        skinning: mj["skinning"] && mL > 0x0,
                        maxBones: mL,
                        useVertexTexture: mM,
                        morphTargets: mj["morphTargets"],
                        morphNormals: mj["morphNormals"],
                        maxMorphTargets: mN["maxMorphTargets"],
                        maxMorphNormals: mN["maxMorphNormals"],
                        numDirLights: mh["directional"]["length"],
                        numPointLights: mh["point"]["length"],
                        numSpotLights: mh["spot"]["length"],
                        numRectAreaLights: mh["rectArea"]["length"],
                        numHemiLights: mh["hemi"]["length"],
                        numDirLightShadows: mh["directionalShadowMap"]["length"],
                        numPointLightShadows: mh["pointShadowMap"]["length"],
                        numSpotLightShadows: mh["spotShadowMap"]["length"],
                        numClippingPlanes: mW,
                        numClipIntersection: mH,
                        dithering: mj["dithering"],
                        shadowMapEnabled: mN["shadowMap"]["enabled"] && mS["length"] > 0x0,
                        shadowMapType: mN["shadowMap"]["type"],
                        toneMapping: mj["toneMapped"] ? mN["toneMapping"] : 0x0,
                        physicallyCorrectLights: mN["physicallyCorrectLights"],
                        premultipliedAlpha: mj["premultipliedAlpha"],
                        alphaTest: mj["alphaTest"],
                        doubleSided: mj["side"] === r6,
                        flipSided: 0x1 === mj["side"],
                        depthPacking: void 0x0 !== mj["depthPacking"] && mj["depthPacking"],
                        index0AttributeName: mj["index0AttributeName"],
                        extensionDerivatives: mj["extensions"] && mj["extensions"]["derivatives"],
                        extensionFragDepth: mj["extensions"] && mj["extensions"]["fragDepth"],
                        extensionDrawBuffers: mj["extensions"] && mj["extensions"]["drawBuffers"],
                        extensionShaderTextureLOD: mj["extensions"] && mj["extensions"]["shaderTextureLOD"],
                        rendererExtensionFragDepth: mI || null !== mX["get"]("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: mI || null !== mX["get"]("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: mI || null !== mX["get"]("EXT_shader_texture_lod"),
                        onBeforeCompile: mj["onBeforeCompile"],
                    };
                }),
                    (this["getProgramCacheKey"] = function (mj) {
                        var mh = [];
                        if ((mj["shaderID"] ? mh["push"](mj["shaderID"]) : (mh["push"](mj["fragmentShader"]), mh["push"](mj["vertexShader"])), void 0x0 !== mj["defines"])) {
                            for (var mS in mj["defines"]) mh["push"](mS), mh["push"](mj["defines"][mS]);
                        }
                        if (void 0x0 === mj["isRawShaderMaterial"]) {
                            for (var mg = 0x0; mg < mw["length"]; mg++) mh["push"](mj[mw[mg]]);
                            mh["push"](mN["outputEncoding"]), mh["push"](mN["gammaFactor"]);
                        }
                        return mh["push"](mj["onBeforeCompile"]["toString"]()), mh["join"]();
                    }),
                    (this["acquireProgram"] = function (mj, mh) {
                        for (var mS, mg = 0x0, mW = mP["length"]; mg < mW; mg++) {
                            var mH = mP[mg];
                            if (mH["cacheKey"] === mh) {
                                ++(mS = mH)["usedTimes"];
                                break;
                            }
                        }
                        return void 0x0 === mS && ((mS = new dj(mN, mh, mj)), mP["push"](mS)), mS;
                    }),
                    (this["releaseProgram"] = function (mj) {
                        if (0x0 == --mj["usedTimes"]) {
                            var mh = mP["indexOf"](mj);
                            (mP[mh] = mP[mP["length"] - 0x1]), mP["pop"](), mj["destroy"]();
                        }
                    }),
                    (this["programs"] = mP);
            }
            function dS() {
                var mN = new WeakMap();
                return {
                    get: function (mX) {
                        var mf = mN["get"](mX);
                        return void 0x0 === mf && ((mf = {}), mN["set"](mX, mf)), mf;
                    },
                    remove: function (mX) {
                        mN["delete"](mX);
                    },
                    update: function (mX, mf, mP) {
                        mN["get"](mX)[mf] = mP;
                    },
                    dispose: function () {
                        mN = new WeakMap();
                    },
                };
            }
            function dg(mN, mX) {
                return mN["groupOrder"] !== mX["groupOrder"]
                    ? mN["groupOrder"] - mX["groupOrder"]
                    : mN["renderOrder"] !== mX["renderOrder"]
                    ? mN["renderOrder"] - mX["renderOrder"]
                    : mN["program"] !== mX["program"]
                    ? mN["program"]["id"] - mX["program"]["id"]
                    : mN["material"]["id"] !== mX["material"]["id"]
                    ? mN["material"]["id"] - mX["material"]["id"]
                    : mN["z"] !== mX["z"]
                    ? mN["z"] - mX["z"]
                    : mN["id"] - mX["id"];
            }
            function dW(mN, mX) {
                return mN["groupOrder"] !== mX["groupOrder"]
                    ? mN["groupOrder"] - mX["groupOrder"]
                    : mN["renderOrder"] !== mX["renderOrder"]
                    ? mN["renderOrder"] - mX["renderOrder"]
                    : mN["z"] !== mX["z"]
                    ? mX["z"] - mN["z"]
                    : mN["id"] - mX["id"];
            }
            function dH() {
                var mN = [],
                    mX = 0x0,
                    mf = [],
                    mP = [],
                    mI = { id: -0x1 };
                function mA(mM, mp, mk, mU, mq, mw) {
                    var mO = mN[mX];
                    return (
                        void 0x0 === mO
                            ? ((mO = { id: mM["id"], object: mM, geometry: mp, material: mk, program: mk["program"] || mI, groupOrder: mU, renderOrder: mM["renderOrder"], z: mq, group: mw }), (mN[mX] = mO))
                            : ((mO["id"] = mM["id"]),
                              (mO["object"] = mM),
                              (mO["geometry"] = mp),
                              (mO["material"] = mk),
                              (mO["program"] = mk["program"] || mI),
                              (mO["groupOrder"] = mU),
                              (mO["renderOrder"] = mM["renderOrder"]),
                              (mO["z"] = mq),
                              (mO["group"] = mw)),
                        mX++,
                        mO
                    );
                }
                return {
                    opaque: mf,
                    transparent: mP,
                    init: function () {
                        (mX = 0x0), (mf["length"] = 0x0), (mP["length"] = 0x0);
                    },
                    push: function (mM, mp, mk, mU, mq, mw) {
                        var mO = mA(mM, mp, mk, mU, mq, mw);
                        (!0x0 === mk["transparent"] ? mP : mf)["push"](mO);
                    },
                    unshift: function (mM, mp, mk, mU, mq, mw) {
                        var mO = mA(mM, mp, mk, mU, mq, mw);
                        (!0x0 === mk["transparent"] ? mP : mf)["unshift"](mO);
                    },
                    finish: function () {
                        for (var mM = mX, mp = mN["length"]; mM < mp; mM++) {
                            var mk = mN[mM];
                            if (null === mk["id"]) break;
                            (mk["id"] = null), (mk["object"] = null), (mk["geometry"] = null), (mk["material"] = null), (mk["program"] = null), (mk["group"] = null);
                        }
                    },
                    sort: function (mM, mp) {
                        mf["length"] > 0x1 && mf["sort"](mM || dg), mP["length"] > 0x1 && mP["sort"](mp || dW);
                    },
                };
            }
            function dx() {
                var mN = new WeakMap();
                function mX(mf) {
                    var mP = mf["target"];
                    mP["removeEventListener"]("dispose", mX), mN["delete"](mP);
                }
                return {
                    get: function (mf, mP) {
                        var mI,
                            mA = mN["get"](mf);
                        return (
                            void 0x0 === mA ? ((mI = new dH()), mN["set"](mf, new WeakMap()), mN["get"](mf)["set"](mP, mI), mf["addEventListener"]("dispose", mX)) : void 0x0 === (mI = mA["get"](mP)) && ((mI = new dH()), mA["set"](mP, mI)),
                            mI
                        );
                    },
                    dispose: function () {
                        mN = new WeakMap();
                    },
                };
            }
            function dK() {
                var mN = {};
                return {
                    get: function (mX) {
                        if (void 0x0 !== mN[mX["id"]]) return mN[mX["id"]];
                        var mf;
                        switch (mX["type"]) {
                            case "DirectionalLight":
                                mf = { direction: new Ed(), color: new Rq() };
                                break;
                            case "SpotLight":
                                mf = { position: new Ed(), direction: new Ed(), color: new Rq(), distance: 0x0, coneCos: 0x0, penumbraCos: 0x0, decay: 0x0 };
                                break;
                            case "PointLight":
                                mf = { position: new Ed(), color: new Rq(), distance: 0x0, decay: 0x0 };
                                break;
                            case "HemisphereLight":
                                mf = { direction: new Ed(), skyColor: new Rq(), groundColor: new Rq() };
                                break;
                            case "RectAreaLight":
                                mf = { color: new Rq(), position: new Ed(), halfWidth: new Ed(), halfHeight: new Ed() };
                        }
                        return (mN[mX["id"]] = mf), mf;
                    },
                };
            }
            var dV = 0x0;
            function dJ(mN, mX) {
                return (mX["castShadow"] ? 0x1 : 0x0) - (mN["castShadow"] ? 0x1 : 0x0);
            }
            function dG() {
                for (
                    var mN,
                        mX = new dK(),
                        mf =
                            ((mN = {}),
                            {
                                get: function (mk) {
                                    if (void 0x0 !== mN[mk["id"]]) return mN[mk["id"]];
                                    var mU;
                                    switch (mk["type"]) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            mU = { shadowBias: 0x0, shadowRadius: 0x1, shadowMapSize: new E3() };
                                            break;
                                        case "PointLight":
                                            mU = { shadowBias: 0x0, shadowRadius: 0x1, shadowMapSize: new E3(), shadowCameraNear: 0x1, shadowCameraFar: 0x3e8 };
                                    }
                                    return (mN[mk["id"]] = mU), mU;
                                },
                            }),
                        mP = {
                            version: 0x0,
                            hash: { directionalLength: -0x1, pointLength: -0x1, spotLength: -0x1, rectAreaLength: -0x1, hemiLength: -0x1, numDirectionalShadows: -0x1, numPointShadows: -0x1, numSpotShadows: -0x1 },
                            ambient: [0x0, 0x0, 0x0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotShadowMatrix: [],
                            rectArea: [],
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                        },
                        mI = 0x0;
                    mI < 0x9;
                    mI++
                )
                    mP["probe"]["push"](new Ed());
                var mA = new Ed(),
                    mM = new Ey(),
                    mp = new Ey();
                return {
                    setup: function (mk, mU, mq) {
                        for (var mw = 0x0, mO = 0x0, mj = 0x0, mh = 0x0; mh < 0x9; mh++) mP["probe"][mh]["set"](0x0, 0x0, 0x0);
                        var mS = 0x0,
                            mg = 0x0,
                            mW = 0x0,
                            mH = 0x0,
                            mx = 0x0,
                            mK = 0x0,
                            mV = 0x0,
                            mJ = 0x0,
                            mG = mq["matrixWorldInverse"];
                        mk["sort"](dJ), (mh = 0x0);
                        for (var mL = mk["length"]; mh < mL; mh++) {
                            var mQ = mk[mh],
                                mz = mQ["color"],
                                v0 = mQ["intensity"],
                                v1 = mQ["distance"],
                                v2 = mQ["shadow"] && mQ["shadow"]["map"] ? mQ["shadow"]["map"]["texture"] : null;
                            if (mQ["isAmbientLight"]) (mw += mz["r"] * v0), (mO += mz["g"] * v0), (mj += mz["b"] * v0);
                            else {
                                if (mQ["isLightProbe"]) {
                                    for (var v3 = 0x0; v3 < 0x9; v3++) mP["probe"][v3]["addScaledVector"](mQ["sh"]["coefficients"][v3], v0);
                                } else {
                                    if (mQ["isDirectionalLight"]) {
                                        if (
                                            ((v6 = mX["get"](mQ))["color"]["copy"](mQ["color"])["multiplyScalar"](mQ["intensity"]),
                                            v6["direction"]["setFromMatrixPosition"](mQ["matrixWorld"]),
                                            mA["setFromMatrixPosition"](mQ["target"]["matrixWorld"]),
                                            v6["direction"]["sub"](mA),
                                            v6["direction"]["transformDirection"](mG),
                                            mQ["castShadow"])
                                        ) {
                                            var v4 = mQ["shadow"];
                                            ((v5 = mf["get"](mQ))["shadowBias"] = v4["bias"]),
                                                (v5["shadowRadius"] = v4["radius"]),
                                                (v5["shadowMapSize"] = v4["mapSize"]),
                                                (mP["directionalShadow"][mS] = v5),
                                                (mP["directionalShadowMap"][mS] = v2),
                                                (mP["directionalShadowMatrix"][mS] = mQ["shadow"]["matrix"]),
                                                mK++;
                                        }
                                        (mP["directional"][mS] = v6), mS++;
                                    } else {
                                        if (mQ["isSpotLight"])
                                            ((v6 = mX["get"](mQ))["position"]["setFromMatrixPosition"](mQ["matrixWorld"]),
                                            v6["position"]["applyMatrix4"](mG),
                                            v6["color"]["copy"](mz)["multiplyScalar"](v0),
                                            (v6["distance"] = v1),
                                            v6["direction"]["setFromMatrixPosition"](mQ["matrixWorld"]),
                                            mA["setFromMatrixPosition"](mQ["target"]["matrixWorld"]),
                                            v6["direction"]["sub"](mA),
                                            v6["direction"]["transformDirection"](mG),
                                            (v6["coneCos"] = Math["cos"](mQ["angle"])),
                                            (v6["penumbraCos"] = Math["cos"](mQ["angle"] * (0x1 - mQ["penumbra"]))),
                                            (v6["decay"] = mQ["decay"]),
                                            mQ["castShadow"]) &&
                                                ((v4 = mQ["shadow"]),
                                                (((v5 = mf["get"](mQ))["shadowBias"] = v4["bias"]),
                                                (v5["shadowRadius"] = v4["radius"]),
                                                (v5["shadowMapSize"] = v4["mapSize"]),
                                                (mP["spotShadow"][mW] = v5),
                                                (mP["spotShadowMap"][mW] = v2),
                                                (mP["spotShadowMatrix"][mW] = mQ["shadow"]["matrix"]),
                                                mJ++)),
                                                (mP["spot"][mW] = v6),
                                                mW++;
                                        else {
                                            if (mQ["isRectAreaLight"])
                                                (v6 = mX["get"](mQ))["color"]["copy"](mz)["multiplyScalar"](v0),
                                                    v6["position"]["setFromMatrixPosition"](mQ["matrixWorld"]),
                                                    v6["position"]["applyMatrix4"](mG),
                                                    mp["identity"](),
                                                    mM["copy"](mQ["matrixWorld"]),
                                                    mM["premultiply"](mG),
                                                    mp["extractRotation"](mM),
                                                    v6["halfWidth"]["set"](0.5 * mQ["width"], 0x0, 0x0),
                                                    v6["halfHeight"]["set"](0x0, 0.5 * mQ["height"], 0x0),
                                                    v6["halfWidth"]["applyMatrix4"](mp),
                                                    v6["halfHeight"]["applyMatrix4"](mp),
                                                    (mP["rectArea"][mH] = v6),
                                                    mH++;
                                            else {
                                                if (mQ["isPointLight"]) {
                                                    if (
                                                        ((v6 = mX["get"](mQ))["position"]["setFromMatrixPosition"](mQ["matrixWorld"]),
                                                        v6["position"]["applyMatrix4"](mG),
                                                        v6["color"]["copy"](mQ["color"])["multiplyScalar"](mQ["intensity"]),
                                                        (v6["distance"] = mQ["distance"]),
                                                        (v6["decay"] = mQ["decay"]),
                                                        mQ["castShadow"])
                                                    ) {
                                                        var v5;
                                                        (v4 = mQ["shadow"]),
                                                            (((v5 = mf["get"](mQ))["shadowBias"] = v4["bias"]),
                                                            (v5["shadowRadius"] = v4["radius"]),
                                                            (v5["shadowMapSize"] = v4["mapSize"]),
                                                            (v5["shadowCameraNear"] = v4["camera"]["near"]),
                                                            (v5["shadowCameraFar"] = v4["camera"]["far"]),
                                                            (mP["pointShadow"][mg] = v5),
                                                            (mP["pointShadowMap"][mg] = v2),
                                                            (mP["pointShadowMatrix"][mg] = mQ["shadow"]["matrix"]),
                                                            mV++);
                                                    }
                                                    (mP["point"][mg] = v6), mg++;
                                                } else {
                                                    if (mQ["isHemisphereLight"]) {
                                                        var v6;
                                                        (v6 = mX["get"](mQ))["direction"]["setFromMatrixPosition"](mQ["matrixWorld"]),
                                                            v6["direction"]["transformDirection"](mG),
                                                            v6["direction"]["normalize"](),
                                                            v6["skyColor"]["copy"](mQ["color"])["multiplyScalar"](v0),
                                                            v6["groundColor"]["copy"](mQ["groundColor"])["multiplyScalar"](v0),
                                                            (mP["hemi"][mx] = v6),
                                                            mx++;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        (mP["ambient"][0x0] = mw), (mP["ambient"][0x1] = mO), (mP["ambient"][0x2] = mj);
                        var v7 = mP["hash"];
                        (v7["directionalLength"] === mS &&
                            v7["pointLength"] === mg &&
                            v7["spotLength"] === mW &&
                            v7["rectAreaLength"] === mH &&
                            v7["hemiLength"] === mx &&
                            v7["numDirectionalShadows"] === mK &&
                            v7["numPointShadows"] === mV &&
                            v7["numSpotShadows"] === mJ) ||
                            ((mP["directional"]["length"] = mS),
                            (mP["spot"]["length"] = mW),
                            (mP["rectArea"]["length"] = mH),
                            (mP["point"]["length"] = mg),
                            (mP["hemi"]["length"] = mx),
                            (mP["directionalShadow"]["length"] = mK),
                            (mP["directionalShadowMap"]["length"] = mK),
                            (mP["pointShadow"]["length"] = mV),
                            (mP["pointShadowMap"]["length"] = mV),
                            (mP["spotShadow"]["length"] = mJ),
                            (mP["spotShadowMap"]["length"] = mJ),
                            (mP["directionalShadowMatrix"]["length"] = mK),
                            (mP["pointShadowMatrix"]["length"] = mV),
                            (mP["spotShadowMatrix"]["length"] = mJ),
                            (v7["directionalLength"] = mS),
                            (v7["pointLength"] = mg),
                            (v7["spotLength"] = mW),
                            (v7["rectAreaLength"] = mH),
                            (v7["hemiLength"] = mx),
                            (v7["numDirectionalShadows"] = mK),
                            (v7["numPointShadows"] = mV),
                            (v7["numSpotShadows"] = mJ),
                            (mP["version"] = dV++));
                    },
                    state: mP,
                };
            }
            function dL() {
                var mN = new dG(),
                    mX = [],
                    mf = [];
                return {
                    init: function () {
                        (mX["length"] = 0x0), (mf["length"] = 0x0);
                    },
                    state: { lightsArray: mX, shadowsArray: mf, lights: mN },
                    setupLights: function (mP) {
                        mN["setup"](mX, mf, mP);
                    },
                    pushLight: function (mP) {
                        mX["push"](mP);
                    },
                    pushShadow: function (mP) {
                        mf["push"](mP);
                    },
                };
            }
            function dQ() {
                var mN = new WeakMap();
                function mX(mf) {
                    var mP = mf["target"];
                    mP["removeEventListener"]("dispose", mX), mN["delete"](mP);
                }
                return {
                    get: function (mf, mP) {
                        var mI;
                        return (
                            !0x1 === mN["has"](mf)
                                ? ((mI = new dL()), mN["set"](mf, new WeakMap()), mN["get"](mf)["set"](mP, mI), mf["addEventListener"]("dispose", mX))
                                : !0x1 === mN["get"](mf)["has"](mP)
                                ? ((mI = new dL()), mN["get"](mf)["set"](mP, mI))
                                : (mI = mN["get"](mf)["get"](mP)),
                            mI
                        );
                    },
                    dispose: function () {
                        mN = new WeakMap();
                    },
                };
            }
            function dz(mN) {
                Rg["call"](this),
                    (this["type"] = "MeshDepthMaterial"),
                    (this["depthPacking"] = 0xc80),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["map"] = null),
                    (this["alphaMap"] = null),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["fog"] = !0x1),
                    this["setValues"](mN);
            }
            function Y0(mN) {
                Rg["call"](this),
                    (this["type"] = "MeshDistanceMaterial"),
                    (this["referencePosition"] = new Ed()),
                    (this["nearDistance"] = 0x1),
                    (this["farDistance"] = 0x3e8),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["map"] = null),
                    (this["alphaMap"] = null),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["fog"] = !0x1),
                    this["setValues"](mN);
            }
            (dz["prototype"] = Object["create"](Rg["prototype"])),
                (dz["prototype"]["constructor"] = dz),
                (dz["prototype"]["isMeshDepthMaterial"] = !0x0),
                (dz["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        (this["depthPacking"] = mN["depthPacking"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["map"] = mN["map"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        this
                    );
                }),
                (Y0["prototype"] = Object["create"](Rg["prototype"])),
                (Y0["prototype"]["constructor"] = Y0),
                (Y0["prototype"]["isMeshDistanceMaterial"] = !0x0),
                (Y0["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["referencePosition"]["copy"](mN["referencePosition"]),
                        (this["nearDistance"] = mN["nearDistance"]),
                        (this["farDistance"] = mN["farDistance"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["map"] = mN["map"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        this
                    );
                });
            function Y1(mN, mX, mf) {
                var mP = new Tz(),
                    mI = new E3(),
                    mA = new E3(),
                    mM = new E8(),
                    mp = [],
                    mk = [],
                    mU = {},
                    mq = { 0x0: 0x1, 0x1: r5, 0x2: r6 },
                    mw = new TW({
                        defines: { SAMPLE_RATE: 0x2 / 0x8, HALF_SAMPLE_RATE: 0x1 / 0x8 },
                        uniforms: { shadow_pass: { value: null }, resolution: { value: new E3() }, radius: { value: 0x4 } },
                        vertexShader: "void\x20main()\x20{\x0a\x09gl_Position\x20=\x20vec4(\x20position,\x201.0\x20);\x0a}",
                        fragmentShader:
                            "uniform\x20sampler2D\x20shadow_pass;\x0auniform\x20vec2\x20resolution;\x0auniform\x20float\x20radius;\x0a#include\x20<packing>\x0avoid\x20main()\x20{\x0a\x20\x20float\x20mean\x20=\x200.0;\x0a\x20\x20float\x20squared_mean\x20=\x200.0;\x0a\x09float\x20depth\x20=\x20unpackRGBAToDepth(\x20texture2D(\x20shadow_pass,\x20(\x20gl_FragCoord.xy\x20\x20)\x20/\x20resolution\x20)\x20);\x0a\x20\x20for\x20(\x20float\x20i\x20=\x20-1.0;\x20i\x20<\x201.0\x20;\x20i\x20+=\x20SAMPLE_RATE)\x20{\x0a\x20\x20\x20\x20#ifdef\x20HORIZONAL_PASS\x0a\x20\x20\x20\x20\x20\x20vec2\x20distribution\x20=\x20unpackRGBATo2Half(\x20texture2D(\x20shadow_pass,\x20(\x20gl_FragCoord.xy\x20+\x20vec2(\x20i,\x200.0\x20)\x20*\x20radius\x20)\x20/\x20resolution\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20mean\x20+=\x20distribution.x;\x0a\x20\x20\x20\x20\x20\x20squared_mean\x20+=\x20distribution.y\x20*\x20distribution.y\x20+\x20distribution.x\x20*\x20distribution.x;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20float\x20depth\x20=\x20unpackRGBAToDepth(\x20texture2D(\x20shadow_pass,\x20(\x20gl_FragCoord.xy\x20+\x20vec2(\x200.0,\x20\x20i\x20)\x20\x20*\x20radius\x20)\x20/\x20resolution\x20)\x20);\x0a\x20\x20\x20\x20\x20\x20mean\x20+=\x20depth;\x0a\x20\x20\x20\x20\x20\x20squared_mean\x20+=\x20depth\x20*\x20depth;\x0a\x20\x20\x20\x20#endif\x0a\x20\x20}\x0a\x20\x20mean\x20=\x20mean\x20*\x20HALF_SAMPLE_RATE;\x0a\x20\x20squared_mean\x20=\x20squared_mean\x20*\x20HALF_SAMPLE_RATE;\x0a\x20\x20float\x20std_dev\x20=\x20sqrt(\x20squared_mean\x20-\x20mean\x20*\x20mean\x20);\x0a\x20\x20gl_FragColor\x20=\x20pack2HalfToRGBA(\x20vec2(\x20mean,\x20std_dev\x20)\x20);\x0a}",
                    }),
                    mO = mw["clone"]();
                mO["defines"]["HORIZONAL_PASS"] = 0x1;
                var mj = new TR();
                mj["setAttribute"]("position", new Rx(new Float32Array([-0x1, -0x1, 0.5, 0x3, -0x1, 0.5, -0x1, 0x3, 0.5]), 0x3));
                var mh = new TA(mj, mw),
                    mS = this;
                function mg(mV, mJ) {
                    var mG = mX["update"](mh);
                    (mw["uniforms"]["shadow_pass"]["value"] = mV["map"]["texture"]),
                        (mw["uniforms"]["resolution"]["value"] = mV["mapSize"]),
                        (mw["uniforms"]["radius"]["value"] = mV["radius"]),
                        mN["setRenderTarget"](mV["mapPass"]),
                        mN["clear"](),
                        mN["renderBufferDirect"](mJ, null, mG, mw, mh, null),
                        (mO["uniforms"]["shadow_pass"]["value"] = mV["mapPass"]["texture"]),
                        (mO["uniforms"]["resolution"]["value"] = mV["mapSize"]),
                        (mO["uniforms"]["radius"]["value"] = mV["radius"]),
                        mN["setRenderTarget"](mV["map"]),
                        mN["clear"](),
                        mN["renderBufferDirect"](mJ, null, mG, mO, mh, null);
                }
                function mW(mV, mJ, mG) {
                    var mL = (mV << 0x0) | (mJ << 0x1) | (mG << 0x2),
                        mQ = mp[mL];
                    return void 0x0 === mQ && ((mQ = new dz({ depthPacking: 0xc81, morphTargets: mV, skinning: mJ })), (mp[mL] = mQ)), mQ;
                }
                function mH(mV, mJ, mG) {
                    var mL = (mV << 0x0) | (mJ << 0x1) | (mG << 0x2),
                        mQ = mk[mL];
                    return void 0x0 === mQ && ((mQ = new Y0({ morphTargets: mV, skinning: mJ })), (mk[mL] = mQ)), mQ;
                }
                function mx(mV, mJ, mG, mL, mQ, mz, v0) {
                    var v1 = null,
                        v2 = mW,
                        v3 = mV["customDepthMaterial"];
                    if ((!0x0 === mL["isPointLight"] && ((v2 = mH), (v3 = mV["customDistanceMaterial"])), void 0x0 === v3)) {
                        var v4 = !0x1;
                        !0x0 === mG["morphTargets"] && (v4 = mJ["morphAttributes"] && mJ["morphAttributes"]["position"] && mJ["morphAttributes"]["position"]["length"] > 0x0);
                        var v5 = !0x1;
                        !0x0 === mV["isSkinnedMesh"] && (!0x0 === mG["skinning"] ? (v5 = !0x0) : console["warn"]("THREE.WebGLShadowMap:\x20THREE.SkinnedMesh\x20with\x20material.skinning\x20set\x20to\x20false:", mV)),
                            (v1 = v2(v4, v5, !0x0 === mV["isInstancedMesh"]));
                    } else v1 = v3;
                    if (mN["localClippingEnabled"] && !0x0 === mG["clipShadows"] && 0x0 !== mG["clippingPlanes"]["length"]) {
                        var v6 = v1["uuid"],
                            v7 = mG["uuid"],
                            v8 = mU[v6];
                        void 0x0 === v8 && ((v8 = {}), (mU[v6] = v8));
                        var v9 = v8[v7];
                        void 0x0 === v9 && ((v9 = v1["clone"]()), (v8[v7] = v9)), (v1 = v9);
                    }
                    return (
                        (v1["visible"] = mG["visible"]),
                        (v1["wireframe"] = mG["wireframe"]),
                        (v1["side"] = 0x3 === v0 ? (null !== mG["shadowSide"] ? mG["shadowSide"] : mG["side"]) : null !== mG["shadowSide"] ? mG["shadowSide"] : mq[mG["side"]]),
                        (v1["clipShadows"] = mG["clipShadows"]),
                        (v1["clippingPlanes"] = mG["clippingPlanes"]),
                        (v1["clipIntersection"] = mG["clipIntersection"]),
                        (v1["wireframeLinewidth"] = mG["wireframeLinewidth"]),
                        (v1["linewidth"] = mG["linewidth"]),
                        !0x0 === mL["isPointLight"] && !0x0 === v1["isMeshDistanceMaterial"] && (v1["referencePosition"]["setFromMatrixPosition"](mL["matrixWorld"]), (v1["nearDistance"] = mQ), (v1["farDistance"] = mz)),
                        v1
                    );
                }
                function mK(mV, mJ, mG, mL, mQ) {
                    if (!0x1 !== mV["visible"]) {
                        if (mV["layers"]["test"](mJ["layers"]) && (mV["isMesh"] || mV["isLine"] || mV["isPoints"]) && (mV["castShadow"] || (mV["receiveShadow"] && 0x3 === mQ)) && (!mV["frustumCulled"] || mP["intersectsObject"](mV))) {
                            mV["modelViewMatrix"]["multiplyMatrices"](mG["matrixWorldInverse"], mV["matrixWorld"]);
                            var mz = mX["update"](mV),
                                v0 = mV["material"];
                            if (Array["isArray"](v0))
                                for (var v1 = mz["groups"], v2 = 0x0, v3 = v1["length"]; v2 < v3; v2++) {
                                    var v4 = v1[v2],
                                        v5 = v0[v4["materialIndex"]];
                                    if (v5 && v5["visible"]) {
                                        var v6 = mx(mV, mz, v5, mL, mG["near"], mG["far"], mQ);
                                        mN["renderBufferDirect"](mG, null, mz, v6, mV, v4);
                                    }
                                }
                            else v0["visible"] && ((v6 = mx(mV, mz, v0, mL, mG["near"], mG["far"], mQ)), mN["renderBufferDirect"](mG, null, mz, v6, mV, null));
                        }
                        for (var v7 = mV["children"], v8 = 0x0, v9 = v7["length"]; v8 < v9; v8++) mK(v7[v8], mJ, mG, mL, mQ);
                    }
                }
                (this["enabled"] = !0x1),
                    (this["autoUpdate"] = !0x0),
                    (this["needsUpdate"] = !0x1),
                    (this["type"] = 0x1),
                    (this["render"] = function (mV, mJ, mG) {
                        if (!0x1 !== mS["enabled"] && (!0x1 !== mS["autoUpdate"] || !0x1 !== mS["needsUpdate"]) && 0x0 !== mV["length"]) {
                            var mL = mN["getRenderTarget"](),
                                mQ = mN["getActiveCubeFace"](),
                                mz = mN["getActiveMipmapLevel"](),
                                v0 = mN["state"];
                            v0["setBlending"](0x0), v0["buffers"]["color"]["setClear"](0x1, 0x1, 0x1, 0x1), v0["buffers"]["depth"]["setTest"](!0x0), v0["setScissorTest"](!0x1);
                            for (var v1 = 0x0, v2 = mV["length"]; v1 < v2; v1++) {
                                var v3 = mV[v1],
                                    v4 = v3["shadow"];
                                if (void 0x0 !== v4) {
                                    mI["copy"](v4["mapSize"]);
                                    var v5 = v4["getFrameExtents"]();
                                    if (
                                        (mI["multiply"](v5),
                                        mA["copy"](v4["mapSize"]),
                                        (mI["x"] > mf || mI["y"] > mf) &&
                                            (mI["x"] > mf && ((mA["x"] = Math["floor"](mf / v5["x"])), (mI["x"] = mA["x"] * v5["x"]), (v4["mapSize"]["x"] = mA["x"])),
                                            mI["y"] > mf && ((mA["y"] = Math["floor"](mf / v5["y"])), (mI["y"] = mA["y"] * v5["y"]), (v4["mapSize"]["y"] = mA["y"]))),
                                        null === v4["map"] && !v4["isPointLightShadow"] && 0x3 === this["type"])
                                    ) {
                                        var v6 = { minFilter: rB, magFilter: rB, format: rf };
                                        (v4["map"] = new E9(mI["x"], mI["y"], v6)), (v4["map"]["texture"]["name"] = v3["name"] + ".shadowMap"), (v4["mapPass"] = new E9(mI["x"], mI["y"], v6)), v4["camera"]["updateProjectionMatrix"]();
                                    }
                                    null === v4["map"] &&
                                        ((v6 = { minFilter: rC, magFilter: rC, format: rf }),
                                        ((v4["map"] = new E9(mI["x"], mI["y"], v6)), (v4["map"]["texture"]["name"] = v3["name"] + ".shadowMap"), v4["camera"]["updateProjectionMatrix"]()));
                                    mN["setRenderTarget"](v4["map"]), mN["clear"]();
                                    for (var v7 = v4["getViewportCount"](), v8 = 0x0; v8 < v7; v8++) {
                                        var v9 = v4["getViewport"](v8);
                                        mM["set"](mA["x"] * v9["x"], mA["y"] * v9["y"], mA["x"] * v9["z"], mA["y"] * v9["w"]),
                                            v0["viewport"](mM),
                                            v4["updateMatrices"](v3, v8),
                                            (mP = v4["getFrustum"]()),
                                            mK(mJ, mG, v4["camera"], v3, this["type"]);
                                    }
                                    v4["isPointLightShadow"] || 0x3 !== this["type"] || mg(v4, mG);
                                } else console["warn"]("THREE.WebGLShadowMap:", v3, "has\x20no\x20shadow.");
                            }
                            (mS["needsUpdate"] = !0x1), mN["setRenderTarget"](mL, mQ, mz);
                        }
                    });
            }
            function Y2(mN, mX, mf) {
                var mP = mf["isWebGL2"],
                    mI = new (function () {
                        var vv = !0x1,
                            vy = new E8(),
                            vD = null,
                            vN = new E8(0x0, 0x0, 0x0, 0x0);
                        return {
                            setMask: function (vX) {
                                vD === vX || vv || (mN["colorMask"](vX, vX, vX, vX), (vD = vX));
                            },
                            setLocked: function (vX) {
                                vv = vX;
                            },
                            setClear: function (vX, vf, vP, vI, vA) {
                                !0x0 === vA && ((vX *= vI), (vf *= vI), (vP *= vI)), vy["set"](vX, vf, vP, vI), !0x1 === vN["equals"](vy) && (mN["clearColor"](vX, vf, vP, vI), vN["copy"](vy));
                            },
                            reset: function () {
                                (vv = !0x1), (vD = null), vN["set"](-0x1, 0x0, 0x0, 0x0);
                            },
                        };
                    })(),
                    mA = new (function () {
                        var vv = !0x1,
                            vy = null,
                            vD = null,
                            vN = null;
                        return {
                            setTest: function (vX) {
                                vX ? vR(0xb71) : vT(0xb71);
                            },
                            setMask: function (vX) {
                                vy === vX || vv || (mN["depthMask"](vX), (vy = vX));
                            },
                            setFunc: function (vX) {
                                if (vD !== vX) {
                                    if (vX)
                                        switch (vX) {
                                            case 0x0:
                                                mN["depthFunc"](0x200);
                                                break;
                                            case 0x1:
                                                mN["depthFunc"](0x207);
                                                break;
                                            case 0x2:
                                                mN["depthFunc"](0x201);
                                                break;
                                            case 0x3:
                                            default:
                                                mN["depthFunc"](0x203);
                                                break;
                                            case 0x4:
                                                mN["depthFunc"](0x202);
                                                break;
                                            case 0x5:
                                                mN["depthFunc"](0x206);
                                                break;
                                            case 0x6:
                                                mN["depthFunc"](0x204);
                                                break;
                                            case 0x7:
                                                mN["depthFunc"](0x205);
                                        }
                                    else mN["depthFunc"](0x203);
                                    vD = vX;
                                }
                            },
                            setLocked: function (vX) {
                                vv = vX;
                            },
                            setClear: function (vX) {
                                vN !== vX && (mN["clearDepth"](vX), (vN = vX));
                            },
                            reset: function () {
                                (vv = !0x1), (vy = null), (vD = null), (vN = null);
                            },
                        };
                    })(),
                    mM = new (function () {
                        var vv = !0x1,
                            vy = null,
                            vD = null,
                            vN = null,
                            vX = null,
                            vf = null,
                            vP = null,
                            vI = null,
                            vA = null;
                        return {
                            setTest: function (vM) {
                                vv || (vM ? vR(0xb90) : vT(0xb90));
                            },
                            setMask: function (vM) {
                                vy === vM || vv || (mN["stencilMask"](vM), (vy = vM));
                            },
                            setFunc: function (vM, vp, vk) {
                                (vD === vM && vN === vp && vX === vk) || (mN["stencilFunc"](vM, vp, vk), (vD = vM), (vN = vp), (vX = vk));
                            },
                            setOp: function (vM, vp, vk) {
                                (vf === vM && vP === vp && vI === vk) || (mN["stencilOp"](vM, vp, vk), (vf = vM), (vP = vp), (vI = vk));
                            },
                            setLocked: function (vM) {
                                vv = vM;
                            },
                            setClear: function (vM) {
                                vA !== vM && (mN["clearStencil"](vM), (vA = vM));
                            },
                            reset: function () {
                                (vv = !0x1), (vy = null), (vD = null), (vN = null), (vX = null), (vf = null), (vP = null), (vI = null), (vA = null);
                            },
                        };
                    })(),
                    mp = mN["getParameter"](0x8869),
                    mk = new Uint8Array(mp),
                    mU = new Uint8Array(mp),
                    mq = new Uint8Array(mp),
                    mw = {},
                    mO = null,
                    mj = null,
                    mh = null,
                    mS = null,
                    mg = null,
                    mW = null,
                    mH = null,
                    mx = null,
                    mK = null,
                    mV = !0x1,
                    mJ = null,
                    mG = null,
                    mL = null,
                    mQ = null,
                    mz = null,
                    v0 = mN["getParameter"](0x8b4d),
                    v1 = !0x1,
                    v2 = 0x0,
                    v3 = mN["getParameter"](0x1f02);
                -0x1 !== v3["indexOf"]("WebGL")
                    ? ((v2 = parseFloat(/^WebGL\ ([0-9])/["exec"](v3)[0x1])), (v1 = v2 >= 0x1))
                    : -0x1 !== v3["indexOf"]("OpenGL\x20ES") && ((v2 = parseFloat(/^OpenGL\ ES\ ([0-9])/["exec"](v3)[0x1])), (v1 = v2 >= 0x2));
                var v4 = null,
                    v5 = {},
                    v6 = new E8(),
                    v7 = new E8();
                function v8(vv, vy, vD) {
                    var vN = new Uint8Array(0x4),
                        vX = mN["createTexture"]();
                    mN["bindTexture"](vv, vX), mN["texParameteri"](vv, 0x2801, 0x2600), mN["texParameteri"](vv, 0x2800, 0x2600);
                    for (var vf = 0x0; vf < vD; vf++) mN["texImage2D"](vy + vf, 0x0, 0x1908, 0x1, 0x1, 0x0, 0x1908, 0x1401, vN);
                    return vX;
                }
                var v9 = {};
                function vE(vv, vy) {
                    ((mk[vv] = 0x1), 0x0 === mU[vv] && (mN["enableVertexAttribArray"](vv), (mU[vv] = 0x1)), mq[vv] !== vy) &&
                        ((mP ? mN : mX["get"]("ANGLE_instanced_arrays"))[mP ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](vv, vy), (mq[vv] = vy));
                }
                function vR(vv) {
                    !0x0 !== mw[vv] && (mN["enable"](vv), (mw[vv] = !0x0));
                }
                function vT(vv) {
                    !0x1 !== mw[vv] && (mN["disable"](vv), (mw[vv] = !0x1));
                }
                (v9[0xde1] = v8(0xde1, 0xde1, 0x1)), (v9[0x8513] = v8(0x8513, 0x8515, 0x6)), mI["setClear"](0x0, 0x0, 0x0, 0x1), mA["setClear"](0x1), mM["setClear"](0x0), vR(0xb71), mA["setFunc"](0x3), vF(!0x1), vb(0x1), vR(0xb44), vB(0x0);
                var vC = { [r8]: 0x8006, 0x65: 0x800a, 0x66: 0x800b };
                if (mP) (vC[0x67] = 0x8007), (vC[0x68] = 0x8008);
                else {
                    var vd = mX["get"]("EXT_blend_minmax");
                    null !== vd && ((vC[0x67] = vd["MIN_EXT"]), (vC[0x68] = vd["MAX_EXT"]));
                }
                var vY = { 0xc8: 0x0, 0xc9: 0x1, 0xca: 0x300, 0xcc: 0x302, 0xd2: 0x308, 0xd0: 0x306, 0xce: 0x304, 0xcb: 0x301, 0xcd: 0x303, 0xd1: 0x307, 0xcf: 0x305 };
                function vB(vv, vy, vD, vN, vX, vf, vP, vI) {
                    if (0x0 !== vv) {
                        if ((mj || (vR(0xbe2), (mj = !0x0)), 0x5 === vv))
                            (vX = vX || vy),
                                (vf = vf || vD),
                                (vP = vP || vN),
                                (vy === mS && vX === mH) || (mN["blendEquationSeparate"](vC[vy], vC[vX]), (mS = vy), (mH = vX)),
                                (vD === mg && vN === mW && vf === mx && vP === mK) || (mN["blendFuncSeparate"](vY[vD], vY[vN], vY[vf], vY[vP]), (mg = vD), (mW = vN), (mx = vf), (mK = vP)),
                                (mh = vv),
                                (mV = null);
                        else {
                            if (vv !== mh || vI !== mV) {
                                if (((mS === r8 && mH === r8) || (mN["blendEquation"](0x8006), (mS = r8), (mH = r8)), vI))
                                    switch (vv) {
                                        case 0x1:
                                            mN["blendFuncSeparate"](0x1, 0x303, 0x1, 0x303);
                                            break;
                                        case 0x2:
                                            mN["blendFunc"](0x1, 0x1);
                                            break;
                                        case 0x3:
                                            mN["blendFuncSeparate"](0x0, 0x0, 0x301, 0x303);
                                            break;
                                        case r7:
                                            mN["blendFuncSeparate"](0x0, 0x300, 0x0, 0x302);
                                            break;
                                        default:
                                            console["error"]("THREE.WebGLState:\x20Invalid\x20blending:\x20", vv);
                                    }
                                else
                                    switch (vv) {
                                        case 0x1:
                                            mN["blendFuncSeparate"](0x302, 0x303, 0x1, 0x303);
                                            break;
                                        case 0x2:
                                            mN["blendFunc"](0x302, 0x1);
                                            break;
                                        case 0x3:
                                            mN["blendFunc"](0x0, 0x301);
                                            break;
                                        case r7:
                                            mN["blendFunc"](0x0, 0x300);
                                            break;
                                        default:
                                            console["error"]("THREE.WebGLState:\x20Invalid\x20blending:\x20", vv);
                                    }
                                (mg = null), (mW = null), (mx = null), (mK = null), (mh = vv), (mV = vI);
                            }
                        }
                    } else mj && (vT(0xbe2), (mj = !0x1));
                }
                function vF(vv) {
                    mJ !== vv && (vv ? mN["frontFace"](0x900) : mN["frontFace"](0x901), (mJ = vv));
                }
                function vb(vv) {
                    0x0 !== vv ? (vR(0xb44), vv !== mG && (0x1 === vv ? mN["cullFace"](0x405) : 0x2 === vv ? mN["cullFace"](0x404) : mN["cullFace"](0x408))) : vT(0xb44), (mG = vv);
                }
                function vZ(vv, vy, vD) {
                    vv ? (vR(0x8037), (mQ === vy && mz === vD) || (mN["polygonOffset"](vy, vD), (mQ = vy), (mz = vD))) : vT(0x8037);
                }
                function vm(vv) {
                    void 0x0 === vv && (vv = 0x84c0 + v0 - 0x1), v4 !== vv && (mN["activeTexture"](vv), (v4 = vv));
                }
                return {
                    buffers: { color: mI, depth: mA, stencil: mM },
                    initAttributes: function () {
                        for (var vv = 0x0, vy = mk["length"]; vv < vy; vv++) mk[vv] = 0x0;
                    },
                    enableAttribute: function (vv) {
                        vE(vv, 0x0);
                    },
                    enableAttributeAndDivisor: vE,
                    disableUnusedAttributes: function () {
                        for (var vv = 0x0, vy = mU["length"]; vv !== vy; ++vv) mU[vv] !== mk[vv] && (mN["disableVertexAttribArray"](vv), (mU[vv] = 0x0));
                    },
                    vertexAttribPointer: function (vv, vy, vD, vN, vX, vf) {
                        !0x0 !== mP || (0x1404 !== vD && 0x1405 !== vD) ? mN["vertexAttribPointer"](vv, vy, vD, vN, vX, vf) : mN["vertexAttribIPointer"](vv, vy, vD, vN, vX, vf);
                    },
                    enable: vR,
                    disable: vT,
                    useProgram: function (vv) {
                        return mO !== vv && (mN["useProgram"](vv), (mO = vv), !0x0);
                    },
                    setBlending: vB,
                    setMaterial: function (vv, vy) {
                        vv["side"] === r6 ? vT(0xb44) : vR(0xb44);
                        var vD = 0x1 === vv["side"];
                        vy && (vD = !vD),
                            vF(vD),
                            0x1 === vv["blending"] && !0x1 === vv["transparent"]
                                ? vB(0x0)
                                : vB(vv["blending"], vv["blendEquation"], vv["blendSrc"], vv["blendDst"], vv["blendEquationAlpha"], vv["blendSrcAlpha"], vv["blendDstAlpha"], vv["premultipliedAlpha"]),
                            mA["setFunc"](vv["depthFunc"]),
                            mA["setTest"](vv["depthTest"]),
                            mA["setMask"](vv["depthWrite"]),
                            mI["setMask"](vv["colorWrite"]);
                        var vN = vv["stencilWrite"];
                        mM["setTest"](vN),
                            vN && (mM["setMask"](vv["stencilWriteMask"]), mM["setFunc"](vv["stencilFunc"], vv["stencilRef"], vv["stencilFuncMask"]), mM["setOp"](vv["stencilFail"], vv["stencilZFail"], vv["stencilZPass"])),
                            vZ(vv["polygonOffset"], vv["polygonOffsetFactor"], vv["polygonOffsetUnits"]);
                    },
                    setFlipSided: vF,
                    setCullFace: vb,
                    setLineWidth: function (vv) {
                        vv !== mL && (v1 && mN["lineWidth"](vv), (mL = vv));
                    },
                    setPolygonOffset: vZ,
                    setScissorTest: function (vv) {
                        vv ? vR(0xc11) : vT(0xc11);
                    },
                    activeTexture: vm,
                    bindTexture: function (vv, vy) {
                        null === v4 && vm();
                        var vD = v5[v4];
                        void 0x0 === vD && ((vD = { type: void 0x0, texture: void 0x0 }), (v5[v4] = vD)), (vD["type"] === vv && vD["texture"] === vy) || (mN["bindTexture"](vv, vy || v9[vv]), (vD["type"] = vv), (vD["texture"] = vy));
                    },
                    unbindTexture: function () {
                        var vv = v5[v4];
                        void 0x0 !== vv && void 0x0 !== vv["type"] && (mN["bindTexture"](vv["type"], null), (vv["type"] = void 0x0), (vv["texture"] = void 0x0));
                    },
                    compressedTexImage2D: function () {
                        try {
                            mN["compressedTexImage2D"]["apply"](mN, arguments);
                        } catch (vv) {
                            console["error"]("THREE.WebGLState:", vv);
                        }
                    },
                    texImage2D: function () {
                        try {
                            mN["texImage2D"]["apply"](mN, arguments);
                        } catch (vv) {
                            console["error"]("THREE.WebGLState:", vv);
                        }
                    },
                    texImage3D: function () {
                        try {
                            mN["texImage3D"]["apply"](mN, arguments);
                        } catch (vv) {
                            console["error"]("THREE.WebGLState:", vv);
                        }
                    },
                    scissor: function (vv) {
                        !0x1 === v6["equals"](vv) && (mN["scissor"](vv["x"], vv["y"], vv["z"], vv["w"]), v6["copy"](vv));
                    },
                    viewport: function (vv) {
                        !0x1 === v7["equals"](vv) && (mN["viewport"](vv["x"], vv["y"], vv["z"], vv["w"]), v7["copy"](vv));
                    },
                    reset: function () {
                        for (var vv = 0x0; vv < mU["length"]; vv++) 0x1 === mU[vv] && (mN["disableVertexAttribArray"](vv), (mU[vv] = 0x0));
                        (mw = {}), (v4 = null), (v5 = {}), (mO = null), (mh = null), (mJ = null), (mG = null), mI["reset"](), mA["reset"](), mM["reset"]();
                    },
                };
            }
            function Y3(mN, mX, mf, mP, mI, mA, mM) {
                var mp,
                    mk = mI["isWebGL2"],
                    mU = mI["maxTextures"],
                    mq = mI["maxCubemapSize"],
                    mw = mI["maxTextureSize"],
                    mO = mI["maxSamples"],
                    mj = new WeakMap(),
                    mh = !0x1;
                try {
                    mh = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(0x1, 0x1)["getContext"]("2d");
                } catch (vT) {}
                function mS(vC, vd) {
                    return mh ? new OffscreenCanvas(vC, vd) : document["createElementNS"]("http://www.w3.org/1999/xhtml", "canvas");
                }
                function mg(vC, vd, vY, vB) {
                    var vF = 0x1;
                    if (((vC["width"] > vB || vC["height"] > vB) && (vF = vB / Math["max"](vC["width"], vC["height"])), vF < 0x1 || !0x0 === vd)) {
                        if (
                            ("undefined" != typeof HTMLImageElement && vC instanceof HTMLImageElement) ||
                            ("undefined" != typeof HTMLCanvasElement && vC instanceof HTMLCanvasElement) ||
                            ("undefined" != typeof ImageBitmap && vC instanceof ImageBitmap)
                        ) {
                            var vb = vd ? E2["floorPowerOfTwo"] : Math["floor"],
                                vZ = vb(vF * vC["width"]),
                                vm = vb(vF * vC["height"]);
                            void 0x0 === mp && (mp = mS(vZ, vm));
                            var vv = vY ? mS(vZ, vm) : mp;
                            return (
                                (vv["width"] = vZ),
                                (vv["height"] = vm),
                                vv["getContext"]("2d")["drawImage"](vC, 0x0, 0x0, vZ, vm),
                                console["warn"]("THREE.WebGLRenderer:\x20Texture\x20has\x20been\x20resized\x20from\x20(" + vC["width"] + "x" + vC["height"] + ")\x20to\x20(" + vZ + "x" + vm + ")."),
                                vv
                            );
                        }
                        return "data" in vC && console["warn"]("THREE.WebGLRenderer:\x20Image\x20in\x20DataTexture\x20is\x20too\x20big\x20(" + vC["width"] + "x" + vC["height"] + ")."), vC;
                    }
                    return vC;
                }
                function mW(vC) {
                    return E2["isPowerOfTwo"](vC["width"]) && E2["isPowerOfTwo"](vC["height"]);
                }
                function mH(vC, vd) {
                    return vC["generateMipmaps"] && vd && vC["minFilter"] !== rC && vC["minFilter"] !== rB;
                }
                function mx(vC, vd, vY, vB) {
                    mN["generateMipmap"](vC), (mP["get"](vd)["__maxMipLevel"] = Math["log"](Math["max"](vY, vB)) * Math["LOG2E"]);
                }
                function mK(vC, vd, vY) {
                    if (!0x1 === mk) return vd;
                    if (null !== vC) {
                        if (void 0x0 !== mN[vC]) return mN[vC];
                        console["warn"]("THREE.WebGLRenderer:\x20Attempt\x20to\x20use\x20non-existing\x20WebGL\x20internal\x20format\x20\x27" + vC + "\x27");
                    }
                    var vB = vd;
                    return (
                        0x1903 === vd && (0x1406 === vY && (vB = 0x822e), 0x140b === vY && (vB = 0x822d), 0x1401 === vY && (vB = 0x8229)),
                        0x1907 === vd && (0x1406 === vY && (vB = 0x8815), 0x140b === vY && (vB = 0x881b), 0x1401 === vY && (vB = 0x8051)),
                        0x1908 === vd && (0x1406 === vY && (vB = 0x8814), 0x140b === vY && (vB = 0x881a), 0x1401 === vY && (vB = 0x8058)),
                        (0x822d !== vB && 0x822e !== vB && 0x881a !== vB && 0x8814 !== vB) || mX["get"]("EXT_color_buffer_float"),
                        vB
                    );
                }
                function mV(vC) {
                    return vC === rC || vC === rd || vC === rY ? 0x2600 : 0x2601;
                }
                function mJ(vC) {
                    var vd = vC["target"];
                    vd["removeEventListener"]("dispose", mJ),
                        (function (vY) {
                            var vB = mP["get"](vY);
                            if (void 0x0 === vB["__webglInit"]) return;
                            mN["deleteTexture"](vB["__webglTexture"]), mP["remove"](vY);
                        })(vd),
                        vd["isVideoTexture"] && mj["delete"](vd),
                        mM["memory"]["textures"]--;
                }
                function mG(vC) {
                    var vd = vC["target"];
                    vd["removeEventListener"]("dispose", mG),
                        (function (vY) {
                            var vB = mP["get"](vY),
                                vF = mP["get"](vY["texture"]);
                            if (!vY) return;
                            void 0x0 !== vF["__webglTexture"] && mN["deleteTexture"](vF["__webglTexture"]), vY["depthTexture"] && vY["depthTexture"]["dispose"]();
                            if (vY["isWebGLCubeRenderTarget"]) {
                                for (var vb = 0x0; vb < 0x6; vb++) mN["deleteFramebuffer"](vB["__webglFramebuffer"][vb]), vB["__webglDepthbuffer"] && mN["deleteRenderbuffer"](vB["__webglDepthbuffer"][vb]);
                            } else
                                mN["deleteFramebuffer"](vB["__webglFramebuffer"]),
                                    vB["__webglDepthbuffer"] && mN["deleteRenderbuffer"](vB["__webglDepthbuffer"]),
                                    vB["__webglMultisampledFramebuffer"] && mN["deleteFramebuffer"](vB["__webglMultisampledFramebuffer"]),
                                    vB["__webglColorRenderbuffer"] && mN["deleteRenderbuffer"](vB["__webglColorRenderbuffer"]),
                                    vB["__webglDepthRenderbuffer"] && mN["deleteRenderbuffer"](vB["__webglDepthRenderbuffer"]);
                            mP["remove"](vY["texture"]), mP["remove"](vY);
                        })(vd),
                        mM["memory"]["textures"]--;
                }
                var mL = 0x0;
                function mQ(vC, vd) {
                    var vY = mP["get"](vC);
                    if (
                        (vC["isVideoTexture"] &&
                            (function (vF) {
                                var vb = mM["render"]["frame"];
                                mj["get"](vF) !== vb && (mj["set"](vF, vb), vF["update"]());
                            })(vC),
                        vC["version"] > 0x0 && vY["__version"] !== vC["version"])
                    ) {
                        var vB = vC["image"];
                        if (void 0x0 === vB) console["warn"]("THREE.WebGLRenderer:\x20Texture\x20marked\x20for\x20update\x20but\x20image\x20is\x20undefined");
                        else {
                            if (!0x1 !== vB["complete"]) return void v5(vY, vC, vd);
                            console["warn"]("THREE.WebGLRenderer:\x20Texture\x20marked\x20for\x20update\x20but\x20image\x20is\x20incomplete");
                        }
                    }
                    mf["activeTexture"](0x84c0 + vd), mf["bindTexture"](0xde1, vY["__webglTexture"]);
                }
                function mz(vC, vd) {
                    if (0x6 === vC["image"]["length"]) {
                        var vY = mP["get"](vC);
                        if (vC["version"] > 0x0 && vY["__version"] !== vC["version"]) {
                            v4(vY, vC), mf["activeTexture"](0x84c0 + vd), mf["bindTexture"](0x8513, vY["__webglTexture"]), mN["pixelStorei"](0x9240, vC["flipY"]);
                            for (var vB = vC && (vC["isCompressedTexture"] || vC["image"][0x0]["isCompressedTexture"]), vF = vC["image"][0x0] && vC["image"][0x0]["isDataTexture"], vb = [], vZ = 0x0; vZ < 0x6; vZ++)
                                vb[vZ] = vB || vF ? (vF ? vC["image"][vZ]["image"] : vC["image"][vZ]) : mg(vC["image"][vZ], !0x1, !0x0, mq);
                            var vm,
                                vv = vb[0x0],
                                vy = mW(vv) || mk,
                                vD = mA["convert"](vC["format"]),
                                vN = mA["convert"](vC["type"]),
                                vX = mK(vC["internalFormat"], vD, vN);
                            if ((v3(0x8513, vC, vy), vB)) {
                                for (vZ = 0x0; vZ < 0x6; vZ++) {
                                    vm = vb[vZ]["mipmaps"];
                                    for (var vf = 0x0; vf < vm["length"]; vf++) {
                                        var vP = vm[vf];
                                        vC["format"] !== rf && vC["format"] !== rX
                                            ? null !== vD
                                                ? mf["compressedTexImage2D"](0x8515 + vZ, vf, vX, vP["width"], vP["height"], 0x0, vP["data"])
                                                : console["warn"]("THREE.WebGLRenderer:\x20Attempt\x20to\x20load\x20unsupported\x20compressed\x20texture\x20format\x20in\x20.setTextureCube()")
                                            : mf["texImage2D"](0x8515 + vZ, vf, vX, vP["width"], vP["height"], 0x0, vD, vN, vP["data"]);
                                    }
                                }
                                vY["__maxMipLevel"] = vm["length"] - 0x1;
                            } else {
                                vm = vC["mipmaps"];
                                for (vZ = 0x0; vZ < 0x6; vZ++)
                                    if (vF) {
                                        mf["texImage2D"](0x8515 + vZ, 0x0, vX, vb[vZ]["width"], vb[vZ]["height"], 0x0, vD, vN, vb[vZ]["data"]);
                                        for (vf = 0x0; vf < vm["length"]; vf++) {
                                            var vI = (vP = vm[vf])["image"][vZ]["image"];
                                            mf["texImage2D"](0x8515 + vZ, vf + 0x1, vX, vI["width"], vI["height"], 0x0, vD, vN, vI["data"]);
                                        }
                                    } else {
                                        mf["texImage2D"](0x8515 + vZ, 0x0, vX, vD, vN, vb[vZ]);
                                        for (vf = 0x0; vf < vm["length"]; vf++) {
                                            (vP = vm[vf]), mf["texImage2D"](0x8515 + vZ, vf + 0x1, vX, vD, vN, vP["image"][vZ]);
                                        }
                                    }
                                vY["__maxMipLevel"] = vm["length"];
                            }
                            mH(vC, vy) && mx(0x8513, vC, vv["width"], vv["height"]), (vY["__version"] = vC["version"]), vC["onUpdate"] && vC["onUpdate"](vC);
                        } else mf["activeTexture"](0x84c0 + vd), mf["bindTexture"](0x8513, vY["__webglTexture"]);
                    }
                }
                function v0(vC, vd) {
                    mf["activeTexture"](0x84c0 + vd), mf["bindTexture"](0x8513, mP["get"](vC)["__webglTexture"]);
                }
                var v1 = { [rE]: 0x2901, [rR]: 0x812f, [rT]: 0x8370 },
                    v2 = { [rC]: 0x2600, [rd]: 0x2700, [rY]: 0x2702, [rB]: 0x2601, [rF]: 0x2701, [rb]: 0x2703 };
                function v3(vC, vd, vY) {
                    vY
                        ? (mN["texParameteri"](vC, 0x2802, v1[vd["wrapS"]]),
                          mN["texParameteri"](vC, 0x2803, v1[vd["wrapT"]]),
                          (0x806f !== vC && 0x8c1a !== vC) || mN["texParameteri"](vC, 0x8072, v1[vd["wrapR"]]),
                          mN["texParameteri"](vC, 0x2800, v2[vd["magFilter"]]),
                          mN["texParameteri"](vC, 0x2801, v2[vd["minFilter"]]))
                        : (mN["texParameteri"](vC, 0x2802, 0x812f),
                          mN["texParameteri"](vC, 0x2803, 0x812f),
                          (0x806f !== vC && 0x8c1a !== vC) || mN["texParameteri"](vC, 0x8072, 0x812f),
                          (vd["wrapS"] === rR && vd["wrapT"] === rR) ||
                              console["warn"]("THREE.WebGLRenderer:\x20Texture\x20is\x20not\x20power\x20of\x20two.\x20Texture.wrapS\x20and\x20Texture.wrapT\x20should\x20be\x20set\x20to\x20THREE.ClampToEdgeWrapping."),
                          mN["texParameteri"](vC, 0x2800, mV(vd["magFilter"])),
                          mN["texParameteri"](vC, 0x2801, mV(vd["minFilter"])),
                          vd["minFilter"] !== rC &&
                              vd["minFilter"] !== rB &&
                              console["warn"]("THREE.WebGLRenderer:\x20Texture\x20is\x20not\x20power\x20of\x20two.\x20Texture.minFilter\x20should\x20be\x20set\x20to\x20THREE.NearestFilter\x20or\x20THREE.LinearFilter."));
                    var vB = mX["get"]("EXT_texture_filter_anisotropic");
                    if (vB) {
                        if (vd["type"] === ry && null === mX["get"]("OES_texture_float_linear")) return;
                        if (vd["type"] === rD && null === (mk || mX["get"]("OES_texture_half_float_linear"))) return;
                        (vd["anisotropy"] > 0x1 || mP["get"](vd)["__currentAnisotropy"]) &&
                            (mN["texParameterf"](vC, vB["TEXTURE_MAX_ANISOTROPY_EXT"], Math["min"](vd["anisotropy"], mI["getMaxAnisotropy"]())), (mP["get"](vd)["__currentAnisotropy"] = vd["anisotropy"]));
                    }
                }
                function v4(vC, vd) {
                    void 0x0 === vC["__webglInit"] && ((vC["__webglInit"] = !0x0), vd["addEventListener"]("dispose", mJ), (vC["__webglTexture"] = mN["createTexture"]()), mM["memory"]["textures"]++);
                }
                function v5(vC, vd, vY) {
                    var vB = 0xde1;
                    vd["isDataTexture2DArray"] && (vB = 0x8c1a),
                        vd["isDataTexture3D"] && (vB = 0x806f),
                        v4(vC, vd),
                        mf["activeTexture"](0x84c0 + vY),
                        mf["bindTexture"](vB, vC["__webglTexture"]),
                        mN["pixelStorei"](0x9240, vd["flipY"]),
                        mN["pixelStorei"](0x9241, vd["premultiplyAlpha"]),
                        mN["pixelStorei"](0xcf5, vd["unpackAlignment"]);
                    var vF =
                            (function (vP) {
                                return !mk && (vP["wrapS"] !== rR || vP["wrapT"] !== rR || (vP["minFilter"] !== rC && vP["minFilter"] !== rB));
                            })(vd) && !0x1 === mW(vd["image"]),
                        vb = mg(vd["image"], vF, !0x1, mw),
                        vZ = mW(vb) || mk,
                        vm = mA["convert"](vd["format"]),
                        vv = mA["convert"](vd["type"]),
                        vy = mK(vd["internalFormat"], vm, vv);
                    v3(vB, vd, vZ);
                    var vD,
                        vN = vd["mipmaps"];
                    if (vd["isDepthTexture"])
                        (vy = 0x1902),
                            mk
                                ? (vy = vd["type"] === ry ? 0x8cac : vd["type"] === rv ? 0x81a6 : vd["type"] === rN ? 0x88f0 : 0x81a5)
                                : vd["type"] === ry && console["error"]("WebGLRenderer:\x20Floating\x20point\x20depth\x20texture\x20requires\x20WebGL2."),
                            vd["format"] === rI &&
                                0x1902 === vy &&
                                vd["type"] !== rm &&
                                vd["type"] !== rv &&
                                (console["warn"]("THREE.WebGLRenderer:\x20Use\x20UnsignedShortType\x20or\x20UnsignedIntType\x20for\x20DepthFormat\x20DepthTexture."), (vd["type"] = rm), (vv = mA["convert"](vd["type"]))),
                            vd["format"] === rA &&
                                0x1902 === vy &&
                                ((vy = 0x84f9), vd["type"] !== rN && (console["warn"]("THREE.WebGLRenderer:\x20Use\x20UnsignedInt248Type\x20for\x20DepthStencilFormat\x20DepthTexture."), (vd["type"] = rN), (vv = mA["convert"](vd["type"])))),
                            mf["texImage2D"](0xde1, 0x0, vy, vb["width"], vb["height"], 0x0, vm, vv, null);
                    else {
                        if (vd["isDataTexture"]) {
                            if (vN["length"] > 0x0 && vZ) {
                                for (var vX = 0x0, vf = vN["length"]; vX < vf; vX++) (vD = vN[vX]), mf["texImage2D"](0xde1, vX, vy, vD["width"], vD["height"], 0x0, vm, vv, vD["data"]);
                                (vd["generateMipmaps"] = !0x1), (vC["__maxMipLevel"] = vN["length"] - 0x1);
                            } else mf["texImage2D"](0xde1, 0x0, vy, vb["width"], vb["height"], 0x0, vm, vv, vb["data"]), (vC["__maxMipLevel"] = 0x0);
                        } else {
                            if (vd["isCompressedTexture"]) {
                                for (vX = 0x0, vf = vN["length"]; vX < vf; vX++)
                                    (vD = vN[vX]),
                                        vd["format"] !== rf && vd["format"] !== rX
                                            ? null !== vm
                                                ? mf["compressedTexImage2D"](0xde1, vX, vy, vD["width"], vD["height"], 0x0, vD["data"])
                                                : console["warn"]("THREE.WebGLRenderer:\x20Attempt\x20to\x20load\x20unsupported\x20compressed\x20texture\x20format\x20in\x20.uploadTexture()")
                                            : mf["texImage2D"](0xde1, vX, vy, vD["width"], vD["height"], 0x0, vm, vv, vD["data"]);
                                vC["__maxMipLevel"] = vN["length"] - 0x1;
                            } else {
                                if (vd["isDataTexture2DArray"]) mf["texImage3D"](0x8c1a, 0x0, vy, vb["width"], vb["height"], vb["depth"], 0x0, vm, vv, vb["data"]), (vC["__maxMipLevel"] = 0x0);
                                else {
                                    if (vd["isDataTexture3D"]) mf["texImage3D"](0x806f, 0x0, vy, vb["width"], vb["height"], vb["depth"], 0x0, vm, vv, vb["data"]), (vC["__maxMipLevel"] = 0x0);
                                    else {
                                        if (vN["length"] > 0x0 && vZ) {
                                            for (vX = 0x0, vf = vN["length"]; vX < vf; vX++) (vD = vN[vX]), mf["texImage2D"](0xde1, vX, vy, vm, vv, vD);
                                            (vd["generateMipmaps"] = !0x1), (vC["__maxMipLevel"] = vN["length"] - 0x1);
                                        } else mf["texImage2D"](0xde1, 0x0, vy, vm, vv, vb), (vC["__maxMipLevel"] = 0x0);
                                    }
                                }
                            }
                        }
                    }
                    mH(vd, vZ) && mx(vB, vd, vb["width"], vb["height"]), (vC["__version"] = vd["version"]), vd["onUpdate"] && vd["onUpdate"](vd);
                }
                function v6(vC, vd, vY, vB) {
                    var vF = mA["convert"](vd["texture"]["format"]),
                        vb = mA["convert"](vd["texture"]["type"]),
                        vZ = mK(vd["texture"]["internalFormat"], vF, vb);
                    mf["texImage2D"](vB, 0x0, vZ, vd["width"], vd["height"], 0x0, vF, vb, null),
                        mN["bindFramebuffer"](0x8d40, vC),
                        mN["framebufferTexture2D"](0x8d40, vY, vB, mP["get"](vd["texture"])["__webglTexture"], 0x0),
                        mN["bindFramebuffer"](0x8d40, null);
                }
                function v7(vC, vd, vY) {
                    if ((mN["bindRenderbuffer"](0x8d41, vC), vd["depthBuffer"] && !vd["stencilBuffer"])) {
                        var vB = 0x81a5;
                        if (vY) {
                            var vF = vd["depthTexture"];
                            vF && vF["isDepthTexture"] && (vF["type"] === ry ? (vB = 0x8cac) : vF["type"] === rv && (vB = 0x81a6));
                            var vb = v9(vd);
                            mN["renderbufferStorageMultisample"](0x8d41, vb, vB, vd["width"], vd["height"]);
                        } else mN["renderbufferStorage"](0x8d41, vB, vd["width"], vd["height"]);
                        mN["framebufferRenderbuffer"](0x8d40, 0x8d00, 0x8d41, vC);
                    } else {
                        if (vd["depthBuffer"] && vd["stencilBuffer"]) {
                            if (vY) (vb = v9(vd)), mN["renderbufferStorageMultisample"](0x8d41, vb, 0x88f0, vd["width"], vd["height"]);
                            else mN["renderbufferStorage"](0x8d41, 0x84f9, vd["width"], vd["height"]);
                            mN["framebufferRenderbuffer"](0x8d40, 0x821a, 0x8d41, vC);
                        } else {
                            var vZ = mA["convert"](vd["texture"]["format"]),
                                vm = mA["convert"](vd["texture"]["type"]);
                            vB = mK(vd["texture"]["internalFormat"], vZ, vm);
                            if (vY) (vb = v9(vd)), mN["renderbufferStorageMultisample"](0x8d41, vb, vB, vd["width"], vd["height"]);
                            else mN["renderbufferStorage"](0x8d41, vB, vd["width"], vd["height"]);
                        }
                    }
                    mN["bindRenderbuffer"](0x8d41, null);
                }
                function v8(vC) {
                    var vd = mP["get"](vC),
                        vY = !0x0 === vC["isWebGLCubeRenderTarget"];
                    if (vC["depthTexture"]) {
                        if (vY) throw new Error("target.depthTexture\x20not\x20supported\x20in\x20Cube\x20render\x20targets");
                        !(function (vF, vb) {
                            if (vb && vb["isWebGLCubeRenderTarget"]) throw new Error("Depth\x20Texture\x20with\x20cube\x20render\x20targets\x20is\x20not\x20supported");
                            if ((mN["bindFramebuffer"](0x8d40, vF), !vb["depthTexture"] || !vb["depthTexture"]["isDepthTexture"])) throw new Error("renderTarget.depthTexture\x20must\x20be\x20an\x20instance\x20of\x20THREE.DepthTexture");
                            (mP["get"](vb["depthTexture"])["__webglTexture"] && vb["depthTexture"]["image"]["width"] === vb["width"] && vb["depthTexture"]["image"]["height"] === vb["height"]) ||
                                ((vb["depthTexture"]["image"]["width"] = vb["width"]), (vb["depthTexture"]["image"]["height"] = vb["height"]), (vb["depthTexture"]["needsUpdate"] = !0x0)),
                                mQ(vb["depthTexture"], 0x0);
                            var vZ = mP["get"](vb["depthTexture"])["__webglTexture"];
                            if (vb["depthTexture"]["format"] === rI) mN["framebufferTexture2D"](0x8d40, 0x8d00, 0xde1, vZ, 0x0);
                            else {
                                if (vb["depthTexture"]["format"] !== rA) throw new Error("Unknown\x20depthTexture\x20format");
                                mN["framebufferTexture2D"](0x8d40, 0x821a, 0xde1, vZ, 0x0);
                            }
                        })(vd["__webglFramebuffer"], vC);
                    } else {
                        if (vY) {
                            vd["__webglDepthbuffer"] = [];
                            for (var vB = 0x0; vB < 0x6; vB++) mN["bindFramebuffer"](0x8d40, vd["__webglFramebuffer"][vB]), (vd["__webglDepthbuffer"][vB] = mN["createRenderbuffer"]()), v7(vd["__webglDepthbuffer"][vB], vC, !0x1);
                        } else mN["bindFramebuffer"](0x8d40, vd["__webglFramebuffer"]), (vd["__webglDepthbuffer"] = mN["createRenderbuffer"]()), v7(vd["__webglDepthbuffer"], vC, !0x1);
                    }
                    mN["bindFramebuffer"](0x8d40, null);
                }
                function v9(vC) {
                    return mk && vC["isWebGLMultisampleRenderTarget"] ? Math["min"](mO, vC["samples"]) : 0x0;
                }
                var vE = !0x1,
                    vR = !0x1;
                (this["allocateTextureUnit"] = function () {
                    var vC = mL;
                    return vC >= mU && console["warn"]("THREE.WebGLTextures:\x20Trying\x20to\x20use\x20" + vC + "\x20texture\x20units\x20while\x20this\x20GPU\x20supports\x20only\x20" + mU), (mL += 0x1), vC;
                }),
                    (this["resetTextureUnits"] = function () {
                        mL = 0x0;
                    }),
                    (this["setTexture2D"] = mQ),
                    (this["setTexture2DArray"] = function (vC, vd) {
                        var vY = mP["get"](vC);
                        vC["version"] > 0x0 && vY["__version"] !== vC["version"] ? v5(vY, vC, vd) : (mf["activeTexture"](0x84c0 + vd), mf["bindTexture"](0x8c1a, vY["__webglTexture"]));
                    }),
                    (this["setTexture3D"] = function (vC, vd) {
                        var vY = mP["get"](vC);
                        vC["version"] > 0x0 && vY["__version"] !== vC["version"] ? v5(vY, vC, vd) : (mf["activeTexture"](0x84c0 + vd), mf["bindTexture"](0x806f, vY["__webglTexture"]));
                    }),
                    (this["setTextureCube"] = mz),
                    (this["setTextureCubeDynamic"] = v0),
                    (this["setupRenderTarget"] = function (vC) {
                        var vd = mP["get"](vC),
                            vY = mP["get"](vC["texture"]);
                        vC["addEventListener"]("dispose", mG), (vY["__webglTexture"] = mN["createTexture"]()), mM["memory"]["textures"]++;
                        var vB = !0x0 === vC["isWebGLCubeRenderTarget"],
                            vF = !0x0 === vC["isWebGLMultisampleRenderTarget"],
                            vb = mW(vC) || mk;
                        if (
                            (!mk ||
                                vC["texture"]["format"] !== rX ||
                                (vC["texture"]["type"] !== ry && vC["texture"]["type"] !== rD) ||
                                ((vC["texture"]["format"] = rf), console["warn"]("THREE.WebGLRenderer:\x20Rendering\x20to\x20textures\x20with\x20RGB\x20format\x20is\x20not\x20supported.\x20Using\x20RGBA\x20format\x20instead.")),
                            vB)
                        ) {
                            vd["__webglFramebuffer"] = [];
                            for (var vZ = 0x0; vZ < 0x6; vZ++) vd["__webglFramebuffer"][vZ] = mN["createFramebuffer"]();
                        } else {
                            if (((vd["__webglFramebuffer"] = mN["createFramebuffer"]()), vF)) {
                                if (mk) {
                                    (vd["__webglMultisampledFramebuffer"] = mN["createFramebuffer"]()), (vd["__webglColorRenderbuffer"] = mN["createRenderbuffer"]()), mN["bindRenderbuffer"](0x8d41, vd["__webglColorRenderbuffer"]);
                                    var vm = mA["convert"](vC["texture"]["format"]),
                                        vv = mA["convert"](vC["texture"]["type"]),
                                        vy = mK(vC["texture"]["internalFormat"], vm, vv),
                                        vD = v9(vC);
                                    mN["renderbufferStorageMultisample"](0x8d41, vD, vy, vC["width"], vC["height"]),
                                        mN["bindFramebuffer"](0x8d40, vd["__webglMultisampledFramebuffer"]),
                                        mN["framebufferRenderbuffer"](0x8d40, 0x8ce0, 0x8d41, vd["__webglColorRenderbuffer"]),
                                        mN["bindRenderbuffer"](0x8d41, null),
                                        vC["depthBuffer"] && ((vd["__webglDepthRenderbuffer"] = mN["createRenderbuffer"]()), v7(vd["__webglDepthRenderbuffer"], vC, !0x0)),
                                        mN["bindFramebuffer"](0x8d40, null);
                                } else console["warn"]("THREE.WebGLRenderer:\x20WebGLMultisampleRenderTarget\x20can\x20only\x20be\x20used\x20with\x20WebGL2.");
                            }
                        }
                        if (vB) {
                            mf["bindTexture"](0x8513, vY["__webglTexture"]), v3(0x8513, vC["texture"], vb);
                            for (vZ = 0x0; vZ < 0x6; vZ++) v6(vd["__webglFramebuffer"][vZ], vC, 0x8ce0, 0x8515 + vZ);
                            mH(vC["texture"], vb) && mx(0x8513, vC["texture"], vC["width"], vC["height"]), mf["bindTexture"](0x8513, null);
                        } else
                            mf["bindTexture"](0xde1, vY["__webglTexture"]),
                                v3(0xde1, vC["texture"], vb),
                                v6(vd["__webglFramebuffer"], vC, 0x8ce0, 0xde1),
                                mH(vC["texture"], vb) && mx(0xde1, vC["texture"], vC["width"], vC["height"]),
                                mf["bindTexture"](0xde1, null);
                        vC["depthBuffer"] && v8(vC);
                    }),
                    (this["updateRenderTargetMipmap"] = function (vC) {
                        var vd = vC["texture"];
                        if (mH(vd, mW(vC) || mk)) {
                            var vY = vC["isWebGLCubeRenderTarget"] ? 0x8513 : 0xde1,
                                vB = mP["get"](vd)["__webglTexture"];
                            mf["bindTexture"](vY, vB), mx(vY, vd, vC["width"], vC["height"]), mf["bindTexture"](vY, null);
                        }
                    }),
                    (this["updateMultisampleRenderTarget"] = function (vC) {
                        if (vC["isWebGLMultisampleRenderTarget"]) {
                            if (mk) {
                                var vd = mP["get"](vC);
                                mN["bindFramebuffer"](0x8ca8, vd["__webglMultisampledFramebuffer"]), mN["bindFramebuffer"](0x8ca9, vd["__webglFramebuffer"]);
                                var vY = vC["width"],
                                    vB = vC["height"],
                                    vF = 0x4000;
                                vC["depthBuffer"] && (vF |= 0x100),
                                    vC["stencilBuffer"] && (vF |= 0x400),
                                    mN["blitFramebuffer"](0x0, 0x0, vY, vB, 0x0, 0x0, vY, vB, vF, 0x2600),
                                    mN["bindFramebuffer"](0x8d40, vd["__webglMultisampledFramebuffer"]);
                            } else console["warn"]("THREE.WebGLRenderer:\x20WebGLMultisampleRenderTarget\x20can\x20only\x20be\x20used\x20with\x20WebGL2.");
                        }
                    }),
                    (this["safeSetTexture2D"] = function (vC, vd) {
                        vC &&
                            vC["isWebGLRenderTarget"] &&
                            (!0x1 === vE && (console["warn"]("THREE.WebGLTextures.safeSetTexture2D:\x20don\x27t\x20use\x20render\x20targets\x20as\x20textures.\x20Use\x20their\x20.texture\x20property\x20instead."), (vE = !0x0)),
                            (vC = vC["texture"])),
                            mQ(vC, vd);
                    }),
                    (this["safeSetTextureCube"] = function (vC, vd) {
                        vC &&
                            vC["isWebGLCubeRenderTarget"] &&
                            (!0x1 === vR && (console["warn"]("THREE.WebGLTextures.safeSetTextureCube:\x20don\x27t\x20use\x20cube\x20render\x20targets\x20as\x20textures.\x20Use\x20their\x20.texture\x20property\x20instead."), (vR = !0x0)),
                            (vC = vC["texture"])),
                            (vC && vC["isCubeTexture"]) || (Array["isArray"](vC["image"]) && 0x6 === vC["image"]["length"]) ? mz(vC, vd) : v0(vC, vd);
                    });
            }
            function Y4(mN, mX, mf) {
                var mP = mf["isWebGL2"];
                return {
                    convert: function (mI) {
                        var mA;
                        if (mI === rZ) return 0x1401;
                        if (0x3f9 === mI) return 0x8033;
                        if (0x3fa === mI) return 0x8034;
                        if (0x3fb === mI) return 0x8363;
                        if (0x3f2 === mI) return 0x1400;
                        if (0x3f3 === mI) return 0x1402;
                        if (mI === rm) return 0x1403;
                        if (0x3f5 === mI) return 0x1404;
                        if (mI === rv) return 0x1405;
                        if (mI === ry) return 0x1406;
                        if (mI === rD) return mP ? 0x140b : null !== (mA = mX["get"]("OES_texture_half_float")) ? mA["HALF_FLOAT_OES"] : null;
                        if (0x3fd === mI) return 0x1906;
                        if (mI === rX) return 0x1907;
                        if (mI === rf) return 0x1908;
                        if (0x400 === mI) return 0x1909;
                        if (0x401 === mI) return 0x190a;
                        if (mI === rI) return 0x1902;
                        if (mI === rA) return 0x84f9;
                        if (0x404 === mI) return 0x1903;
                        if (0x405 === mI) return 0x8d94;
                        if (0x406 === mI) return 0x8227;
                        if (0x407 === mI) return 0x8228;
                        if (0x408 === mI) return 0x8d98;
                        if (0x409 === mI) return 0x8d99;
                        if (0x83f0 === mI || 0x83f1 === mI || 0x83f2 === mI || 0x83f3 === mI) {
                            if (null === (mA = mX["get"]("WEBGL_compressed_texture_s3tc"))) return null;
                            if (0x83f0 === mI) return mA["COMPRESSED_RGB_S3TC_DXT1_EXT"];
                            if (0x83f1 === mI) return mA["COMPRESSED_RGBA_S3TC_DXT1_EXT"];
                            if (0x83f2 === mI) return mA["COMPRESSED_RGBA_S3TC_DXT3_EXT"];
                            if (0x83f3 === mI) return mA["COMPRESSED_RGBA_S3TC_DXT5_EXT"];
                        }
                        if (0x8c00 === mI || 0x8c01 === mI || 0x8c02 === mI || 0x8c03 === mI) {
                            if (null === (mA = mX["get"]("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (0x8c00 === mI) return mA["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"];
                            if (0x8c01 === mI) return mA["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"];
                            if (0x8c02 === mI) return mA["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"];
                            if (0x8c03 === mI) return mA["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"];
                        }
                        if (0x8d64 === mI) return null !== (mA = mX["get"]("WEBGL_compressed_texture_etc1")) ? mA["COMPRESSED_RGB_ETC1_WEBGL"] : null;
                        if ((0x9274 === mI || 0x9278 === mI) && null !== (mA = mX["get"]("WEBGL_compressed_texture_etc"))) {
                            if (0x9274 === mI) return mA["COMPRESSED_RGB8_ETC2"];
                            if (0x9278 === mI) return mA["COMPRESSED_RGBA8_ETC2_EAC"];
                        }
                        return 0x93b0 === mI ||
                            0x93b1 === mI ||
                            0x93b2 === mI ||
                            0x93b3 === mI ||
                            0x93b4 === mI ||
                            0x93b5 === mI ||
                            0x93b6 === mI ||
                            0x93b7 === mI ||
                            0x93b8 === mI ||
                            0x93b9 === mI ||
                            0x93ba === mI ||
                            0x93bb === mI ||
                            0x93bc === mI ||
                            0x93bd === mI ||
                            0x93d0 === mI ||
                            0x93d1 === mI ||
                            0x93d2 === mI ||
                            0x93d3 === mI ||
                            0x93d4 === mI ||
                            0x93d5 === mI ||
                            0x93d6 === mI ||
                            0x93d7 === mI ||
                            0x93d8 === mI ||
                            0x93d9 === mI ||
                            0x93da === mI ||
                            0x93db === mI ||
                            0x93dc === mI ||
                            0x93dd === mI
                            ? null !== (mA = mX["get"]("WEBGL_compressed_texture_astc"))
                                ? mI
                                : null
                            : 0x8e8c === mI
                            ? null !== (mA = mX["get"]("EXT_texture_compression_bptc"))
                                ? mI
                                : null
                            : mI === rN
                            ? mP
                                ? 0x84fa
                                : null !== (mA = mX["get"]("WEBGL_depth_texture"))
                                ? mA["UNSIGNED_INT_24_8_WEBGL"]
                                : null
                            : void 0x0;
                    },
                };
            }
            function Y5(mN) {
                Tx["call"](this), (this["cameras"] = mN || []);
            }
            function Y6() {
                Eg["call"](this), (this["type"] = "Group");
            }
            function Y7() {
                (this["_targetRay"] = null), (this["_grip"] = null);
            }
            function Y8(mN, mX) {
                var mf = this,
                    mP = null,
                    mI = 0x1,
                    mA = null,
                    mM = "local-floor",
                    mp = null,
                    mk = [],
                    mU = new Map(),
                    mq = new Tx();
                mq["layers"]["enable"](0x1), (mq["viewport"] = new E8());
                var mw = new Tx();
                mw["layers"]["enable"](0x2), (mw["viewport"] = new E8());
                var mO = [mq, mw],
                    mj = new Y5();
                mj["layers"]["enable"](0x1), mj["layers"]["enable"](0x2);
                var mh = null,
                    mS = null;
                function mg(mQ) {
                    var mz = mU["get"](mQ["inputSource"]);
                    mz && mz["dispatchEvent"]({ type: mQ["type"] });
                }
                function mW() {
                    mU["forEach"](function (mQ, mz) {
                        mQ["disconnect"](mz);
                    }),
                        mU["clear"](),
                        mN["setFramebuffer"](null),
                        mN["setRenderTarget"](mN["getRenderTarget"]()),
                        mL["stop"](),
                        (mf["isPresenting"] = !0x1),
                        mf["dispatchEvent"]({ type: "sessionend" });
                }
                function mH(mQ) {
                    (mA = mQ), mL["setContext"](mP), mL["start"](), (mf["isPresenting"] = !0x0), mf["dispatchEvent"]({ type: "sessionstart" });
                }
                function mx(mQ) {
                    for (var mz = mP["inputSources"], v0 = 0x0; v0 < mk["length"]; v0++) mU["set"](mz[v0], mk[v0]);
                    for (v0 = 0x0; v0 < mQ["removed"]["length"]; v0++) {
                        var v1 = mQ["removed"][v0];
                        (v2 = mU["get"](v1)) && (v2["dispatchEvent"]({ type: "disconnected", data: v1 }), mU["delete"](v1));
                    }
                    for (v0 = 0x0; v0 < mQ["added"]["length"]; v0++) {
                        var v2;
                        (v1 = mQ["added"][v0]), (v2 = mU["get"](v1)) && v2["dispatchEvent"]({ type: "connected", data: v1 });
                    }
                }
                (this["enabled"] = !0x1),
                    (this["isPresenting"] = !0x1),
                    (this["getController"] = function (mQ) {
                        var mz = mk[mQ];
                        return void 0x0 === mz && ((mz = new Y7()), (mk[mQ] = mz)), mz["getTargetRaySpace"]();
                    }),
                    (this["getControllerGrip"] = function (mQ) {
                        var mz = mk[mQ];
                        return void 0x0 === mz && ((mz = new Y7()), (mk[mQ] = mz)), mz["getGripSpace"]();
                    }),
                    (this["setFramebufferScaleFactor"] = function (mQ) {
                        (mI = mQ), !0x0 === mf["isPresenting"] && console["warn"]("THREE.WebXRManager:\x20Cannot\x20change\x20framebuffer\x20scale\x20while\x20presenting.");
                    }),
                    (this["setReferenceSpaceType"] = function (mQ) {
                        (mM = mQ), !0x0 === mf["isPresenting"] && console["warn"]("THREE.WebXRManager:\x20Cannot\x20change\x20reference\x20space\x20type\x20while\x20presenting.");
                    }),
                    (this["getReferenceSpace"] = function () {
                        return mA;
                    }),
                    (this["getSession"] = function () {
                        return mP;
                    }),
                    (this["setSession"] = function (mQ) {
                        if (null !== (mP = mQ)) {
                            mP["addEventListener"]("select", mg),
                                mP["addEventListener"]("selectstart", mg),
                                mP["addEventListener"]("selectend", mg),
                                mP["addEventListener"]("squeeze", mg),
                                mP["addEventListener"]("squeezestart", mg),
                                mP["addEventListener"]("squeezeend", mg),
                                mP["addEventListener"]("end", mW);
                            var mz = mX["getContextAttributes"]();
                            !0x0 !== mz["xrCompatible"] && mX["makeXRCompatible"]();
                            var v0 = { antialias: mz["antialias"], alpha: mz["alpha"], depth: mz["depth"], stencil: mz["stencil"], framebufferScaleFactor: mI },
                                v1 = new XRWebGLLayer(mP, mX, v0);
                            mP["updateRenderState"]({ baseLayer: v1 }), mP["requestReferenceSpace"](mM)["then"](mH), mP["addEventListener"]("inputsourceschange", mx);
                        }
                    });
                var mK = new Ed(),
                    mV = new Ed();
                function mJ(mQ, mz) {
                    null === mz ? mQ["matrixWorld"]["copy"](mQ["matrix"]) : mQ["matrixWorld"]["multiplyMatrices"](mz["matrixWorld"], mQ["matrix"]), mQ["matrixWorldInverse"]["getInverse"](mQ["matrixWorld"]);
                }
                this["getCamera"] = function (mQ) {
                    (mj["near"] = mw["near"] = mq["near"] = mQ["near"]),
                        (mj["far"] = mw["far"] = mq["far"] = mQ["far"]),
                        (mh === mj["near"] && mS === mj["far"]) || (mP["updateRenderState"]({ depthNear: mj["near"], depthFar: mj["far"] }), (mh = mj["near"]), (mS = mj["far"]));
                    var mz = mQ["parent"],
                        v0 = mj["cameras"];
                    mJ(mj, mz);
                    for (var v1 = 0x0; v1 < v0["length"]; v1++) mJ(v0[v1], mz);
                    mQ["matrixWorld"]["copy"](mj["matrixWorld"]);
                    for (var v2 = mQ["children"], v3 = ((v1 = 0x0), v2["length"]); v1 < v3; v1++) v2[v1]["updateMatrixWorld"](!0x0);
                    return (
                        0x2 === v0["length"]
                            ? (function (v4, v5, v6) {
                                  mK["setFromMatrixPosition"](v5["matrixWorld"]), mV["setFromMatrixPosition"](v6["matrixWorld"]);
                                  var v7 = mK["distanceTo"](mV),
                                      v8 = v5["projectionMatrix"]["elements"],
                                      v9 = v6["projectionMatrix"]["elements"],
                                      vE = v8[0xe] / (v8[0xa] - 0x1),
                                      vR = v8[0xe] / (v8[0xa] + 0x1),
                                      vT = (v8[0x9] + 0x1) / v8[0x5],
                                      vC = (v8[0x9] - 0x1) / v8[0x5],
                                      vd = (v8[0x8] - 0x1) / v8[0x0],
                                      vY = (v9[0x8] + 0x1) / v9[0x0],
                                      vB = vE * vd,
                                      vF = vE * vY,
                                      vb = v7 / (-vd + vY),
                                      vZ = vb * -vd;
                                  v5["matrixWorld"]["decompose"](v4["position"], v4["quaternion"], v4["scale"]),
                                      v4["translateX"](vZ),
                                      v4["translateZ"](vb),
                                      v4["matrixWorld"]["compose"](v4["position"], v4["quaternion"], v4["scale"]),
                                      v4["matrixWorldInverse"]["getInverse"](v4["matrixWorld"]);
                                  var vm = vE + vb,
                                      vv = vR + vb,
                                      vy = vB - vZ,
                                      vD = vF + (v7 - vZ),
                                      vN = ((vT * vR) / vv) * vm,
                                      vX = ((vC * vR) / vv) * vm;
                                  v4["projectionMatrix"]["makePerspective"](vy, vD, vN, vX, vm, vv);
                              })(mj, mq, mw)
                            : mj["projectionMatrix"]["copy"](mq["projectionMatrix"]),
                        mj
                    );
                };
                var mG = null,
                    mL = new C1();
                mL["setAnimationLoop"](function (mQ, mz) {
                    if (null !== (mp = mz["getViewerPose"](mA))) {
                        var v0 = mp["views"],
                            v1 = mP["renderState"]["baseLayer"];
                        mN["setFramebuffer"](v1["framebuffer"]);
                        var v2 = !0x1;
                        v0["length"] !== mj["cameras"]["length"] && ((mj["cameras"]["length"] = 0x0), (v2 = !0x0));
                        for (var v3 = 0x0; v3 < v0["length"]; v3++) {
                            var v4 = v0[v3],
                                v5 = v1["getViewport"](v4),
                                v6 = mO[v3];
                            v6["matrix"]["fromArray"](v4["transform"]["matrix"]),
                                v6["projectionMatrix"]["fromArray"](v4["projectionMatrix"]),
                                v6["viewport"]["set"](v5["x"], v5["y"], v5["width"], v5["height"]),
                                0x0 === v3 && mj["matrix"]["copy"](v6["matrix"]),
                                !0x0 === v2 && mj["cameras"]["push"](v6);
                        }
                    }
                    var v7 = mP["inputSources"];
                    for (v3 = 0x0; v3 < mk["length"]; v3++) {
                        var v8 = mk[v3],
                            v9 = v7[v3];
                        v8["update"](v9, mz, mA);
                    }
                    mG && mG(mQ, mz);
                }),
                    (this["setAnimationLoop"] = function (mQ) {
                        mG = mQ;
                    }),
                    (this["dispose"] = function () {});
            }
            function Y9(mN) {
                function mX(mP, mI, mA) {
                    (mP["opacity"]["value"] = mI["opacity"]),
                        mI["color"] && mP["diffuse"]["value"]["copy"](mI["color"]),
                        mI["emissive"] && mP["emissive"]["value"]["copy"](mI["emissive"])["multiplyScalar"](mI["emissiveIntensity"]),
                        mI["map"] && (mP["map"]["value"] = mI["map"]),
                        mI["alphaMap"] && (mP["alphaMap"]["value"] = mI["alphaMap"]),
                        mI["specularMap"] && (mP["specularMap"]["value"] = mI["specularMap"]);
                    var mM,
                        mp,
                        mk = mI["envMap"] || mA;
                    mk &&
                        ((mP["envMap"]["value"] = mk),
                        (mP["flipEnvMap"]["value"] = mk["isCubeTexture"] ? -0x1 : 0x1),
                        (mP["reflectivity"]["value"] = mI["reflectivity"]),
                        (mP["refractionRatio"]["value"] = mI["refractionRatio"]),
                        (mP["maxMipLevel"]["value"] = mN["get"](mk)["__maxMipLevel"])),
                        mI["lightMap"] && ((mP["lightMap"]["value"] = mI["lightMap"]), (mP["lightMapIntensity"]["value"] = mI["lightMapIntensity"])),
                        mI["aoMap"] && ((mP["aoMap"]["value"] = mI["aoMap"]), (mP["aoMapIntensity"]["value"] = mI["aoMapIntensity"])),
                        mI["map"]
                            ? (mM = mI["map"])
                            : mI["specularMap"]
                            ? (mM = mI["specularMap"])
                            : mI["displacementMap"]
                            ? (mM = mI["displacementMap"])
                            : mI["normalMap"]
                            ? (mM = mI["normalMap"])
                            : mI["bumpMap"]
                            ? (mM = mI["bumpMap"])
                            : mI["roughnessMap"]
                            ? (mM = mI["roughnessMap"])
                            : mI["metalnessMap"]
                            ? (mM = mI["metalnessMap"])
                            : mI["alphaMap"]
                            ? (mM = mI["alphaMap"])
                            : mI["emissiveMap"] && (mM = mI["emissiveMap"]),
                        void 0x0 !== mM && (mM["isWebGLRenderTarget"] && (mM = mM["texture"]), !0x0 === mM["matrixAutoUpdate"] && mM["updateMatrix"](), mP["uvTransform"]["value"]["copy"](mM["matrix"])),
                        mI["aoMap"] ? (mp = mI["aoMap"]) : mI["lightMap"] && (mp = mI["lightMap"]),
                        void 0x0 !== mp && (mp["isWebGLRenderTarget"] && (mp = mp["texture"]), !0x0 === mp["matrixAutoUpdate"] && mp["updateMatrix"](), mP["uv2Transform"]["value"]["copy"](mp["matrix"]));
                }
                function mf(mP, mI, mA) {
                    (mP["roughness"]["value"] = mI["roughness"]),
                        (mP["metalness"]["value"] = mI["metalness"]),
                        mI["roughnessMap"] && (mP["roughnessMap"]["value"] = mI["roughnessMap"]),
                        mI["metalnessMap"] && (mP["metalnessMap"]["value"] = mI["metalnessMap"]),
                        mI["emissiveMap"] && (mP["emissiveMap"]["value"] = mI["emissiveMap"]),
                        mI["bumpMap"] && ((mP["bumpMap"]["value"] = mI["bumpMap"]), (mP["bumpScale"]["value"] = mI["bumpScale"]), 0x1 === mI["side"] && (mP["bumpScale"]["value"] *= -0x1)),
                        mI["normalMap"] && ((mP["normalMap"]["value"] = mI["normalMap"]), mP["normalScale"]["value"]["copy"](mI["normalScale"]), 0x1 === mI["side"] && mP["normalScale"]["value"]["negate"]()),
                        mI["displacementMap"] && ((mP["displacementMap"]["value"] = mI["displacementMap"]), (mP["displacementScale"]["value"] = mI["displacementScale"]), (mP["displacementBias"]["value"] = mI["displacementBias"])),
                        (mI["envMap"] || mA) && (mP["envMapIntensity"]["value"] = mI["envMapIntensity"]);
                }
                return {
                    refreshFogUniforms: function (mP, mI) {
                        mP["fogColor"]["value"]["copy"](mI["color"]), mI["isFog"] ? ((mP["fogNear"]["value"] = mI["near"]), (mP["fogFar"]["value"] = mI["far"])) : mI["isFogExp2"] && (mP["fogDensity"]["value"] = mI["density"]);
                    },
                    refreshMaterialUniforms: function (mP, mI, mA, mM, mp) {
                        mI["isMeshBasicMaterial"]
                            ? mX(mP, mI)
                            : mI["isMeshLambertMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mU["emissiveMap"] && (mk["emissiveMap"]["value"] = mU["emissiveMap"]);
                              })(mP, mI))
                            : mI["isMeshToonMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mk["specular"]["value"]["copy"](mU["specular"]),
                                      (mk["shininess"]["value"] = Math["max"](mU["shininess"], 0.0001)),
                                      mU["gradientMap"] && (mk["gradientMap"]["value"] = mU["gradientMap"]),
                                      mU["emissiveMap"] && (mk["emissiveMap"]["value"] = mU["emissiveMap"]),
                                      mU["bumpMap"] && ((mk["bumpMap"]["value"] = mU["bumpMap"]), (mk["bumpScale"]["value"] = mU["bumpScale"]), 0x1 === mU["side"] && (mk["bumpScale"]["value"] *= -0x1)),
                                      mU["normalMap"] && ((mk["normalMap"]["value"] = mU["normalMap"]), mk["normalScale"]["value"]["copy"](mU["normalScale"]), 0x1 === mU["side"] && mk["normalScale"]["value"]["negate"]()),
                                      mU["displacementMap"] &&
                                          ((mk["displacementMap"]["value"] = mU["displacementMap"]), (mk["displacementScale"]["value"] = mU["displacementScale"]), (mk["displacementBias"]["value"] = mU["displacementBias"]));
                              })(mP, mI))
                            : mI["isMeshPhongMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mk["specular"]["value"]["copy"](mU["specular"]),
                                      (mk["shininess"]["value"] = Math["max"](mU["shininess"], 0.0001)),
                                      mU["emissiveMap"] && (mk["emissiveMap"]["value"] = mU["emissiveMap"]),
                                      mU["bumpMap"] && ((mk["bumpMap"]["value"] = mU["bumpMap"]), (mk["bumpScale"]["value"] = mU["bumpScale"]), 0x1 === mU["side"] && (mk["bumpScale"]["value"] *= -0x1)),
                                      mU["normalMap"] && ((mk["normalMap"]["value"] = mU["normalMap"]), mk["normalScale"]["value"]["copy"](mU["normalScale"]), 0x1 === mU["side"] && mk["normalScale"]["value"]["negate"]()),
                                      mU["displacementMap"] &&
                                          ((mk["displacementMap"]["value"] = mU["displacementMap"]), (mk["displacementScale"]["value"] = mU["displacementScale"]), (mk["displacementBias"]["value"] = mU["displacementBias"]));
                              })(mP, mI))
                            : mI["isMeshStandardMaterial"]
                            ? (mX(mP, mI, mA),
                              mI["isMeshPhysicalMaterial"]
                                  ? (function (mk, mU, mq) {
                                        mf(mk, mU, mq),
                                            (mk["reflectivity"]["value"] = mU["reflectivity"]),
                                            (mk["clearcoat"]["value"] = mU["clearcoat"]),
                                            (mk["clearcoatRoughness"]["value"] = mU["clearcoatRoughness"]),
                                            mU["sheen"] && mk["sheen"]["value"]["copy"](mU["sheen"]),
                                            mU["clearcoatMap"] && (mk["clearcoatMap"]["value"] = mU["clearcoatMap"]),
                                            mU["clearcoatRoughnessMap"] && (mk["clearcoatRoughnessMap"]["value"] = mU["clearcoatRoughnessMap"]),
                                            mU["clearcoatNormalMap"] &&
                                                (mk["clearcoatNormalScale"]["value"]["copy"](mU["clearcoatNormalScale"]),
                                                (mk["clearcoatNormalMap"]["value"] = mU["clearcoatNormalMap"]),
                                                0x1 === mU["side"] && mk["clearcoatNormalScale"]["value"]["negate"]()),
                                            (mk["transparency"]["value"] = mU["transparency"]);
                                    })(mP, mI, mA)
                                  : mf(mP, mI, mA))
                            : mI["isMeshMatcapMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mU["matcap"] && (mk["matcap"]["value"] = mU["matcap"]),
                                      mU["bumpMap"] && ((mk["bumpMap"]["value"] = mU["bumpMap"]), (mk["bumpScale"]["value"] = mU["bumpScale"]), 0x1 === mU["side"] && (mk["bumpScale"]["value"] *= -0x1)),
                                      mU["normalMap"] && ((mk["normalMap"]["value"] = mU["normalMap"]), mk["normalScale"]["value"]["copy"](mU["normalScale"]), 0x1 === mU["side"] && mk["normalScale"]["value"]["negate"]()),
                                      mU["displacementMap"] &&
                                          ((mk["displacementMap"]["value"] = mU["displacementMap"]), (mk["displacementScale"]["value"] = mU["displacementScale"]), (mk["displacementBias"]["value"] = mU["displacementBias"]));
                              })(mP, mI))
                            : mI["isMeshDepthMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mU["displacementMap"] && ((mk["displacementMap"]["value"] = mU["displacementMap"]), (mk["displacementScale"]["value"] = mU["displacementScale"]), (mk["displacementBias"]["value"] = mU["displacementBias"]));
                              })(mP, mI))
                            : mI["isMeshDistanceMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mU["displacementMap"] && ((mk["displacementMap"]["value"] = mU["displacementMap"]), (mk["displacementScale"]["value"] = mU["displacementScale"]), (mk["displacementBias"]["value"] = mU["displacementBias"])),
                                      (mk["referencePosition"]["value"]["copy"](mU["referencePosition"]), (mk["nearDistance"]["value"] = mU["nearDistance"]), (mk["farDistance"]["value"] = mU["farDistance"]));
                              })(mP, mI))
                            : mI["isMeshNormalMaterial"]
                            ? (mX(mP, mI),
                              (function (mk, mU) {
                                  mU["bumpMap"] && ((mk["bumpMap"]["value"] = mU["bumpMap"]), (mk["bumpScale"]["value"] = mU["bumpScale"]), 0x1 === mU["side"] && (mk["bumpScale"]["value"] *= -0x1)),
                                      mU["normalMap"] && ((mk["normalMap"]["value"] = mU["normalMap"]), mk["normalScale"]["value"]["copy"](mU["normalScale"]), 0x1 === mU["side"] && mk["normalScale"]["value"]["negate"]()),
                                      mU["displacementMap"] &&
                                          ((mk["displacementMap"]["value"] = mU["displacementMap"]), (mk["displacementScale"]["value"] = mU["displacementScale"]), (mk["displacementBias"]["value"] = mU["displacementBias"]));
                              })(mP, mI))
                            : mI["isLineBasicMaterial"]
                            ? ((function (mk, mU) {
                                  mk["diffuse"]["value"]["copy"](mU["color"]), (mk["opacity"]["value"] = mU["opacity"]);
                              })(mP, mI),
                              mI["isLineDashedMaterial"] &&
                                  (function (mk, mU) {
                                      (mk["dashSize"]["value"] = mU["dashSize"]), (mk["totalSize"]["value"] = mU["dashSize"] + mU["gapSize"]), (mk["scale"]["value"] = mU["scale"]);
                                  })(mP, mI))
                            : mI["isPointsMaterial"]
                            ? (function (mk, mU, mq, mw) {
                                  mk["diffuse"]["value"]["copy"](mU["color"]),
                                      (mk["opacity"]["value"] = mU["opacity"]),
                                      (mk["size"]["value"] = mU["size"] * mq),
                                      (mk["scale"]["value"] = 0.5 * mw),
                                      mU["map"] && (mk["map"]["value"] = mU["map"]),
                                      mU["alphaMap"] && (mk["alphaMap"]["value"] = mU["alphaMap"]);
                                  var mO;
                                  mU["map"] ? (mO = mU["map"]) : mU["alphaMap"] && (mO = mU["alphaMap"]), void 0x0 !== mO && (!0x0 === mO["matrixAutoUpdate"] && mO["updateMatrix"](), mk["uvTransform"]["value"]["copy"](mO["matrix"]));
                              })(mP, mI, mM, mp)
                            : mI["isSpriteMaterial"]
                            ? (function (mk, mU) {
                                  mk["diffuse"]["value"]["copy"](mU["color"]),
                                      (mk["opacity"]["value"] = mU["opacity"]),
                                      (mk["rotation"]["value"] = mU["rotation"]),
                                      mU["map"] && (mk["map"]["value"] = mU["map"]),
                                      mU["alphaMap"] && (mk["alphaMap"]["value"] = mU["alphaMap"]);
                                  var mq;
                                  mU["map"] ? (mq = mU["map"]) : mU["alphaMap"] && (mq = mU["alphaMap"]), void 0x0 !== mq && (!0x0 === mq["matrixAutoUpdate"] && mq["updateMatrix"](), mk["uvTransform"]["value"]["copy"](mq["matrix"]));
                              })(mP, mI)
                            : mI["isShadowMaterial"]
                            ? (mP["color"]["value"]["copy"](mI["color"]), (mP["opacity"]["value"] = mI["opacity"]))
                            : mI["isShaderMaterial"] && (mI["uniformsNeedUpdate"] = !0x1);
                    },
                };
            }
            function YE(mN) {
                var mX = void 0x0 !== (mN = mN || {})["canvas"] ? mN["canvas"] : document["createElementNS"]("http://www.w3.org/1999/xhtml", "canvas"),
                    mf = void 0x0 !== mN["context"] ? mN["context"] : null,
                    mP = void 0x0 !== mN["alpha"] && mN["alpha"],
                    mI = void 0x0 === mN["depth"] || mN["depth"],
                    mA = void 0x0 === mN["stencil"] || mN["stencil"],
                    mM = void 0x0 !== mN["antialias"] && mN["antialias"],
                    mp = void 0x0 === mN["premultipliedAlpha"] || mN["premultipliedAlpha"],
                    mk = void 0x0 !== mN["preserveDrawingBuffer"] && mN["preserveDrawingBuffer"],
                    mU = void 0x0 !== mN["powerPreference"] ? mN["powerPreference"] : "default",
                    mq = void 0x0 !== mN["failIfMajorPerformanceCaveat"] && mN["failIfMajorPerformanceCaveat"],
                    mw = null,
                    mO = null;
                (this["domElement"] = mX),
                    (this["debug"] = { checkShaderErrors: !0x0 }),
                    (this["autoClear"] = !0x0),
                    (this["autoClearColor"] = !0x0),
                    (this["autoClearDepth"] = !0x0),
                    (this["autoClearStencil"] = !0x0),
                    (this["sortObjects"] = !0x0),
                    (this["clippingPlanes"] = []),
                    (this["localClippingEnabled"] = !0x1),
                    (this["gammaFactor"] = 0x2),
                    (this["outputEncoding"] = rW),
                    (this["physicallyCorrectLights"] = !0x1),
                    (this["toneMapping"] = 0x0),
                    (this["toneMappingExposure"] = 0x1),
                    (this["toneMappingWhitePoint"] = 0x1),
                    (this["maxMorphTargets"] = 0x8),
                    (this["maxMorphNormals"] = 0x4);
                var mj,
                    mh,
                    mS,
                    mg,
                    mW,
                    mH,
                    mx,
                    mK,
                    mV,
                    mJ,
                    mG,
                    mL,
                    mQ,
                    mz,
                    v0,
                    v1,
                    v2,
                    v3,
                    v4,
                    v5 = this,
                    v6 = !0x1,
                    v7 = null,
                    v8 = 0x0,
                    v9 = 0x0,
                    vE = null,
                    vR = null,
                    vT = -0x1,
                    vC = { geometry: null, program: null, wireframe: !0x1 },
                    vd = null,
                    vY = null,
                    vB = new E8(),
                    vF = new E8(),
                    vb = null,
                    vZ = mX["width"],
                    vm = mX["height"],
                    vv = 0x1,
                    vy = null,
                    vD = null,
                    vN = new E8(0x0, 0x0, vZ, vm),
                    vX = new E8(0x0, 0x0, vZ, vm),
                    vf = !0x1,
                    vP = new Tz(),
                    vI = new CE(),
                    vA = !0x1,
                    vM = !0x1,
                    vp = new Ey(),
                    vk = new Ed();
                function vU() {
                    return null === vE ? vv : 0x1;
                }
                try {
                    var vq = { alpha: mP, depth: mI, stencil: mA, antialias: mM, premultipliedAlpha: mp, preserveDrawingBuffer: mk, powerPreference: mU, failIfMajorPerformanceCaveat: mq };
                    if ((mX["addEventListener"]("webglcontextlost", vh, !0x1), mX["addEventListener"]("webglcontextrestored", vS, !0x1), null === (mj = mf || mX["getContext"]("webgl", vq) || mX["getContext"]("experimental-webgl", vq))))
                        throw null !== mX["getContext"]("webgl") ? new Error("Error\x20creating\x20WebGL\x20context\x20with\x20your\x20selected\x20attributes.") : new Error("Error\x20creating\x20WebGL\x20context.");
                    void 0x0 === mj["getShaderPrecisionFormat"] &&
                        (mj["getShaderPrecisionFormat"] = function () {
                            return { rangeMin: 0x1, rangeMax: 0x1, precision: 0x1 };
                        });
                } catch (vz) {
                    throw (console["error"]("THREE.WebGLRenderer:\x20" + vz["message"]), vz);
                }
                function vw() {
                    (mh = new CR(mj)),
                        !0x1 === (mS = new C9(mj, mh, mN))["isWebGL2"] &&
                            (mh["get"]("WEBGL_depth_texture"),
                            mh["get"]("OES_texture_float"),
                            mh["get"]("OES_texture_half_float"),
                            mh["get"]("OES_texture_half_float_linear"),
                            mh["get"]("OES_standard_derivatives"),
                            mh["get"]("OES_element_index_uint"),
                            mh["get"]("ANGLE_instanced_arrays")),
                        mh["get"]("OES_texture_float_linear"),
                        (v4 = new Y4(mj, mh, mS)),
                        (mg = new Y2(mj, mh, mS))["scissor"](vF["copy"](vX)["multiplyScalar"](vv)["floor"]()),
                        mg["viewport"](vB["copy"](vN)["multiplyScalar"](vv)["floor"]()),
                        (mW = new Cd(mj)),
                        (mH = new dS()),
                        (mx = new Y3(mj, mh, mg, mH, mS, v4, mW)),
                        (mK = new C2(mj, mS)),
                        (mV = new CT(mj, mK, mW)),
                        (mJ = new CF(mj, mV, mK, mW)),
                        (v1 = new CB(mj)),
                        (mG = new dh(v5, mh, mS)),
                        (mL = new Y9(mH)),
                        (mQ = new dx()),
                        (mz = new dQ()),
                        (v0 = new C7(v5, mg, mJ, mp)),
                        (v2 = new C8(mj, mh, mW, mS)),
                        (v3 = new CC(mj, mh, mW, mS)),
                        (mW["programs"] = mG["programs"]),
                        (v5["capabilities"] = mS),
                        (v5["extensions"] = mh),
                        (v5["properties"] = mH),
                        (v5["renderLists"] = mQ),
                        (v5["state"] = mg),
                        (v5["info"] = mW);
                }
                vw();
                var vO = new Y8(v5, mj);
                this["xr"] = vO;
                var vj = new Y1(v5, mJ, mS["maxTextureSize"]);
                function vh(u0) {
                    u0["preventDefault"](), console["log"]("THREE.WebGLRenderer:\x20Context\x20Lost."), (v6 = !0x0);
                }
                function vS() {
                    console["log"]("THREE.WebGLRenderer:\x20Context\x20Restored."), (v6 = !0x1), vw();
                }
                function vg(u0) {
                    var u1 = u0["target"];
                    u1["removeEventListener"]("dispose", vg),
                        (function (u2) {
                            vW(u2), mH["remove"](u2);
                        })(u1);
                }
                function vW(u0) {
                    var u1 = mH["get"](u0)["program"];
                    (u0["program"] = void 0x0), void 0x0 !== u1 && mG["releaseProgram"](u1);
                }
                (this["shadowMap"] = vj),
                    (this["getContext"] = function () {
                        return mj;
                    }),
                    (this["getContextAttributes"] = function () {
                        return mj["getContextAttributes"]();
                    }),
                    (this["forceContextLoss"] = function () {
                        var u0 = mh["get"]("WEBGL_lose_context");
                        u0 && u0["loseContext"]();
                    }),
                    (this["forceContextRestore"] = function () {
                        var u0 = mh["get"]("WEBGL_lose_context");
                        u0 && u0["restoreContext"]();
                    }),
                    (this["getPixelRatio"] = function () {
                        return vv;
                    }),
                    (this["setPixelRatio"] = function (u0) {
                        void 0x0 !== u0 && ((vv = u0), this["setSize"](vZ, vm, !0x1));
                    }),
                    (this["getSize"] = function (u0) {
                        return void 0x0 === u0 && (console["warn"]("WebGLRenderer:\x20.getsize()\x20now\x20requires\x20a\x20Vector2\x20as\x20an\x20argument"), (u0 = new E3())), u0["set"](vZ, vm);
                    }),
                    (this["setSize"] = function (u0, u1, u2) {
                        vO["isPresenting"]
                            ? console["warn"]("THREE.WebGLRenderer:\x20Can\x27t\x20change\x20size\x20while\x20VR\x20device\x20is\x20presenting.")
                            : ((vZ = u0),
                              (vm = u1),
                              (mX["width"] = Math["floor"](u0 * vv)),
                              (mX["height"] = Math["floor"](u1 * vv)),
                              !0x1 !== u2 && ((mX["style"]["width"] = u0 + "px"), (mX["style"]["height"] = u1 + "px")),
                              this["setViewport"](0x0, 0x0, u0, u1));
                    }),
                    (this["getDrawingBufferSize"] = function (u0) {
                        return void 0x0 === u0 && (console["warn"]("WebGLRenderer:\x20.getdrawingBufferSize()\x20now\x20requires\x20a\x20Vector2\x20as\x20an\x20argument"), (u0 = new E3())), u0["set"](vZ * vv, vm * vv)["floor"]();
                    }),
                    (this["setDrawingBufferSize"] = function (u0, u1, u2) {
                        (vZ = u0), (vm = u1), (vv = u2), (mX["width"] = Math["floor"](u0 * u2)), (mX["height"] = Math["floor"](u1 * u2)), this["setViewport"](0x0, 0x0, u0, u1);
                    }),
                    (this["getCurrentViewport"] = function (u0) {
                        return void 0x0 === u0 && (console["warn"]("WebGLRenderer:\x20.getCurrentViewport()\x20now\x20requires\x20a\x20Vector4\x20as\x20an\x20argument"), (u0 = new E8())), u0["copy"](vB);
                    }),
                    (this["getViewport"] = function (u0) {
                        return u0["copy"](vN);
                    }),
                    (this["setViewport"] = function (u0, u1, u2, u3) {
                        u0["isVector4"] ? vN["set"](u0["x"], u0["y"], u0["z"], u0["w"]) : vN["set"](u0, u1, u2, u3), mg["viewport"](vB["copy"](vN)["multiplyScalar"](vv)["floor"]());
                    }),
                    (this["getScissor"] = function (u0) {
                        return u0["copy"](vX);
                    }),
                    (this["setScissor"] = function (u0, u1, u2, u3) {
                        u0["isVector4"] ? vX["set"](u0["x"], u0["y"], u0["z"], u0["w"]) : vX["set"](u0, u1, u2, u3), mg["scissor"](vF["copy"](vX)["multiplyScalar"](vv)["floor"]());
                    }),
                    (this["getScissorTest"] = function () {
                        return vf;
                    }),
                    (this["setScissorTest"] = function (u0) {
                        mg["setScissorTest"]((vf = u0));
                    }),
                    (this["setOpaqueSort"] = function (u0) {
                        vy = u0;
                    }),
                    (this["setTransparentSort"] = function (u0) {
                        vD = u0;
                    }),
                    (this["getClearColor"] = function () {
                        return v0["getClearColor"]();
                    }),
                    (this["setClearColor"] = function () {
                        v0["setClearColor"]["apply"](v0, arguments);
                    }),
                    (this["getClearAlpha"] = function () {
                        return v0["getClearAlpha"]();
                    }),
                    (this["setClearAlpha"] = function () {
                        v0["setClearAlpha"]["apply"](v0, arguments);
                    }),
                    (this["clear"] = function (u0, u1, u2) {
                        var u3 = 0x0;
                        (void 0x0 === u0 || u0) && (u3 |= 0x4000), (void 0x0 === u1 || u1) && (u3 |= 0x100), (void 0x0 === u2 || u2) && (u3 |= 0x400), mj["clear"](u3);
                    }),
                    (this["clearColor"] = function () {
                        this["clear"](!0x0, !0x1, !0x1);
                    }),
                    (this["clearDepth"] = function () {
                        this["clear"](!0x1, !0x0, !0x1);
                    }),
                    (this["clearStencil"] = function () {
                        this["clear"](!0x1, !0x1, !0x0);
                    }),
                    (this["dispose"] = function () {
                        mX["removeEventListener"]("webglcontextlost", vh, !0x1), mX["removeEventListener"]("webglcontextrestored", vS, !0x1), mQ["dispose"](), mz["dispose"](), mH["dispose"](), mJ["dispose"](), vO["dispose"](), vK["stop"]();
                    }),
                    (this["renderBufferImmediate"] = function (u0, u1) {
                        mg["initAttributes"]();
                        var u2 = mH["get"](u0);
                        u0["hasPositions"] && !u2["position"] && (u2["position"] = mj["createBuffer"]()),
                            u0["hasNormals"] && !u2["normal"] && (u2["normal"] = mj["createBuffer"]()),
                            u0["hasUvs"] && !u2["uv"] && (u2["uv"] = mj["createBuffer"]()),
                            u0["hasColors"] && !u2["color"] && (u2["color"] = mj["createBuffer"]());
                        var u3 = u1["getAttributes"]();
                        u0["hasPositions"] &&
                            (mj["bindBuffer"](0x8892, u2["position"]), mj["bufferData"](0x8892, u0["positionArray"], 0x88e8), mg["enableAttribute"](u3["position"]), mj["vertexAttribPointer"](u3["position"], 0x3, 0x1406, !0x1, 0x0, 0x0)),
                            u0["hasNormals"] &&
                                (mj["bindBuffer"](0x8892, u2["normal"]), mj["bufferData"](0x8892, u0["normalArray"], 0x88e8), mg["enableAttribute"](u3["normal"]), mj["vertexAttribPointer"](u3["normal"], 0x3, 0x1406, !0x1, 0x0, 0x0)),
                            u0["hasUvs"] && (mj["bindBuffer"](0x8892, u2["uv"]), mj["bufferData"](0x8892, u0["uvArray"], 0x88e8), mg["enableAttribute"](u3["uv"]), mj["vertexAttribPointer"](u3["uv"], 0x2, 0x1406, !0x1, 0x0, 0x0)),
                            u0["hasColors"] &&
                                (mj["bindBuffer"](0x8892, u2["color"]), mj["bufferData"](0x8892, u0["colorArray"], 0x88e8), mg["enableAttribute"](u3["color"]), mj["vertexAttribPointer"](u3["color"], 0x3, 0x1406, !0x1, 0x0, 0x0)),
                            mg["disableUnusedAttributes"](),
                            mj["drawArrays"](0x4, 0x0, u0["count"]),
                            (u0["count"] = 0x0);
                    });
                var vH = new EW();
                (this["renderBufferDirect"] = function (u0, u1, u2, u3, u4, u5) {
                    null === u1 && (u1 = vH);
                    var u6 = u4["isMesh"] && u4["matrixWorld"]["determinant"]() < 0x0,
                        u7 = vQ(u0, u1, u3, u4);
                    mg["setMaterial"](u3, u6);
                    var u8 = !0x1;
                    (vC["geometry"] === u2["id"] && vC["program"] === u7["id"] && vC["wireframe"] === (!0x0 === u3["wireframe"])) ||
                        ((vC["geometry"] = u2["id"]), (vC["program"] = u7["id"]), (vC["wireframe"] = !0x0 === u3["wireframe"]), (u8 = !0x0)),
                        (u3["morphTargets"] || u3["morphNormals"]) && (v1["update"](u4, u2, u3, u7), (u8 = !0x0)),
                        !0x0 === u4["isInstancedMesh"] && (u8 = !0x0);
                    var u9 = u2["index"],
                        uE = u2["attributes"]["position"];
                    if (null === u9) {
                        if (void 0x0 === uE || 0x0 === uE["count"]) return;
                    } else {
                        if (0x0 === u9["count"]) return;
                    }
                    var uR,
                        uT = 0x1;
                    !0x0 === u3["wireframe"] && ((u9 = mV["getWireframeAttribute"](u2)), (uT = 0x2));
                    var uC = v2;
                    null !== u9 && ((uR = mK["get"](u9)), (uC = v3)["setIndex"](uR)),
                        u8 &&
                            (!(function (uN, uX, uf, uP) {
                                if (!0x1 === mS["isWebGL2"] && (uN["isInstancedMesh"] || uX["isInstancedBufferGeometry"]) && null === mh["get"]("ANGLE_instanced_arrays")) return;
                                mg["initAttributes"]();
                                var uI = uX["attributes"],
                                    uA = uP["getAttributes"](),
                                    uM = uf["defaultAttributeValues"];
                                for (var up in uA) {
                                    var uk = uA[up];
                                    if (uk >= 0x0) {
                                        var uU = uI[up];
                                        if (void 0x0 !== uU) {
                                            var uq = uU["normalized"],
                                                uw = uU["itemSize"];
                                            if (void 0x0 === (uH = mK["get"](uU))) continue;
                                            var uO = uH["buffer"],
                                                uj = uH["type"],
                                                uh = uH["bytesPerElement"];
                                            if (uU["isInterleavedBufferAttribute"]) {
                                                var uS = uU["data"],
                                                    ug = uS["stride"],
                                                    uW = uU["offset"];
                                                uS && uS["isInstancedInterleavedBuffer"]
                                                    ? (mg["enableAttributeAndDivisor"](uk, uS["meshPerAttribute"]), void 0x0 === uX["_maxInstanceCount"] && (uX["_maxInstanceCount"] = uS["meshPerAttribute"] * uS["count"]))
                                                    : mg["enableAttribute"](uk),
                                                    mj["bindBuffer"](0x8892, uO),
                                                    mg["vertexAttribPointer"](uk, uw, uj, uq, ug * uh, uW * uh);
                                            } else
                                                uU["isInstancedBufferAttribute"]
                                                    ? (mg["enableAttributeAndDivisor"](uk, uU["meshPerAttribute"]), void 0x0 === uX["_maxInstanceCount"] && (uX["_maxInstanceCount"] = uU["meshPerAttribute"] * uU["count"]))
                                                    : mg["enableAttribute"](uk),
                                                    mj["bindBuffer"](0x8892, uO),
                                                    mg["vertexAttribPointer"](uk, uw, uj, uq, 0x0, 0x0);
                                        } else {
                                            if ("instanceMatrix" === up) {
                                                var uH;
                                                if (void 0x0 === (uH = mK["get"](uN["instanceMatrix"]))) continue;
                                                (uO = uH["buffer"]),
                                                    (uj = uH["type"]),
                                                    (mg["enableAttributeAndDivisor"](uk + 0x0, 0x1),
                                                    mg["enableAttributeAndDivisor"](uk + 0x1, 0x1),
                                                    mg["enableAttributeAndDivisor"](uk + 0x2, 0x1),
                                                    mg["enableAttributeAndDivisor"](uk + 0x3, 0x1),
                                                    mj["bindBuffer"](0x8892, uO),
                                                    mj["vertexAttribPointer"](uk + 0x0, 0x4, uj, !0x1, 0x40, 0x0),
                                                    mj["vertexAttribPointer"](uk + 0x1, 0x4, uj, !0x1, 0x40, 0x10),
                                                    mj["vertexAttribPointer"](uk + 0x2, 0x4, uj, !0x1, 0x40, 0x20),
                                                    mj["vertexAttribPointer"](uk + 0x3, 0x4, uj, !0x1, 0x40, 0x30));
                                            } else {
                                                if (void 0x0 !== uM) {
                                                    var ux = uM[up];
                                                    if (void 0x0 !== ux)
                                                        switch (ux["length"]) {
                                                            case 0x2:
                                                                mj["vertexAttrib2fv"](uk, ux);
                                                                break;
                                                            case 0x3:
                                                                mj["vertexAttrib3fv"](uk, ux);
                                                                break;
                                                            case 0x4:
                                                                mj["vertexAttrib4fv"](uk, ux);
                                                                break;
                                                            default:
                                                                mj["vertexAttrib1fv"](uk, ux);
                                                        }
                                                }
                                            }
                                        }
                                    }
                                }
                                mg["disableUnusedAttributes"]();
                            })(u4, u2, u3, u7),
                            null !== u9 && mj["bindBuffer"](0x8893, uR["buffer"]));
                    var ud = null !== u9 ? u9["count"] : uE["count"],
                        uY = u2["drawRange"]["start"] * uT,
                        uB = u2["drawRange"]["count"] * uT,
                        uF = null !== u5 ? u5["start"] * uT : 0x0,
                        ub = null !== u5 ? u5["count"] * uT : 0x1 / 0x0,
                        uZ = Math["max"](uY, uF),
                        um = Math["min"](ud, uY + uB, uF + ub) - 0x1,
                        uv = Math["max"](0x0, um - uZ + 0x1);
                    if (0x0 !== uv) {
                        if (u4["isMesh"]) !0x0 === u3["wireframe"] ? (mg["setLineWidth"](u3["wireframeLinewidth"] * vU()), uC["setMode"](0x1)) : uC["setMode"](0x4);
                        else {
                            if (u4["isLine"]) {
                                var uy = u3["linewidth"];
                                void 0x0 === uy && (uy = 0x1), mg["setLineWidth"](uy * vU()), u4["isLineSegments"] ? uC["setMode"](0x1) : u4["isLineLoop"] ? uC["setMode"](0x2) : uC["setMode"](0x3);
                            } else u4["isPoints"] ? uC["setMode"](0x0) : u4["isSprite"] && uC["setMode"](0x4);
                        }
                        if (u4["isInstancedMesh"]) uC["renderInstances"](u2, uZ, uv, u4["count"]);
                        else {
                            if (u2["isInstancedBufferGeometry"]) {
                                var uD = Math["min"](u2["instanceCount"], u2["_maxInstanceCount"]);
                                uC["renderInstances"](u2, uZ, uv, uD);
                            } else uC["render"](uZ, uv);
                        }
                    }
                }),
                    (this["compile"] = function (u0, u1) {
                        (mO = mz["get"](u0, u1))["init"](),
                            u0["traverse"](function (u3) {
                                u3["isLight"] && (mO["pushLight"](u3), u3["castShadow"] && mO["pushShadow"](u3));
                            }),
                            mO["setupLights"](u1);
                        const u2 = {};
                        u0["traverse"](function (u3) {
                            let u4 = u3["material"];
                            if (u4) {
                                if (Array["isArray"](u4))
                                    for (let u5 = 0x0; u5 < u4["length"]; u5++) {
                                        let u6 = u4[u5];
                                        u6["uuid"] in u2 == !0x1 && (vL(u6, u0, u3), (u2[u6["uuid"]] = !0x0));
                                    }
                                else u4["uuid"] in u2 == !0x1 && (vL(u4, u0, u3), (u2[u4["uuid"]] = !0x0));
                            }
                        });
                    });
                var vx = null,
                    vK = new C1();
                function vV(u0, u1, u2, u3) {
                    if (!0x1 !== u0["visible"]) {
                        if (u0["layers"]["test"](u1["layers"])) {
                            if (u0["isGroup"]) u2 = u0["renderOrder"];
                            else {
                                if (u0["isLOD"]) !0x0 === u0["autoUpdate"] && u0["update"](u1);
                                else {
                                    if (u0["isLight"]) mO["pushLight"](u0), u0["castShadow"] && mO["pushShadow"](u0);
                                    else {
                                        if (u0["isSprite"]) {
                                            if (!u0["frustumCulled"] || vP["intersectsSprite"](u0)) {
                                                u3 && vk["setFromMatrixPosition"](u0["matrixWorld"])["applyMatrix4"](vp);
                                                var u4 = mJ["update"](u0);
                                                (u5 = u0["material"])["visible"] && mw["push"](u0, u4, u5, u2, vk["z"], null);
                                            }
                                        } else {
                                            if (u0["isImmediateRenderObject"]) u3 && vk["setFromMatrixPosition"](u0["matrixWorld"])["applyMatrix4"](vp), mw["push"](u0, null, u0["material"], u2, vk["z"], null);
                                            else {
                                                if (
                                                    (u0["isMesh"] || u0["isLine"] || u0["isPoints"]) &&
                                                    (u0["isSkinnedMesh"] && u0["skeleton"]["frame"] !== mW["render"]["frame"] && (u0["skeleton"]["update"](), (u0["skeleton"]["frame"] = mW["render"]["frame"])),
                                                    !u0["frustumCulled"] || vP["intersectsObject"](u0))
                                                ) {
                                                    u3 && vk["setFromMatrixPosition"](u0["matrixWorld"])["applyMatrix4"](vp), (u4 = mJ["update"](u0));
                                                    var u5 = u0["material"];
                                                    if (Array["isArray"](u5))
                                                        for (var u6 = u4["groups"], u7 = 0x0, u8 = u6["length"]; u7 < u8; u7++) {
                                                            var u9 = u6[u7],
                                                                uE = u5[u9["materialIndex"]];
                                                            uE && uE["visible"] && mw["push"](u0, u4, uE, u2, vk["z"], u9);
                                                        }
                                                    else u5["visible"] && mw["push"](u0, u4, u5, u2, vk["z"], null);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        var uR = u0["children"];
                        for (u7 = 0x0, u8 = uR["length"]; u7 < u8; u7++) vV(uR[u7], u1, u2, u3);
                    }
                }
                function vJ(u0, u1, u2, u3) {
                    for (var u4 = 0x0, u5 = u0["length"]; u4 < u5; u4++) {
                        var u6 = u0[u4],
                            u7 = u6["object"],
                            u8 = u6["geometry"],
                            u9 = void 0x0 === u3 ? u6["material"] : u3,
                            uE = u6["group"];
                        if (u2["isArrayCamera"]) {
                            vY = u2;
                            for (var uR = u2["cameras"], uT = 0x0, uC = uR["length"]; uT < uC; uT++) {
                                var ud = uR[uT];
                                u7["layers"]["test"](ud["layers"]) && (mg["viewport"](vB["copy"](ud["viewport"])), mO["setupLights"](ud), vG(u7, u1, ud, u8, u9, uE));
                            }
                        } else (vY = null), vG(u7, u1, u2, u8, u9, uE);
                    }
                }
                function vG(u0, u1, u2, u3, u4, u5) {
                    if (
                        (u0["onBeforeRender"](v5, u1, u2, u3, u4, u5),
                        (mO = mz["get"](u1, vY || u2)),
                        u0["modelViewMatrix"]["multiplyMatrices"](u2["matrixWorldInverse"], u0["matrixWorld"]),
                        u0["normalMatrix"]["getNormalMatrix"](u0["modelViewMatrix"]),
                        u0["isImmediateRenderObject"])
                    ) {
                        var u6 = vQ(u2, u1, u4, u0);
                        mg["setMaterial"](u4),
                            (vC["geometry"] = null),
                            (vC["program"] = null),
                            (vC["wireframe"] = !0x1),
                            (function (u7, u8) {
                                u7["render"](function (u9) {
                                    v5["renderBufferImmediate"](u9, u8);
                                });
                            })(u0, u6);
                    } else v5["renderBufferDirect"](u2, u1, u3, u4, u0, u5);
                    u0["onAfterRender"](v5, u1, u2, u3, u4, u5), (mO = mz["get"](u1, vY || u2));
                }
                function vL(u0, u1, u2) {
                    var u3 = mH["get"](u0),
                        u4 = mO["state"]["lights"],
                        u5 = mO["state"]["shadowsArray"],
                        u6 = u4["state"]["version"],
                        u7 = mG["getParameters"](u0, u4["state"], u5, u1, vI["numPlanes"], vI["numIntersection"], u2),
                        u8 = mG["getProgramCacheKey"](u7),
                        u9 = u3["program"],
                        uE = !0x0;
                    if (void 0x0 === u9) u0["addEventListener"]("dispose", vg);
                    else {
                        if (u9["cacheKey"] !== u8) vW(u0);
                        else {
                            if (u3["lightsStateVersion"] !== u6) (u3["lightsStateVersion"] = u6), (uE = !0x1);
                            else {
                                if (void 0x0 !== u7["shaderID"]) return;
                                uE = !0x1;
                            }
                        }
                    }
                    uE && ((u9 = mG["acquireProgram"](u7, u8)), (u3["program"] = u9), (u3["uniforms"] = u7["uniforms"]), (u3["outputEncoding"] = u7["outputEncoding"]), (u0["program"] = u9));
                    var uR = u9["getAttributes"]();
                    if (u0["morphTargets"]) {
                        u0["numSupportedMorphTargets"] = 0x0;
                        for (var uT = 0x0; uT < v5["maxMorphTargets"]; uT++) uR["morphTarget" + uT] >= 0x0 && u0["numSupportedMorphTargets"]++;
                    }
                    if (u0["morphNormals"]) {
                        u0["numSupportedMorphNormals"] = 0x0;
                        for (uT = 0x0; uT < v5["maxMorphNormals"]; uT++) uR["morphNormal" + uT] >= 0x0 && u0["numSupportedMorphNormals"]++;
                    }
                    var uC = u3["uniforms"];
                    ((u0["isShaderMaterial"] || u0["isRawShaderMaterial"]) && !0x0 !== u0["clipping"]) ||
                        ((u3["numClippingPlanes"] = vI["numPlanes"]), (u3["numIntersection"] = vI["numIntersection"]), (uC["clippingPlanes"] = vI["uniform"])),
                        (u3["environment"] = u0["isMeshStandardMaterial"] ? u1["environment"] : null),
                        (u3["fog"] = u1["fog"]),
                        (u3["needsLights"] = (function (uB) {
                            return uB["isMeshLambertMaterial"] || uB["isMeshToonMaterial"] || uB["isMeshPhongMaterial"] || uB["isMeshStandardMaterial"] || uB["isShadowMaterial"] || (uB["isShaderMaterial"] && !0x0 === uB["lights"]);
                        })(u0)),
                        (u3["lightsStateVersion"] = u6),
                        u3["needsLights"] &&
                            ((uC["ambientLightColor"]["value"] = u4["state"]["ambient"]),
                            (uC["lightProbe"]["value"] = u4["state"]["probe"]),
                            (uC["directionalLights"]["value"] = u4["state"]["directional"]),
                            (uC["directionalLightShadows"]["value"] = u4["state"]["directionalShadow"]),
                            (uC["spotLights"]["value"] = u4["state"]["spot"]),
                            (uC["spotLightShadows"]["value"] = u4["state"]["spotShadow"]),
                            (uC["rectAreaLights"]["value"] = u4["state"]["rectArea"]),
                            (uC["pointLights"]["value"] = u4["state"]["point"]),
                            (uC["pointLightShadows"]["value"] = u4["state"]["pointShadow"]),
                            (uC["hemisphereLights"]["value"] = u4["state"]["hemi"]),
                            (uC["directionalShadowMap"]["value"] = u4["state"]["directionalShadowMap"]),
                            (uC["directionalShadowMatrix"]["value"] = u4["state"]["directionalShadowMatrix"]),
                            (uC["spotShadowMap"]["value"] = u4["state"]["spotShadowMap"]),
                            (uC["spotShadowMatrix"]["value"] = u4["state"]["spotShadowMatrix"]),
                            (uC["pointShadowMap"]["value"] = u4["state"]["pointShadowMap"]),
                            (uC["pointShadowMatrix"]["value"] = u4["state"]["pointShadowMatrix"]));
                    var ud = u3["program"]["getUniforms"](),
                        uY = db["seqWithValue"](ud["seq"], uC);
                    u3["uniformsList"] = uY;
                }
                function vQ(u0, u1, u2, u3) {
                    mx["resetTextureUnits"]();
                    var u4 = u1["fog"],
                        u5 = u2["isMeshStandardMaterial"] ? u1["environment"] : null,
                        u6 = null === vE ? v5["outputEncoding"] : vE["texture"]["encoding"],
                        u7 = mH["get"](u2),
                        u8 = mO["state"]["lights"];
                    if (vA && (vM || u0 !== vd)) {
                        var u9 = u0 === vd && u2["id"] === vT;
                        vI["setState"](u2["clippingPlanes"], u2["clipIntersection"], u2["clipShadows"], u0, u7, u9);
                    }
                    u2["version"] === u7["__version"]
                        ? void 0x0 === u7["program"] || (u2["fog"] && u7["fog"] !== u4) || u7["environment"] !== u5 || (u7["needsLights"] && u7["lightsStateVersion"] !== u8["state"]["version"])
                            ? vL(u2, u1, u3)
                            : void 0x0 === u7["numClippingPlanes"] || (u7["numClippingPlanes"] === vI["numPlanes"] && u7["numIntersection"] === vI["numIntersection"])
                            ? u7["outputEncoding"] !== u6 && vL(u2, u1, u3)
                            : vL(u2, u1, u3)
                        : (vL(u2, u1, u3), (u7["__version"] = u2["version"]));
                    var uE,
                        uR,
                        uT = !0x1,
                        uC = !0x1,
                        ud = !0x1,
                        uY = u7["program"],
                        uB = uY["getUniforms"](),
                        uF = u7["uniforms"];
                    if ((mg["useProgram"](uY["program"]) && ((uT = !0x0), (uC = !0x0), (ud = !0x0)), u2["id"] !== vT && ((vT = u2["id"]), (uC = !0x0)), uT || vd !== u0)) {
                        if (
                            (uB["setValue"](mj, "projectionMatrix", u0["projectionMatrix"]),
                            mS["logarithmicDepthBuffer"] && uB["setValue"](mj, "logDepthBufFC", 0x2 / (Math["log"](u0["far"] + 0x1) / Math["LN2"])),
                            vd !== u0 && ((vd = u0), (uC = !0x0), (ud = !0x0)),
                            u2["isShaderMaterial"] || u2["isMeshPhongMaterial"] || u2["isMeshToonMaterial"] || u2["isMeshStandardMaterial"] || u2["envMap"])
                        ) {
                            var ub = uB["map"]["cameraPosition"];
                            void 0x0 !== ub && ub["setValue"](mj, vk["setFromMatrixPosition"](u0["matrixWorld"]));
                        }
                        (u2["isMeshPhongMaterial"] || u2["isMeshToonMaterial"] || u2["isMeshLambertMaterial"] || u2["isMeshBasicMaterial"] || u2["isMeshStandardMaterial"] || u2["isShaderMaterial"]) &&
                            uB["setValue"](mj, "isOrthographic", !0x0 === u0["isOrthographicCamera"]),
                            (u2["isMeshPhongMaterial"] || u2["isMeshToonMaterial"] || u2["isMeshLambertMaterial"] || u2["isMeshBasicMaterial"] || u2["isMeshStandardMaterial"] || u2["isShaderMaterial"] || u2["skinning"]) &&
                                uB["setValue"](mj, "viewMatrix", u0["matrixWorldInverse"]);
                    }
                    if (u2["skinning"]) {
                        uB["setOptional"](mj, u3, "bindMatrix"), uB["setOptional"](mj, u3, "bindMatrixInverse");
                        var uZ = u3["skeleton"];
                        if (uZ) {
                            var um = uZ["bones"];
                            if (mS["floatVertexTextures"]) {
                                if (void 0x0 === uZ["boneTexture"]) {
                                    var uv = Math["sqrt"](0x4 * um["length"]);
                                    (uv = E2["ceilPowerOfTwo"](uv)), (uv = Math["max"](uv, 0x4));
                                    var uy = new Float32Array(uv * uv * 0x4);
                                    uy["set"](uZ["boneMatrices"]);
                                    var uD = new TG(uy, uv, uv, rf, ry);
                                    (uZ["boneMatrices"] = uy), (uZ["boneTexture"] = uD), (uZ["boneTextureSize"] = uv);
                                }
                                uB["setValue"](mj, "boneTexture", uZ["boneTexture"], mx), uB["setValue"](mj, "boneTextureSize", uZ["boneTextureSize"]);
                            } else uB["setOptional"](mj, uZ, "boneMatrices");
                        }
                    }
                    return (
                        (uC || u7["receiveShadow"] !== u3["receiveShadow"]) && ((u7["receiveShadow"] = u3["receiveShadow"]), uB["setValue"](mj, "receiveShadow", u3["receiveShadow"])),
                        uC &&
                            (uB["setValue"](mj, "toneMappingExposure", v5["toneMappingExposure"]),
                            uB["setValue"](mj, "toneMappingWhitePoint", v5["toneMappingWhitePoint"]),
                            u7["needsLights"] &&
                                ((uR = ud),
                                ((uE = uF)["ambientLightColor"]["needsUpdate"] = uR),
                                (uE["lightProbe"]["needsUpdate"] = uR),
                                (uE["directionalLights"]["needsUpdate"] = uR),
                                (uE["directionalLightShadows"]["needsUpdate"] = uR),
                                (uE["pointLights"]["needsUpdate"] = uR),
                                (uE["pointLightShadows"]["needsUpdate"] = uR),
                                (uE["spotLights"]["needsUpdate"] = uR),
                                (uE["spotLightShadows"]["needsUpdate"] = uR),
                                (uE["rectAreaLights"]["needsUpdate"] = uR),
                                (uE["hemisphereLights"]["needsUpdate"] = uR)),
                            u4 && u2["fog"] && mL["refreshFogUniforms"](uF, u4),
                            mL["refreshMaterialUniforms"](uF, u2, u5, vv, vm),
                            void 0x0 !== uF["ltc_1"] && (uF["ltc_1"]["value"] = C0["LTC_1"]),
                            void 0x0 !== uF["ltc_2"] && (uF["ltc_2"]["value"] = C0["LTC_2"]),
                            db["upload"](mj, u7["uniformsList"], uF, mx)),
                        u2["isShaderMaterial"] && !0x0 === u2["uniformsNeedUpdate"] && (db["upload"](mj, u7["uniformsList"], uF, mx), (u2["uniformsNeedUpdate"] = !0x1)),
                        u2["isSpriteMaterial"] && uB["setValue"](mj, "center", u3["center"]),
                        uB["setValue"](mj, "modelViewMatrix", u3["modelViewMatrix"]),
                        uB["setValue"](mj, "normalMatrix", u3["normalMatrix"]),
                        uB["setValue"](mj, "modelMatrix", u3["matrixWorld"]),
                        uY
                    );
                }
                vK["setAnimationLoop"](function (u0) {
                    vO["isPresenting"] || (vx && vx(u0));
                }),
                    "undefined" != typeof window && vK["setContext"](window),
                    (this["setAnimationLoop"] = function (u0) {
                        (vx = u0), vO["setAnimationLoop"](u0), vK["start"]();
                    }),
                    (this["render"] = function (u0, u1) {
                        var u2, u3;
                        if (
                            (void 0x0 !== arguments[0x2] && (console["warn"]("THREE.WebGLRenderer.render():\x20the\x20renderTarget\x20argument\x20has\x20been\x20removed.\x20Use\x20.setRenderTarget()\x20instead."), (u2 = arguments[0x2])),
                            void 0x0 !== arguments[0x3] && (console["warn"]("THREE.WebGLRenderer.render():\x20the\x20forceClear\x20argument\x20has\x20been\x20removed.\x20Use\x20.clear()\x20instead."), (u3 = arguments[0x3])),
                            u1 && u1["isCamera"])
                        ) {
                            if (!v6) {
                                (vC["geometry"] = null),
                                    (vC["program"] = null),
                                    (vC["wireframe"] = !0x1),
                                    (vT = -0x1),
                                    (vd = null),
                                    !0x0 === u0["autoUpdate"] && u0["updateMatrixWorld"](),
                                    null === u1["parent"] && u1["updateMatrixWorld"](),
                                    vO["enabled"] && vO["isPresenting"] && (u1 = vO["getCamera"](u1)),
                                    u0["onBeforeRender"](v5, u0, u1, u2 || vE),
                                    (mO = mz["get"](u0, u1))["init"](),
                                    vp["multiplyMatrices"](u1["projectionMatrix"], u1["matrixWorldInverse"]),
                                    vP["setFromProjectionMatrix"](vp),
                                    (vM = this["localClippingEnabled"]),
                                    (vA = vI["init"](this["clippingPlanes"], vM, u1)),
                                    (mw = mQ["get"](u0, u1))["init"](),
                                    vV(u0, u1, 0x0, v5["sortObjects"]),
                                    mw["finish"](),
                                    !0x0 === v5["sortObjects"] && mw["sort"](vy, vD),
                                    vA && vI["beginShadows"]();
                                var u4 = mO["state"]["shadowsArray"];
                                vj["render"](u4, u0, u1), mO["setupLights"](u1), vA && vI["endShadows"](), this["info"]["autoReset"] && this["info"]["reset"](), void 0x0 !== u2 && this["setRenderTarget"](u2), v0["render"](mw, u0, u1, u3);
                                var u5 = mw["opaque"],
                                    u6 = mw["transparent"];
                                if (u0["overrideMaterial"]) {
                                    var u7 = u0["overrideMaterial"];
                                    u5["length"] && vJ(u5, u0, u1, u7), u6["length"] && vJ(u6, u0, u1, u7);
                                } else u5["length"] && vJ(u5, u0, u1), u6["length"] && vJ(u6, u0, u1);
                                u0["onAfterRender"](v5, u0, u1),
                                    null !== vE && (mx["updateRenderTargetMipmap"](vE), mx["updateMultisampleRenderTarget"](vE)),
                                    mg["buffers"]["depth"]["setTest"](!0x0),
                                    mg["buffers"]["depth"]["setMask"](!0x0),
                                    mg["buffers"]["color"]["setMask"](!0x0),
                                    mg["setPolygonOffset"](!0x1),
                                    (mw = null),
                                    (mO = null);
                            }
                        } else console["error"]("THREE.WebGLRenderer.render:\x20camera\x20is\x20not\x20an\x20instance\x20of\x20THREE.Camera.");
                    }),
                    (this["setFramebuffer"] = function (u0) {
                        v7 !== u0 && null === vE && mj["bindFramebuffer"](0x8d40, u0), (v7 = u0);
                    }),
                    (this["getActiveCubeFace"] = function () {
                        return v8;
                    }),
                    (this["getActiveMipmapLevel"] = function () {
                        return v9;
                    }),
                    (this["getRenderTarget"] = function () {
                        return vE;
                    }),
                    (this["setRenderTarget"] = function (u0, u1, u2) {
                        (vE = u0), (v8 = u1), (v9 = u2), u0 && void 0x0 === mH["get"](u0)["__webglFramebuffer"] && mx["setupRenderTarget"](u0);
                        var u3 = v7,
                            u4 = !0x1;
                        if (u0) {
                            var u5 = mH["get"](u0)["__webglFramebuffer"];
                            u0["isWebGLCubeRenderTarget"] ? ((u3 = u5[u1 || 0x0]), (u4 = !0x0)) : (u3 = u0["isWebGLMultisampleRenderTarget"] ? mH["get"](u0)["__webglMultisampledFramebuffer"] : u5),
                                vB["copy"](u0["viewport"]),
                                vF["copy"](u0["scissor"]),
                                (vb = u0["scissorTest"]);
                        } else vB["copy"](vN)["multiplyScalar"](vv)["floor"](), vF["copy"](vX)["multiplyScalar"](vv)["floor"](), (vb = vf);
                        if ((vR !== u3 && (mj["bindFramebuffer"](0x8d40, u3), (vR = u3)), mg["viewport"](vB), mg["scissor"](vF), mg["setScissorTest"](vb), u4)) {
                            var u6 = mH["get"](u0["texture"]);
                            mj["framebufferTexture2D"](0x8d40, 0x8ce0, 0x8515 + (u1 || 0x0), u6["__webglTexture"], u2 || 0x0);
                        }
                    }),
                    (this["readRenderTargetPixels"] = function (u0, u1, u2, u3, u4, u5, u6) {
                        if (u0 && u0["isWebGLRenderTarget"]) {
                            var u7 = mH["get"](u0)["__webglFramebuffer"];
                            if ((u0["isWebGLCubeRenderTarget"] && void 0x0 !== u6 && (u7 = u7[u6]), u7)) {
                                var u8 = !0x1;
                                u7 !== vR && (mj["bindFramebuffer"](0x8d40, u7), (u8 = !0x0));
                                try {
                                    var u9 = u0["texture"],
                                        uE = u9["format"],
                                        uR = u9["type"];
                                    if (uE !== rf && v4["convert"](uE) !== mj["getParameter"](0x8b9b))
                                        return void console["error"]("THREE.WebGLRenderer.readRenderTargetPixels:\x20renderTarget\x20is\x20not\x20in\x20RGBA\x20or\x20implementation\x20defined\x20format.");
                                    if (
                                        !(
                                            uR === rZ ||
                                            v4["convert"](uR) === mj["getParameter"](0x8b9a) ||
                                            (uR === ry && (mS["isWebGL2"] || mh["get"]("OES_texture_float") || mh["get"]("WEBGL_color_buffer_float"))) ||
                                            (uR === rD && (mS["isWebGL2"] ? mh["get"]("EXT_color_buffer_float") : mh["get"]("EXT_color_buffer_half_float")))
                                        )
                                    )
                                        return void console["error"]("THREE.WebGLRenderer.readRenderTargetPixels:\x20renderTarget\x20is\x20not\x20in\x20UnsignedByteType\x20or\x20implementation\x20defined\x20type.");
                                    0x8cd5 === mj["checkFramebufferStatus"](0x8d40)
                                        ? u1 >= 0x0 && u1 <= u0["width"] - u3 && u2 >= 0x0 && u2 <= u0["height"] - u4 && mj["readPixels"](u1, u2, u3, u4, v4["convert"](uE), v4["convert"](uR), u5)
                                        : console["error"]("THREE.WebGLRenderer.readRenderTargetPixels:\x20readPixels\x20from\x20renderTarget\x20failed.\x20Framebuffer\x20not\x20complete.");
                                } finally {
                                    u8 && mj["bindFramebuffer"](0x8d40, vR);
                                }
                            }
                        } else console["error"]("THREE.WebGLRenderer.readRenderTargetPixels:\x20renderTarget\x20is\x20not\x20THREE.WebGLRenderTarget.");
                    }),
                    (this["copyFramebufferToTexture"] = function (u0, u1, u2) {
                        void 0x0 === u2 && (u2 = 0x0);
                        var u3 = Math["pow"](0x2, -u2),
                            u4 = Math["floor"](u1["image"]["width"] * u3),
                            u5 = Math["floor"](u1["image"]["height"] * u3),
                            u6 = v4["convert"](u1["format"]);
                        mx["setTexture2D"](u1, 0x0), mj["copyTexImage2D"](0xde1, u2, u6, u0["x"], u0["y"], u4, u5, 0x0), mg["unbindTexture"]();
                    }),
                    (this["copyTextureToTexture"] = function (u0, u1, u2, u3) {
                        void 0x0 === u3 && (u3 = 0x0);
                        var u4 = u1["image"]["width"],
                            u5 = u1["image"]["height"],
                            u6 = v4["convert"](u2["format"]),
                            u7 = v4["convert"](u2["type"]);
                        mx["setTexture2D"](u2, 0x0),
                            u1["isDataTexture"]
                                ? mj["texSubImage2D"](0xde1, u3, u0["x"], u0["y"], u4, u5, u6, u7, u1["image"]["data"])
                                : u1["isCompressedTexture"]
                                ? mj["compressedTexSubImage2D"](0xde1, u3, u0["x"], u0["y"], u1["mipmaps"][0x0]["width"], u1["mipmaps"][0x0]["height"], u6, u1["mipmaps"][0x0]["data"])
                                : mj["texSubImage2D"](0xde1, u3, u0["x"], u0["y"], u6, u7, u1["image"]),
                            0x0 === u3 && u2["generateMipmaps"] && mj["generateMipmap"](0xde1),
                            mg["unbindTexture"]();
                    }),
                    (this["initTexture"] = function (u0) {
                        mx["setTexture2D"](u0, 0x0), mg["unbindTexture"]();
                    }),
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__["dispatchEvent"](new CustomEvent("observe", { detail: this }));
            }
            function YR(mN, mX) {
                (this["name"] = ""), (this["color"] = new Rq(mN)), (this["density"] = void 0x0 !== mX ? mX : 0.00025);
            }
            function YT(mN, mX, mf) {
                (this["name"] = ""), (this["color"] = new Rq(mN)), (this["near"] = void 0x0 !== mX ? mX : 0x1), (this["far"] = void 0x0 !== mf ? mf : 0x3e8);
            }
            function YC(mN, mX) {
                (this["array"] = mN), (this["stride"] = mX), (this["count"] = void 0x0 !== mN ? mN["length"] / mX : 0x0), (this["usage"] = rG), (this["updateRange"] = { offset: 0x0, count: -0x1 }), (this["version"] = 0x0);
            }
            (Y5["prototype"] = Object["assign"](Object["create"](Tx["prototype"]), { constructor: Y5, isArrayCamera: !0x0 })),
                (Y6["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), { constructor: Y6, isGroup: !0x0 })),
                Object["assign"](Y7["prototype"], {
                    constructor: Y7,
                    getTargetRaySpace: function () {
                        return null === this["_targetRay"] && ((this["_targetRay"] = new Y6()), (this["_targetRay"]["matrixAutoUpdate"] = !0x1), (this["_targetRay"]["visible"] = !0x1)), this["_targetRay"];
                    },
                    getGripSpace: function () {
                        return null === this["_grip"] && ((this["_grip"] = new Y6()), (this["_grip"]["matrixAutoUpdate"] = !0x1), (this["_grip"]["visible"] = !0x1)), this["_grip"];
                    },
                    dispatchEvent: function (mN) {
                        return null !== this["_targetRay"] && this["_targetRay"]["dispatchEvent"](mN), null !== this["_grip"] && this["_grip"]["dispatchEvent"](mN), this;
                    },
                    disconnect: function (mN) {
                        return this["dispatchEvent"]({ type: "disconnected", data: mN }), null !== this["_targetRay"] && (this["_targetRay"]["visible"] = !0x1), null !== this["_grip"] && (this["_grip"]["visible"] = !0x1), this;
                    },
                    update: function (mN, mX, mf) {
                        var mP = null,
                            mI = null,
                            mA = this["_targetRay"],
                            mM = this["_grip"];
                        return (
                            mN &&
                                (null !== mA && null !== (mP = mX["getPose"](mN["targetRaySpace"], mf)) && (mA["matrix"]["fromArray"](mP["transform"]["matrix"]), mA["matrix"]["decompose"](mA["position"], mA["rotation"], mA["scale"])),
                                null !== mM &&
                                    mN["gripSpace"] &&
                                    null !== (mI = mX["getPose"](mN["gripSpace"], mf)) &&
                                    (mM["matrix"]["fromArray"](mI["transform"]["matrix"]), mM["matrix"]["decompose"](mM["position"], mM["rotation"], mM["scale"]))),
                            null !== mA && (mA["visible"] = null !== mP),
                            null !== mM && (mM["visible"] = null !== mI),
                            this
                        );
                    },
                }),
                Object["assign"](Y8["prototype"], rQ["prototype"]),
                Object["assign"](YR["prototype"], {
                    isFogExp2: !0x0,
                    clone: function () {
                        return new YR(this["color"], this["density"]);
                    },
                    toJSON: function () {
                        return { type: "FogExp2", color: this["color"]["getHex"](), density: this["density"] };
                    },
                }),
                Object["assign"](YT["prototype"], {
                    isFog: !0x0,
                    clone: function () {
                        return new YT(this["color"], this["near"], this["far"]);
                    },
                    toJSON: function () {
                        return { type: "Fog", color: this["color"]["getHex"](), near: this["near"], far: this["far"] };
                    },
                }),
                Object["defineProperty"](YC["prototype"], "needsUpdate", {
                    set: function (mN) {
                        !0x0 === mN && this["version"]++;
                    },
                }),
                Object["assign"](YC["prototype"], {
                    isInterleavedBuffer: !0x0,
                    onUploadCallback: function () {},
                    setUsage: function (mN) {
                        return (this["usage"] = mN), this;
                    },
                    copy: function (mN) {
                        return (this["array"] = new mN["array"]["constructor"](mN["array"])), (this["count"] = mN["count"]), (this["stride"] = mN["stride"]), (this["usage"] = mN["usage"]), this;
                    },
                    copyAt: function (mN, mX, mf) {
                        (mN *= this["stride"]), (mf *= mX["stride"]);
                        for (var mP = 0x0, mI = this["stride"]; mP < mI; mP++) this["array"][mN + mP] = mX["array"][mf + mP];
                        return this;
                    },
                    set: function (mN, mX) {
                        return void 0x0 === mX && (mX = 0x0), this["array"]["set"](mN, mX), this;
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    onUpload: function (mN) {
                        return (this["onUploadCallback"] = mN), this;
                    },
                });
            var Yd,
                YY = new Ed();
            function YB(mN, mX, mf, mP) {
                (this["name"] = ""), (this["data"] = mN), (this["itemSize"] = mX), (this["offset"] = mf), (this["normalized"] = !0x0 === mP);
            }
            function YF(mN) {
                Rg["call"](this),
                    (this["type"] = "SpriteMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["map"] = null),
                    (this["alphaMap"] = null),
                    (this["rotation"] = 0x0),
                    (this["sizeAttenuation"] = !0x0),
                    (this["transparent"] = !0x0),
                    this["setValues"](mN);
            }
            Object["defineProperties"](YB["prototype"], {
                count: {
                    get: function () {
                        return this["data"]["count"];
                    },
                },
                array: {
                    get: function () {
                        return this["data"]["array"];
                    },
                },
            }),
                Object["assign"](YB["prototype"], {
                    isInterleavedBufferAttribute: !0x0,
                    applyMatrix4: function (mN) {
                        for (var mX = 0x0, mf = this["data"]["count"]; mX < mf; mX++)
                            (YY["x"] = this["getX"](mX)), (YY["y"] = this["getY"](mX)), (YY["z"] = this["getZ"](mX)), YY["applyMatrix4"](mN), this["setXYZ"](mX, YY["x"], YY["y"], YY["z"]);
                        return this;
                    },
                    setX: function (mN, mX) {
                        return (this["data"]["array"][mN * this["data"]["stride"] + this["offset"]] = mX), this;
                    },
                    setY: function (mN, mX) {
                        return (this["data"]["array"][mN * this["data"]["stride"] + this["offset"] + 0x1] = mX), this;
                    },
                    setZ: function (mN, mX) {
                        return (this["data"]["array"][mN * this["data"]["stride"] + this["offset"] + 0x2] = mX), this;
                    },
                    setW: function (mN, mX) {
                        return (this["data"]["array"][mN * this["data"]["stride"] + this["offset"] + 0x3] = mX), this;
                    },
                    getX: function (mN) {
                        return this["data"]["array"][mN * this["data"]["stride"] + this["offset"]];
                    },
                    getY: function (mN) {
                        return this["data"]["array"][mN * this["data"]["stride"] + this["offset"] + 0x1];
                    },
                    getZ: function (mN) {
                        return this["data"]["array"][mN * this["data"]["stride"] + this["offset"] + 0x2];
                    },
                    getW: function (mN) {
                        return this["data"]["array"][mN * this["data"]["stride"] + this["offset"] + 0x3];
                    },
                    setXY: function (mN, mX, mf) {
                        return (mN = mN * this["data"]["stride"] + this["offset"]), (this["data"]["array"][mN + 0x0] = mX), (this["data"]["array"][mN + 0x1] = mf), this;
                    },
                    setXYZ: function (mN, mX, mf, mP) {
                        return (mN = mN * this["data"]["stride"] + this["offset"]), (this["data"]["array"][mN + 0x0] = mX), (this["data"]["array"][mN + 0x1] = mf), (this["data"]["array"][mN + 0x2] = mP), this;
                    },
                    setXYZW: function (mN, mX, mf, mP, mI) {
                        return (
                            (mN = mN * this["data"]["stride"] + this["offset"]),
                            (this["data"]["array"][mN + 0x0] = mX),
                            (this["data"]["array"][mN + 0x1] = mf),
                            (this["data"]["array"][mN + 0x2] = mP),
                            (this["data"]["array"][mN + 0x3] = mI),
                            this
                        );
                    },
                    clone: function () {
                        console["log"]("THREE.InterleavedBufferAttribute.clone():\x20Cloning\x20an\x20interlaved\x20buffer\x20attribute\x20will\x20deinterleave\x20buffer\x20data.");
                        for (var mN = [], mX = 0x0; mX < this["count"]; mX++) for (var mf = mX * this["data"]["stride"] + this["offset"], mP = 0x0; mP < this["itemSize"]; mP++) mN["push"](this["data"]["array"][mf + mP]);
                        return new Rx(new this["array"]["constructor"](mN), this["itemSize"], this["normalized"]);
                    },
                    toJSON: function () {
                        console["log"]("THREE.InterleavedBufferAttribute.toJSON():\x20Serializing\x20an\x20interlaved\x20buffer\x20attribute\x20will\x20deinterleave\x20buffer\x20data.");
                        for (var mN = [], mX = 0x0; mX < this["count"]; mX++) for (var mf = mX * this["data"]["stride"] + this["offset"], mP = 0x0; mP < this["itemSize"]; mP++) mN["push"](this["data"]["array"][mf + mP]);
                        return { itemSize: this["itemSize"], type: this["array"]["constructor"]["name"], array: mN, normalized: this["normalized"] };
                    },
                }),
                (YF["prototype"] = Object["create"](Rg["prototype"])),
                (YF["prototype"]["constructor"] = YF),
                (YF["prototype"]["isSpriteMaterial"] = !0x0),
                (YF["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        (this["map"] = mN["map"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["rotation"] = mN["rotation"]),
                        (this["sizeAttenuation"] = mN["sizeAttenuation"]),
                        this
                    );
                });
            var Yb = new Ed(),
                YZ = new Ed(),
                Ym = new Ed(),
                Yv = new E3(),
                Yy = new E3(),
                YD = new Ey(),
                YN = new Ed(),
                YX = new Ed(),
                Yf = new Ed(),
                YP = new E3(),
                YI = new E3(),
                YA = new E3();
            function YM(mN) {
                if ((Eg["call"](this), (this["type"] = "Sprite"), void 0x0 === Yd)) {
                    Yd = new TR();
                    var mX = new YC(new Float32Array([-0.5, -0.5, 0x0, 0x0, 0x0, 0.5, -0.5, 0x0, 0x1, 0x0, 0.5, 0.5, 0x0, 0x1, 0x1, -0.5, 0.5, 0x0, 0x0, 0x1]), 0x5);
                    Yd["setIndex"]([0x0, 0x1, 0x2, 0x0, 0x2, 0x3]), Yd["setAttribute"]("position", new YB(mX, 0x3, 0x0, !0x1)), Yd["setAttribute"]("uv", new YB(mX, 0x2, 0x3, !0x1));
                }
                (this["geometry"] = Yd), (this["material"] = void 0x0 !== mN ? mN : new YF()), (this["center"] = new E3(0.5, 0.5));
            }
            function Yp(mN, mX, mf, mP, mI, mA) {
                Yv["subVectors"](mN, mf)["addScalar"](0.5)["multiply"](mP),
                    void 0x0 !== mI ? ((Yy["x"] = mA * Yv["x"] - mI * Yv["y"]), (Yy["y"] = mI * Yv["x"] + mA * Yv["y"])) : Yy["copy"](Yv),
                    mN["copy"](mX),
                    (mN["x"] += Yy["x"]),
                    (mN["y"] += Yy["y"]),
                    mN["applyMatrix4"](YD);
            }
            YM["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                constructor: YM,
                isSprite: !0x0,
                raycast: function (mN, mX) {
                    null === mN["camera"] && console["error"]("THREE.Sprite:\x20\x22Raycaster.camera\x22\x20needs\x20to\x20be\x20set\x20in\x20order\x20to\x20raycast\x20against\x20sprites."),
                        YZ["setFromMatrixScale"](this["matrixWorld"]),
                        YD["copy"](mN["camera"]["matrixWorld"]),
                        this["modelViewMatrix"]["multiplyMatrices"](mN["camera"]["matrixWorldInverse"], this["matrixWorld"]),
                        Ym["setFromMatrixPosition"](this["modelViewMatrix"]),
                        mN["camera"]["isPerspectiveCamera"] && !0x1 === this["material"]["sizeAttenuation"] && YZ["multiplyScalar"](-Ym["z"]);
                    var mf,
                        mP,
                        mI = this["material"]["rotation"];
                    0x0 !== mI && ((mP = Math["cos"](mI)), (mf = Math["sin"](mI)));
                    var mA = this["center"];
                    Yp(YN["set"](-0.5, -0.5, 0x0), Ym, mA, YZ, mf, mP), Yp(YX["set"](0.5, -0.5, 0x0), Ym, mA, YZ, mf, mP), Yp(Yf["set"](0.5, 0.5, 0x0), Ym, mA, YZ, mf, mP), YP["set"](0x0, 0x0), YI["set"](0x1, 0x0), YA["set"](0x1, 0x1);
                    var mM = mN["ray"]["intersectTriangle"](YN, YX, Yf, !0x1, Yb);
                    if (null !== mM || (Yp(YX["set"](-0.5, 0.5, 0x0), Ym, mA, YZ, mf, mP), YI["set"](0x0, 0x1), null !== (mM = mN["ray"]["intersectTriangle"](YN, Yf, YX, !0x1, Yb)))) {
                        var mp = mN["ray"]["origin"]["distanceTo"](Yb);
                        mp < mN["near"] || mp > mN["far"] || mX["push"]({ distance: mp, point: Yb["clone"](), uv: RM["getUV"](Yb, YN, YX, Yf, YP, YI, YA, new E3()), face: null, object: this });
                    }
                },
                clone: function () {
                    return new this["constructor"](this["material"])["copy"](this);
                },
                copy: function (mN) {
                    return Eg["prototype"]["copy"]["call"](this, mN), void 0x0 !== mN["center"] && this["center"]["copy"](mN["center"]), this;
                },
            });
            var Yk,
                Yl,
                YU,
                Yq,
                Yw,
                YO = new Ed(),
                Yj = new Ed();
            function Yh() {
                Eg["call"](this), (this["_currentLevel"] = 0x0), (this["type"] = "LOD"), Object["defineProperties"](this, { levels: { enumerable: !0x0, value: [] } }), (this["autoUpdate"] = !0x0);
            }
            function YS(mN, mX) {
                mN && mN["isGeometry"] && console["error"]("THREE.SkinnedMesh\x20no\x20longer\x20supports\x20THREE.Geometry.\x20Use\x20THREE.BufferGeometry\x20instead."),
                    TA["call"](this, mN, mX),
                    (this["type"] = "SkinnedMesh"),
                    (this["bindMode"] = "attached"),
                    (this["bindMatrix"] = new Ey()),
                    (this["bindMatrixInverse"] = new Ey());
            }
            (Yh["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                constructor: Yh,
                isLOD: !0x0,
                copy: function (mN) {
                    Eg["prototype"]["copy"]["call"](this, mN, !0x1);
                    for (var mX = mN["levels"], mf = 0x0, mP = mX["length"]; mf < mP; mf++) {
                        var mI = mX[mf];
                        this["addLevel"](mI["object"]["clone"](), mI["distance"]);
                    }
                    return (this["autoUpdate"] = mN["autoUpdate"]), this;
                },
                addLevel: function (mN, mX) {
                    void 0x0 === mX && (mX = 0x0), (mX = Math["abs"](mX));
                    for (var mf = this["levels"], mP = 0x0; mP < mf["length"] && !(mX < mf[mP]["distance"]); mP++);
                    return mf["splice"](mP, 0x0, { distance: mX, object: mN }), this["add"](mN), this;
                },
                getCurrentLevel: function () {
                    return this["_currentLevel"];
                },
                getObjectForDistance: function (mN) {
                    var mX = this["levels"];
                    if (mX["length"] > 0x0) {
                        for (var mf = 0x1, mP = mX["length"]; mf < mP && !(mN < mX[mf]["distance"]); mf++);
                        return mX[mf - 0x1]["object"];
                    }
                    return null;
                },
                raycast: function (mN, mX) {
                    if (this["levels"]["length"] > 0x0) {
                        YO["setFromMatrixPosition"](this["matrixWorld"]);
                        var mf = mN["ray"]["origin"]["distanceTo"](YO);
                        this["getObjectForDistance"](mf)["raycast"](mN, mX);
                    }
                },
                update: function (mN) {
                    var mX = this["levels"];
                    if (mX["length"] > 0x1) {
                        YO["setFromMatrixPosition"](mN["matrixWorld"]), Yj["setFromMatrixPosition"](this["matrixWorld"]);
                        var mf = YO["distanceTo"](Yj) / mN["zoom"];
                        mX[0x0]["object"]["visible"] = !0x0;
                        for (var mP = 0x1, mI = mX["length"]; mP < mI && mf >= mX[mP]["distance"]; mP++) (mX[mP - 0x1]["object"]["visible"] = !0x1), (mX[mP]["object"]["visible"] = !0x0);
                        for (this["_currentLevel"] = mP - 0x1; mP < mI; mP++) mX[mP]["object"]["visible"] = !0x1;
                    }
                },
                toJSON: function (mN) {
                    var mX = Eg["prototype"]["toJSON"]["call"](this, mN);
                    !0x1 === this["autoUpdate"] && (mX["object"]["autoUpdate"] = !0x1), (mX["object"]["levels"] = []);
                    for (var mf = this["levels"], mP = 0x0, mI = mf["length"]; mP < mI; mP++) {
                        var mA = mf[mP];
                        mX["object"]["levels"]["push"]({ object: mA["object"]["uuid"], distance: mA["distance"] });
                    }
                    return mX;
                },
            })),
                (YS["prototype"] = Object["assign"](Object["create"](TA["prototype"]), {
                    constructor: YS,
                    isSkinnedMesh: !0x0,
                    bind: function (mN, mX) {
                        (this["skeleton"] = mN),
                            void 0x0 === mX && (this["updateMatrixWorld"](!0x0), this["skeleton"]["calculateInverses"](), (mX = this["matrixWorld"])),
                            this["bindMatrix"]["copy"](mX),
                            this["bindMatrixInverse"]["getInverse"](mX);
                    },
                    pose: function () {
                        this["skeleton"]["pose"]();
                    },
                    normalizeSkinWeights: function () {
                        for (var mN = new E8(), mX = this["geometry"]["attributes"]["skinWeight"], mf = 0x0, mP = mX["count"]; mf < mP; mf++) {
                            (mN["x"] = mX["getX"](mf)), (mN["y"] = mX["getY"](mf)), (mN["z"] = mX["getZ"](mf)), (mN["w"] = mX["getW"](mf));
                            var mI = 0x1 / mN["manhattanLength"]();
                            mI !== 0x1 / 0x0 ? mN["multiplyScalar"](mI) : mN["set"](0x1, 0x0, 0x0, 0x0), mX["setXYZW"](mf, mN["x"], mN["y"], mN["z"], mN["w"]);
                        }
                    },
                    updateMatrixWorld: function (mN) {
                        TA["prototype"]["updateMatrixWorld"]["call"](this, mN),
                            "attached" === this["bindMode"]
                                ? this["bindMatrixInverse"]["getInverse"](this["matrixWorld"])
                                : "detached" === this["bindMode"]
                                ? this["bindMatrixInverse"]["getInverse"](this["bindMatrix"])
                                : console["warn"]("THREE.SkinnedMesh:\x20Unrecognized\x20bindMode:\x20" + this["bindMode"]);
                    },
                    clone: function () {
                        return new this["constructor"](this["geometry"], this["material"])["copy"](this);
                    },
                    boneTransform:
                        ((Yk = new Ed()),
                        (Yl = new E8()),
                        (YU = new E8()),
                        (Yq = new Ed()),
                        (Yw = new Ey()),
                        function (mN, mX) {
                            var mf = this["skeleton"],
                                mP = this["geometry"];
                            Yl["fromBufferAttribute"](mP["attributes"]["skinIndex"], mN),
                                YU["fromBufferAttribute"](mP["attributes"]["skinWeight"], mN),
                                Yk["fromBufferAttribute"](mP["attributes"]["position"], mN)["applyMatrix4"](this["bindMatrix"]),
                                mX["set"](0x0, 0x0, 0x0);
                            for (var mI = 0x0; mI < 0x4; mI++) {
                                var mA = YU["getComponent"](mI);
                                if (0x0 !== mA) {
                                    var mM = Yl["getComponent"](mI);
                                    Yw["multiplyMatrices"](mf["bones"][mM]["matrixWorld"], mf["boneInverses"][mM]), mX["addScaledVector"](Yq["copy"](Yk)["applyMatrix4"](Yw), mA);
                                }
                            }
                            return mX["applyMatrix4"](this["bindMatrixInverse"]);
                        }),
                }));
            var Yg = new Ey(),
                YW = new Ey();
            function YH(mN, mX) {
                if (((mN = mN || []), (this["bones"] = mN["slice"](0x0)), (this["boneMatrices"] = new Float32Array(0x10 * this["bones"]["length"])), (this["frame"] = -0x1), void 0x0 === mX)) this["calculateInverses"]();
                else {
                    if (this["bones"]["length"] === mX["length"]) this["boneInverses"] = mX["slice"](0x0);
                    else {
                        console["warn"]("THREE.Skeleton\x20boneInverses\x20is\x20the\x20wrong\x20length."), (this["boneInverses"] = []);
                        for (var mf = 0x0, mP = this["bones"]["length"]; mf < mP; mf++) this["boneInverses"]["push"](new Ey());
                    }
                }
            }
            function Yx() {
                Eg["call"](this), (this["type"] = "Bone");
            }
            Object["assign"](YH["prototype"], {
                calculateInverses: function () {
                    this["boneInverses"] = [];
                    for (var mN = 0x0, mX = this["bones"]["length"]; mN < mX; mN++) {
                        var mf = new Ey();
                        this["bones"][mN] && mf["getInverse"](this["bones"][mN]["matrixWorld"]), this["boneInverses"]["push"](mf);
                    }
                },
                pose: function () {
                    var mN, mX, mf;
                    for (mX = 0x0, mf = this["bones"]["length"]; mX < mf; mX++) (mN = this["bones"][mX]) && mN["matrixWorld"]["getInverse"](this["boneInverses"][mX]);
                    for (mX = 0x0, mf = this["bones"]["length"]; mX < mf; mX++)
                        (mN = this["bones"][mX]) &&
                            (mN["parent"] && mN["parent"]["isBone"] ? (mN["matrix"]["getInverse"](mN["parent"]["matrixWorld"]), mN["matrix"]["multiply"](mN["matrixWorld"])) : mN["matrix"]["copy"](mN["matrixWorld"]),
                            mN["matrix"]["decompose"](mN["position"], mN["quaternion"], mN["scale"]));
                },
                update: function () {
                    for (var mN = this["bones"], mX = this["boneInverses"], mf = this["boneMatrices"], mP = this["boneTexture"], mI = 0x0, mA = mN["length"]; mI < mA; mI++) {
                        var mM = mN[mI] ? mN[mI]["matrixWorld"] : YW;
                        Yg["multiplyMatrices"](mM, mX[mI]), Yg["toArray"](mf, 0x10 * mI);
                    }
                    void 0x0 !== mP && (mP["needsUpdate"] = !0x0);
                },
                clone: function () {
                    return new YH(this["bones"], this["boneInverses"]);
                },
                getBoneByName: function (mN) {
                    for (var mX = 0x0, mf = this["bones"]["length"]; mX < mf; mX++) {
                        var mP = this["bones"][mX];
                        if (mP["name"] === mN) return mP;
                    }
                },
                dispose: function () {
                    this["boneTexture"] && (this["boneTexture"]["dispose"](), (this["boneTexture"] = void 0x0));
                },
            }),
                (Yx["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), { constructor: Yx, isBone: !0x0 }));
            var YK = new Ey(),
                YV = new Ey(),
                YJ = [],
                YG = new TA();
            function YL(mN, mX, mf) {
                TA["call"](this, mN, mX), (this["instanceMatrix"] = new Rx(new Float32Array(0x10 * mf), 0x10)), (this["count"] = mf), (this["frustumCulled"] = !0x1);
            }
            function YQ(mN) {
                Rg["call"](this),
                    (this["type"] = "LineBasicMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["linewidth"] = 0x1),
                    (this["linecap"] = "round"),
                    (this["linejoin"] = "round"),
                    (this["morphTargets"] = !0x1),
                    this["setValues"](mN);
            }
            (YL["prototype"] = Object["assign"](Object["create"](TA["prototype"]), {
                constructor: YL,
                isInstancedMesh: !0x0,
                getMatrixAt: function (mN, mX) {
                    mX["fromArray"](this["instanceMatrix"]["array"], 0x10 * mN);
                },
                raycast: function (mN, mX) {
                    var mf = this["matrixWorld"],
                        mP = this["count"];
                    if (((YG["geometry"] = this["geometry"]), (YG["material"] = this["material"]), void 0x0 !== YG["material"]))
                        for (var mI = 0x0; mI < mP; mI++) {
                            this["getMatrixAt"](mI, YK), YV["multiplyMatrices"](mf, YK), (YG["matrixWorld"] = YV), YG["raycast"](mN, YJ);
                            for (var mA = 0x0, mM = YJ["length"]; mA < mM; mA++) {
                                var mp = YJ[mA];
                                (mp["instanceId"] = mI), (mp["object"] = this), mX["push"](mp);
                            }
                            YJ["length"] = 0x0;
                        }
                },
                setMatrixAt: function (mN, mX) {
                    mX["toArray"](this["instanceMatrix"]["array"], 0x10 * mN);
                },
                updateMorphTargets: function () {},
            })),
                (YQ["prototype"] = Object["create"](Rg["prototype"])),
                (YQ["prototype"]["constructor"] = YQ),
                (YQ["prototype"]["isLineBasicMaterial"] = !0x0),
                (YQ["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        (this["linewidth"] = mN["linewidth"]),
                        (this["linecap"] = mN["linecap"]),
                        (this["linejoin"] = mN["linejoin"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        this
                    );
                });
            var Yz = new Ed(),
                n0 = new Ed(),
                n1 = new Ey(),
                n2 = new RY(),
                n3 = new R7();
            function n4(mN, mX, mf) {
                0x1 === mf && console["error"]("THREE.Line:\x20parameter\x20THREE.LinePieces\x20no\x20longer\x20supported.\x20Use\x20THREE.LineSegments\x20instead."),
                    Eg["call"](this),
                    (this["type"] = "Line"),
                    (this["geometry"] = void 0x0 !== mN ? mN : new TR()),
                    (this["material"] = void 0x0 !== mX ? mX : new YQ()),
                    this["updateMorphTargets"]();
            }
            n4["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                constructor: n4,
                isLine: !0x0,
                computeLineDistances: function () {
                    var mN = this["geometry"];
                    if (mN["isBufferGeometry"]) {
                        if (null === mN["index"]) {
                            for (var mX = mN["attributes"]["position"], mf = [0x0], mP = 0x1, mI = mX["count"]; mP < mI; mP++)
                                Yz["fromBufferAttribute"](mX, mP - 0x1), n0["fromBufferAttribute"](mX, mP), (mf[mP] = mf[mP - 0x1]), (mf[mP] += Yz["distanceTo"](n0));
                            mN["setAttribute"]("lineDistance", new T0(mf, 0x1));
                        } else console["warn"]("THREE.Line.computeLineDistances():\x20Computation\x20only\x20possible\x20with\x20non-indexed\x20BufferGeometry.");
                    } else {
                        if (mN["isGeometry"]) {
                            var mA = mN["vertices"];
                            (mf = mN["lineDistances"])[0x0] = 0x0;
                            for (mP = 0x1, mI = mA["length"]; mP < mI; mP++) (mf[mP] = mf[mP - 0x1]), (mf[mP] += mA[mP - 0x1]["distanceTo"](mA[mP]));
                        }
                    }
                    return this;
                },
                raycast: function (mN, mX) {
                    var mf = this["geometry"],
                        mP = this["matrixWorld"],
                        mI = mN["params"]["Line"]["threshold"];
                    if ((null === mf["boundingSphere"] && mf["computeBoundingSphere"](), n3["copy"](mf["boundingSphere"]), n3["applyMatrix4"](mP), (n3["radius"] += mI), !0x1 !== mN["ray"]["intersectsSphere"](n3))) {
                        n1["getInverse"](mP), n2["copy"](mN["ray"])["applyMatrix4"](n1);
                        var mA = mI / ((this["scale"]["x"] + this["scale"]["y"] + this["scale"]["z"]) / 0x3),
                            mM = mA * mA,
                            mp = new Ed(),
                            mk = new Ed(),
                            mU = new Ed(),
                            mq = new Ed(),
                            mw = this && this["isLineSegments"] ? 0x2 : 0x1;
                        if (mf["isBufferGeometry"]) {
                            var mO = mf["index"],
                                mj = mf["attributes"]["position"]["array"];
                            if (null !== mO)
                                for (var mh = mO["array"], mS = 0x0, mg = mh["length"] - 0x1; mS < mg; mS += mw) {
                                    var mW = mh[mS],
                                        mH = mh[mS + 0x1];
                                    if ((mp["fromArray"](mj, 0x3 * mW), mk["fromArray"](mj, 0x3 * mH), !(n2["distanceSqToSegment"](mp, mk, mq, mU) > mM)))
                                        mq["applyMatrix4"](this["matrixWorld"]),
                                            (mV = mN["ray"]["origin"]["distanceTo"](mq)) < mN["near"] ||
                                                mV > mN["far"] ||
                                                mX["push"]({ distance: mV, point: mU["clone"]()["applyMatrix4"](this["matrixWorld"]), index: mS, face: null, faceIndex: null, object: this });
                                }
                            else
                                for (mS = 0x0, mg = mj["length"] / 0x3 - 0x1; mS < mg; mS += mw) {
                                    if ((mp["fromArray"](mj, 0x3 * mS), mk["fromArray"](mj, 0x3 * mS + 0x3), !(n2["distanceSqToSegment"](mp, mk, mq, mU) > mM)))
                                        mq["applyMatrix4"](this["matrixWorld"]),
                                            (mV = mN["ray"]["origin"]["distanceTo"](mq)) < mN["near"] ||
                                                mV > mN["far"] ||
                                                mX["push"]({ distance: mV, point: mU["clone"]()["applyMatrix4"](this["matrixWorld"]), index: mS, face: null, faceIndex: null, object: this });
                                }
                        } else {
                            if (mf["isGeometry"]) {
                                var mx = mf["vertices"],
                                    mK = mx["length"];
                                for (mS = 0x0; mS < mK - 0x1; mS += mw) {
                                    var mV;
                                    if (!(n2["distanceSqToSegment"](mx[mS], mx[mS + 0x1], mq, mU) > mM))
                                        mq["applyMatrix4"](this["matrixWorld"]),
                                            (mV = mN["ray"]["origin"]["distanceTo"](mq)) < mN["near"] ||
                                                mV > mN["far"] ||
                                                mX["push"]({ distance: mV, point: mU["clone"]()["applyMatrix4"](this["matrixWorld"]), index: mS, face: null, faceIndex: null, object: this });
                                }
                            }
                        }
                    }
                },
                updateMorphTargets: function () {
                    var mN,
                        mX,
                        mf,
                        mP = this["geometry"];
                    if (mP["isBufferGeometry"]) {
                        var mI = mP["morphAttributes"],
                            mA = Object["keys"](mI);
                        if (mA["length"] > 0x0) {
                            var mM = mI[mA[0x0]];
                            if (void 0x0 !== mM) {
                                for (this["morphTargetInfluences"] = [], this["morphTargetDictionary"] = {}, mN = 0x0, mX = mM["length"]; mN < mX; mN++)
                                    (mf = mM[mN]["name"] || String(mN)), this["morphTargetInfluences"]["push"](0x0), (this["morphTargetDictionary"][mf] = mN);
                            }
                        }
                    } else {
                        var mp = mP["morphTargets"];
                        void 0x0 !== mp && mp["length"] > 0x0 && console["error"]("THREE.Line.updateMorphTargets()\x20does\x20not\x20support\x20THREE.Geometry.\x20Use\x20THREE.BufferGeometry\x20instead.");
                    }
                },
                clone: function () {
                    return new this["constructor"](this["geometry"], this["material"])["copy"](this);
                },
            });
            var n5 = new Ed(),
                n6 = new Ed();
            function n7(mN, mX) {
                n4["call"](this, mN, mX), (this["type"] = "LineSegments");
            }
            function n8(mN, mX) {
                n4["call"](this, mN, mX), (this["type"] = "LineLoop");
            }
            function n9(mN) {
                Rg["call"](this),
                    (this["type"] = "PointsMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["map"] = null),
                    (this["alphaMap"] = null),
                    (this["size"] = 0x1),
                    (this["sizeAttenuation"] = !0x0),
                    (this["morphTargets"] = !0x1),
                    this["setValues"](mN);
            }
            (n7["prototype"] = Object["assign"](Object["create"](n4["prototype"]), {
                constructor: n7,
                isLineSegments: !0x0,
                computeLineDistances: function () {
                    var mN = this["geometry"];
                    if (mN["isBufferGeometry"]) {
                        if (null === mN["index"]) {
                            for (var mX = mN["attributes"]["position"], mf = [], mP = 0x0, mI = mX["count"]; mP < mI; mP += 0x2)
                                n5["fromBufferAttribute"](mX, mP), n6["fromBufferAttribute"](mX, mP + 0x1), (mf[mP] = 0x0 === mP ? 0x0 : mf[mP - 0x1]), (mf[mP + 0x1] = mf[mP] + n5["distanceTo"](n6));
                            mN["setAttribute"]("lineDistance", new T0(mf, 0x1));
                        } else console["warn"]("THREE.LineSegments.computeLineDistances():\x20Computation\x20only\x20possible\x20with\x20non-indexed\x20BufferGeometry.");
                    } else {
                        if (mN["isGeometry"]) {
                            var mA = mN["vertices"];
                            for (mf = mN["lineDistances"], mP = 0x0, mI = mA["length"]; mP < mI; mP += 0x2)
                                n5["copy"](mA[mP]), n6["copy"](mA[mP + 0x1]), (mf[mP] = 0x0 === mP ? 0x0 : mf[mP - 0x1]), (mf[mP + 0x1] = mf[mP] + n5["distanceTo"](n6));
                        }
                    }
                    return this;
                },
            })),
                (n8["prototype"] = Object["assign"](Object["create"](n4["prototype"]), { constructor: n8, isLineLoop: !0x0 })),
                (n9["prototype"] = Object["create"](Rg["prototype"])),
                (n9["prototype"]["constructor"] = n9),
                (n9["prototype"]["isPointsMaterial"] = !0x0),
                (n9["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        (this["map"] = mN["map"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["size"] = mN["size"]),
                        (this["sizeAttenuation"] = mN["sizeAttenuation"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        this
                    );
                });
            var nE = new Ey(),
                nR = new RY(),
                nT = new R7(),
                nC = new Ed();
            function nd(mN, mX) {
                Eg["call"](this), (this["type"] = "Points"), (this["geometry"] = void 0x0 !== mN ? mN : new TR()), (this["material"] = void 0x0 !== mX ? mX : new n9()), this["updateMorphTargets"]();
            }
            function nY(mN, mX, mf, mP, mI, mA, mM) {
                var mp = nR["distanceSqToPoint"](mN);
                if (mp < mf) {
                    var mk = new Ed();
                    nR["closestPointToPoint"](mN, mk), mk["applyMatrix4"](mP);
                    var mU = mI["ray"]["origin"]["distanceTo"](mk);
                    if (mU < mI["near"] || mU > mI["far"]) return;
                    mA["push"]({ distance: mU, distanceToRay: Math["sqrt"](mp), point: mk, index: mX, face: null, object: mM });
                }
            }
            function nB(mN, mX, mf, mP, mI, mA, mM, mp, mk) {
                E7["call"](this, mN, mX, mf, mP, mI, mA, mM, mp, mk),
                    (this["format"] = void 0x0 !== mM ? mM : rX),
                    (this["minFilter"] = void 0x0 !== mA ? mA : rB),
                    (this["magFilter"] = void 0x0 !== mI ? mI : rB),
                    (this["generateMipmaps"] = !0x1);
            }
            function nF(mN, mX, mf, mP, mI, mA, mM, mp, mk, mU, mq, mw) {
                E7["call"](this, null, mA, mM, mp, mk, mU, mP, mI, mq, mw), (this["image"] = { width: mX, height: mf }), (this["mipmaps"] = mN), (this["flipY"] = !0x1), (this["generateMipmaps"] = !0x1);
            }
            function nb(mN, mX, mf, mP, mI, mA, mM, mp, mk) {
                E7["call"](this, mN, mX, mf, mP, mI, mA, mM, mp, mk), (this["needsUpdate"] = !0x0);
            }
            function nZ(mN, mX, mf, mP, mI, mA, mM, mp, mk, mU) {
                if ((mU = void 0x0 !== mU ? mU : rI) !== rI && mU !== rA) throw new Error("DepthTexture\x20format\x20must\x20be\x20either\x20THREE.DepthFormat\x20or\x20THREE.DepthStencilFormat");
                void 0x0 === mf && mU === rI && (mf = rm),
                    void 0x0 === mf && mU === rA && (mf = rN),
                    E7["call"](this, null, mP, mI, mA, mM, mp, mU, mf, mk),
                    (this["image"] = { width: mN, height: mX }),
                    (this["magFilter"] = void 0x0 !== mM ? mM : rC),
                    (this["minFilter"] = void 0x0 !== mp ? mp : rC),
                    (this["flipY"] = !0x1),
                    (this["generateMipmaps"] = !0x1);
            }
            function nm(mN) {
                TR["call"](this), (this["type"] = "WireframeGeometry");
                var mX,
                    mf,
                    mP,
                    mI,
                    mA,
                    mM,
                    mp,
                    mk,
                    mU,
                    mq,
                    mw = [],
                    mO = [0x0, 0x0],
                    mj = {},
                    mh = ["a", "b", "c"];
                if (mN && mN["isGeometry"]) {
                    var mS = mN["faces"];
                    for (mX = 0x0, mP = mS["length"]; mX < mP; mX++) {
                        var mg = mS[mX];
                        for (mf = 0x0; mf < 0x3; mf++)
                            (mp = mg[mh[mf]]),
                                (mk = mg[mh[(mf + 0x1) % 0x3]]),
                                (mO[0x0] = Math["min"](mp, mk)),
                                (mO[0x1] = Math["max"](mp, mk)),
                                void 0x0 === mj[(mU = mO[0x0] + "," + mO[0x1])] && (mj[mU] = { index1: mO[0x0], index2: mO[0x1] });
                    }
                    for (mU in mj) (mM = mj[mU]), (mq = mN["vertices"][mM["index1"]]), mw["push"](mq["x"], mq["y"], mq["z"]), (mq = mN["vertices"][mM["index2"]]), mw["push"](mq["x"], mq["y"], mq["z"]);
                } else {
                    if (mN && mN["isBufferGeometry"]) {
                        var mW, mH, mx, mK, mV, mJ, mG;
                        if (((mq = new Ed()), null !== mN["index"])) {
                            for (mW = mN["attributes"]["position"], mH = mN["index"], 0x0 === (mx = mN["groups"])["length"] && (mx = [{ start: 0x0, count: mH["count"], materialIndex: 0x0 }]), mI = 0x0, mA = mx["length"]; mI < mA; ++mI)
                                for (mX = mV = (mK = mx[mI])["start"], mP = mV + mK["count"]; mX < mP; mX += 0x3)
                                    for (mf = 0x0; mf < 0x3; mf++)
                                        (mp = mH["getX"](mX + mf)),
                                            (mk = mH["getX"](mX + ((mf + 0x1) % 0x3))),
                                            (mO[0x0] = Math["min"](mp, mk)),
                                            (mO[0x1] = Math["max"](mp, mk)),
                                            void 0x0 === mj[(mU = mO[0x0] + "," + mO[0x1])] && (mj[mU] = { index1: mO[0x0], index2: mO[0x1] });
                            for (mU in mj) (mM = mj[mU]), mq["fromBufferAttribute"](mW, mM["index1"]), mw["push"](mq["x"], mq["y"], mq["z"]), mq["fromBufferAttribute"](mW, mM["index2"]), mw["push"](mq["x"], mq["y"], mq["z"]);
                        } else {
                            for (mX = 0x0, mP = (mW = mN["attributes"]["position"])["count"] / 0x3; mX < mP; mX++)
                                for (mf = 0x0; mf < 0x3; mf++)
                                    (mJ = 0x3 * mX + mf),
                                        mq["fromBufferAttribute"](mW, mJ),
                                        mw["push"](mq["x"], mq["y"], mq["z"]),
                                        (mG = 0x3 * mX + ((mf + 0x1) % 0x3)),
                                        mq["fromBufferAttribute"](mW, mG),
                                        mw["push"](mq["x"], mq["y"], mq["z"]);
                        }
                    }
                }
                this["setAttribute"]("position", new T0(mw, 0x3));
            }
            function nv(mN, mX, mf) {
                TO["call"](this), (this["type"] = "ParametricGeometry"), (this["parameters"] = { func: mN, slices: mX, stacks: mf }), this["fromBufferGeometry"](new ny(mN, mX, mf)), this["mergeVertices"]();
            }
            function ny(mN, mX, mf) {
                TR["call"](this), (this["type"] = "ParametricBufferGeometry"), (this["parameters"] = { func: mN, slices: mX, stacks: mf });
                var mP,
                    mI,
                    mA = [],
                    mM = [],
                    mp = [],
                    mk = [],
                    mU = 0.00001,
                    mq = new Ed(),
                    mw = new Ed(),
                    mO = new Ed(),
                    mj = new Ed(),
                    mh = new Ed();
                mN["length"] < 0x3 && console["error"]("THREE.ParametricGeometry:\x20Function\x20must\x20now\x20modify\x20a\x20Vector3\x20as\x20third\x20parameter.");
                var mS = mX + 0x1;
                for (mP = 0x0; mP <= mf; mP++) {
                    var mg = mP / mf;
                    for (mI = 0x0; mI <= mX; mI++) {
                        var mW = mI / mX;
                        mN(mW, mg, mw),
                            mM["push"](mw["x"], mw["y"], mw["z"]),
                            mW - mU >= 0x0 ? (mN(mW - mU, mg, mO), mj["subVectors"](mw, mO)) : (mN(mW + mU, mg, mO), mj["subVectors"](mO, mw)),
                            mg - mU >= 0x0 ? (mN(mW, mg - mU, mO), mh["subVectors"](mw, mO)) : (mN(mW, mg + mU, mO), mh["subVectors"](mO, mw)),
                            mq["crossVectors"](mj, mh)["normalize"](),
                            mp["push"](mq["x"], mq["y"], mq["z"]),
                            mk["push"](mW, mg);
                    }
                }
                for (mP = 0x0; mP < mf; mP++)
                    for (mI = 0x0; mI < mX; mI++) {
                        var mH = mP * mS + mI,
                            mx = mP * mS + mI + 0x1,
                            mK = (mP + 0x1) * mS + mI + 0x1,
                            mV = (mP + 0x1) * mS + mI;
                        mA["push"](mH, mx, mV), mA["push"](mx, mK, mV);
                    }
                this["setIndex"](mA), this["setAttribute"]("position", new T0(mM, 0x3)), this["setAttribute"]("normal", new T0(mp, 0x3)), this["setAttribute"]("uv", new T0(mk, 0x2));
            }
            function nD(mN, mX, mf, mP) {
                TO["call"](this), (this["type"] = "PolyhedronGeometry"), (this["parameters"] = { vertices: mN, indices: mX, radius: mf, detail: mP }), this["fromBufferGeometry"](new nN(mN, mX, mf, mP)), this["mergeVertices"]();
            }
            function nN(mN, mX, mf, mP) {
                TR["call"](this), (this["type"] = "PolyhedronBufferGeometry"), (this["parameters"] = { vertices: mN, indices: mX, radius: mf, detail: mP }), (mf = mf || 0x1);
                var mI = [],
                    mA = [];
                function mM(mO, mj, mh, mS) {
                    var mg,
                        mW,
                        mH = Math["pow"](0x2, mS),
                        mx = [];
                    for (mg = 0x0; mg <= mH; mg++) {
                        mx[mg] = [];
                        var mK = mO["clone"]()["lerp"](mh, mg / mH),
                            mV = mj["clone"]()["lerp"](mh, mg / mH),
                            mJ = mH - mg;
                        for (mW = 0x0; mW <= mJ; mW++) mx[mg][mW] = 0x0 === mW && mg === mH ? mK : mK["clone"]()["lerp"](mV, mW / mJ);
                    }
                    for (mg = 0x0; mg < mH; mg++)
                        for (mW = 0x0; mW < 0x2 * (mH - mg) - 0x1; mW++) {
                            var mG = Math["floor"](mW / 0x2);
                            mW % 0x2 == 0x0 ? (mp(mx[mg][mG + 0x1]), mp(mx[mg + 0x1][mG]), mp(mx[mg][mG])) : (mp(mx[mg][mG + 0x1]), mp(mx[mg + 0x1][mG + 0x1]), mp(mx[mg + 0x1][mG]));
                        }
                }
                function mp(mO) {
                    mI["push"](mO["x"], mO["y"], mO["z"]);
                }
                function mk(mO, mj) {
                    var mh = 0x3 * mO;
                    (mj["x"] = mN[mh + 0x0]), (mj["y"] = mN[mh + 0x1]), (mj["z"] = mN[mh + 0x2]);
                }
                function mU(mO, mj, mh, mS) {
                    mS < 0x0 && 0x1 === mO["x"] && (mA[mj] = mO["x"] - 0x1), 0x0 === mh["x"] && 0x0 === mh["z"] && (mA[mj] = mS / 0x2 / Math["PI"] + 0.5);
                }
                function mq(mO) {
                    return Math["atan2"](mO["z"], -mO["x"]);
                }
                function mw(mO) {
                    return Math["atan2"](-mO["y"], Math["sqrt"](mO["x"] * mO["x"] + mO["z"] * mO["z"]));
                }
                !(function (mO) {
                    for (var mj = new Ed(), mh = new Ed(), mS = new Ed(), mg = 0x0; mg < mX["length"]; mg += 0x3) mk(mX[mg + 0x0], mj), mk(mX[mg + 0x1], mh), mk(mX[mg + 0x2], mS), mM(mj, mh, mS, mO);
                })((mP = mP || 0x0)),
                    (function (mO) {
                        for (var mj = new Ed(), mh = 0x0; mh < mI["length"]; mh += 0x3)
                            (mj["x"] = mI[mh + 0x0]), (mj["y"] = mI[mh + 0x1]), (mj["z"] = mI[mh + 0x2]), mj["normalize"]()["multiplyScalar"](mO), (mI[mh + 0x0] = mj["x"]), (mI[mh + 0x1] = mj["y"]), (mI[mh + 0x2] = mj["z"]);
                    })(mf),
                    (function () {
                        for (var mO = new Ed(), mj = 0x0; mj < mI["length"]; mj += 0x3) {
                            (mO["x"] = mI[mj + 0x0]), (mO["y"] = mI[mj + 0x1]), (mO["z"] = mI[mj + 0x2]);
                            var mh = mq(mO) / 0x2 / Math["PI"] + 0.5,
                                mS = mw(mO) / Math["PI"] + 0.5;
                            mA["push"](mh, 0x1 - mS);
                        }
                        (function () {
                            for (var mg = new Ed(), mW = new Ed(), mH = new Ed(), mx = new Ed(), mK = new E3(), mV = new E3(), mJ = new E3(), mG = 0x0, mL = 0x0; mG < mI["length"]; mG += 0x9, mL += 0x6) {
                                mg["set"](mI[mG + 0x0], mI[mG + 0x1], mI[mG + 0x2]),
                                    mW["set"](mI[mG + 0x3], mI[mG + 0x4], mI[mG + 0x5]),
                                    mH["set"](mI[mG + 0x6], mI[mG + 0x7], mI[mG + 0x8]),
                                    mK["set"](mA[mL + 0x0], mA[mL + 0x1]),
                                    mV["set"](mA[mL + 0x2], mA[mL + 0x3]),
                                    mJ["set"](mA[mL + 0x4], mA[mL + 0x5]),
                                    mx["copy"](mg)["add"](mW)["add"](mH)["divideScalar"](0x3);
                                var mQ = mq(mx);
                                mU(mK, mL + 0x0, mg, mQ), mU(mV, mL + 0x2, mW, mQ), mU(mJ, mL + 0x4, mH, mQ);
                            }
                        })(),
                            (function () {
                                for (var mg = 0x0; mg < mA["length"]; mg += 0x6) {
                                    var mW = mA[mg + 0x0],
                                        mH = mA[mg + 0x2],
                                        mx = mA[mg + 0x4],
                                        mK = Math["max"](mW, mH, mx),
                                        mV = Math["min"](mW, mH, mx);
                                    mK > 0.9 && mV < 0.1 && (mW < 0.2 && (mA[mg + 0x0] += 0x1), mH < 0.2 && (mA[mg + 0x2] += 0x1), mx < 0.2 && (mA[mg + 0x4] += 0x1));
                                }
                            })();
                    })(),
                    this["setAttribute"]("position", new T0(mI, 0x3)),
                    this["setAttribute"]("normal", new T0(mI["slice"](), 0x3)),
                    this["setAttribute"]("uv", new T0(mA, 0x2)),
                    0x0 === mP ? this["computeVertexNormals"]() : this["normalizeNormals"]();
            }
            function nX(mN, mX) {
                TO["call"](this), (this["type"] = "TetrahedronGeometry"), (this["parameters"] = { radius: mN, detail: mX }), this["fromBufferGeometry"](new nf(mN, mX)), this["mergeVertices"]();
            }
            function nf(mN, mX) {
                nN["call"](this, [0x1, 0x1, 0x1, -0x1, -0x1, 0x1, -0x1, 0x1, -0x1, 0x1, -0x1, -0x1], [0x2, 0x1, 0x0, 0x0, 0x3, 0x2, 0x1, 0x3, 0x0, 0x2, 0x3, 0x1], mN, mX),
                    (this["type"] = "TetrahedronBufferGeometry"),
                    (this["parameters"] = { radius: mN, detail: mX });
            }
            function nP(mN, mX) {
                TO["call"](this), (this["type"] = "OctahedronGeometry"), (this["parameters"] = { radius: mN, detail: mX }), this["fromBufferGeometry"](new nI(mN, mX)), this["mergeVertices"]();
            }
            function nI(mN, mX) {
                nN["call"](
                    this,
                    [0x1, 0x0, 0x0, -0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, -0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, -0x1],
                    [0x0, 0x2, 0x4, 0x0, 0x4, 0x3, 0x0, 0x3, 0x5, 0x0, 0x5, 0x2, 0x1, 0x2, 0x5, 0x1, 0x5, 0x3, 0x1, 0x3, 0x4, 0x1, 0x4, 0x2],
                    mN,
                    mX
                ),
                    (this["type"] = "OctahedronBufferGeometry"),
                    (this["parameters"] = { radius: mN, detail: mX });
            }
            function nA(mN, mX) {
                TO["call"](this), (this["type"] = "IcosahedronGeometry"), (this["parameters"] = { radius: mN, detail: mX }), this["fromBufferGeometry"](new nM(mN, mX)), this["mergeVertices"]();
            }
            function nM(mN, mX) {
                var mf = (0x1 + Math["sqrt"](0x5)) / 0x2,
                    mP = [-0x1, mf, 0x0, 0x1, mf, 0x0, -0x1, -mf, 0x0, 0x1, -mf, 0x0, 0x0, -0x1, mf, 0x0, 0x1, mf, 0x0, -0x1, -mf, 0x0, 0x1, -mf, mf, 0x0, -0x1, mf, 0x0, 0x1, -mf, 0x0, -0x1, -mf, 0x0, 0x1];
                nN["call"](
                    this,
                    mP,
                    [
                        0x0,
                        0xb,
                        0x5,
                        0x0,
                        0x5,
                        0x1,
                        0x0,
                        0x1,
                        0x7,
                        0x0,
                        0x7,
                        0xa,
                        0x0,
                        0xa,
                        0xb,
                        0x1,
                        0x5,
                        0x9,
                        0x5,
                        0xb,
                        0x4,
                        0xb,
                        0xa,
                        0x2,
                        0xa,
                        0x7,
                        0x6,
                        0x7,
                        0x1,
                        0x8,
                        0x3,
                        0x9,
                        0x4,
                        0x3,
                        0x4,
                        0x2,
                        0x3,
                        0x2,
                        0x6,
                        0x3,
                        0x6,
                        0x8,
                        0x3,
                        0x8,
                        0x9,
                        0x4,
                        0x9,
                        0x5,
                        0x2,
                        0x4,
                        0xb,
                        0x6,
                        0x2,
                        0xa,
                        0x8,
                        0x6,
                        0x7,
                        0x9,
                        0x8,
                        0x1,
                    ],
                    mN,
                    mX
                ),
                    (this["type"] = "IcosahedronBufferGeometry"),
                    (this["parameters"] = { radius: mN, detail: mX });
            }
            function np(mN, mX) {
                TO["call"](this), (this["type"] = "DodecahedronGeometry"), (this["parameters"] = { radius: mN, detail: mX }), this["fromBufferGeometry"](new nk(mN, mX)), this["mergeVertices"]();
            }
            function nk(mN, mX) {
                var mf = (0x1 + Math["sqrt"](0x5)) / 0x2,
                    mP = 0x1 / mf,
                    mI = [
                        -0x1,
                        -0x1,
                        -0x1,
                        -0x1,
                        -0x1,
                        0x1,
                        -0x1,
                        0x1,
                        -0x1,
                        -0x1,
                        0x1,
                        0x1,
                        0x1,
                        -0x1,
                        -0x1,
                        0x1,
                        -0x1,
                        0x1,
                        0x1,
                        0x1,
                        -0x1,
                        0x1,
                        0x1,
                        0x1,
                        0x0,
                        -mP,
                        -mf,
                        0x0,
                        -mP,
                        mf,
                        0x0,
                        mP,
                        -mf,
                        0x0,
                        mP,
                        mf,
                        -mP,
                        -mf,
                        0x0,
                        -mP,
                        mf,
                        0x0,
                        mP,
                        -mf,
                        0x0,
                        mP,
                        mf,
                        0x0,
                        -mf,
                        0x0,
                        -mP,
                        mf,
                        0x0,
                        -mP,
                        -mf,
                        0x0,
                        mP,
                        mf,
                        0x0,
                        mP,
                    ];
                nN["call"](
                    this,
                    mI,
                    [
                        0x3,
                        0xb,
                        0x7,
                        0x3,
                        0x7,
                        0xf,
                        0x3,
                        0xf,
                        0xd,
                        0x7,
                        0x13,
                        0x11,
                        0x7,
                        0x11,
                        0x6,
                        0x7,
                        0x6,
                        0xf,
                        0x11,
                        0x4,
                        0x8,
                        0x11,
                        0x8,
                        0xa,
                        0x11,
                        0xa,
                        0x6,
                        0x8,
                        0x0,
                        0x10,
                        0x8,
                        0x10,
                        0x2,
                        0x8,
                        0x2,
                        0xa,
                        0x0,
                        0xc,
                        0x1,
                        0x0,
                        0x1,
                        0x12,
                        0x0,
                        0x12,
                        0x10,
                        0x6,
                        0xa,
                        0x2,
                        0x6,
                        0x2,
                        0xd,
                        0x6,
                        0xd,
                        0xf,
                        0x2,
                        0x10,
                        0x12,
                        0x2,
                        0x12,
                        0x3,
                        0x2,
                        0x3,
                        0xd,
                        0x12,
                        0x1,
                        0x9,
                        0x12,
                        0x9,
                        0xb,
                        0x12,
                        0xb,
                        0x3,
                        0x4,
                        0xe,
                        0xc,
                        0x4,
                        0xc,
                        0x0,
                        0x4,
                        0x0,
                        0x8,
                        0xb,
                        0x9,
                        0x5,
                        0xb,
                        0x5,
                        0x13,
                        0xb,
                        0x13,
                        0x7,
                        0x13,
                        0x5,
                        0xe,
                        0x13,
                        0xe,
                        0x4,
                        0x13,
                        0x4,
                        0x11,
                        0x1,
                        0xc,
                        0xe,
                        0x1,
                        0xe,
                        0x5,
                        0x1,
                        0x5,
                        0x9,
                    ],
                    mN,
                    mX
                ),
                    (this["type"] = "DodecahedronBufferGeometry"),
                    (this["parameters"] = { radius: mN, detail: mX });
            }
            function nU(mN, mX, mf, mP, mI, mA) {
                TO["call"](this),
                    (this["type"] = "TubeGeometry"),
                    (this["parameters"] = { path: mN, tubularSegments: mX, radius: mf, radialSegments: mP, closed: mI }),
                    void 0x0 !== mA && console["warn"]("THREE.TubeGeometry:\x20taper\x20has\x20been\x20removed.");
                var mM = new nq(mN, mX, mf, mP, mI);
                (this["tangents"] = mM["tangents"]), (this["normals"] = mM["normals"]), (this["binormals"] = mM["binormals"]), this["fromBufferGeometry"](mM), this["mergeVertices"]();
            }
            function nq(mN, mX, mf, mP, mI) {
                TR["call"](this),
                    (this["type"] = "TubeBufferGeometry"),
                    (this["parameters"] = { path: mN, tubularSegments: mX, radius: mf, radialSegments: mP, closed: mI }),
                    (mX = mX || 0x40),
                    (mf = mf || 0x1),
                    (mP = mP || 0x8),
                    (mI = mI || !0x1);
                var mA = mN["computeFrenetFrames"](mX, mI);
                (this["tangents"] = mA["tangents"]), (this["normals"] = mA["normals"]), (this["binormals"] = mA["binormals"]);
                var mM,
                    mp,
                    mk = new Ed(),
                    mU = new Ed(),
                    mq = new E3(),
                    mw = new Ed(),
                    mO = [],
                    mj = [],
                    mh = [],
                    mS = [];
                function mg(mW) {
                    mw = mN["getPointAt"](mW / mX, mw);
                    var mH = mA["normals"][mW],
                        mx = mA["binormals"][mW];
                    for (mp = 0x0; mp <= mP; mp++) {
                        var mK = (mp / mP) * Math["PI"] * 0x2,
                            mV = Math["sin"](mK),
                            mJ = -Math["cos"](mK);
                        (mU["x"] = mJ * mH["x"] + mV * mx["x"]),
                            (mU["y"] = mJ * mH["y"] + mV * mx["y"]),
                            (mU["z"] = mJ * mH["z"] + mV * mx["z"]),
                            mU["normalize"](),
                            mj["push"](mU["x"], mU["y"], mU["z"]),
                            (mk["x"] = mw["x"] + mf * mU["x"]),
                            (mk["y"] = mw["y"] + mf * mU["y"]),
                            (mk["z"] = mw["z"] + mf * mU["z"]),
                            mO["push"](mk["x"], mk["y"], mk["z"]);
                    }
                }
                !(function () {
                    for (mM = 0x0; mM < mX; mM++) mg(mM);
                    mg(!0x1 === mI ? mX : 0x0),
                        (function () {
                            for (mM = 0x0; mM <= mX; mM++) for (mp = 0x0; mp <= mP; mp++) (mq["x"] = mM / mX), (mq["y"] = mp / mP), mh["push"](mq["x"], mq["y"]);
                        })(),
                        (function () {
                            for (mp = 0x1; mp <= mX; mp++)
                                for (mM = 0x1; mM <= mP; mM++) {
                                    var mW = (mP + 0x1) * (mp - 0x1) + (mM - 0x1),
                                        mH = (mP + 0x1) * mp + (mM - 0x1),
                                        mx = (mP + 0x1) * mp + mM,
                                        mK = (mP + 0x1) * (mp - 0x1) + mM;
                                    mS["push"](mW, mH, mK), mS["push"](mH, mx, mK);
                                }
                        })();
                })(),
                    this["setIndex"](mS),
                    this["setAttribute"]("position", new T0(mO, 0x3)),
                    this["setAttribute"]("normal", new T0(mj, 0x3)),
                    this["setAttribute"]("uv", new T0(mh, 0x2));
            }
            function nw(mN, mX, mf, mP, mI, mA, mM) {
                TO["call"](this),
                    (this["type"] = "TorusKnotGeometry"),
                    (this["parameters"] = { radius: mN, tube: mX, tubularSegments: mf, radialSegments: mP, p: mI, q: mA }),
                    void 0x0 !== mM && console["warn"]("THREE.TorusKnotGeometry:\x20heightScale\x20has\x20been\x20deprecated.\x20Use\x20.scale(\x20x,\x20y,\x20z\x20)\x20instead."),
                    this["fromBufferGeometry"](new nO(mN, mX, mf, mP, mI, mA)),
                    this["mergeVertices"]();
            }
            function nO(mN, mX, mf, mP, mI, mA) {
                TR["call"](this),
                    (this["type"] = "TorusKnotBufferGeometry"),
                    (this["parameters"] = { radius: mN, tube: mX, tubularSegments: mf, radialSegments: mP, p: mI, q: mA }),
                    (mN = mN || 0x1),
                    (mX = mX || 0.4),
                    (mf = Math["floor"](mf) || 0x40),
                    (mP = Math["floor"](mP) || 0x8),
                    (mI = mI || 0x2),
                    (mA = mA || 0x3);
                var mM,
                    mp,
                    mk = [],
                    mU = [],
                    mq = [],
                    mw = [],
                    mO = new Ed(),
                    mj = new Ed(),
                    mh = new Ed(),
                    mS = new Ed(),
                    mg = new Ed(),
                    mW = new Ed(),
                    mH = new Ed();
                for (mM = 0x0; mM <= mf; ++mM) {
                    var mx = (mM / mf) * mI * Math["PI"] * 0x2;
                    for (
                        v0(mx, mI, mA, mN, mh), v0(mx + 0.01, mI, mA, mN, mS), mW["subVectors"](mS, mh), mH["addVectors"](mS, mh), mg["crossVectors"](mW, mH), mH["crossVectors"](mg, mW), mg["normalize"](), mH["normalize"](), mp = 0x0;
                        mp <= mP;
                        ++mp
                    ) {
                        var mK = (mp / mP) * Math["PI"] * 0x2,
                            mV = -mX * Math["cos"](mK),
                            mJ = mX * Math["sin"](mK);
                        (mO["x"] = mh["x"] + (mV * mH["x"] + mJ * mg["x"])),
                            (mO["y"] = mh["y"] + (mV * mH["y"] + mJ * mg["y"])),
                            (mO["z"] = mh["z"] + (mV * mH["z"] + mJ * mg["z"])),
                            mU["push"](mO["x"], mO["y"], mO["z"]),
                            mj["subVectors"](mO, mh)["normalize"](),
                            mq["push"](mj["x"], mj["y"], mj["z"]),
                            mw["push"](mM / mf),
                            mw["push"](mp / mP);
                    }
                }
                for (mp = 0x1; mp <= mf; mp++)
                    for (mM = 0x1; mM <= mP; mM++) {
                        var mG = (mP + 0x1) * (mp - 0x1) + (mM - 0x1),
                            mL = (mP + 0x1) * mp + (mM - 0x1),
                            mQ = (mP + 0x1) * mp + mM,
                            mz = (mP + 0x1) * (mp - 0x1) + mM;
                        mk["push"](mG, mL, mz), mk["push"](mL, mQ, mz);
                    }
                function v0(v1, v2, v3, v4, v5) {
                    var v6 = Math["cos"](v1),
                        v7 = Math["sin"](v1),
                        v8 = (v3 / v2) * v1,
                        v9 = Math["cos"](v8);
                    (v5["x"] = v4 * (0x2 + v9) * 0.5 * v6), (v5["y"] = v4 * (0x2 + v9) * v7 * 0.5), (v5["z"] = v4 * Math["sin"](v8) * 0.5);
                }
                this["setIndex"](mk), this["setAttribute"]("position", new T0(mU, 0x3)), this["setAttribute"]("normal", new T0(mq, 0x3)), this["setAttribute"]("uv", new T0(mw, 0x2));
            }
            function nj(mN, mX, mf, mP, mI) {
                TO["call"](this),
                    (this["type"] = "TorusGeometry"),
                    (this["parameters"] = { radius: mN, tube: mX, radialSegments: mf, tubularSegments: mP, arc: mI }),
                    this["fromBufferGeometry"](new nh(mN, mX, mf, mP, mI)),
                    this["mergeVertices"]();
            }
            function nh(mN, mX, mf, mP, mI) {
                TR["call"](this),
                    (this["type"] = "TorusBufferGeometry"),
                    (this["parameters"] = { radius: mN, tube: mX, radialSegments: mf, tubularSegments: mP, arc: mI }),
                    (mN = mN || 0x1),
                    (mX = mX || 0.4),
                    (mf = Math["floor"](mf) || 0x8),
                    (mP = Math["floor"](mP) || 0x6),
                    (mI = mI || 0x2 * Math["PI"]);
                var mA,
                    mM,
                    mp = [],
                    mk = [],
                    mU = [],
                    mq = [],
                    mw = new Ed(),
                    mO = new Ed(),
                    mj = new Ed();
                for (mA = 0x0; mA <= mf; mA++)
                    for (mM = 0x0; mM <= mP; mM++) {
                        var mh = (mM / mP) * mI,
                            mS = (mA / mf) * Math["PI"] * 0x2;
                        (mO["x"] = (mN + mX * Math["cos"](mS)) * Math["cos"](mh)),
                            (mO["y"] = (mN + mX * Math["cos"](mS)) * Math["sin"](mh)),
                            (mO["z"] = mX * Math["sin"](mS)),
                            mk["push"](mO["x"], mO["y"], mO["z"]),
                            (mw["x"] = mN * Math["cos"](mh)),
                            (mw["y"] = mN * Math["sin"](mh)),
                            mj["subVectors"](mO, mw)["normalize"](),
                            mU["push"](mj["x"], mj["y"], mj["z"]),
                            mq["push"](mM / mP),
                            mq["push"](mA / mf);
                    }
                for (mA = 0x1; mA <= mf; mA++)
                    for (mM = 0x1; mM <= mP; mM++) {
                        var mg = (mP + 0x1) * mA + mM - 0x1,
                            mW = (mP + 0x1) * (mA - 0x1) + mM - 0x1,
                            mH = (mP + 0x1) * (mA - 0x1) + mM,
                            mx = (mP + 0x1) * mA + mM;
                        mp["push"](mg, mW, mx), mp["push"](mW, mH, mx);
                    }
                this["setIndex"](mp), this["setAttribute"]("position", new T0(mk, 0x3)), this["setAttribute"]("normal", new T0(mU, 0x3)), this["setAttribute"]("uv", new T0(mq, 0x2));
            }
            (nd["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                constructor: nd,
                isPoints: !0x0,
                raycast: function (mN, mX) {
                    var mf = this["geometry"],
                        mP = this["matrixWorld"],
                        mI = mN["params"]["Points"]["threshold"];
                    if ((null === mf["boundingSphere"] && mf["computeBoundingSphere"](), nT["copy"](mf["boundingSphere"]), nT["applyMatrix4"](mP), (nT["radius"] += mI), !0x1 !== mN["ray"]["intersectsSphere"](nT))) {
                        nE["getInverse"](mP), nR["copy"](mN["ray"])["applyMatrix4"](nE);
                        var mA = mI / ((this["scale"]["x"] + this["scale"]["y"] + this["scale"]["z"]) / 0x3),
                            mM = mA * mA;
                        if (mf["isBufferGeometry"]) {
                            var mp = mf["index"],
                                mk = mf["attributes"]["position"]["array"];
                            if (null !== mp)
                                for (var mU = mp["array"], mq = 0x0, mw = mU["length"]; mq < mw; mq++) {
                                    var mO = mU[mq];
                                    nC["fromArray"](mk, 0x3 * mO), nY(nC, mO, mM, mP, mN, mX, this);
                                }
                            else {
                                mq = 0x0;
                                for (var mj = mk["length"] / 0x3; mq < mj; mq++) nC["fromArray"](mk, 0x3 * mq), nY(nC, mq, mM, mP, mN, mX, this);
                            }
                        } else {
                            var mh = mf["vertices"];
                            for (mq = 0x0, mj = mh["length"]; mq < mj; mq++) nY(mh[mq], mq, mM, mP, mN, mX, this);
                        }
                    }
                },
                updateMorphTargets: function () {
                    var mN,
                        mX,
                        mf,
                        mP = this["geometry"];
                    if (mP["isBufferGeometry"]) {
                        var mI = mP["morphAttributes"],
                            mA = Object["keys"](mI);
                        if (mA["length"] > 0x0) {
                            var mM = mI[mA[0x0]];
                            if (void 0x0 !== mM) {
                                for (this["morphTargetInfluences"] = [], this["morphTargetDictionary"] = {}, mN = 0x0, mX = mM["length"]; mN < mX; mN++)
                                    (mf = mM[mN]["name"] || String(mN)), this["morphTargetInfluences"]["push"](0x0), (this["morphTargetDictionary"][mf] = mN);
                            }
                        }
                    } else {
                        var mp = mP["morphTargets"];
                        void 0x0 !== mp && mp["length"] > 0x0 && console["error"]("THREE.Points.updateMorphTargets()\x20does\x20not\x20support\x20THREE.Geometry.\x20Use\x20THREE.BufferGeometry\x20instead.");
                    }
                },
                clone: function () {
                    return new this["constructor"](this["geometry"], this["material"])["copy"](this);
                },
            })),
                (nB["prototype"] = Object["assign"](Object["create"](E7["prototype"]), {
                    constructor: nB,
                    isVideoTexture: !0x0,
                    update: function () {
                        var mN = this["image"];
                        mN["readyState"] >= mN["HAVE_CURRENT_DATA"] && (this["needsUpdate"] = !0x0);
                    },
                })),
                (nF["prototype"] = Object["create"](E7["prototype"])),
                (nF["prototype"]["constructor"] = nF),
                (nF["prototype"]["isCompressedTexture"] = !0x0),
                (nb["prototype"] = Object["create"](E7["prototype"])),
                (nb["prototype"]["constructor"] = nb),
                (nb["prototype"]["isCanvasTexture"] = !0x0),
                (nZ["prototype"] = Object["create"](E7["prototype"])),
                (nZ["prototype"]["constructor"] = nZ),
                (nZ["prototype"]["isDepthTexture"] = !0x0),
                (nm["prototype"] = Object["create"](TR["prototype"])),
                (nm["prototype"]["constructor"] = nm),
                (nv["prototype"] = Object["create"](TO["prototype"])),
                (nv["prototype"]["constructor"] = nv),
                (ny["prototype"] = Object["create"](TR["prototype"])),
                (ny["prototype"]["constructor"] = ny),
                (nD["prototype"] = Object["create"](TO["prototype"])),
                (nD["prototype"]["constructor"] = nD),
                (nN["prototype"] = Object["create"](TR["prototype"])),
                (nN["prototype"]["constructor"] = nN),
                (nX["prototype"] = Object["create"](TO["prototype"])),
                (nX["prototype"]["constructor"] = nX),
                (nf["prototype"] = Object["create"](nN["prototype"])),
                (nf["prototype"]["constructor"] = nf),
                (nP["prototype"] = Object["create"](TO["prototype"])),
                (nP["prototype"]["constructor"] = nP),
                (nI["prototype"] = Object["create"](nN["prototype"])),
                (nI["prototype"]["constructor"] = nI),
                (nA["prototype"] = Object["create"](TO["prototype"])),
                (nA["prototype"]["constructor"] = nA),
                (nM["prototype"] = Object["create"](nN["prototype"])),
                (nM["prototype"]["constructor"] = nM),
                (np["prototype"] = Object["create"](TO["prototype"])),
                (np["prototype"]["constructor"] = np),
                (nk["prototype"] = Object["create"](nN["prototype"])),
                (nk["prototype"]["constructor"] = nk),
                (nU["prototype"] = Object["create"](TO["prototype"])),
                (nU["prototype"]["constructor"] = nU),
                (nq["prototype"] = Object["create"](TR["prototype"])),
                (nq["prototype"]["constructor"] = nq),
                (nq["prototype"]["toJSON"] = function () {
                    var mN = TR["prototype"]["toJSON"]["call"](this);
                    return (mN["path"] = this["parameters"]["path"]["toJSON"]()), mN;
                }),
                (nw["prototype"] = Object["create"](TO["prototype"])),
                (nw["prototype"]["constructor"] = nw),
                (nO["prototype"] = Object["create"](TR["prototype"])),
                (nO["prototype"]["constructor"] = nO),
                (nj["prototype"] = Object["create"](TO["prototype"])),
                (nj["prototype"]["constructor"] = nj),
                (nh["prototype"] = Object["create"](TR["prototype"])),
                (nh["prototype"]["constructor"] = nh);
            var nS = function (mN, mX, mf) {
                mf = mf || 0x2;
                var mP,
                    mI,
                    mA,
                    mM,
                    mp,
                    mk,
                    mU,
                    mq = mX && mX["length"],
                    mw = mq ? mX[0x0] * mf : mN["length"],
                    mO = ng(mN, 0x0, mw, mf, !0x0),
                    mj = [];
                if (!mO || mO["next"] === mO["prev"]) return mj;
                if (
                    (mq &&
                        (mO = (function (mS, mg, mW, mH) {
                            var mx,
                                mK,
                                mV,
                                mJ = [];
                            for (mx = 0x0, mK = mg["length"]; mx < mK; mx++) (mV = ng(mS, mg[mx] * mH, mx < mK - 0x1 ? mg[mx + 0x1] * mH : mS["length"], mH, !0x1)) === mV["next"] && (mV["steiner"] = !0x0), mJ["push"](B0(mV));
                            for (mJ["sort"](nG), mx = 0x0; mx < mJ["length"]; mx++) nL(mJ[mx], mW), (mW = nW(mW, mW["next"]));
                            return mW;
                        })(mN, mX, mO, mf)),
                    mN["length"] > 0x50 * mf)
                ) {
                    (mP = mA = mN[0x0]), (mI = mM = mN[0x1]);
                    for (var mh = mf; mh < mw; mh += mf) (mp = mN[mh]) < mP && (mP = mp), (mk = mN[mh + 0x1]) < mI && (mI = mk), mp > mA && (mA = mp), mk > mM && (mM = mk);
                    mU = 0x0 !== (mU = Math["max"](mA - mP, mM - mI)) ? 0x1 / mU : 0x0;
                }
                return nH(mO, mj, mf, mP, mI, mU), mj;
            };
            function ng(mN, mX, mf, mP, mI) {
                var mA, mM;
                if (
                    mI ===
                    (function (mp, mk, mU, mq) {
                        for (var mw = 0x0, mO = mk, mj = mU - mq; mO < mU; mO += mq) (mw += (mp[mj] - mp[mO]) * (mp[mO + 0x1] + mp[mj + 0x1])), (mj = mO);
                        return mw;
                    })(mN, mX, mf, mP) >
                        0x0
                ) {
                    for (mA = mX; mA < mf; mA += mP) mM = BE(mA, mN[mA], mN[mA + 0x1], mM);
                } else {
                    for (mA = mf - mP; mA >= mX; mA -= mP) mM = BE(mA, mN[mA], mN[mA + 0x1], mM);
                }
                return mM && B4(mM, mM["next"]) && (BR(mM), (mM = mM["next"])), mM;
            }
            function nW(mN, mX) {
                if (!mN) return mN;
                mX || (mX = mN);
                var mf,
                    mP = mN;
                do {
                    if (((mf = !0x1), mP["steiner"] || (!B4(mP, mP["next"]) && 0x0 !== B3(mP["prev"], mP, mP["next"])))) mP = mP["next"];
                    else {
                        if ((BR(mP), (mP = mX = mP["prev"]) === mP["next"])) break;
                        mf = !0x0;
                    }
                } while (mf || mP !== mX);
                return mX;
            }
            function nH(mN, mX, mf, mP, mI, mA, mM) {
                if (mN) {
                    !mM &&
                        mA &&
                        (function (mq, mw, mO, mj) {
                            var mh = mq;
                            do {
                                null === mh["z"] && (mh["z"] = nz(mh["x"], mh["y"], mw, mO, mj)), (mh["prevZ"] = mh["prev"]), (mh["nextZ"] = mh["next"]), (mh = mh["next"]);
                            } while (mh !== mq);
                            (mh["prevZ"]["nextZ"] = null),
                                (mh["prevZ"] = null),
                                (function (mS) {
                                    var mg,
                                        mW,
                                        mH,
                                        mx,
                                        mK,
                                        mV,
                                        mJ,
                                        mG,
                                        mL = 0x1;
                                    do {
                                        for (mW = mS, mS = null, mK = null, mV = 0x0; mW; ) {
                                            for (mV++, mH = mW, mJ = 0x0, mg = 0x0; mg < mL && (mJ++, (mH = mH["nextZ"])); mg++);
                                            for (mG = mL; mJ > 0x0 || (mG > 0x0 && mH); )
                                                0x0 !== mJ && (0x0 === mG || !mH || mW["z"] <= mH["z"]) ? ((mx = mW), (mW = mW["nextZ"]), mJ--) : ((mx = mH), (mH = mH["nextZ"]), mG--),
                                                    mK ? (mK["nextZ"] = mx) : (mS = mx),
                                                    (mx["prevZ"] = mK),
                                                    (mK = mx);
                                            mW = mH;
                                        }
                                        (mK["nextZ"] = null), (mL *= 0x2);
                                    } while (mV > 0x1);
                                })(mh);
                        })(mN, mP, mI, mA);
                    for (var mp, mk, mU = mN; mN["prev"] !== mN["next"]; )
                        if (((mp = mN["prev"]), (mk = mN["next"]), mA ? nK(mN, mP, mI, mA) : nx(mN))) mX["push"](mp["i"] / mf), mX["push"](mN["i"] / mf), mX["push"](mk["i"] / mf), BR(mN), (mN = mk["next"]), (mU = mk["next"]);
                        else {
                            if ((mN = mk) === mU) {
                                mM ? (0x1 === mM ? nH((mN = nV(nW(mN), mX, mf)), mX, mf, mP, mI, mA, 0x2) : 0x2 === mM && nJ(mN, mX, mf, mP, mI, mA)) : nH(nW(mN), mX, mf, mP, mI, mA, 0x1);
                                break;
                            }
                        }
                }
            }
            function nx(mN) {
                var mX = mN["prev"],
                    mf = mN,
                    mP = mN["next"];
                if (B3(mX, mf, mP) >= 0x0) return !0x1;
                for (var mI = mN["next"]["next"]; mI !== mN["prev"]; ) {
                    if (B1(mX["x"], mX["y"], mf["x"], mf["y"], mP["x"], mP["y"], mI["x"], mI["y"]) && B3(mI["prev"], mI, mI["next"]) >= 0x0) return !0x1;
                    mI = mI["next"];
                }
                return !0x0;
            }
            function nK(mN, mX, mf, mP) {
                var mI = mN["prev"],
                    mA = mN,
                    mM = mN["next"];
                if (B3(mI, mA, mM) >= 0x0) return !0x1;
                for (
                    var mp = mI["x"] < mA["x"] ? (mI["x"] < mM["x"] ? mI["x"] : mM["x"]) : mA["x"] < mM["x"] ? mA["x"] : mM["x"],
                        mk = mI["y"] < mA["y"] ? (mI["y"] < mM["y"] ? mI["y"] : mM["y"]) : mA["y"] < mM["y"] ? mA["y"] : mM["y"],
                        mU = mI["x"] > mA["x"] ? (mI["x"] > mM["x"] ? mI["x"] : mM["x"]) : mA["x"] > mM["x"] ? mA["x"] : mM["x"],
                        mq = mI["y"] > mA["y"] ? (mI["y"] > mM["y"] ? mI["y"] : mM["y"]) : mA["y"] > mM["y"] ? mA["y"] : mM["y"],
                        mw = nz(mp, mk, mX, mf, mP),
                        mO = nz(mU, mq, mX, mf, mP),
                        mj = mN["prevZ"],
                        mh = mN["nextZ"];
                    mj && mj["z"] >= mw && mh && mh["z"] <= mO;

                ) {
                    if (mj !== mN["prev"] && mj !== mN["next"] && B1(mI["x"], mI["y"], mA["x"], mA["y"], mM["x"], mM["y"], mj["x"], mj["y"]) && B3(mj["prev"], mj, mj["next"]) >= 0x0) return !0x1;
                    if (((mj = mj["prevZ"]), mh !== mN["prev"] && mh !== mN["next"] && B1(mI["x"], mI["y"], mA["x"], mA["y"], mM["x"], mM["y"], mh["x"], mh["y"]) && B3(mh["prev"], mh, mh["next"]) >= 0x0)) return !0x1;
                    mh = mh["nextZ"];
                }
                for (; mj && mj["z"] >= mw; ) {
                    if (mj !== mN["prev"] && mj !== mN["next"] && B1(mI["x"], mI["y"], mA["x"], mA["y"], mM["x"], mM["y"], mj["x"], mj["y"]) && B3(mj["prev"], mj, mj["next"]) >= 0x0) return !0x1;
                    mj = mj["prevZ"];
                }
                for (; mh && mh["z"] <= mO; ) {
                    if (mh !== mN["prev"] && mh !== mN["next"] && B1(mI["x"], mI["y"], mA["x"], mA["y"], mM["x"], mM["y"], mh["x"], mh["y"]) && B3(mh["prev"], mh, mh["next"]) >= 0x0) return !0x1;
                    mh = mh["nextZ"];
                }
                return !0x0;
            }
            function nV(mN, mX, mf) {
                var mP = mN;
                do {
                    var mI = mP["prev"],
                        mA = mP["next"]["next"];
                    !B4(mI, mA) && B5(mI, mP, mP["next"], mA) && B8(mI, mA) && B8(mA, mI) && (mX["push"](mI["i"] / mf), mX["push"](mP["i"] / mf), mX["push"](mA["i"] / mf), BR(mP), BR(mP["next"]), (mP = mN = mA)), (mP = mP["next"]);
                } while (mP !== mN);
                return nW(mP);
            }
            function nJ(mN, mX, mf, mP, mI, mA) {
                var mM = mN;
                do {
                    for (var mp = mM["next"]["next"]; mp !== mM["prev"]; ) {
                        if (mM["i"] !== mp["i"] && B2(mM, mp)) {
                            var mk = B9(mM, mp);
                            return (mM = nW(mM, mM["next"])), (mk = nW(mk, mk["next"])), nH(mM, mX, mf, mP, mI, mA), void nH(mk, mX, mf, mP, mI, mA);
                        }
                        mp = mp["next"];
                    }
                    mM = mM["next"];
                } while (mM !== mN);
            }
            function nG(mN, mX) {
                return mN["x"] - mX["x"];
            }
            function nL(mN, mX) {
                if (
                    ((mX = (function (mP, mI) {
                        var mA,
                            mM = mI,
                            mp = mP["x"],
                            mk = mP["y"],
                            mU = -0x1 / 0x0;
                        do {
                            if (mk <= mM["y"] && mk >= mM["next"]["y"] && mM["next"]["y"] !== mM["y"]) {
                                var mq = mM["x"] + ((mk - mM["y"]) * (mM["next"]["x"] - mM["x"])) / (mM["next"]["y"] - mM["y"]);
                                if (mq <= mp && mq > mU) {
                                    if (((mU = mq), mq === mp)) {
                                        if (mk === mM["y"]) return mM;
                                        if (mk === mM["next"]["y"]) return mM["next"];
                                    }
                                    mA = mM["x"] < mM["next"]["x"] ? mM : mM["next"];
                                }
                            }
                            mM = mM["next"];
                        } while (mM !== mI);
                        if (!mA) return null;
                        if (mp === mU) return mA;
                        var mw,
                            mO = mA,
                            mj = mA["x"],
                            mh = mA["y"],
                            mS = 0x1 / 0x0;
                        mM = mA;
                        do {
                            mp >= mM["x"] &&
                                mM["x"] >= mj &&
                                mp !== mM["x"] &&
                                B1(mk < mh ? mp : mU, mk, mj, mh, mk < mh ? mU : mp, mk, mM["x"], mM["y"]) &&
                                ((mw = Math["abs"](mk - mM["y"]) / (mp - mM["x"])), B8(mM, mP) && (mw < mS || (mw === mS && (mM["x"] > mA["x"] || (mM["x"] === mA["x"] && nQ(mA, mM))))) && ((mA = mM), (mS = mw))),
                                (mM = mM["next"]);
                        } while (mM !== mO);
                        return mA;
                    })(mN, mX)),
                    mX)
                ) {
                    var mf = B9(mX, mN);
                    nW(mX, mX["next"]), nW(mf, mf["next"]);
                }
            }
            function nQ(mN, mX) {
                return B3(mN["prev"], mN, mX["prev"]) < 0x0 && B3(mX["next"], mN, mN["next"]) < 0x0;
            }
            function nz(mN, mX, mf, mP, mI) {
                return (
                    (mN = 0x55555555 & ((mN = 0x33333333 & ((mN = 0xf0f0f0f & ((mN = 0xff00ff & ((mN = 0x7fff * (mN - mf) * mI) | (mN << 0x8))) | (mN << 0x4))) | (mN << 0x2))) | (mN << 0x1))) |
                    ((mX = 0x55555555 & ((mX = 0x33333333 & ((mX = 0xf0f0f0f & ((mX = 0xff00ff & ((mX = 0x7fff * (mX - mP) * mI) | (mX << 0x8))) | (mX << 0x4))) | (mX << 0x2))) | (mX << 0x1))) << 0x1)
                );
            }
            function B0(mN) {
                var mX = mN,
                    mf = mN;
                do {
                    (mX["x"] < mf["x"] || (mX["x"] === mf["x"] && mX["y"] < mf["y"])) && (mf = mX), (mX = mX["next"]);
                } while (mX !== mN);
                return mf;
            }
            function B1(mN, mX, mf, mP, mI, mA, mM, mp) {
                return (mI - mM) * (mX - mp) - (mN - mM) * (mA - mp) >= 0x0 && (mN - mM) * (mP - mp) - (mf - mM) * (mX - mp) >= 0x0 && (mf - mM) * (mA - mp) - (mI - mM) * (mP - mp) >= 0x0;
            }
            function B2(mN, mX) {
                return (
                    mN["next"]["i"] !== mX["i"] &&
                    mN["prev"]["i"] !== mX["i"] &&
                    !(function (mf, mP) {
                        var mI = mf;
                        do {
                            if (mI["i"] !== mf["i"] && mI["next"]["i"] !== mf["i"] && mI["i"] !== mP["i"] && mI["next"]["i"] !== mP["i"] && B5(mI, mI["next"], mf, mP)) return !0x0;
                            mI = mI["next"];
                        } while (mI !== mf);
                        return !0x1;
                    })(mN, mX) &&
                    ((B8(mN, mX) &&
                        B8(mX, mN) &&
                        (function (mf, mP) {
                            var mI = mf,
                                mA = !0x1,
                                mM = (mf["x"] + mP["x"]) / 0x2,
                                mp = (mf["y"] + mP["y"]) / 0x2;
                            do {
                                mI["y"] > mp != mI["next"]["y"] > mp && mI["next"]["y"] !== mI["y"] && mM < ((mI["next"]["x"] - mI["x"]) * (mp - mI["y"])) / (mI["next"]["y"] - mI["y"]) + mI["x"] && (mA = !mA), (mI = mI["next"]);
                            } while (mI !== mf);
                            return mA;
                        })(mN, mX) &&
                        (B3(mN["prev"], mN, mX["prev"]) || B3(mN, mX["prev"], mX))) ||
                        (B4(mN, mX) && B3(mN["prev"], mN, mN["next"]) > 0x0 && B3(mX["prev"], mX, mX["next"]) > 0x0))
                );
            }
            function B3(mN, mX, mf) {
                return (mX["y"] - mN["y"]) * (mf["x"] - mX["x"]) - (mX["x"] - mN["x"]) * (mf["y"] - mX["y"]);
            }
            function B4(mN, mX) {
                return mN["x"] === mX["x"] && mN["y"] === mX["y"];
            }
            function B5(mN, mX, mf, mP) {
                var mI = B7(B3(mN, mX, mf)),
                    mA = B7(B3(mN, mX, mP)),
                    mM = B7(B3(mf, mP, mN)),
                    mp = B7(B3(mf, mP, mX));
                return (mI !== mA && mM !== mp) || !(0x0 !== mI || !B6(mN, mf, mX)) || !(0x0 !== mA || !B6(mN, mP, mX)) || !(0x0 !== mM || !B6(mf, mN, mP)) || !(0x0 !== mp || !B6(mf, mX, mP));
            }
            function B6(mN, mX, mf) {
                return mX["x"] <= Math["max"](mN["x"], mf["x"]) && mX["x"] >= Math["min"](mN["x"], mf["x"]) && mX["y"] <= Math["max"](mN["y"], mf["y"]) && mX["y"] >= Math["min"](mN["y"], mf["y"]);
            }
            function B7(mN) {
                return mN > 0x0 ? 0x1 : mN < 0x0 ? -0x1 : 0x0;
            }
            function B8(mN, mX) {
                return B3(mN["prev"], mN, mN["next"]) < 0x0 ? B3(mN, mX, mN["next"]) >= 0x0 && B3(mN, mN["prev"], mX) >= 0x0 : B3(mN, mX, mN["prev"]) < 0x0 || B3(mN, mN["next"], mX) < 0x0;
            }
            function B9(mN, mX) {
                var mf = new BT(mN["i"], mN["x"], mN["y"]),
                    mP = new BT(mX["i"], mX["x"], mX["y"]),
                    mI = mN["next"],
                    mA = mX["prev"];
                return (mN["next"] = mX), (mX["prev"] = mN), (mf["next"] = mI), (mI["prev"] = mf), (mP["next"] = mf), (mf["prev"] = mP), (mA["next"] = mP), (mP["prev"] = mA), mP;
            }
            function BE(mN, mX, mf, mP) {
                var mI = new BT(mN, mX, mf);
                return mP ? ((mI["next"] = mP["next"]), (mI["prev"] = mP), (mP["next"]["prev"] = mI), (mP["next"] = mI)) : ((mI["prev"] = mI), (mI["next"] = mI)), mI;
            }
            function BR(mN) {
                (mN["next"]["prev"] = mN["prev"]), (mN["prev"]["next"] = mN["next"]), mN["prevZ"] && (mN["prevZ"]["nextZ"] = mN["nextZ"]), mN["nextZ"] && (mN["nextZ"]["prevZ"] = mN["prevZ"]);
            }
            function BT(mN, mX, mf) {
                (this["i"] = mN), (this["x"] = mX), (this["y"] = mf), (this["prev"] = null), (this["next"] = null), (this["z"] = null), (this["prevZ"] = null), (this["nextZ"] = null), (this["steiner"] = !0x1);
            }
            var BC = {
                area: function (mN) {
                    for (var mX = mN["length"], mf = 0x0, mP = mX - 0x1, mI = 0x0; mI < mX; mP = mI++) mf += mN[mP]["x"] * mN[mI]["y"] - mN[mI]["x"] * mN[mP]["y"];
                    return 0.5 * mf;
                },
                isClockWise: function (mN) {
                    return BC["area"](mN) < 0x0;
                },
                triangulateShape: function (mN, mX) {
                    var mf = [],
                        mP = [],
                        mI = [];
                    Bd(mN), BY(mf, mN);
                    var mA = mN["length"];
                    mX["forEach"](Bd);
                    for (var mM = 0x0; mM < mX["length"]; mM++) mP["push"](mA), (mA += mX[mM]["length"]), BY(mf, mX[mM]);
                    var mp = nS(mf, mP);
                    for (mM = 0x0; mM < mp["length"]; mM += 0x3) mI["push"](mp["slice"](mM, mM + 0x3));
                    return mI;
                },
            };
            function Bd(mN) {
                var mX = mN["length"];
                mX > 0x2 && mN[mX - 0x1]["equals"](mN[0x0]) && mN["pop"]();
            }
            function BY(mN, mX) {
                for (var mf = 0x0; mf < mX["length"]; mf++) mN["push"](mX[mf]["x"]), mN["push"](mX[mf]["y"]);
            }
            function BB(mN, mX) {
                TO["call"](this), (this["type"] = "ExtrudeGeometry"), (this["parameters"] = { shapes: mN, options: mX }), this["fromBufferGeometry"](new BF(mN, mX)), this["mergeVertices"]();
            }
            function BF(mN, mX) {
                TR["call"](this), (this["type"] = "ExtrudeBufferGeometry"), (this["parameters"] = { shapes: mN, options: mX }), (mN = Array["isArray"](mN) ? mN : [mN]);
                for (var mf = this, mP = [], mI = [], mA = 0x0, mM = mN["length"]; mA < mM; mA++) {
                    mp(mN[mA]);
                }
                function mp(mk) {
                    var mU = [],
                        mq = void 0x0 !== mX["curveSegments"] ? mX["curveSegments"] : 0xc,
                        mw = void 0x0 !== mX["steps"] ? mX["steps"] : 0x1,
                        mO = void 0x0 !== mX["depth"] ? mX["depth"] : 0x64,
                        mj = void 0x0 === mX["bevelEnabled"] || mX["bevelEnabled"],
                        mh = void 0x0 !== mX["bevelThickness"] ? mX["bevelThickness"] : 0x6,
                        mS = void 0x0 !== mX["bevelSize"] ? mX["bevelSize"] : mh - 0x2,
                        mg = void 0x0 !== mX["bevelOffset"] ? mX["bevelOffset"] : 0x0,
                        mW = void 0x0 !== mX["bevelSegments"] ? mX["bevelSegments"] : 0x3,
                        mH = mX["extrudePath"],
                        mx = void 0x0 !== mX["UVGenerator"] ? mX["UVGenerator"] : Bb;
                    void 0x0 !== mX["amount"] && (console["warn"]("THREE.ExtrudeBufferGeometry:\x20amount\x20has\x20been\x20renamed\x20to\x20depth."), (mO = mX["amount"]));
                    var mK,
                        mV,
                        mJ,
                        mG,
                        mL,
                        mQ,
                        mz,
                        v0,
                        v1 = !0x1;
                    mH && ((mK = mH["getSpacedPoints"](mw)), (v1 = !0x0), (mj = !0x1), (mV = mH["computeFrenetFrames"](mw, !0x1)), (mJ = new Ed()), (mG = new Ed()), (mL = new Ed())), mj || ((mW = 0x0), (mh = 0x0), (mS = 0x0), (mg = 0x0));
                    var v2 = mk["extractPoints"](mq),
                        v3 = v2["shape"],
                        v4 = v2["holes"];
                    if (!BC["isClockWise"](v3)) {
                        for (v3 = v3["reverse"](), mz = 0x0, v0 = v4["length"]; mz < v0; mz++) (mQ = v4[mz]), BC["isClockWise"](mQ) && (v4[mz] = mQ["reverse"]());
                    }
                    var v5 = BC["triangulateShape"](v3, v4),
                        v6 = v3;
                    for (mz = 0x0, v0 = v4["length"]; mz < v0; mz++) (mQ = v4[mz]), (v3 = v3["concat"](mQ));
                    function v7(vk, vU, vq) {
                        return vU || console["error"]("THREE.ExtrudeGeometry:\x20vec\x20does\x20not\x20exist"), vU["clone"]()["multiplyScalar"](vq)["add"](vk);
                    }
                    var v8,
                        v9,
                        vE,
                        vR,
                        vT,
                        vC,
                        vd = v3["length"],
                        vY = v5["length"];
                    function vB(vk, vU, vq) {
                        var vw,
                            vO,
                            vj,
                            vh = vk["x"] - vU["x"],
                            vS = vk["y"] - vU["y"],
                            vg = vq["x"] - vk["x"],
                            vW = vq["y"] - vk["y"],
                            vH = vh * vh + vS * vS,
                            vx = vh * vW - vS * vg;
                        if (Math["abs"](vx) > Number["EPSILON"]) {
                            var vK = Math["sqrt"](vH),
                                vV = Math["sqrt"](vg * vg + vW * vW),
                                vJ = vU["x"] - vS / vK,
                                vG = vU["y"] + vh / vK,
                                vL = ((vq["x"] - vW / vV - vJ) * vW - (vq["y"] + vg / vV - vG) * vg) / (vh * vW - vS * vg),
                                vQ = (vw = vJ + vh * vL - vk["x"]) * vw + (vO = vG + vS * vL - vk["y"]) * vO;
                            if (vQ <= 0x2) return new E3(vw, vO);
                            vj = Math["sqrt"](vQ / 0x2);
                        } else {
                            var vz = !0x1;
                            vh > Number["EPSILON"] ? vg > Number["EPSILON"] && (vz = !0x0) : vh < -Number["EPSILON"] ? vg < -Number["EPSILON"] && (vz = !0x0) : Math["sign"](vS) === Math["sign"](vW) && (vz = !0x0),
                                vz ? ((vw = -vS), (vO = vh), (vj = Math["sqrt"](vH))) : ((vw = vh), (vO = vS), (vj = Math["sqrt"](vH / 0x2)));
                        }
                        return new E3(vw / vj, vO / vj);
                    }
                    for (var vF = [], vb = 0x0, vZ = v6["length"], vm = vZ - 0x1, vv = vb + 0x1; vb < vZ; vb++, vm++, vv++) vm === vZ && (vm = 0x0), vv === vZ && (vv = 0x0), (vF[vb] = vB(v6[vb], v6[vm], v6[vv]));
                    var vy,
                        vD,
                        vN = [],
                        vX = vF["concat"]();
                    for (mz = 0x0, v0 = v4["length"]; mz < v0; mz++) {
                        for (mQ = v4[mz], vy = [], vb = 0x0, vm = (vZ = mQ["length"]) - 0x1, vv = vb + 0x1; vb < vZ; vb++, vm++, vv++) vm === vZ && (vm = 0x0), vv === vZ && (vv = 0x0), (vy[vb] = vB(mQ[vb], mQ[vm], mQ[vv]));
                        vN["push"](vy), (vX = vX["concat"](vy));
                    }
                    for (v8 = 0x0; v8 < mW; v8++) {
                        for (vE = v8 / mW, vR = mh * Math["cos"]((vE * Math["PI"]) / 0x2), v9 = mS * Math["sin"]((vE * Math["PI"]) / 0x2) + mg, vb = 0x0, vZ = v6["length"]; vb < vZ; vb++)
                            vP((vT = v7(v6[vb], vF[vb], v9))["x"], vT["y"], -vR);
                        for (mz = 0x0, v0 = v4["length"]; mz < v0; mz++) for (mQ = v4[mz], vy = vN[mz], vb = 0x0, vZ = mQ["length"]; vb < vZ; vb++) vP((vT = v7(mQ[vb], vy[vb], v9))["x"], vT["y"], -vR);
                    }
                    for (v9 = mS + mg, vb = 0x0; vb < vd; vb++)
                        (vT = mj ? v7(v3[vb], vX[vb], v9) : v3[vb]),
                            v1
                                ? (mG["copy"](mV["normals"][0x0])["multiplyScalar"](vT["x"]), mJ["copy"](mV["binormals"][0x0])["multiplyScalar"](vT["y"]), mL["copy"](mK[0x0])["add"](mG)["add"](mJ), vP(mL["x"], mL["y"], mL["z"]))
                                : vP(vT["x"], vT["y"], 0x0);
                    for (vD = 0x1; vD <= mw; vD++)
                        for (vb = 0x0; vb < vd; vb++)
                            (vT = mj ? v7(v3[vb], vX[vb], v9) : v3[vb]),
                                v1
                                    ? (mG["copy"](mV["normals"][vD])["multiplyScalar"](vT["x"]), mJ["copy"](mV["binormals"][vD])["multiplyScalar"](vT["y"]), mL["copy"](mK[vD])["add"](mG)["add"](mJ), vP(mL["x"], mL["y"], mL["z"]))
                                    : vP(vT["x"], vT["y"], (mO / mw) * vD);
                    for (v8 = mW - 0x1; v8 >= 0x0; v8--) {
                        for (vE = v8 / mW, vR = mh * Math["cos"]((vE * Math["PI"]) / 0x2), v9 = mS * Math["sin"]((vE * Math["PI"]) / 0x2) + mg, vb = 0x0, vZ = v6["length"]; vb < vZ; vb++)
                            vP((vT = v7(v6[vb], vF[vb], v9))["x"], vT["y"], mO + vR);
                        for (mz = 0x0, v0 = v4["length"]; mz < v0; mz++)
                            for (mQ = v4[mz], vy = vN[mz], vb = 0x0, vZ = mQ["length"]; vb < vZ; vb++) (vT = v7(mQ[vb], vy[vb], v9)), v1 ? vP(vT["x"], vT["y"] + mK[mw - 0x1]["y"], mK[mw - 0x1]["x"] + vR) : vP(vT["x"], vT["y"], mO + vR);
                    }
                    function vf(vk, vU) {
                        var vq, vw;
                        for (vb = vk["length"]; --vb >= 0x0; ) {
                            (vq = vb), (vw = vb - 0x1) < 0x0 && (vw = vk["length"] - 0x1);
                            var vO = 0x0,
                                vj = mw + 0x2 * mW;
                            for (vO = 0x0; vO < vj; vO++) {
                                var vh = vd * vO,
                                    vS = vd * (vO + 0x1);
                                vA(vU + vq + vh, vU + vw + vh, vU + vw + vS, vU + vq + vS);
                            }
                        }
                    }
                    function vP(vk, vU, vq) {
                        mU["push"](vk), mU["push"](vU), mU["push"](vq);
                    }
                    function vI(vk, vU, vq) {
                        vM(vk), vM(vU), vM(vq);
                        var vw = mP["length"] / 0x3,
                            vO = mx["generateTopUV"](mf, mP, vw - 0x3, vw - 0x2, vw - 0x1);
                        vp(vO[0x0]), vp(vO[0x1]), vp(vO[0x2]);
                    }
                    function vA(vk, vU, vq, vw) {
                        vM(vk), vM(vU), vM(vw), vM(vU), vM(vq), vM(vw);
                        var vO = mP["length"] / 0x3,
                            vj = mx["generateSideWallUV"](mf, mP, vO - 0x6, vO - 0x3, vO - 0x2, vO - 0x1);
                        vp(vj[0x0]), vp(vj[0x1]), vp(vj[0x3]), vp(vj[0x1]), vp(vj[0x2]), vp(vj[0x3]);
                    }
                    function vM(vk) {
                        mP["push"](mU[0x3 * vk + 0x0]), mP["push"](mU[0x3 * vk + 0x1]), mP["push"](mU[0x3 * vk + 0x2]);
                    }
                    function vp(vk) {
                        mI["push"](vk["x"]), mI["push"](vk["y"]);
                    }
                    !(function () {
                        var vk = mP["length"] / 0x3;
                        if (mj) {
                            var vU = 0x0,
                                vq = vd * vU;
                            for (vb = 0x0; vb < vY; vb++) vI((vC = v5[vb])[0x2] + vq, vC[0x1] + vq, vC[0x0] + vq);
                            for (vq = vd * (vU = mw + 0x2 * mW), vb = 0x0; vb < vY; vb++) vI((vC = v5[vb])[0x0] + vq, vC[0x1] + vq, vC[0x2] + vq);
                        } else {
                            for (vb = 0x0; vb < vY; vb++) vI((vC = v5[vb])[0x2], vC[0x1], vC[0x0]);
                            for (vb = 0x0; vb < vY; vb++) vI((vC = v5[vb])[0x0] + vd * mw, vC[0x1] + vd * mw, vC[0x2] + vd * mw);
                        }
                        mf["addGroup"](vk, mP["length"] / 0x3 - vk, 0x0);
                    })(),
                        (function () {
                            var vk = mP["length"] / 0x3,
                                vU = 0x0;
                            for (vf(v6, vU), vU += v6["length"], mz = 0x0, v0 = v4["length"]; mz < v0; mz++) vf((mQ = v4[mz]), vU), (vU += mQ["length"]);
                            mf["addGroup"](vk, mP["length"] / 0x3 - vk, 0x1);
                        })();
                }
                this["setAttribute"]("position", new T0(mP, 0x3)), this["setAttribute"]("uv", new T0(mI, 0x2)), this["computeVertexNormals"]();
            }
            (BB["prototype"] = Object["create"](TO["prototype"])),
                (BB["prototype"]["constructor"] = BB),
                (BB["prototype"]["toJSON"] = function () {
                    var mN = TO["prototype"]["toJSON"]["call"](this);
                    return BZ(this["parameters"]["shapes"], this["parameters"]["options"], mN);
                }),
                (BF["prototype"] = Object["create"](TR["prototype"])),
                (BF["prototype"]["constructor"] = BF),
                (BF["prototype"]["toJSON"] = function () {
                    var mN = TR["prototype"]["toJSON"]["call"](this);
                    return BZ(this["parameters"]["shapes"], this["parameters"]["options"], mN);
                });
            var Bb = {
                generateTopUV: function (mN, mX, mf, mP, mI) {
                    var mA = mX[0x3 * mf],
                        mM = mX[0x3 * mf + 0x1],
                        mp = mX[0x3 * mP],
                        mk = mX[0x3 * mP + 0x1],
                        mU = mX[0x3 * mI],
                        mq = mX[0x3 * mI + 0x1];
                    return [new E3(mA, mM), new E3(mp, mk), new E3(mU, mq)];
                },
                generateSideWallUV: function (mN, mX, mf, mP, mI, mA) {
                    var mM = mX[0x3 * mf],
                        mp = mX[0x3 * mf + 0x1],
                        mk = mX[0x3 * mf + 0x2],
                        mU = mX[0x3 * mP],
                        mq = mX[0x3 * mP + 0x1],
                        mw = mX[0x3 * mP + 0x2],
                        mO = mX[0x3 * mI],
                        mj = mX[0x3 * mI + 0x1],
                        mh = mX[0x3 * mI + 0x2],
                        mS = mX[0x3 * mA],
                        mg = mX[0x3 * mA + 0x1],
                        mW = mX[0x3 * mA + 0x2];
                    return Math["abs"](mp - mq) < 0.01 ? [new E3(mM, 0x1 - mk), new E3(mU, 0x1 - mw), new E3(mO, 0x1 - mh), new E3(mS, 0x1 - mW)] : [new E3(mp, 0x1 - mk), new E3(mq, 0x1 - mw), new E3(mj, 0x1 - mh), new E3(mg, 0x1 - mW)];
                },
            };
            function BZ(mN, mX, mf) {
                if (((mf["shapes"] = []), Array["isArray"](mN)))
                    for (var mP = 0x0, mI = mN["length"]; mP < mI; mP++) {
                        var mA = mN[mP];
                        mf["shapes"]["push"](mA["uuid"]);
                    }
                else mf["shapes"]["push"](mN["uuid"]);
                return void 0x0 !== mX["extrudePath"] && (mf["options"]["extrudePath"] = mX["extrudePath"]["toJSON"]()), mf;
            }
            function Bm(mN, mX) {
                TO["call"](this), (this["type"] = "TextGeometry"), (this["parameters"] = { text: mN, parameters: mX }), this["fromBufferGeometry"](new Bv(mN, mX)), this["mergeVertices"]();
            }
            function Bv(mN, mX) {
                var mf = (mX = mX || {})["font"];
                if (!mf || !mf["isFont"]) return console["error"]("THREE.TextGeometry:\x20font\x20parameter\x20is\x20not\x20an\x20instance\x20of\x20THREE.Font."), new TO();
                var mP = mf["generateShapes"](mN, mX["size"]);
                (mX["depth"] = void 0x0 !== mX["height"] ? mX["height"] : 0x32),
                    void 0x0 === mX["bevelThickness"] && (mX["bevelThickness"] = 0xa),
                    void 0x0 === mX["bevelSize"] && (mX["bevelSize"] = 0x8),
                    void 0x0 === mX["bevelEnabled"] && (mX["bevelEnabled"] = !0x1),
                    BF["call"](this, mP, mX),
                    (this["type"] = "TextBufferGeometry");
            }
            function By(mN, mX, mf, mP, mI, mA, mM) {
                TO["call"](this),
                    (this["type"] = "SphereGeometry"),
                    (this["parameters"] = { radius: mN, widthSegments: mX, heightSegments: mf, phiStart: mP, phiLength: mI, thetaStart: mA, thetaLength: mM }),
                    this["fromBufferGeometry"](new BD(mN, mX, mf, mP, mI, mA, mM)),
                    this["mergeVertices"]();
            }
            function BD(mN, mX, mf, mP, mI, mA, mM) {
                TR["call"](this),
                    (this["type"] = "SphereBufferGeometry"),
                    (this["parameters"] = { radius: mN, widthSegments: mX, heightSegments: mf, phiStart: mP, phiLength: mI, thetaStart: mA, thetaLength: mM }),
                    (mN = mN || 0x1),
                    (mX = Math["max"](0x3, Math["floor"](mX) || 0x8)),
                    (mf = Math["max"](0x2, Math["floor"](mf) || 0x6)),
                    (mP = void 0x0 !== mP ? mP : 0x0),
                    (mI = void 0x0 !== mI ? mI : 0x2 * Math["PI"]),
                    (mA = void 0x0 !== mA ? mA : 0x0),
                    (mM = void 0x0 !== mM ? mM : Math["PI"]);
                var mp,
                    mk,
                    mU = Math["min"](mA + mM, Math["PI"]),
                    mq = 0x0,
                    mw = [],
                    mO = new Ed(),
                    mj = new Ed(),
                    mh = [],
                    mS = [],
                    mg = [],
                    mW = [];
                for (mk = 0x0; mk <= mf; mk++) {
                    var mH = [],
                        mx = mk / mf,
                        mK = 0x0;
                    for (0x0 == mk && 0x0 == mA ? (mK = 0.5 / mX) : mk == mf && mU == Math["PI"] && (mK = -0.5 / mX), mp = 0x0; mp <= mX; mp++) {
                        var mV = mp / mX;
                        (mO["x"] = -mN * Math["cos"](mP + mV * mI) * Math["sin"](mA + mx * mM)),
                            (mO["y"] = mN * Math["cos"](mA + mx * mM)),
                            (mO["z"] = mN * Math["sin"](mP + mV * mI) * Math["sin"](mA + mx * mM)),
                            mS["push"](mO["x"], mO["y"], mO["z"]),
                            mj["copy"](mO)["normalize"](),
                            mg["push"](mj["x"], mj["y"], mj["z"]),
                            mW["push"](mV + mK, 0x1 - mx),
                            mH["push"](mq++);
                    }
                    mw["push"](mH);
                }
                for (mk = 0x0; mk < mf; mk++)
                    for (mp = 0x0; mp < mX; mp++) {
                        var mJ = mw[mk][mp + 0x1],
                            mG = mw[mk][mp],
                            mL = mw[mk + 0x1][mp],
                            mQ = mw[mk + 0x1][mp + 0x1];
                        (0x0 !== mk || mA > 0x0) && mh["push"](mJ, mG, mQ), (mk !== mf - 0x1 || mU < Math["PI"]) && mh["push"](mG, mL, mQ);
                    }
                this["setIndex"](mh), this["setAttribute"]("position", new T0(mS, 0x3)), this["setAttribute"]("normal", new T0(mg, 0x3)), this["setAttribute"]("uv", new T0(mW, 0x2));
            }
            function BN(mN, mX, mf, mP, mI, mA) {
                TO["call"](this),
                    (this["type"] = "RingGeometry"),
                    (this["parameters"] = { innerRadius: mN, outerRadius: mX, thetaSegments: mf, phiSegments: mP, thetaStart: mI, thetaLength: mA }),
                    this["fromBufferGeometry"](new BX(mN, mX, mf, mP, mI, mA)),
                    this["mergeVertices"]();
            }
            function BX(mN, mX, mf, mP, mI, mA) {
                TR["call"](this),
                    (this["type"] = "RingBufferGeometry"),
                    (this["parameters"] = { innerRadius: mN, outerRadius: mX, thetaSegments: mf, phiSegments: mP, thetaStart: mI, thetaLength: mA }),
                    (mN = mN || 0.5),
                    (mX = mX || 0x1),
                    (mI = void 0x0 !== mI ? mI : 0x0),
                    (mA = void 0x0 !== mA ? mA : 0x2 * Math["PI"]),
                    (mf = void 0x0 !== mf ? Math["max"](0x3, mf) : 0x8);
                var mM,
                    mp,
                    mk,
                    mU = [],
                    mq = [],
                    mw = [],
                    mO = [],
                    mj = mN,
                    mh = (mX - mN) / (mP = void 0x0 !== mP ? Math["max"](0x1, mP) : 0x1),
                    mS = new Ed(),
                    mg = new E3();
                for (mp = 0x0; mp <= mP; mp++) {
                    for (mk = 0x0; mk <= mf; mk++)
                        (mM = mI + (mk / mf) * mA),
                            (mS["x"] = mj * Math["cos"](mM)),
                            (mS["y"] = mj * Math["sin"](mM)),
                            mq["push"](mS["x"], mS["y"], mS["z"]),
                            mw["push"](0x0, 0x0, 0x1),
                            (mg["x"] = (mS["x"] / mX + 0x1) / 0x2),
                            (mg["y"] = (mS["y"] / mX + 0x1) / 0x2),
                            mO["push"](mg["x"], mg["y"]);
                    mj += mh;
                }
                for (mp = 0x0; mp < mP; mp++) {
                    var mW = mp * (mf + 0x1);
                    for (mk = 0x0; mk < mf; mk++) {
                        var mH = (mM = mk + mW),
                            mx = mM + mf + 0x1,
                            mK = mM + mf + 0x2,
                            mV = mM + 0x1;
                        mU["push"](mH, mx, mV), mU["push"](mx, mK, mV);
                    }
                }
                this["setIndex"](mU), this["setAttribute"]("position", new T0(mq, 0x3)), this["setAttribute"]("normal", new T0(mw, 0x3)), this["setAttribute"]("uv", new T0(mO, 0x2));
            }
            function Bf(mN, mX, mf, mP) {
                TO["call"](this), (this["type"] = "LatheGeometry"), (this["parameters"] = { points: mN, segments: mX, phiStart: mf, phiLength: mP }), this["fromBufferGeometry"](new BP(mN, mX, mf, mP)), this["mergeVertices"]();
            }
            function BP(mN, mX, mf, mP) {
                TR["call"](this),
                    (this["type"] = "LatheBufferGeometry"),
                    (this["parameters"] = { points: mN, segments: mX, phiStart: mf, phiLength: mP }),
                    (mX = Math["floor"](mX) || 0xc),
                    (mf = mf || 0x0),
                    (mP = mP || 0x2 * Math["PI"]),
                    (mP = E2["clamp"](mP, 0x0, 0x2 * Math["PI"]));
                var mI,
                    mA,
                    mM,
                    mp = [],
                    mk = [],
                    mU = [],
                    mq = 0x1 / mX,
                    mw = new Ed(),
                    mO = new E3();
                for (mA = 0x0; mA <= mX; mA++) {
                    var mj = mf + mA * mq * mP,
                        mh = Math["sin"](mj),
                        mS = Math["cos"](mj);
                    for (mM = 0x0; mM <= mN["length"] - 0x1; mM++)
                        (mw["x"] = mN[mM]["x"] * mh), (mw["y"] = mN[mM]["y"]), (mw["z"] = mN[mM]["x"] * mS), mk["push"](mw["x"], mw["y"], mw["z"]), (mO["x"] = mA / mX), (mO["y"] = mM / (mN["length"] - 0x1)), mU["push"](mO["x"], mO["y"]);
                }
                for (mA = 0x0; mA < mX; mA++)
                    for (mM = 0x0; mM < mN["length"] - 0x1; mM++) {
                        var mg = (mI = mM + mA * mN["length"]),
                            mW = mI + mN["length"],
                            mH = mI + mN["length"] + 0x1,
                            mx = mI + 0x1;
                        mp["push"](mg, mW, mx), mp["push"](mW, mH, mx);
                    }
                if ((this["setIndex"](mp), this["setAttribute"]("position", new T0(mk, 0x3)), this["setAttribute"]("uv", new T0(mU, 0x2)), this["computeVertexNormals"](), mP === 0x2 * Math["PI"])) {
                    var mK = this["attributes"]["normal"]["array"],
                        mV = new Ed(),
                        mJ = new Ed(),
                        mG = new Ed();
                    for (mI = mX * mN["length"] * 0x3, mA = 0x0, mM = 0x0; mA < mN["length"]; mA++, mM += 0x3)
                        (mV["x"] = mK[mM + 0x0]),
                            (mV["y"] = mK[mM + 0x1]),
                            (mV["z"] = mK[mM + 0x2]),
                            (mJ["x"] = mK[mI + mM + 0x0]),
                            (mJ["y"] = mK[mI + mM + 0x1]),
                            (mJ["z"] = mK[mI + mM + 0x2]),
                            mG["addVectors"](mV, mJ)["normalize"](),
                            (mK[mM + 0x0] = mK[mI + mM + 0x0] = mG["x"]),
                            (mK[mM + 0x1] = mK[mI + mM + 0x1] = mG["y"]),
                            (mK[mM + 0x2] = mK[mI + mM + 0x2] = mG["z"]);
                }
            }
            function BI(mN, mX) {
                TO["call"](this),
                    (this["type"] = "ShapeGeometry"),
                    "object" == typeof mX && (console["warn"]("THREE.ShapeGeometry:\x20Options\x20parameter\x20has\x20been\x20removed."), (mX = mX["curveSegments"])),
                    (this["parameters"] = { shapes: mN, curveSegments: mX }),
                    this["fromBufferGeometry"](new BA(mN, mX)),
                    this["mergeVertices"]();
            }
            function BA(mN, mX) {
                TR["call"](this), (this["type"] = "ShapeBufferGeometry"), (this["parameters"] = { shapes: mN, curveSegments: mX }), (mX = mX || 0xc);
                var mf = [],
                    mP = [],
                    mI = [],
                    mA = [],
                    mM = 0x0,
                    mp = 0x0;
                if (!0x1 === Array["isArray"](mN)) mU(mN);
                else {
                    for (var mk = 0x0; mk < mN["length"]; mk++) mU(mN[mk]), this["addGroup"](mM, mp, mk), (mM += mp), (mp = 0x0);
                }
                function mU(mq) {
                    var mw,
                        mO,
                        mj,
                        mh = mP["length"] / 0x3,
                        mS = mq["extractPoints"](mX),
                        mg = mS["shape"],
                        mW = mS["holes"];
                    for (!0x1 === BC["isClockWise"](mg) && (mg = mg["reverse"]()), mw = 0x0, mO = mW["length"]; mw < mO; mw++) (mj = mW[mw]), !0x0 === BC["isClockWise"](mj) && (mW[mw] = mj["reverse"]());
                    var mH = BC["triangulateShape"](mg, mW);
                    for (mw = 0x0, mO = mW["length"]; mw < mO; mw++) (mj = mW[mw]), (mg = mg["concat"](mj));
                    for (mw = 0x0, mO = mg["length"]; mw < mO; mw++) {
                        var mx = mg[mw];
                        mP["push"](mx["x"], mx["y"], 0x0), mI["push"](0x0, 0x0, 0x1), mA["push"](mx["x"], mx["y"]);
                    }
                    for (mw = 0x0, mO = mH["length"]; mw < mO; mw++) {
                        var mK = mH[mw],
                            mV = mK[0x0] + mh,
                            mJ = mK[0x1] + mh,
                            mG = mK[0x2] + mh;
                        mf["push"](mV, mJ, mG), (mp += 0x3);
                    }
                }
                this["setIndex"](mf), this["setAttribute"]("position", new T0(mP, 0x3)), this["setAttribute"]("normal", new T0(mI, 0x3)), this["setAttribute"]("uv", new T0(mA, 0x2));
            }
            function BM(mN, mX) {
                if (((mX["shapes"] = []), Array["isArray"](mN)))
                    for (var mf = 0x0, mP = mN["length"]; mf < mP; mf++) {
                        var mI = mN[mf];
                        mX["shapes"]["push"](mI["uuid"]);
                    }
                else mX["shapes"]["push"](mN["uuid"]);
                return mX;
            }
            function Bp(mN, mX) {
                TR["call"](this), (this["type"] = "EdgesGeometry"), (this["parameters"] = { thresholdAngle: mX }), (mX = void 0x0 !== mX ? mX : 0x1);
                var mf,
                    mP,
                    mI,
                    mA,
                    mM = [],
                    mp = Math["cos"](E2["DEG2RAD"] * mX),
                    mk = [0x0, 0x0],
                    mU = {},
                    mq = ["a", "b", "c"];
                mN["isBufferGeometry"] ? (mA = new TO())["fromBufferGeometry"](mN) : (mA = mN["clone"]()), mA["mergeVertices"](), mA["computeFaceNormals"]();
                for (var mw = mA["vertices"], mO = mA["faces"], mj = 0x0, mh = mO["length"]; mj < mh; mj++)
                    for (var mS = mO[mj], mg = 0x0; mg < 0x3; mg++)
                        (mf = mS[mq[mg]]),
                            (mP = mS[mq[(mg + 0x1) % 0x3]]),
                            (mk[0x0] = Math["min"](mf, mP)),
                            (mk[0x1] = Math["max"](mf, mP)),
                            void 0x0 === mU[(mI = mk[0x0] + "," + mk[0x1])] ? (mU[mI] = { index1: mk[0x0], index2: mk[0x1], face1: mj, face2: void 0x0 }) : (mU[mI]["face2"] = mj);
                for (mI in mU) {
                    var mW = mU[mI];
                    if (void 0x0 === mW["face2"] || mO[mW["face1"]]["normal"]["dot"](mO[mW["face2"]]["normal"]) <= mp) {
                        var mH = mw[mW["index1"]];
                        mM["push"](mH["x"], mH["y"], mH["z"]), (mH = mw[mW["index2"]]), mM["push"](mH["x"], mH["y"], mH["z"]);
                    }
                }
                this["setAttribute"]("position", new T0(mM, 0x3));
            }
            function Bk(mN, mX, mf, mP, mI, mA, mM, mp) {
                TO["call"](this),
                    (this["type"] = "CylinderGeometry"),
                    (this["parameters"] = { radiusTop: mN, radiusBottom: mX, height: mf, radialSegments: mP, heightSegments: mI, openEnded: mA, thetaStart: mM, thetaLength: mp }),
                    this["fromBufferGeometry"](new BU(mN, mX, mf, mP, mI, mA, mM, mp)),
                    this["mergeVertices"]();
            }
            function BU(mN, mX, mf, mP, mI, mA, mM, mp) {
                TR["call"](this), (this["type"] = "CylinderBufferGeometry"), (this["parameters"] = { radiusTop: mN, radiusBottom: mX, height: mf, radialSegments: mP, heightSegments: mI, openEnded: mA, thetaStart: mM, thetaLength: mp });
                var mk = this;
                (mN = void 0x0 !== mN ? mN : 0x1),
                    (mX = void 0x0 !== mX ? mX : 0x1),
                    (mf = mf || 0x1),
                    (mP = Math["floor"](mP) || 0x8),
                    (mI = Math["floor"](mI) || 0x1),
                    (mA = void 0x0 !== mA && mA),
                    (mM = void 0x0 !== mM ? mM : 0x0),
                    (mp = void 0x0 !== mp ? mp : 0x2 * Math["PI"]);
                var mU = [],
                    mq = [],
                    mw = [],
                    mO = [],
                    mj = 0x0,
                    mh = [],
                    mS = mf / 0x2,
                    mg = 0x0;
                function mW(mH) {
                    var mx,
                        mK,
                        mV,
                        mJ = new E3(),
                        mG = new Ed(),
                        mL = 0x0,
                        mQ = !0x0 === mH ? mN : mX,
                        mz = !0x0 === mH ? 0x1 : -0x1;
                    for (mK = mj, mx = 0x1; mx <= mP; mx++) mq["push"](0x0, mS * mz, 0x0), mw["push"](0x0, mz, 0x0), mO["push"](0.5, 0.5), mj++;
                    for (mV = mj, mx = 0x0; mx <= mP; mx++) {
                        var v0 = (mx / mP) * mp + mM,
                            v1 = Math["cos"](v0),
                            v2 = Math["sin"](v0);
                        (mG["x"] = mQ * v2),
                            (mG["y"] = mS * mz),
                            (mG["z"] = mQ * v1),
                            mq["push"](mG["x"], mG["y"], mG["z"]),
                            mw["push"](0x0, mz, 0x0),
                            (mJ["x"] = 0.5 * v1 + 0.5),
                            (mJ["y"] = 0.5 * v2 * mz + 0.5),
                            mO["push"](mJ["x"], mJ["y"]),
                            mj++;
                    }
                    for (mx = 0x0; mx < mP; mx++) {
                        var v3 = mK + mx,
                            v4 = mV + mx;
                        !0x0 === mH ? mU["push"](v4, v4 + 0x1, v3) : mU["push"](v4 + 0x1, v4, v3), (mL += 0x3);
                    }
                    mk["addGroup"](mg, mL, !0x0 === mH ? 0x1 : 0x2), (mg += mL);
                }
                !(function () {
                    var mH,
                        mx,
                        mK = new Ed(),
                        mV = new Ed(),
                        mJ = 0x0,
                        mG = (mX - mN) / mf;
                    for (mx = 0x0; mx <= mI; mx++) {
                        var mL = [],
                            mQ = mx / mI,
                            mz = mQ * (mX - mN) + mN;
                        for (mH = 0x0; mH <= mP; mH++) {
                            var v0 = mH / mP,
                                v1 = v0 * mp + mM,
                                v2 = Math["sin"](v1),
                                v3 = Math["cos"](v1);
                            (mV["x"] = mz * v2),
                                (mV["y"] = -mQ * mf + mS),
                                (mV["z"] = mz * v3),
                                mq["push"](mV["x"], mV["y"], mV["z"]),
                                mK["set"](v2, mG, v3)["normalize"](),
                                mw["push"](mK["x"], mK["y"], mK["z"]),
                                mO["push"](v0, 0x1 - mQ),
                                mL["push"](mj++);
                        }
                        mh["push"](mL);
                    }
                    for (mH = 0x0; mH < mP; mH++)
                        for (mx = 0x0; mx < mI; mx++) {
                            var v4 = mh[mx][mH],
                                v5 = mh[mx + 0x1][mH],
                                v6 = mh[mx + 0x1][mH + 0x1],
                                v7 = mh[mx][mH + 0x1];
                            mU["push"](v4, v5, v7), mU["push"](v5, v6, v7), (mJ += 0x6);
                        }
                    mk["addGroup"](mg, mJ, 0x0), (mg += mJ);
                })(),
                    !0x1 === mA && (mN > 0x0 && mW(!0x0), mX > 0x0 && mW(!0x1)),
                    this["setIndex"](mU),
                    this["setAttribute"]("position", new T0(mq, 0x3)),
                    this["setAttribute"]("normal", new T0(mw, 0x3)),
                    this["setAttribute"]("uv", new T0(mO, 0x2));
            }
            function Bq(mN, mX, mf, mP, mI, mA, mM) {
                Bk["call"](this, 0x0, mN, mX, mf, mP, mI, mA, mM), (this["type"] = "ConeGeometry"), (this["parameters"] = { radius: mN, height: mX, radialSegments: mf, heightSegments: mP, openEnded: mI, thetaStart: mA, thetaLength: mM });
            }
            function Bw(mN, mX, mf, mP, mI, mA, mM) {
                BU["call"](this, 0x0, mN, mX, mf, mP, mI, mA, mM),
                    (this["type"] = "ConeBufferGeometry"),
                    (this["parameters"] = { radius: mN, height: mX, radialSegments: mf, heightSegments: mP, openEnded: mI, thetaStart: mA, thetaLength: mM });
            }
            function BO(mN, mX, mf, mP) {
                TO["call"](this), (this["type"] = "CircleGeometry"), (this["parameters"] = { radius: mN, segments: mX, thetaStart: mf, thetaLength: mP }), this["fromBufferGeometry"](new Bj(mN, mX, mf, mP)), this["mergeVertices"]();
            }
            function Bj(mN, mX, mf, mP) {
                TR["call"](this),
                    (this["type"] = "CircleBufferGeometry"),
                    (this["parameters"] = { radius: mN, segments: mX, thetaStart: mf, thetaLength: mP }),
                    (mN = mN || 0x1),
                    (mX = void 0x0 !== mX ? Math["max"](0x3, mX) : 0x8),
                    (mf = void 0x0 !== mf ? mf : 0x0),
                    (mP = void 0x0 !== mP ? mP : 0x2 * Math["PI"]);
                var mI,
                    mA,
                    mM = [],
                    mp = [],
                    mk = [],
                    mU = [],
                    mq = new Ed(),
                    mw = new E3();
                for (mp["push"](0x0, 0x0, 0x0), mk["push"](0x0, 0x0, 0x1), mU["push"](0.5, 0.5), mA = 0x0, mI = 0x3; mA <= mX; mA++, mI += 0x3) {
                    var mO = mf + (mA / mX) * mP;
                    (mq["x"] = mN * Math["cos"](mO)),
                        (mq["y"] = mN * Math["sin"](mO)),
                        mp["push"](mq["x"], mq["y"], mq["z"]),
                        mk["push"](0x0, 0x0, 0x1),
                        (mw["x"] = (mp[mI] / mN + 0x1) / 0x2),
                        (mw["y"] = (mp[mI + 0x1] / mN + 0x1) / 0x2),
                        mU["push"](mw["x"], mw["y"]);
                }
                for (mI = 0x1; mI <= mX; mI++) mM["push"](mI, mI + 0x1, 0x0);
                this["setIndex"](mM), this["setAttribute"]("position", new T0(mp, 0x3)), this["setAttribute"]("normal", new T0(mk, 0x3)), this["setAttribute"]("uv", new T0(mU, 0x2));
            }
            (Bm["prototype"] = Object["create"](TO["prototype"])),
                (Bm["prototype"]["constructor"] = Bm),
                (Bv["prototype"] = Object["create"](BF["prototype"])),
                (Bv["prototype"]["constructor"] = Bv),
                (By["prototype"] = Object["create"](TO["prototype"])),
                (By["prototype"]["constructor"] = By),
                (BD["prototype"] = Object["create"](TR["prototype"])),
                (BD["prototype"]["constructor"] = BD),
                (BN["prototype"] = Object["create"](TO["prototype"])),
                (BN["prototype"]["constructor"] = BN),
                (BX["prototype"] = Object["create"](TR["prototype"])),
                (BX["prototype"]["constructor"] = BX),
                (Bf["prototype"] = Object["create"](TO["prototype"])),
                (Bf["prototype"]["constructor"] = Bf),
                (BP["prototype"] = Object["create"](TR["prototype"])),
                (BP["prototype"]["constructor"] = BP),
                (BI["prototype"] = Object["create"](TO["prototype"])),
                (BI["prototype"]["constructor"] = BI),
                (BI["prototype"]["toJSON"] = function () {
                    var mN = TO["prototype"]["toJSON"]["call"](this);
                    return BM(this["parameters"]["shapes"], mN);
                }),
                (BA["prototype"] = Object["create"](TR["prototype"])),
                (BA["prototype"]["constructor"] = BA),
                (BA["prototype"]["toJSON"] = function () {
                    var mN = TR["prototype"]["toJSON"]["call"](this);
                    return BM(this["parameters"]["shapes"], mN);
                }),
                (Bp["prototype"] = Object["create"](TR["prototype"])),
                (Bp["prototype"]["constructor"] = Bp),
                (Bk["prototype"] = Object["create"](TO["prototype"])),
                (Bk["prototype"]["constructor"] = Bk),
                (BU["prototype"] = Object["create"](TR["prototype"])),
                (BU["prototype"]["constructor"] = BU),
                (Bq["prototype"] = Object["create"](Bk["prototype"])),
                (Bq["prototype"]["constructor"] = Bq),
                (Bw["prototype"] = Object["create"](BU["prototype"])),
                (Bw["prototype"]["constructor"] = Bw),
                (BO["prototype"] = Object["create"](TO["prototype"])),
                (BO["prototype"]["constructor"] = BO),
                (Bj["prototype"] = Object["create"](TR["prototype"])),
                (Bj["prototype"]["constructor"] = Bj);
            var Bh = Object["freeze"]({
                __proto__: null,
                WireframeGeometry: nm,
                ParametricGeometry: nv,
                ParametricBufferGeometry: ny,
                TetrahedronGeometry: nX,
                TetrahedronBufferGeometry: nf,
                OctahedronGeometry: nP,
                OctahedronBufferGeometry: nI,
                IcosahedronGeometry: nA,
                IcosahedronBufferGeometry: nM,
                DodecahedronGeometry: np,
                DodecahedronBufferGeometry: nk,
                PolyhedronGeometry: nD,
                PolyhedronBufferGeometry: nN,
                TubeGeometry: nU,
                TubeBufferGeometry: nq,
                TorusKnotGeometry: nw,
                TorusKnotBufferGeometry: nO,
                TorusGeometry: nj,
                TorusBufferGeometry: nh,
                TextGeometry: Bm,
                TextBufferGeometry: Bv,
                SphereGeometry: By,
                SphereBufferGeometry: BD,
                RingGeometry: BN,
                RingBufferGeometry: BX,
                PlaneGeometry: C3,
                PlaneBufferGeometry: C4,
                LatheGeometry: Bf,
                LatheBufferGeometry: BP,
                ShapeGeometry: BI,
                ShapeBufferGeometry: BA,
                ExtrudeGeometry: BB,
                ExtrudeBufferGeometry: BF,
                EdgesGeometry: Bp,
                ConeGeometry: Bq,
                ConeBufferGeometry: Bw,
                CylinderGeometry: Bk,
                CylinderBufferGeometry: BU,
                CircleGeometry: BO,
                CircleBufferGeometry: Bj,
                BoxGeometry: class extends TO {
                    constructor(mN, mX, mf, mP, mI, mA) {
                        super(),
                            (this["type"] = "BoxGeometry"),
                            (this["parameters"] = { width: mN, height: mX, depth: mf, widthSegments: mP, heightSegments: mI, depthSegments: mA }),
                            this["fromBufferGeometry"](new Tj(mN, mX, mf, mP, mI, mA)),
                            this["mergeVertices"]();
                    }
                },
                BoxBufferGeometry: Tj,
            });
            function BS(mN) {
                Rg["call"](this), (this["type"] = "ShadowMaterial"), (this["color"] = new Rq(0x0)), (this["transparent"] = !0x0), this["setValues"](mN);
            }
            function Bg(mN) {
                TW["call"](this, mN), (this["type"] = "RawShaderMaterial");
            }
            function BW(mN) {
                Rg["call"](this),
                    (this["defines"] = { STANDARD: "" }),
                    (this["type"] = "MeshStandardMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["roughness"] = 0x1),
                    (this["metalness"] = 0x0),
                    (this["map"] = null),
                    (this["lightMap"] = null),
                    (this["lightMapIntensity"] = 0x1),
                    (this["aoMap"] = null),
                    (this["aoMapIntensity"] = 0x1),
                    (this["emissive"] = new Rq(0x0)),
                    (this["emissiveIntensity"] = 0x1),
                    (this["emissiveMap"] = null),
                    (this["bumpMap"] = null),
                    (this["bumpScale"] = 0x1),
                    (this["normalMap"] = null),
                    (this["normalMapType"] = rV),
                    (this["normalScale"] = new E3(0x1, 0x1)),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["roughnessMap"] = null),
                    (this["metalnessMap"] = null),
                    (this["alphaMap"] = null),
                    (this["envMap"] = null),
                    (this["envMapIntensity"] = 0x1),
                    (this["refractionRatio"] = 0.98),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["wireframeLinecap"] = "round"),
                    (this["wireframeLinejoin"] = "round"),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    (this["vertexTangents"] = !0x1),
                    this["setValues"](mN);
            }
            function BH(mN) {
                BW["call"](this),
                    (this["defines"] = { STANDARD: "", PHYSICAL: "" }),
                    (this["type"] = "MeshPhysicalMaterial"),
                    (this["clearcoat"] = 0x0),
                    (this["clearcoatMap"] = null),
                    (this["clearcoatRoughness"] = 0x0),
                    (this["clearcoatRoughnessMap"] = null),
                    (this["clearcoatNormalScale"] = new E3(0x1, 0x1)),
                    (this["clearcoatNormalMap"] = null),
                    (this["reflectivity"] = 0.5),
                    (this["sheen"] = null),
                    (this["transparency"] = 0x0),
                    this["setValues"](mN);
            }
            function Bx(mN) {
                Rg["call"](this),
                    (this["type"] = "MeshPhongMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["specular"] = new Rq(0x111111)),
                    (this["shininess"] = 0x1e),
                    (this["map"] = null),
                    (this["lightMap"] = null),
                    (this["lightMapIntensity"] = 0x1),
                    (this["aoMap"] = null),
                    (this["aoMapIntensity"] = 0x1),
                    (this["emissive"] = new Rq(0x0)),
                    (this["emissiveIntensity"] = 0x1),
                    (this["emissiveMap"] = null),
                    (this["bumpMap"] = null),
                    (this["bumpScale"] = 0x1),
                    (this["normalMap"] = null),
                    (this["normalMapType"] = rV),
                    (this["normalScale"] = new E3(0x1, 0x1)),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["specularMap"] = null),
                    (this["alphaMap"] = null),
                    (this["envMap"] = null),
                    (this["combine"] = 0x0),
                    (this["reflectivity"] = 0x1),
                    (this["refractionRatio"] = 0.98),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["wireframeLinecap"] = "round"),
                    (this["wireframeLinejoin"] = "round"),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    this["setValues"](mN);
            }
            function BK(mN) {
                Rg["call"](this),
                    (this["defines"] = { TOON: "" }),
                    (this["type"] = "MeshToonMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["specular"] = new Rq(0x111111)),
                    (this["shininess"] = 0x1e),
                    (this["map"] = null),
                    (this["gradientMap"] = null),
                    (this["lightMap"] = null),
                    (this["lightMapIntensity"] = 0x1),
                    (this["aoMap"] = null),
                    (this["aoMapIntensity"] = 0x1),
                    (this["emissive"] = new Rq(0x0)),
                    (this["emissiveIntensity"] = 0x1),
                    (this["emissiveMap"] = null),
                    (this["bumpMap"] = null),
                    (this["bumpScale"] = 0x1),
                    (this["normalMap"] = null),
                    (this["normalMapType"] = rV),
                    (this["normalScale"] = new E3(0x1, 0x1)),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["specularMap"] = null),
                    (this["alphaMap"] = null),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["wireframeLinecap"] = "round"),
                    (this["wireframeLinejoin"] = "round"),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    this["setValues"](mN);
            }
            function BV(mN) {
                Rg["call"](this),
                    (this["type"] = "MeshNormalMaterial"),
                    (this["bumpMap"] = null),
                    (this["bumpScale"] = 0x1),
                    (this["normalMap"] = null),
                    (this["normalMapType"] = rV),
                    (this["normalScale"] = new E3(0x1, 0x1)),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["fog"] = !0x1),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    this["setValues"](mN);
            }
            function BJ(mN) {
                Rg["call"](this),
                    (this["type"] = "MeshLambertMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["map"] = null),
                    (this["lightMap"] = null),
                    (this["lightMapIntensity"] = 0x1),
                    (this["aoMap"] = null),
                    (this["aoMapIntensity"] = 0x1),
                    (this["emissive"] = new Rq(0x0)),
                    (this["emissiveIntensity"] = 0x1),
                    (this["emissiveMap"] = null),
                    (this["specularMap"] = null),
                    (this["alphaMap"] = null),
                    (this["envMap"] = null),
                    (this["combine"] = 0x0),
                    (this["reflectivity"] = 0x1),
                    (this["refractionRatio"] = 0.98),
                    (this["wireframe"] = !0x1),
                    (this["wireframeLinewidth"] = 0x1),
                    (this["wireframeLinecap"] = "round"),
                    (this["wireframeLinejoin"] = "round"),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    this["setValues"](mN);
            }
            function BG(mN) {
                Rg["call"](this),
                    (this["defines"] = { MATCAP: "" }),
                    (this["type"] = "MeshMatcapMaterial"),
                    (this["color"] = new Rq(0xffffff)),
                    (this["matcap"] = null),
                    (this["map"] = null),
                    (this["bumpMap"] = null),
                    (this["bumpScale"] = 0x1),
                    (this["normalMap"] = null),
                    (this["normalMapType"] = rV),
                    (this["normalScale"] = new E3(0x1, 0x1)),
                    (this["displacementMap"] = null),
                    (this["displacementScale"] = 0x1),
                    (this["displacementBias"] = 0x0),
                    (this["alphaMap"] = null),
                    (this["skinning"] = !0x1),
                    (this["morphTargets"] = !0x1),
                    (this["morphNormals"] = !0x1),
                    this["setValues"](mN);
            }
            function BL(mN) {
                YQ["call"](this), (this["type"] = "LineDashedMaterial"), (this["scale"] = 0x1), (this["dashSize"] = 0x3), (this["gapSize"] = 0x1), this["setValues"](mN);
            }
            (BS["prototype"] = Object["create"](Rg["prototype"])),
                (BS["prototype"]["constructor"] = BS),
                (BS["prototype"]["isShadowMaterial"] = !0x0),
                (BS["prototype"]["copy"] = function (mN) {
                    return Rg["prototype"]["copy"]["call"](this, mN), this["color"]["copy"](mN["color"]), this;
                }),
                (Bg["prototype"] = Object["create"](TW["prototype"])),
                (Bg["prototype"]["constructor"] = Bg),
                (Bg["prototype"]["isRawShaderMaterial"] = !0x0),
                (BW["prototype"] = Object["create"](Rg["prototype"])),
                (BW["prototype"]["constructor"] = BW),
                (BW["prototype"]["isMeshStandardMaterial"] = !0x0),
                (BW["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        (this["defines"] = { STANDARD: "" }),
                        this["color"]["copy"](mN["color"]),
                        (this["roughness"] = mN["roughness"]),
                        (this["metalness"] = mN["metalness"]),
                        (this["map"] = mN["map"]),
                        (this["lightMap"] = mN["lightMap"]),
                        (this["lightMapIntensity"] = mN["lightMapIntensity"]),
                        (this["aoMap"] = mN["aoMap"]),
                        (this["aoMapIntensity"] = mN["aoMapIntensity"]),
                        this["emissive"]["copy"](mN["emissive"]),
                        (this["emissiveMap"] = mN["emissiveMap"]),
                        (this["emissiveIntensity"] = mN["emissiveIntensity"]),
                        (this["bumpMap"] = mN["bumpMap"]),
                        (this["bumpScale"] = mN["bumpScale"]),
                        (this["normalMap"] = mN["normalMap"]),
                        (this["normalMapType"] = mN["normalMapType"]),
                        this["normalScale"]["copy"](mN["normalScale"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        (this["roughnessMap"] = mN["roughnessMap"]),
                        (this["metalnessMap"] = mN["metalnessMap"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["envMap"] = mN["envMap"]),
                        (this["envMapIntensity"] = mN["envMapIntensity"]),
                        (this["refractionRatio"] = mN["refractionRatio"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["wireframeLinecap"] = mN["wireframeLinecap"]),
                        (this["wireframeLinejoin"] = mN["wireframeLinejoin"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        (this["vertexTangents"] = mN["vertexTangents"]),
                        this
                    );
                }),
                (BH["prototype"] = Object["create"](BW["prototype"])),
                (BH["prototype"]["constructor"] = BH),
                (BH["prototype"]["isMeshPhysicalMaterial"] = !0x0),
                (BH["prototype"]["copy"] = function (mN) {
                    return (
                        BW["prototype"]["copy"]["call"](this, mN),
                        (this["defines"] = { STANDARD: "", PHYSICAL: "" }),
                        (this["clearcoat"] = mN["clearcoat"]),
                        (this["clearcoatMap"] = mN["clearcoatMap"]),
                        (this["clearcoatRoughness"] = mN["clearcoatRoughness"]),
                        (this["clearcoatRoughnessMap"] = mN["clearcoatRoughnessMap"]),
                        (this["clearcoatNormalMap"] = mN["clearcoatNormalMap"]),
                        this["clearcoatNormalScale"]["copy"](mN["clearcoatNormalScale"]),
                        (this["reflectivity"] = mN["reflectivity"]),
                        mN["sheen"] ? (this["sheen"] = (this["sheen"] || new Rq())["copy"](mN["sheen"])) : (this["sheen"] = null),
                        (this["transparency"] = mN["transparency"]),
                        this
                    );
                }),
                (Bx["prototype"] = Object["create"](Rg["prototype"])),
                (Bx["prototype"]["constructor"] = Bx),
                (Bx["prototype"]["isMeshPhongMaterial"] = !0x0),
                (Bx["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        this["specular"]["copy"](mN["specular"]),
                        (this["shininess"] = mN["shininess"]),
                        (this["map"] = mN["map"]),
                        (this["lightMap"] = mN["lightMap"]),
                        (this["lightMapIntensity"] = mN["lightMapIntensity"]),
                        (this["aoMap"] = mN["aoMap"]),
                        (this["aoMapIntensity"] = mN["aoMapIntensity"]),
                        this["emissive"]["copy"](mN["emissive"]),
                        (this["emissiveMap"] = mN["emissiveMap"]),
                        (this["emissiveIntensity"] = mN["emissiveIntensity"]),
                        (this["bumpMap"] = mN["bumpMap"]),
                        (this["bumpScale"] = mN["bumpScale"]),
                        (this["normalMap"] = mN["normalMap"]),
                        (this["normalMapType"] = mN["normalMapType"]),
                        this["normalScale"]["copy"](mN["normalScale"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        (this["specularMap"] = mN["specularMap"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["envMap"] = mN["envMap"]),
                        (this["combine"] = mN["combine"]),
                        (this["reflectivity"] = mN["reflectivity"]),
                        (this["refractionRatio"] = mN["refractionRatio"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["wireframeLinecap"] = mN["wireframeLinecap"]),
                        (this["wireframeLinejoin"] = mN["wireframeLinejoin"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        this
                    );
                }),
                (BK["prototype"] = Object["create"](Rg["prototype"])),
                (BK["prototype"]["constructor"] = BK),
                (BK["prototype"]["isMeshToonMaterial"] = !0x0),
                (BK["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        this["specular"]["copy"](mN["specular"]),
                        (this["shininess"] = mN["shininess"]),
                        (this["map"] = mN["map"]),
                        (this["gradientMap"] = mN["gradientMap"]),
                        (this["lightMap"] = mN["lightMap"]),
                        (this["lightMapIntensity"] = mN["lightMapIntensity"]),
                        (this["aoMap"] = mN["aoMap"]),
                        (this["aoMapIntensity"] = mN["aoMapIntensity"]),
                        this["emissive"]["copy"](mN["emissive"]),
                        (this["emissiveMap"] = mN["emissiveMap"]),
                        (this["emissiveIntensity"] = mN["emissiveIntensity"]),
                        (this["bumpMap"] = mN["bumpMap"]),
                        (this["bumpScale"] = mN["bumpScale"]),
                        (this["normalMap"] = mN["normalMap"]),
                        (this["normalMapType"] = mN["normalMapType"]),
                        this["normalScale"]["copy"](mN["normalScale"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        (this["specularMap"] = mN["specularMap"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["wireframeLinecap"] = mN["wireframeLinecap"]),
                        (this["wireframeLinejoin"] = mN["wireframeLinejoin"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        this
                    );
                }),
                (BV["prototype"] = Object["create"](Rg["prototype"])),
                (BV["prototype"]["constructor"] = BV),
                (BV["prototype"]["isMeshNormalMaterial"] = !0x0),
                (BV["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        (this["bumpMap"] = mN["bumpMap"]),
                        (this["bumpScale"] = mN["bumpScale"]),
                        (this["normalMap"] = mN["normalMap"]),
                        (this["normalMapType"] = mN["normalMapType"]),
                        this["normalScale"]["copy"](mN["normalScale"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        this
                    );
                }),
                (BJ["prototype"] = Object["create"](Rg["prototype"])),
                (BJ["prototype"]["constructor"] = BJ),
                (BJ["prototype"]["isMeshLambertMaterial"] = !0x0),
                (BJ["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        this["color"]["copy"](mN["color"]),
                        (this["map"] = mN["map"]),
                        (this["lightMap"] = mN["lightMap"]),
                        (this["lightMapIntensity"] = mN["lightMapIntensity"]),
                        (this["aoMap"] = mN["aoMap"]),
                        (this["aoMapIntensity"] = mN["aoMapIntensity"]),
                        this["emissive"]["copy"](mN["emissive"]),
                        (this["emissiveMap"] = mN["emissiveMap"]),
                        (this["emissiveIntensity"] = mN["emissiveIntensity"]),
                        (this["specularMap"] = mN["specularMap"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["envMap"] = mN["envMap"]),
                        (this["combine"] = mN["combine"]),
                        (this["reflectivity"] = mN["reflectivity"]),
                        (this["refractionRatio"] = mN["refractionRatio"]),
                        (this["wireframe"] = mN["wireframe"]),
                        (this["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                        (this["wireframeLinecap"] = mN["wireframeLinecap"]),
                        (this["wireframeLinejoin"] = mN["wireframeLinejoin"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        this
                    );
                }),
                (BG["prototype"] = Object["create"](Rg["prototype"])),
                (BG["prototype"]["constructor"] = BG),
                (BG["prototype"]["isMeshMatcapMaterial"] = !0x0),
                (BG["prototype"]["copy"] = function (mN) {
                    return (
                        Rg["prototype"]["copy"]["call"](this, mN),
                        (this["defines"] = { MATCAP: "" }),
                        this["color"]["copy"](mN["color"]),
                        (this["matcap"] = mN["matcap"]),
                        (this["map"] = mN["map"]),
                        (this["bumpMap"] = mN["bumpMap"]),
                        (this["bumpScale"] = mN["bumpScale"]),
                        (this["normalMap"] = mN["normalMap"]),
                        (this["normalMapType"] = mN["normalMapType"]),
                        this["normalScale"]["copy"](mN["normalScale"]),
                        (this["displacementMap"] = mN["displacementMap"]),
                        (this["displacementScale"] = mN["displacementScale"]),
                        (this["displacementBias"] = mN["displacementBias"]),
                        (this["alphaMap"] = mN["alphaMap"]),
                        (this["skinning"] = mN["skinning"]),
                        (this["morphTargets"] = mN["morphTargets"]),
                        (this["morphNormals"] = mN["morphNormals"]),
                        this
                    );
                }),
                (BL["prototype"] = Object["create"](YQ["prototype"])),
                (BL["prototype"]["constructor"] = BL),
                (BL["prototype"]["isLineDashedMaterial"] = !0x0),
                (BL["prototype"]["copy"] = function (mN) {
                    return YQ["prototype"]["copy"]["call"](this, mN), (this["scale"] = mN["scale"]), (this["dashSize"] = mN["dashSize"]), (this["gapSize"] = mN["gapSize"]), this;
                });
            var BQ = Object["freeze"]({
                    __proto__: null,
                    ShadowMaterial: BS,
                    SpriteMaterial: YF,
                    RawShaderMaterial: Bg,
                    ShaderMaterial: TW,
                    PointsMaterial: n9,
                    MeshPhysicalMaterial: BH,
                    MeshStandardMaterial: BW,
                    MeshPhongMaterial: Bx,
                    MeshToonMaterial: BK,
                    MeshNormalMaterial: BV,
                    MeshLambertMaterial: BJ,
                    MeshDepthMaterial: dz,
                    MeshDistanceMaterial: Y0,
                    MeshBasicMaterial: RW,
                    MeshMatcapMaterial: BG,
                    LineDashedMaterial: BL,
                    LineBasicMaterial: YQ,
                    Material: Rg,
                }),
                Bz = {
                    arraySlice: function (mN, mX, mf) {
                        return Bz["isTypedArray"](mN) ? new mN["constructor"](mN["subarray"](mX, void 0x0 !== mf ? mf : mN["length"])) : mN["slice"](mX, mf);
                    },
                    convertArray: function (mN, mX, mf) {
                        return !mN || (!mf && mN["constructor"] === mX) ? mN : "number" == typeof mX["BYTES_PER_ELEMENT"] ? new mX(mN) : Array["prototype"]["slice"]["call"](mN);
                    },
                    isTypedArray: function (mN) {
                        return ArrayBuffer["isView"](mN) && !(mN instanceof DataView);
                    },
                    getKeyframeOrder: function (mN) {
                        for (var mX = mN["length"], mf = new Array(mX), mP = 0x0; mP !== mX; ++mP) mf[mP] = mP;
                        return (
                            mf["sort"](function (mI, mA) {
                                return mN[mI] - mN[mA];
                            }),
                            mf
                        );
                    },
                    sortedArray: function (mN, mX, mf) {
                        for (var mP = mN["length"], mI = new mN["constructor"](mP), mA = 0x0, mM = 0x0; mM !== mP; ++mA) for (var mp = mf[mA] * mX, mk = 0x0; mk !== mX; ++mk) mI[mM++] = mN[mp + mk];
                        return mI;
                    },
                    flattenJSON: function (mN, mX, mf, mP) {
                        for (var mI = 0x1, mA = mN[0x0]; void 0x0 !== mA && void 0x0 === mA[mP]; ) mA = mN[mI++];
                        if (void 0x0 !== mA) {
                            var mM = mA[mP];
                            if (void 0x0 !== mM) {
                                if (Array["isArray"](mM))
                                    do {
                                        void 0x0 !== (mM = mA[mP]) && (mX["push"](mA["time"]), mf["push"]["apply"](mf, mM)), (mA = mN[mI++]);
                                    } while (void 0x0 !== mA);
                                else {
                                    if (void 0x0 !== mM["toArray"])
                                        do {
                                            void 0x0 !== (mM = mA[mP]) && (mX["push"](mA["time"]), mM["toArray"](mf, mf["length"])), (mA = mN[mI++]);
                                        } while (void 0x0 !== mA);
                                    else
                                        do {
                                            void 0x0 !== (mM = mA[mP]) && (mX["push"](mA["time"]), mf["push"](mM)), (mA = mN[mI++]);
                                        } while (void 0x0 !== mA);
                                }
                            }
                        }
                    },
                    subclip: function (mN, mX, mf, mP, mI) {
                        mI = mI || 0x1e;
                        var mA = mN["clone"]();
                        mA["name"] = mX;
                        for (var mM = [], mp = 0x0; mp < mA["tracks"]["length"]; ++mp) {
                            for (var mk = mA["tracks"][mp], mU = mk["getValueSize"](), mq = [], mw = [], mO = 0x0; mO < mk["times"]["length"]; ++mO) {
                                var mj = mk["times"][mO] * mI;
                                if (!(mj < mf || mj >= mP)) {
                                    mq["push"](mk["times"][mO]);
                                    for (var mh = 0x0; mh < mU; ++mh) mw["push"](mk["values"][mO * mU + mh]);
                                }
                            }
                            0x0 !== mq["length"] && ((mk["times"] = Bz["convertArray"](mq, mk["times"]["constructor"])), (mk["values"] = Bz["convertArray"](mw, mk["values"]["constructor"])), mM["push"](mk));
                        }
                        mA["tracks"] = mM;
                        var mS = 0x1 / 0x0;
                        for (mp = 0x0; mp < mA["tracks"]["length"]; ++mp) mS > mA["tracks"][mp]["times"][0x0] && (mS = mA["tracks"][mp]["times"][0x0]);
                        for (mp = 0x0; mp < mA["tracks"]["length"]; ++mp) mA["tracks"][mp]["shift"](-0x1 * mS);
                        return mA["resetDuration"](), mA;
                    },
                    makeClipAdditive: function (mN, mX, mf, mP) {
                        void 0x0 === mX && (mX = 0x0), void 0x0 === mf && (mf = mN), (void 0x0 === mP || mP <= 0x0) && (mP = 0x1e);
                        for (var mI = mN["tracks"]["length"], mA = mX / mP, mM = 0x0; mM < mI; ++mM) {
                            var mp = mf["tracks"][mM],
                                mk = mp["ValueTypeName"];
                            if ("bool" !== mk && "string" !== mk) {
                                var mU = mN["tracks"]["find"](function (mx) {
                                    return mx["name"] === mp["name"] && mx["ValueTypeName"] === mk;
                                });
                                if (void 0x0 !== mU) {
                                    var mq,
                                        mw = mp["getValueSize"](),
                                        mO = mp["times"]["length"] - 0x1;
                                    if (mA <= mp["times"][0x0]) mq = Bz["arraySlice"](mp["values"], 0x0, mp["valueSize"]);
                                    else {
                                        if (mA >= mp["times"][mO]) {
                                            var mj = mO * mw;
                                            mq = Bz["arraySlice"](mp["values"], mj);
                                        } else {
                                            var mh = mp["createInterpolant"]();
                                            mh["evaluate"](mA), (mq = mh["resultBuffer"]);
                                        }
                                    }
                                    if ("quaternion" === mk) new ER(mq[0x0], mq[0x1], mq[0x2], mq[0x3])["normalize"]()["conjugate"]()["toArray"](mq);
                                    for (var mS = mU["times"]["length"], mg = 0x0; mg < mS; ++mg) {
                                        var mW = mg * mw;
                                        if ("quaternion" === mk) ER["multiplyQuaternionsFlat"](mU["values"], mW, mq, 0x0, mU["values"], mW);
                                        else {
                                            for (var mH = 0x0; mH < mw; ++mH) mU["values"][mW + mH] -= mq[mH];
                                        }
                                    }
                                }
                            }
                        }
                        return (mN["blendMode"] = 0x9c5), mN;
                    },
                };
            function F0(mN, mX, mf, mP) {
                (this["parameterPositions"] = mN), (this["_cachedIndex"] = 0x0), (this["resultBuffer"] = void 0x0 !== mP ? mP : new mX["constructor"](mf)), (this["sampleValues"] = mX), (this["valueSize"] = mf);
            }
            function F1(mN, mX, mf, mP) {
                F0["call"](this, mN, mX, mf, mP), (this["_weightPrev"] = -0x0), (this["_offsetPrev"] = -0x0), (this["_weightNext"] = -0x0), (this["_offsetNext"] = -0x0);
            }
            function F2(mN, mX, mf, mP) {
                F0["call"](this, mN, mX, mf, mP);
            }
            function F3(mN, mX, mf, mP) {
                F0["call"](this, mN, mX, mf, mP);
            }
            function F4(mN, mX, mf, mP) {
                if (void 0x0 === mN) throw new Error("THREE.KeyframeTrack:\x20track\x20name\x20is\x20undefined");
                if (void 0x0 === mX || 0x0 === mX["length"]) throw new Error("THREE.KeyframeTrack:\x20no\x20keyframes\x20in\x20track\x20named\x20" + mN);
                (this["name"] = mN), (this["times"] = Bz["convertArray"](mX, this["TimeBufferType"])), (this["values"] = Bz["convertArray"](mf, this["ValueBufferType"])), this["setInterpolation"](mP || this["DefaultInterpolation"]);
            }
            function F5(mN, mX, mf) {
                F4["call"](this, mN, mX, mf);
            }
            function F6(mN, mX, mf, mP) {
                F4["call"](this, mN, mX, mf, mP);
            }
            function F7(mN, mX, mf, mP) {
                F4["call"](this, mN, mX, mf, mP);
            }
            function F8(mN, mX, mf, mP) {
                F0["call"](this, mN, mX, mf, mP);
            }
            function F9(mN, mX, mf, mP) {
                F4["call"](this, mN, mX, mf, mP);
            }
            function FE(mN, mX, mf, mP) {
                F4["call"](this, mN, mX, mf, mP);
            }
            function FR(mN, mX, mf, mP) {
                F4["call"](this, mN, mX, mf, mP);
            }
            function FT(mN, mX, mf, mP) {
                (this["name"] = mN),
                    (this["tracks"] = mf),
                    (this["duration"] = void 0x0 !== mX ? mX : -0x1),
                    (this["blendMode"] = void 0x0 !== mP ? mP : rh),
                    (this["uuid"] = E2["generateUUID"]()),
                    this["duration"] < 0x0 && this["resetDuration"]();
            }
            function FC(mN) {
                if (void 0x0 === mN["type"]) throw new Error("THREE.KeyframeTrack:\x20track\x20type\x20undefined,\x20can\x20not\x20parse");
                var mX = (function (mI) {
                    switch (mI["toLowerCase"]()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return F7;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return FR;
                        case "color":
                            return F6;
                        case "quaternion":
                            return F9;
                        case "bool":
                        case "boolean":
                            return F5;
                        case "string":
                            return FE;
                    }
                    throw new Error("THREE.KeyframeTrack:\x20Unsupported\x20typeName:\x20" + mI);
                })(mN["type"]);
                if (void 0x0 === mN["times"]) {
                    var mf = [],
                        mP = [];
                    Bz["flattenJSON"](mN["keys"], mf, mP, "value"), (mN["times"] = mf), (mN["values"] = mP);
                }
                return void 0x0 !== mX["parse"] ? mX["parse"](mN) : new mX(mN["name"], mN["times"], mN["values"], mN["interpolation"]);
            }
            Object["assign"](F0["prototype"], {
                evaluate: function (mN) {
                    var mX = this["parameterPositions"],
                        mf = this["_cachedIndex"],
                        mP = mX[mf],
                        mI = mX[mf - 0x1];
                    mU: {
                        mq: {
                            var mA;
                            mw: {
                                mO: if (!(mN < mP)) {
                                    for (var mM = mf + 0x2; ; ) {
                                        if (void 0x0 === mP) {
                                            if (mN < mI) break mO;
                                            return (mf = mX["length"]), (this["_cachedIndex"] = mf), this["afterEnd_"](mf - 0x1, mN, mI);
                                        }
                                        if (mf === mM) break;
                                        if (((mI = mP), mN < (mP = mX[++mf]))) break mq;
                                    }
                                    mA = mX["length"];
                                    break mw;
                                }
                                if (mN >= mI) break mU;
                                var mp = mX[0x1];
                                mN < mp && ((mf = 0x2), (mI = mp));
                                for (mM = mf - 0x2; ; ) {
                                    if (void 0x0 === mI) return (this["_cachedIndex"] = 0x0), this["beforeStart_"](0x0, mN, mP);
                                    if (mf === mM) break;
                                    if (((mP = mI), mN >= (mI = mX[--mf - 0x1]))) break mq;
                                }
                                (mA = mf), (mf = 0x0);
                            }
                            for (; mf < mA; ) {
                                var mk = (mf + mA) >>> 0x1;
                                mN < mX[mk] ? (mA = mk) : (mf = mk + 0x1);
                            }
                            if (((mP = mX[mf]), void 0x0 === (mI = mX[mf - 0x1]))) return (this["_cachedIndex"] = 0x0), this["beforeStart_"](0x0, mN, mP);
                            if (void 0x0 === mP) return (mf = mX["length"]), (this["_cachedIndex"] = mf), this["afterEnd_"](mf - 0x1, mI, mN);
                        }
                        (this["_cachedIndex"] = mf), this["intervalChanged_"](mf, mI, mP);
                    }
                    return this["interpolate_"](mf, mI, mN, mP);
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function () {
                    return this["settings"] || this["DefaultSettings_"];
                },
                copySampleValue_: function (mN) {
                    for (var mX = this["resultBuffer"], mf = this["sampleValues"], mP = this["valueSize"], mI = mN * mP, mA = 0x0; mA !== mP; ++mA) mX[mA] = mf[mI + mA];
                    return mX;
                },
                interpolate_: function () {
                    throw new Error("call\x20to\x20abstract\x20method");
                },
                intervalChanged_: function () {},
            }),
                Object["assign"](F0["prototype"], { beforeStart_: F0["prototype"]["copySampleValue_"], afterEnd_: F0["prototype"]["copySampleValue_"] }),
                (F1["prototype"] = Object["assign"](Object["create"](F0["prototype"]), {
                    constructor: F1,
                    DefaultSettings_: { endingStart: rw, endingEnd: rw },
                    intervalChanged_: function (mN, mX, mf) {
                        var mP = this["parameterPositions"],
                            mI = mN - 0x2,
                            mA = mN + 0x1,
                            mM = mP[mI],
                            mp = mP[mA];
                        if (void 0x0 === mM)
                            switch (this["getSettings_"]()["endingStart"]) {
                                case rO:
                                    (mI = mN), (mM = 0x2 * mX - mf);
                                    break;
                                case rj:
                                    mM = mX + mP[(mI = mP["length"] - 0x2)] - mP[mI + 0x1];
                                    break;
                                default:
                                    (mI = mN), (mM = mf);
                            }
                        if (void 0x0 === mp)
                            switch (this["getSettings_"]()["endingEnd"]) {
                                case rO:
                                    (mA = mN), (mp = 0x2 * mf - mX);
                                    break;
                                case rj:
                                    (mA = 0x1), (mp = mf + mP[0x1] - mP[0x0]);
                                    break;
                                default:
                                    (mA = mN - 0x1), (mp = mX);
                            }
                        var mk = 0.5 * (mf - mX),
                            mU = this["valueSize"];
                        (this["_weightPrev"] = mk / (mX - mM)), (this["_weightNext"] = mk / (mp - mf)), (this["_offsetPrev"] = mI * mU), (this["_offsetNext"] = mA * mU);
                    },
                    interpolate_: function (mN, mX, mf, mP) {
                        for (
                            var mI = this["resultBuffer"],
                                mA = this["sampleValues"],
                                mM = this["valueSize"],
                                mp = mN * mM,
                                mk = mp - mM,
                                mU = this["_offsetPrev"],
                                mq = this["_offsetNext"],
                                mw = this["_weightPrev"],
                                mO = this["_weightNext"],
                                mj = (mf - mX) / (mP - mX),
                                mh = mj * mj,
                                mS = mh * mj,
                                mg = -mw * mS + 0x2 * mw * mh - mw * mj,
                                mW = (0x1 + mw) * mS + (-1.5 - 0x2 * mw) * mh + (-0.5 + mw) * mj + 0x1,
                                mH = (-0x1 - mO) * mS + (1.5 + mO) * mh + 0.5 * mj,
                                mx = mO * mS - mO * mh,
                                mK = 0x0;
                            mK !== mM;
                            ++mK
                        )
                            mI[mK] = mg * mA[mU + mK] + mW * mA[mk + mK] + mH * mA[mp + mK] + mx * mA[mq + mK];
                        return mI;
                    },
                })),
                (F2["prototype"] = Object["assign"](Object["create"](F0["prototype"]), {
                    constructor: F2,
                    interpolate_: function (mN, mX, mf, mP) {
                        for (var mI = this["resultBuffer"], mA = this["sampleValues"], mM = this["valueSize"], mp = mN * mM, mk = mp - mM, mU = (mf - mX) / (mP - mX), mq = 0x1 - mU, mw = 0x0; mw !== mM; ++mw)
                            mI[mw] = mA[mk + mw] * mq + mA[mp + mw] * mU;
                        return mI;
                    },
                })),
                (F3["prototype"] = Object["assign"](Object["create"](F0["prototype"]), {
                    constructor: F3,
                    interpolate_: function (mN) {
                        return this["copySampleValue_"](mN - 0x1);
                    },
                })),
                Object["assign"](F4, {
                    toJSON: function (mN) {
                        var mX,
                            mf = mN["constructor"];
                        if (void 0x0 !== mf["toJSON"]) mX = mf["toJSON"](mN);
                        else {
                            mX = { name: mN["name"], times: Bz["convertArray"](mN["times"], Array), values: Bz["convertArray"](mN["values"], Array) };
                            var mP = mN["getInterpolation"]();
                            mP !== mN["DefaultInterpolation"] && (mX["interpolation"] = mP);
                        }
                        return (mX["type"] = mN["ValueTypeName"]), mX;
                    },
                }),
                Object["assign"](F4["prototype"], {
                    constructor: F4,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: rU,
                    InterpolantFactoryMethodDiscrete: function (mN) {
                        return new F3(this["times"], this["values"], this["getValueSize"](), mN);
                    },
                    InterpolantFactoryMethodLinear: function (mN) {
                        return new F2(this["times"], this["values"], this["getValueSize"](), mN);
                    },
                    InterpolantFactoryMethodSmooth: function (mN) {
                        return new F1(this["times"], this["values"], this["getValueSize"](), mN);
                    },
                    setInterpolation: function (mN) {
                        var mX;
                        switch (mN) {
                            case rk:
                                mX = this["InterpolantFactoryMethodDiscrete"];
                                break;
                            case rU:
                                mX = this["InterpolantFactoryMethodLinear"];
                                break;
                            case rq:
                                mX = this["InterpolantFactoryMethodSmooth"];
                        }
                        if (void 0x0 === mX) {
                            var mf = "unsupported\x20interpolation\x20for\x20" + this["ValueTypeName"] + "\x20keyframe\x20track\x20named\x20" + this["name"];
                            if (void 0x0 === this["createInterpolant"]) {
                                if (mN === this["DefaultInterpolation"]) throw new Error(mf);
                                this["setInterpolation"](this["DefaultInterpolation"]);
                            }
                            return console["warn"]("THREE.KeyframeTrack:", mf), this;
                        }
                        return (this["createInterpolant"] = mX), this;
                    },
                    getInterpolation: function () {
                        switch (this["createInterpolant"]) {
                            case this["InterpolantFactoryMethodDiscrete"]:
                                return rk;
                            case this["InterpolantFactoryMethodLinear"]:
                                return rU;
                            case this["InterpolantFactoryMethodSmooth"]:
                                return rq;
                        }
                    },
                    getValueSize: function () {
                        return this["values"]["length"] / this["times"]["length"];
                    },
                    shift: function (mN) {
                        if (0x0 !== mN) {
                            for (var mX = this["times"], mf = 0x0, mP = mX["length"]; mf !== mP; ++mf) mX[mf] += mN;
                        }
                        return this;
                    },
                    scale: function (mN) {
                        if (0x1 !== mN) {
                            for (var mX = this["times"], mf = 0x0, mP = mX["length"]; mf !== mP; ++mf) mX[mf] *= mN;
                        }
                        return this;
                    },
                    trim: function (mN, mX) {
                        for (var mf = this["times"], mP = mf["length"], mI = 0x0, mA = mP - 0x1; mI !== mP && mf[mI] < mN; ) ++mI;
                        for (; -0x1 !== mA && mf[mA] > mX; ) --mA;
                        if ((++mA, 0x0 !== mI || mA !== mP)) {
                            mI >= mA && (mI = (mA = Math["max"](mA, 0x1)) - 0x1);
                            var mM = this["getValueSize"]();
                            (this["times"] = Bz["arraySlice"](mf, mI, mA)), (this["values"] = Bz["arraySlice"](this["values"], mI * mM, mA * mM));
                        }
                        return this;
                    },
                    validate: function () {
                        var mN = !0x0,
                            mX = this["getValueSize"]();
                        mX - Math["floor"](mX) != 0x0 && (console["error"]("THREE.KeyframeTrack:\x20Invalid\x20value\x20size\x20in\x20track.", this), (mN = !0x1));
                        var mf = this["times"],
                            mP = this["values"],
                            mI = mf["length"];
                        0x0 === mI && (console["error"]("THREE.KeyframeTrack:\x20Track\x20is\x20empty.", this), (mN = !0x1));
                        for (var mA = null, mM = 0x0; mM !== mI; mM++) {
                            var mp = mf[mM];
                            if ("number" == typeof mp && isNaN(mp)) {
                                console["error"]("THREE.KeyframeTrack:\x20Time\x20is\x20not\x20a\x20valid\x20number.", this, mM, mp), (mN = !0x1);
                                break;
                            }
                            if (null !== mA && mA > mp) {
                                console["error"]("THREE.KeyframeTrack:\x20Out\x20of\x20order\x20keys.", this, mM, mp, mA), (mN = !0x1);
                                break;
                            }
                            mA = mp;
                        }
                        if (void 0x0 !== mP && Bz["isTypedArray"](mP)) {
                            mM = 0x0;
                            for (var mk = mP["length"]; mM !== mk; ++mM) {
                                var mU = mP[mM];
                                if (isNaN(mU)) {
                                    console["error"]("THREE.KeyframeTrack:\x20Value\x20is\x20not\x20a\x20valid\x20number.", this, mM, mU), (mN = !0x1);
                                    break;
                                }
                            }
                        }
                        return mN;
                    },
                    optimize: function () {
                        for (var mN = Bz["arraySlice"](this["times"]), mX = Bz["arraySlice"](this["values"]), mf = this["getValueSize"](), mP = this["getInterpolation"]() === rq, mI = 0x1, mA = mN["length"] - 0x1, mM = 0x1; mM < mA; ++mM) {
                            var mp = !0x1,
                                mk = mN[mM];
                            if (mk !== mN[mM + 0x1] && (0x1 !== mM || mk !== mk[0x0])) {
                                if (mP) mp = !0x0;
                                else
                                    for (var mU = mM * mf, mq = mU - mf, mw = mU + mf, mO = 0x0; mO !== mf; ++mO) {
                                        var mj = mX[mU + mO];
                                        if (mj !== mX[mq + mO] || mj !== mX[mw + mO]) {
                                            mp = !0x0;
                                            break;
                                        }
                                    }
                            }
                            if (mp) {
                                if (mM !== mI) {
                                    mN[mI] = mN[mM];
                                    var mh = mM * mf,
                                        mS = mI * mf;
                                    for (mO = 0x0; mO !== mf; ++mO) mX[mS + mO] = mX[mh + mO];
                                }
                                ++mI;
                            }
                        }
                        if (mA > 0x0) {
                            mN[mI] = mN[mA];
                            for (mh = mA * mf, mS = mI * mf, mO = 0x0; mO !== mf; ++mO) mX[mS + mO] = mX[mh + mO];
                            ++mI;
                        }
                        return mI !== mN["length"] ? ((this["times"] = Bz["arraySlice"](mN, 0x0, mI)), (this["values"] = Bz["arraySlice"](mX, 0x0, mI * mf))) : ((this["times"] = mN), (this["values"] = mX)), this;
                    },
                    clone: function () {
                        var mN = Bz["arraySlice"](this["times"], 0x0),
                            mX = Bz["arraySlice"](this["values"], 0x0),
                            mf = new (0x0, this["constructor"])(this["name"], mN, mX);
                        return (mf["createInterpolant"] = this["createInterpolant"]), mf;
                    },
                }),
                (F5["prototype"] = Object["assign"](Object["create"](F4["prototype"]), {
                    constructor: F5,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: rk,
                    InterpolantFactoryMethodLinear: void 0x0,
                    InterpolantFactoryMethodSmooth: void 0x0,
                })),
                (F6["prototype"] = Object["assign"](Object["create"](F4["prototype"]), { constructor: F6, ValueTypeName: "color" })),
                (F7["prototype"] = Object["assign"](Object["create"](F4["prototype"]), { constructor: F7, ValueTypeName: "number" })),
                (F8["prototype"] = Object["assign"](Object["create"](F0["prototype"]), {
                    constructor: F8,
                    interpolate_: function (mN, mX, mf, mP) {
                        for (var mI = this["resultBuffer"], mA = this["sampleValues"], mM = this["valueSize"], mp = mN * mM, mk = (mf - mX) / (mP - mX), mU = mp + mM; mp !== mU; mp += 0x4) ER["slerpFlat"](mI, 0x0, mA, mp - mM, mA, mp, mk);
                        return mI;
                    },
                })),
                (F9["prototype"] = Object["assign"](Object["create"](F4["prototype"]), {
                    constructor: F9,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: rU,
                    InterpolantFactoryMethodLinear: function (mN) {
                        return new F8(this["times"], this["values"], this["getValueSize"](), mN);
                    },
                    InterpolantFactoryMethodSmooth: void 0x0,
                })),
                (FE["prototype"] = Object["assign"](Object["create"](F4["prototype"]), {
                    constructor: FE,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: rk,
                    InterpolantFactoryMethodLinear: void 0x0,
                    InterpolantFactoryMethodSmooth: void 0x0,
                })),
                (FR["prototype"] = Object["assign"](Object["create"](F4["prototype"]), { constructor: FR, ValueTypeName: "vector" })),
                Object["assign"](FT, {
                    parse: function (mN) {
                        for (var mX = [], mf = mN["tracks"], mP = 0x1 / (mN["fps"] || 0x1), mI = 0x0, mA = mf["length"]; mI !== mA; ++mI) mX["push"](FC(mf[mI])["scale"](mP));
                        return new FT(mN["name"], mN["duration"], mX, mN["blendMode"]);
                    },
                    toJSON: function (mN) {
                        for (var mX = [], mf = mN["tracks"], mP = { name: mN["name"], duration: mN["duration"], tracks: mX, uuid: mN["uuid"], blendMode: mN["blendMode"] }, mI = 0x0, mA = mf["length"]; mI !== mA; ++mI)
                            mX["push"](F4["toJSON"](mf[mI]));
                        return mP;
                    },
                    CreateFromMorphTargetSequence: function (mN, mX, mf, mP) {
                        for (var mI = mX["length"], mA = [], mM = 0x0; mM < mI; mM++) {
                            var mp = [],
                                mk = [];
                            mp["push"]((mM + mI - 0x1) % mI, mM, (mM + 0x1) % mI), mk["push"](0x0, 0x1, 0x0);
                            var mU = Bz["getKeyframeOrder"](mp);
                            (mp = Bz["sortedArray"](mp, 0x1, mU)),
                                (mk = Bz["sortedArray"](mk, 0x1, mU)),
                                mP || 0x0 !== mp[0x0] || (mp["push"](mI), mk["push"](mk[0x0])),
                                mA["push"](new F7(".morphTargetInfluences[" + mX[mM]["name"] + "]", mp, mk)["scale"](0x1 / mf));
                        }
                        return new FT(mN, -0x1, mA);
                    },
                    findByName: function (mN, mX) {
                        var mf = mN;
                        if (!Array["isArray"](mN)) {
                            var mP = mN;
                            mf = (mP["geometry"] && mP["geometry"]["animations"]) || mP["animations"];
                        }
                        for (var mI = 0x0; mI < mf["length"]; mI++) if (mf[mI]["name"] === mX) return mf[mI];
                        return null;
                    },
                    CreateClipsFromMorphTargetSequences: function (mN, mX, mf) {
                        for (var mP = {}, mI = /^([\w-]*?)([\d]+)$/, mA = 0x0, mM = mN["length"]; mA < mM; mA++) {
                            var mp = mN[mA],
                                mk = mp["name"]["match"](mI);
                            if (mk && mk["length"] > 0x1) {
                                var mU = mP[(mw = mk[0x1])];
                                mU || (mP[mw] = mU = []), mU["push"](mp);
                            }
                        }
                        var mq = [];
                        for (var mw in mP) mq["push"](FT["CreateFromMorphTargetSequence"](mw, mP[mw], mX, mf));
                        return mq;
                    },
                    parseAnimation: function (mN, mX) {
                        if (!mN) return console["error"]("THREE.AnimationClip:\x20No\x20animation\x20in\x20JSONLoader\x20data."), null;
                        for (
                            var mf = function (mx, mK, mV, mJ, mG) {
                                    if (0x0 !== mV["length"]) {
                                        var mL = [],
                                            mQ = [];
                                        Bz["flattenJSON"](mV, mL, mQ, mJ), 0x0 !== mL["length"] && mG["push"](new mx(mK, mL, mQ));
                                    }
                                },
                                mP = [],
                                mI = mN["name"] || "default",
                                mA = mN["length"] || -0x1,
                                mM = mN["fps"] || 0x1e,
                                mp = mN["blendMode"],
                                mk = mN["hierarchy"] || [],
                                mU = 0x0;
                            mU < mk["length"];
                            mU++
                        ) {
                            var mq = mk[mU]["keys"];
                            if (mq && 0x0 !== mq["length"]) {
                                if (mq[0x0]["morphTargets"]) {
                                    for (var mw = {}, mO = 0x0; mO < mq["length"]; mO++)
                                        if (mq[mO]["morphTargets"]) {
                                            for (var mj = 0x0; mj < mq[mO]["morphTargets"]["length"]; mj++) mw[mq[mO]["morphTargets"][mj]] = -0x1;
                                        }
                                    for (var mh in mw) {
                                        var mS = [],
                                            mg = [];
                                        for (mj = 0x0; mj !== mq[mO]["morphTargets"]["length"]; ++mj) {
                                            var mW = mq[mO];
                                            mS["push"](mW["time"]), mg["push"](mW["morphTarget"] === mh ? 0x1 : 0x0);
                                        }
                                        mP["push"](new F7(".morphTargetInfluence[" + mh + "]", mS, mg));
                                    }
                                    mA = mw["length"] * (mM || 0x1);
                                } else {
                                    var mH = ".bones[" + mX[mU]["name"] + "]";
                                    mf(FR, mH + ".position", mq, "pos", mP), mf(F9, mH + ".quaternion", mq, "rot", mP), mf(FR, mH + ".scale", mq, "scl", mP);
                                }
                            }
                        }
                        return 0x0 === mP["length"] ? null : new FT(mI, mA, mP, mp);
                    },
                }),
                Object["assign"](FT["prototype"], {
                    resetDuration: function () {
                        for (var mN = 0x0, mX = 0x0, mf = this["tracks"]["length"]; mX !== mf; ++mX) {
                            var mP = this["tracks"][mX];
                            mN = Math["max"](mN, mP["times"][mP["times"]["length"] - 0x1]);
                        }
                        return (this["duration"] = mN), this;
                    },
                    trim: function () {
                        for (var mN = 0x0; mN < this["tracks"]["length"]; mN++) this["tracks"][mN]["trim"](0x0, this["duration"]);
                        return this;
                    },
                    validate: function () {
                        for (var mN = !0x0, mX = 0x0; mX < this["tracks"]["length"]; mX++) mN = mN && this["tracks"][mX]["validate"]();
                        return mN;
                    },
                    optimize: function () {
                        for (var mN = 0x0; mN < this["tracks"]["length"]; mN++) this["tracks"][mN]["optimize"]();
                        return this;
                    },
                    clone: function () {
                        for (var mN = [], mX = 0x0; mX < this["tracks"]["length"]; mX++) mN["push"](this["tracks"][mX]["clone"]());
                        return new FT(this["name"], this["duration"], mN, this["blendMode"]);
                    },
                });
            var Fd = {
                enabled: !0x1,
                files: {},
                add: function (mN, mX) {
                    !0x1 !== this["enabled"] && (this["files"][mN] = mX);
                },
                get: function (mN) {
                    if (!0x1 !== this["enabled"]) return this["files"][mN];
                },
                remove: function (mN) {
                    delete this["files"][mN];
                },
                clear: function () {
                    this["files"] = {};
                },
            };
            function FY(mN, mX, mf) {
                var mP = this,
                    mI = !0x1,
                    mA = 0x0,
                    mM = 0x0,
                    mp = void 0x0,
                    mk = [];
                (this["onStart"] = void 0x0),
                    (this["onLoad"] = mN),
                    (this["onProgress"] = mX),
                    (this["onError"] = mf),
                    (this["itemStart"] = function (mU) {
                        mM++, !0x1 === mI && void 0x0 !== mP["onStart"] && mP["onStart"](mU, mA, mM), (mI = !0x0);
                    }),
                    (this["itemEnd"] = function (mU) {
                        mA++, void 0x0 !== mP["onProgress"] && mP["onProgress"](mU, mA, mM), mA === mM && ((mI = !0x1), void 0x0 !== mP["onLoad"] && mP["onLoad"]());
                    }),
                    (this["itemError"] = function (mU) {
                        void 0x0 !== mP["onError"] && mP["onError"](mU);
                    }),
                    (this["resolveURL"] = function (mU) {
                        return mp ? mp(mU) : mU;
                    }),
                    (this["setURLModifier"] = function (mU) {
                        return (mp = mU), this;
                    }),
                    (this["addHandler"] = function (mU, mq) {
                        return mk["push"](mU, mq), this;
                    }),
                    (this["removeHandler"] = function (mU) {
                        var mq = mk["indexOf"](mU);
                        return -0x1 !== mq && mk["splice"](mq, 0x2), this;
                    }),
                    (this["getHandler"] = function (mU) {
                        for (var mq = 0x0, mw = mk["length"]; mq < mw; mq += 0x2) {
                            var mO = mk[mq],
                                mj = mk[mq + 0x1];
                            if ((mO["global"] && (mO["lastIndex"] = 0x0), mO["test"](mU))) return mj;
                        }
                        return null;
                    });
            }
            var FB = new FY();
            function FF(mN) {
                (this["manager"] = void 0x0 !== mN ? mN : FB), (this["crossOrigin"] = "anonymous"), (this["path"] = ""), (this["resourcePath"] = ""), (this["requestHeader"] = {});
            }
            Object["assign"](FF["prototype"], {
                load: function () {},
                loadAsync: function (mN, mX) {
                    var mf = this;
                    return new Promise(function (mP, mI) {
                        mf["load"](mN, mP, mX, mI);
                    });
                },
                parse: function () {},
                setCrossOrigin: function (mN) {
                    return (this["crossOrigin"] = mN), this;
                },
                setPath: function (mN) {
                    return (this["path"] = mN), this;
                },
                setResourcePath: function (mN) {
                    return (this["resourcePath"] = mN), this;
                },
                setRequestHeader: function (mN) {
                    return (this["requestHeader"] = mN), this;
                },
            });
            var Fb = {};
            function FZ(mN) {
                FF["call"](this, mN);
            }
            function Fm(mN) {
                FF["call"](this, mN);
            }
            function Fv(mN) {
                FF["call"](this, mN);
            }
            function Fy(mN) {
                FF["call"](this, mN);
            }
            function FD(mN) {
                FF["call"](this, mN);
            }
            function FN(mN) {
                FF["call"](this, mN);
            }
            function FX(mN) {
                FF["call"](this, mN);
            }
            function Ff() {
                (this["type"] = "Curve"), (this["arcLengthDivisions"] = 0xc8);
            }
            function FP(mN, mX, mf, mP, mI, mA, mM, mp) {
                Ff["call"](this),
                    (this["type"] = "EllipseCurve"),
                    (this["aX"] = mN || 0x0),
                    (this["aY"] = mX || 0x0),
                    (this["xRadius"] = mf || 0x1),
                    (this["yRadius"] = mP || 0x1),
                    (this["aStartAngle"] = mI || 0x0),
                    (this["aEndAngle"] = mA || 0x2 * Math["PI"]),
                    (this["aClockwise"] = mM || !0x1),
                    (this["aRotation"] = mp || 0x0);
            }
            function FI(mN, mX, mf, mP, mI, mA) {
                FP["call"](this, mN, mX, mf, mf, mP, mI, mA), (this["type"] = "ArcCurve");
            }
            function FA() {
                var mN = 0x0,
                    mX = 0x0,
                    mf = 0x0,
                    mP = 0x0;
                function mI(mA, mM, mp, mk) {
                    (mN = mA), (mX = mp), (mf = -0x3 * mA + 0x3 * mM - 0x2 * mp - mk), (mP = 0x2 * mA - 0x2 * mM + mp + mk);
                }
                return {
                    initCatmullRom: function (mA, mM, mp, mk, mU) {
                        mI(mM, mp, mU * (mp - mA), mU * (mk - mM));
                    },
                    initNonuniformCatmullRom: function (mA, mM, mp, mk, mU, mq, mw) {
                        var mO = (mM - mA) / mU - (mp - mA) / (mU + mq) + (mp - mM) / mq,
                            mj = (mp - mM) / mq - (mk - mM) / (mq + mw) + (mk - mp) / mw;
                        mI(mM, mp, (mO *= mq), (mj *= mq));
                    },
                    calc: function (mA) {
                        var mM = mA * mA;
                        return mN + mX * mA + mf * mM + mP * (mM * mA);
                    },
                };
            }
            (FZ["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                constructor: FZ,
                load: function (mN, mX, mf, mP) {
                    void 0x0 === mN && (mN = ""), void 0x0 !== this["path"] && (mN = this["path"] + mN), (mN = this["manager"]["resolveURL"](mN));
                    var mI = this,
                        mA = Fd["get"](mN);
                    if (void 0x0 !== mA)
                        return (
                            mI["manager"]["itemStart"](mN),
                            setTimeout(function () {
                                mX && mX(mA), mI["manager"]["itemEnd"](mN);
                            }, 0x0),
                            mA
                        );
                    if (void 0x0 === Fb[mN]) {
                        var mM = mN["match"](/^data:(.*?)(;base64)?,(.*)$/);
                        if (mM) {
                            var mp = mM[0x1],
                                mk = !!mM[0x2],
                                mU = mM[0x3];
                            (mU = decodeURIComponent(mU)), mk && (mU = atob(mU));
                            try {
                                var mq,
                                    mw = (this["responseType"] || "")["toLowerCase"]();
                                switch (mw) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var mO = new Uint8Array(mU["length"]), mj = 0x0; mj < mU["length"]; mj++) mO[mj] = mU["charCodeAt"](mj);
                                        mq = "blob" === mw ? new Blob([mO["buffer"]], { type: mp }) : mO["buffer"];
                                        break;
                                    case "document":
                                        var mh = new DOMParser();
                                        mq = mh["parseFromString"](mU, mp);
                                        break;
                                    case "json":
                                        mq = JSON["parse"](mU);
                                        break;
                                    default:
                                        mq = mU;
                                }
                                setTimeout(function () {
                                    mX && mX(mq), mI["manager"]["itemEnd"](mN);
                                }, 0x0);
                            } catch (mW) {
                                setTimeout(function () {
                                    mP && mP(mW), mI["manager"]["itemError"](mN), mI["manager"]["itemEnd"](mN);
                                }, 0x0);
                            }
                        } else {
                            (Fb[mN] = []), Fb[mN]["push"]({ onLoad: mX, onProgress: mf, onError: mP });
                            var mS = new XMLHttpRequest();
                            for (var mg in (mS["open"]("GET", mN, !0x0),
                            mS["addEventListener"](
                                "load",
                                function (mH) {
                                    var mx = this["response"],
                                        mK = Fb[mN];
                                    if ((delete Fb[mN], 0xc8 === this["status"] || 0x0 === this["status"])) {
                                        0x0 === this["status"] && console["warn"]("THREE.FileLoader:\x20HTTP\x20Status\x200\x20received."), Fd["add"](mN, mx);
                                        for (var mV = 0x0, mJ = mK["length"]; mV < mJ; mV++) {
                                            (mG = mK[mV])["onLoad"] && mG["onLoad"](mx);
                                        }
                                        mI["manager"]["itemEnd"](mN);
                                    } else {
                                        for (mV = 0x0, mJ = mK["length"]; mV < mJ; mV++) {
                                            var mG;
                                            (mG = mK[mV])["onError"] && mG["onError"](mH);
                                        }
                                        mI["manager"]["itemError"](mN), mI["manager"]["itemEnd"](mN);
                                    }
                                },
                                !0x1
                            ),
                            mS["addEventListener"](
                                "progress",
                                function (mH) {
                                    for (var mx = Fb[mN], mK = 0x0, mV = mx["length"]; mK < mV; mK++) {
                                        var mJ = mx[mK];
                                        mJ["onProgress"] && mJ["onProgress"](mH);
                                    }
                                },
                                !0x1
                            ),
                            mS["addEventListener"](
                                "error",
                                function (mH) {
                                    var mx = Fb[mN];
                                    delete Fb[mN];
                                    for (var mK = 0x0, mV = mx["length"]; mK < mV; mK++) {
                                        var mJ = mx[mK];
                                        mJ["onError"] && mJ["onError"](mH);
                                    }
                                    mI["manager"]["itemError"](mN), mI["manager"]["itemEnd"](mN);
                                },
                                !0x1
                            ),
                            mS["addEventListener"](
                                "abort",
                                function (mH) {
                                    var mx = Fb[mN];
                                    delete Fb[mN];
                                    for (var mK = 0x0, mV = mx["length"]; mK < mV; mK++) {
                                        var mJ = mx[mK];
                                        mJ["onError"] && mJ["onError"](mH);
                                    }
                                    mI["manager"]["itemError"](mN), mI["manager"]["itemEnd"](mN);
                                },
                                !0x1
                            ),
                            void 0x0 !== this["responseType"] && (mS["responseType"] = this["responseType"]),
                            void 0x0 !== this["withCredentials"] && (mS["withCredentials"] = this["withCredentials"]),
                            mS["overrideMimeType"] && mS["overrideMimeType"](void 0x0 !== this["mimeType"] ? this["mimeType"] : "text/plain"),
                            this["requestHeader"]))
                                mS["setRequestHeader"](mg, this["requestHeader"][mg]);
                            mS["send"](null);
                        }
                        return mI["manager"]["itemStart"](mN), mS;
                    }
                    Fb[mN]["push"]({ onLoad: mX, onProgress: mf, onError: mP });
                },
                setResponseType: function (mN) {
                    return (this["responseType"] = mN), this;
                },
                setWithCredentials: function (mN) {
                    return (this["withCredentials"] = mN), this;
                },
                setMimeType: function (mN) {
                    return (this["mimeType"] = mN), this;
                },
            })),
                (Fm["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: Fm,
                    load: function (mN, mX, mf, mP) {
                        var mI = this,
                            mA = new FZ(mI["manager"]);
                        mA["setPath"](mI["path"]),
                            mA["load"](
                                mN,
                                function (mM) {
                                    try {
                                        mX(mI["parse"](JSON["parse"](mM)));
                                    } catch (mp) {
                                        mP ? mP(mp) : console["error"](mp), mI["manager"]["itemError"](mN);
                                    }
                                },
                                mf,
                                mP
                            );
                    },
                    parse: function (mN) {
                        for (var mX = [], mf = 0x0; mf < mN["length"]; mf++) {
                            var mP = FT["parse"](mN[mf]);
                            mX["push"](mP);
                        }
                        return mX;
                    },
                })),
                (Fv["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: Fv,
                    load: function (mN, mX, mf, mP) {
                        var mI = this,
                            mA = [],
                            mM = new nF();
                        mM["image"] = mA;
                        var mp = new FZ(this["manager"]);
                        function mk(mO) {
                            mp["load"](
                                mN[mO],
                                function (mj) {
                                    var mh = mI["parse"](mj, !0x0);
                                    (mA[mO] = { width: mh["width"], height: mh["height"], format: mh["format"], mipmaps: mh["mipmaps"] }),
                                        0x6 === (mU += 0x1) && (0x1 === mh["mipmapCount"] && (mM["minFilter"] = rB), (mM["format"] = mh["format"]), (mM["needsUpdate"] = !0x0), mX && mX(mM));
                                },
                                mf,
                                mP
                            );
                        }
                        if ((mp["setPath"](this["path"]), mp["setResponseType"]("arraybuffer"), Array["isArray"](mN))) {
                            for (var mU = 0x0, mq = 0x0, mw = mN["length"]; mq < mw; ++mq) mk(mq);
                        } else
                            mp["load"](
                                mN,
                                function (mO) {
                                    var mj = mI["parse"](mO, !0x0);
                                    if (mj["isCubemap"])
                                        for (var mh = mj["mipmaps"]["length"] / mj["mipmapCount"], mS = 0x0; mS < mh; mS++) {
                                            mA[mS] = { mipmaps: [] };
                                            for (var mg = 0x0; mg < mj["mipmapCount"]; mg++)
                                                mA[mS]["mipmaps"]["push"](mj["mipmaps"][mS * mj["mipmapCount"] + mg]), (mA[mS]["format"] = mj["format"]), (mA[mS]["width"] = mj["width"]), (mA[mS]["height"] = mj["height"]);
                                        }
                                    else (mM["image"]["width"] = mj["width"]), (mM["image"]["height"] = mj["height"]), (mM["mipmaps"] = mj["mipmaps"]);
                                    0x1 === mj["mipmapCount"] && (mM["minFilter"] = rB), (mM["format"] = mj["format"]), (mM["needsUpdate"] = !0x0), mX && mX(mM);
                                },
                                mf,
                                mP
                            );
                        return mM;
                    },
                })),
                (Fy["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: Fy,
                    load: function (mN, mX, mf, mP) {
                        var mI = this,
                            mA = new TG(),
                            mM = new FZ(this["manager"]);
                        return (
                            mM["setResponseType"]("arraybuffer"),
                            mM["setPath"](this["path"]),
                            mM["load"](
                                mN,
                                function (mp) {
                                    var mk = mI["parse"](mp);
                                    mk &&
                                        (void 0x0 !== mk["image"] ? (mA["image"] = mk["image"]) : void 0x0 !== mk["data"] && ((mA["image"]["width"] = mk["width"]), (mA["image"]["height"] = mk["height"]), (mA["image"]["data"] = mk["data"])),
                                        (mA["wrapS"] = void 0x0 !== mk["wrapS"] ? mk["wrapS"] : rR),
                                        (mA["wrapT"] = void 0x0 !== mk["wrapT"] ? mk["wrapT"] : rR),
                                        (mA["magFilter"] = void 0x0 !== mk["magFilter"] ? mk["magFilter"] : rB),
                                        (mA["minFilter"] = void 0x0 !== mk["minFilter"] ? mk["minFilter"] : rB),
                                        (mA["anisotropy"] = void 0x0 !== mk["anisotropy"] ? mk["anisotropy"] : 0x1),
                                        void 0x0 !== mk["format"] && (mA["format"] = mk["format"]),
                                        void 0x0 !== mk["type"] && (mA["type"] = mk["type"]),
                                        void 0x0 !== mk["mipmaps"] && ((mA["mipmaps"] = mk["mipmaps"]), (mA["minFilter"] = rb)),
                                        0x1 === mk["mipmapCount"] && (mA["minFilter"] = rB),
                                        (mA["needsUpdate"] = !0x0),
                                        mX && mX(mA, mk));
                                },
                                mf,
                                mP
                            ),
                            mA
                        );
                    },
                })),
                (FD["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: FD,
                    load: function (mN, mX, mf, mP) {
                        void 0x0 !== this["path"] && (mN = this["path"] + mN), (mN = this["manager"]["resolveURL"](mN));
                        var mI = this,
                            mA = Fd["get"](mN);
                        if (void 0x0 !== mA)
                            return (
                                mI["manager"]["itemStart"](mN),
                                setTimeout(function () {
                                    mX && mX(mA), mI["manager"]["itemEnd"](mN);
                                }, 0x0),
                                mA
                            );
                        var mM = document["createElementNS"]("http://www.w3.org/1999/xhtml", "img");
                        function mp() {
                            mM["removeEventListener"]("load", mp, !0x1), mM["removeEventListener"]("error", mk, !0x1), Fd["add"](mN, this), mX && mX(this), mI["manager"]["itemEnd"](mN);
                        }
                        function mk(mU) {
                            mM["removeEventListener"]("load", mp, !0x1), mM["removeEventListener"]("error", mk, !0x1), mP && mP(mU), mI["manager"]["itemError"](mN), mI["manager"]["itemEnd"](mN);
                        }
                        return (
                            mM["addEventListener"]("load", mp, !0x1),
                            mM["addEventListener"]("error", mk, !0x1),
                            "data:" !== mN["substr"](0x0, 0x5) && void 0x0 !== this["crossOrigin"] && (mM["crossOrigin"] = this["crossOrigin"]),
                            mI["manager"]["itemStart"](mN),
                            (mM["src"] = mN),
                            mM
                        );
                    },
                })),
                (FN["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: FN,
                    load: function (mN, mX, mf, mP) {
                        var mI = new Cb(),
                            mA = new FD(this["manager"]);
                        mA["setCrossOrigin"](this["crossOrigin"]), mA["setPath"](this["path"]);
                        var mM = 0x0;
                        function mp(mU) {
                            mA["load"](
                                mN[mU],
                                function (mq) {
                                    (mI["images"][mU] = mq), 0x6 === ++mM && ((mI["needsUpdate"] = !0x0), mX && mX(mI));
                                },
                                void 0x0,
                                mP
                            );
                        }
                        for (var mk = 0x0; mk < mN["length"]; ++mk) mp(mk);
                        return mI;
                    },
                })),
                (FX["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: FX,
                    load: function (mN, mX, mf, mP) {
                        var mI = new E7(),
                            mA = new FD(this["manager"]);
                        return (
                            mA["setCrossOrigin"](this["crossOrigin"]),
                            mA["setPath"](this["path"]),
                            mA["load"](
                                mN,
                                function (mM) {
                                    mI["image"] = mM;
                                    var mp = mN["search"](/\.jpe?g($|\?)/i) > 0x0 || 0x0 === mN["search"](/^data\:image\/jpeg/);
                                    (mI["format"] = mp ? rX : rf), (mI["needsUpdate"] = !0x0), void 0x0 !== mX && mX(mI);
                                },
                                mf,
                                mP
                            ),
                            mI
                        );
                    },
                })),
                Object["assign"](Ff["prototype"], {
                    getPoint: function () {
                        return console["warn"]("THREE.Curve:\x20.getPoint()\x20not\x20implemented."), null;
                    },
                    getPointAt: function (mN, mX) {
                        var mf = this["getUtoTmapping"](mN);
                        return this["getPoint"](mf, mX);
                    },
                    getPoints: function (mN) {
                        void 0x0 === mN && (mN = 0x5);
                        for (var mX = [], mf = 0x0; mf <= mN; mf++) mX["push"](this["getPoint"](mf / mN));
                        return mX;
                    },
                    getSpacedPoints: function (mN) {
                        void 0x0 === mN && (mN = 0x5);
                        for (var mX = [], mf = 0x0; mf <= mN; mf++) mX["push"](this["getPointAt"](mf / mN));
                        return mX;
                    },
                    getLength: function () {
                        var mN = this["getLengths"]();
                        return mN[mN["length"] - 0x1];
                    },
                    getLengths: function (mN) {
                        if ((void 0x0 === mN && (mN = this["arcLengthDivisions"]), this["cacheArcLengths"] && this["cacheArcLengths"]["length"] === mN + 0x1 && !this["needsUpdate"])) return this["cacheArcLengths"];
                        this["needsUpdate"] = !0x1;
                        var mX,
                            mf,
                            mP = [],
                            mI = this["getPoint"](0x0),
                            mA = 0x0;
                        for (mP["push"](0x0), mf = 0x1; mf <= mN; mf++) (mA += (mX = this["getPoint"](mf / mN))["distanceTo"](mI)), mP["push"](mA), (mI = mX);
                        return (this["cacheArcLengths"] = mP), mP;
                    },
                    updateArcLengths: function () {
                        (this["needsUpdate"] = !0x0), this["getLengths"]();
                    },
                    getUtoTmapping: function (mN, mX) {
                        var mf,
                            mP = this["getLengths"](),
                            mI = 0x0,
                            mA = mP["length"];
                        mf = mX || mN * mP[mA - 0x1];
                        for (var mM, mp = 0x0, mk = mA - 0x1; mp <= mk; )
                            if ((mM = mP[(mI = Math["floor"](mp + (mk - mp) / 0x2))] - mf) < 0x0) mp = mI + 0x1;
                            else {
                                if (!(mM > 0x0)) {
                                    mk = mI;
                                    break;
                                }
                                mk = mI - 0x1;
                            }
                        if (mP[(mI = mk)] === mf) return mI / (mA - 0x1);
                        var mU = mP[mI];
                        return (mI + (mf - mU) / (mP[mI + 0x1] - mU)) / (mA - 0x1);
                    },
                    getTangent: function (mN, mX) {
                        var mf = 0.0001,
                            mP = mN - mf,
                            mI = mN + mf;
                        mP < 0x0 && (mP = 0x0), mI > 0x1 && (mI = 0x1);
                        var mA = this["getPoint"](mP),
                            mM = this["getPoint"](mI),
                            mp = mX || (mA["isVector2"] ? new E3() : new Ed());
                        return mp["copy"](mM)["sub"](mA)["normalize"](), mp;
                    },
                    getTangentAt: function (mN, mX) {
                        var mf = this["getUtoTmapping"](mN);
                        return this["getTangent"](mf, mX);
                    },
                    computeFrenetFrames: function (mN, mX) {
                        var mf,
                            mP,
                            mI,
                            mA = new Ed(),
                            mM = [],
                            mp = [],
                            mk = [],
                            mU = new Ed(),
                            mq = new Ey();
                        for (mf = 0x0; mf <= mN; mf++) (mP = mf / mN), (mM[mf] = this["getTangentAt"](mP, new Ed())), mM[mf]["normalize"]();
                        (mp[0x0] = new Ed()), (mk[0x0] = new Ed());
                        var mw = Number["MAX_VALUE"],
                            mO = Math["abs"](mM[0x0]["x"]),
                            mj = Math["abs"](mM[0x0]["y"]),
                            mh = Math["abs"](mM[0x0]["z"]);
                        for (
                            mO <= mw && ((mw = mO), mA["set"](0x1, 0x0, 0x0)),
                                mj <= mw && ((mw = mj), mA["set"](0x0, 0x1, 0x0)),
                                mh <= mw && mA["set"](0x0, 0x0, 0x1),
                                mU["crossVectors"](mM[0x0], mA)["normalize"](),
                                mp[0x0]["crossVectors"](mM[0x0], mU),
                                mk[0x0]["crossVectors"](mM[0x0], mp[0x0]),
                                mf = 0x1;
                            mf <= mN;
                            mf++
                        )
                            (mp[mf] = mp[mf - 0x1]["clone"]()),
                                (mk[mf] = mk[mf - 0x1]["clone"]()),
                                mU["crossVectors"](mM[mf - 0x1], mM[mf]),
                                mU["length"]() > Number["EPSILON"] && (mU["normalize"](), (mI = Math["acos"](E2["clamp"](mM[mf - 0x1]["dot"](mM[mf]), -0x1, 0x1))), mp[mf]["applyMatrix4"](mq["makeRotationAxis"](mU, mI))),
                                mk[mf]["crossVectors"](mM[mf], mp[mf]);
                        if (!0x0 === mX) {
                            for (mI = Math["acos"](E2["clamp"](mp[0x0]["dot"](mp[mN]), -0x1, 0x1)), mI /= mN, mM[0x0]["dot"](mU["crossVectors"](mp[0x0], mp[mN])) > 0x0 && (mI = -mI), mf = 0x1; mf <= mN; mf++)
                                mp[mf]["applyMatrix4"](mq["makeRotationAxis"](mM[mf], mI * mf)), mk[mf]["crossVectors"](mM[mf], mp[mf]);
                        }
                        return { tangents: mM, normals: mp, binormals: mk };
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    copy: function (mN) {
                        return (this["arcLengthDivisions"] = mN["arcLengthDivisions"]), this;
                    },
                    toJSON: function () {
                        var mN = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
                        return (mN["arcLengthDivisions"] = this["arcLengthDivisions"]), (mN["type"] = this["type"]), mN;
                    },
                    fromJSON: function (mN) {
                        return (this["arcLengthDivisions"] = mN["arcLengthDivisions"]), this;
                    },
                }),
                (FP["prototype"] = Object["create"](Ff["prototype"])),
                (FP["prototype"]["constructor"] = FP),
                (FP["prototype"]["isEllipseCurve"] = !0x0),
                (FP["prototype"]["getPoint"] = function (mN, mX) {
                    for (var mf = mX || new E3(), mP = 0x2 * Math["PI"], mI = this["aEndAngle"] - this["aStartAngle"], mA = Math["abs"](mI) < Number["EPSILON"]; mI < 0x0; ) mI += mP;
                    for (; mI > mP; ) mI -= mP;
                    mI < Number["EPSILON"] && (mI = mA ? 0x0 : mP), !0x0 !== this["aClockwise"] || mA || (mI === mP ? (mI = -mP) : (mI -= mP));
                    var mM = this["aStartAngle"] + mN * mI,
                        mp = this["aX"] + this["xRadius"] * Math["cos"](mM),
                        mk = this["aY"] + this["yRadius"] * Math["sin"](mM);
                    if (0x0 !== this["aRotation"]) {
                        var mU = Math["cos"](this["aRotation"]),
                            mq = Math["sin"](this["aRotation"]),
                            mw = mp - this["aX"],
                            mO = mk - this["aY"];
                        (mp = mw * mU - mO * mq + this["aX"]), (mk = mw * mq + mO * mU + this["aY"]);
                    }
                    return mf["set"](mp, mk);
                }),
                (FP["prototype"]["copy"] = function (mN) {
                    return (
                        Ff["prototype"]["copy"]["call"](this, mN),
                        (this["aX"] = mN["aX"]),
                        (this["aY"] = mN["aY"]),
                        (this["xRadius"] = mN["xRadius"]),
                        (this["yRadius"] = mN["yRadius"]),
                        (this["aStartAngle"] = mN["aStartAngle"]),
                        (this["aEndAngle"] = mN["aEndAngle"]),
                        (this["aClockwise"] = mN["aClockwise"]),
                        (this["aRotation"] = mN["aRotation"]),
                        this
                    );
                }),
                (FP["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (
                        (mN["aX"] = this["aX"]),
                        (mN["aY"] = this["aY"]),
                        (mN["xRadius"] = this["xRadius"]),
                        (mN["yRadius"] = this["yRadius"]),
                        (mN["aStartAngle"] = this["aStartAngle"]),
                        (mN["aEndAngle"] = this["aEndAngle"]),
                        (mN["aClockwise"] = this["aClockwise"]),
                        (mN["aRotation"] = this["aRotation"]),
                        mN
                    );
                }),
                (FP["prototype"]["fromJSON"] = function (mN) {
                    return (
                        Ff["prototype"]["fromJSON"]["call"](this, mN),
                        (this["aX"] = mN["aX"]),
                        (this["aY"] = mN["aY"]),
                        (this["xRadius"] = mN["xRadius"]),
                        (this["yRadius"] = mN["yRadius"]),
                        (this["aStartAngle"] = mN["aStartAngle"]),
                        (this["aEndAngle"] = mN["aEndAngle"]),
                        (this["aClockwise"] = mN["aClockwise"]),
                        (this["aRotation"] = mN["aRotation"]),
                        this
                    );
                }),
                (FI["prototype"] = Object["create"](FP["prototype"])),
                (FI["prototype"]["constructor"] = FI),
                (FI["prototype"]["isArcCurve"] = !0x0);
            var FM = new Ed(),
                Fp = new FA(),
                Fk = new FA(),
                FU = new FA();
            function Fq(mN, mX, mf, mP) {
                Ff["call"](this), (this["type"] = "CatmullRomCurve3"), (this["points"] = mN || []), (this["closed"] = mX || !0x1), (this["curveType"] = mf || "centripetal"), (this["tension"] = mP || 0.5);
            }
            function Fw(mN, mX, mf, mP, mI) {
                var mA = 0.5 * (mP - mX),
                    mM = 0.5 * (mI - mf),
                    mp = mN * mN;
                return (0x2 * mf - 0x2 * mP + mA + mM) * (mN * mp) + (-0x3 * mf + 0x3 * mP - 0x2 * mA - mM) * mp + mA * mN + mf;
            }
            function FO(mN, mX, mf, mP) {
                return (
                    (function (mI, mA) {
                        var mM = 0x1 - mI;
                        return mM * mM * mA;
                    })(mN, mX) +
                    (function (mI, mA) {
                        return 0x2 * (0x1 - mI) * mI * mA;
                    })(mN, mf) +
                    (function (mI, mA) {
                        return mI * mI * mA;
                    })(mN, mP)
                );
            }
            function Fj(mN, mX, mf, mP, mI) {
                return (
                    (function (mA, mM) {
                        var mp = 0x1 - mA;
                        return mp * mp * mp * mM;
                    })(mN, mX) +
                    (function (mA, mM) {
                        var mp = 0x1 - mA;
                        return 0x3 * mp * mp * mA * mM;
                    })(mN, mf) +
                    (function (mA, mM) {
                        return 0x3 * (0x1 - mA) * mA * mA * mM;
                    })(mN, mP) +
                    (function (mA, mM) {
                        return mA * mA * mA * mM;
                    })(mN, mI)
                );
            }
            function Fh(mN, mX, mf, mP) {
                Ff["call"](this), (this["type"] = "CubicBezierCurve"), (this["v0"] = mN || new E3()), (this["v1"] = mX || new E3()), (this["v2"] = mf || new E3()), (this["v3"] = mP || new E3());
            }
            function FS(mN, mX, mf, mP) {
                Ff["call"](this), (this["type"] = "CubicBezierCurve3"), (this["v0"] = mN || new Ed()), (this["v1"] = mX || new Ed()), (this["v2"] = mf || new Ed()), (this["v3"] = mP || new Ed());
            }
            function Fg(mN, mX) {
                Ff["call"](this), (this["type"] = "LineCurve"), (this["v1"] = mN || new E3()), (this["v2"] = mX || new E3());
            }
            function FW(mN, mX) {
                Ff["call"](this), (this["type"] = "LineCurve3"), (this["v1"] = mN || new Ed()), (this["v2"] = mX || new Ed());
            }
            function FH(mN, mX, mf) {
                Ff["call"](this), (this["type"] = "QuadraticBezierCurve"), (this["v0"] = mN || new E3()), (this["v1"] = mX || new E3()), (this["v2"] = mf || new E3());
            }
            function Fx(mN, mX, mf) {
                Ff["call"](this), (this["type"] = "QuadraticBezierCurve3"), (this["v0"] = mN || new Ed()), (this["v1"] = mX || new Ed()), (this["v2"] = mf || new Ed());
            }
            function FK(mN) {
                Ff["call"](this), (this["type"] = "SplineCurve"), (this["points"] = mN || []);
            }
            (Fq["prototype"] = Object["create"](Ff["prototype"])),
                (Fq["prototype"]["constructor"] = Fq),
                (Fq["prototype"]["isCatmullRomCurve3"] = !0x0),
                (Fq["prototype"]["getPoint"] = function (mN, mX) {
                    var mf,
                        mP,
                        mI,
                        mA,
                        mM = mX || new Ed(),
                        mp = this["points"],
                        mk = mp["length"],
                        mU = (mk - (this["closed"] ? 0x0 : 0x1)) * mN,
                        mq = Math["floor"](mU),
                        mw = mU - mq;
                    if (
                        (this["closed"] ? (mq += mq > 0x0 ? 0x0 : (Math["floor"](Math["abs"](mq) / mk) + 0x1) * mk) : 0x0 === mw && mq === mk - 0x1 && ((mq = mk - 0x2), (mw = 0x1)),
                        this["closed"] || mq > 0x0 ? (mf = mp[(mq - 0x1) % mk]) : (FM["subVectors"](mp[0x0], mp[0x1])["add"](mp[0x0]), (mf = FM)),
                        (mP = mp[mq % mk]),
                        (mI = mp[(mq + 0x1) % mk]),
                        this["closed"] || mq + 0x2 < mk ? (mA = mp[(mq + 0x2) % mk]) : (FM["subVectors"](mp[mk - 0x1], mp[mk - 0x2])["add"](mp[mk - 0x1]), (mA = FM)),
                        "centripetal" === this["curveType"] || "chordal" === this["curveType"])
                    ) {
                        var mO = "chordal" === this["curveType"] ? 0.5 : 0.25,
                            mj = Math["pow"](mf["distanceToSquared"](mP), mO),
                            mh = Math["pow"](mP["distanceToSquared"](mI), mO),
                            mS = Math["pow"](mI["distanceToSquared"](mA), mO);
                        mh < 0.0001 && (mh = 0x1),
                            mj < 0.0001 && (mj = mh),
                            mS < 0.0001 && (mS = mh),
                            Fp["initNonuniformCatmullRom"](mf["x"], mP["x"], mI["x"], mA["x"], mj, mh, mS),
                            Fk["initNonuniformCatmullRom"](mf["y"], mP["y"], mI["y"], mA["y"], mj, mh, mS),
                            FU["initNonuniformCatmullRom"](mf["z"], mP["z"], mI["z"], mA["z"], mj, mh, mS);
                    } else
                        "catmullrom" === this["curveType"] &&
                            (Fp["initCatmullRom"](mf["x"], mP["x"], mI["x"], mA["x"], this["tension"]),
                            Fk["initCatmullRom"](mf["y"], mP["y"], mI["y"], mA["y"], this["tension"]),
                            FU["initCatmullRom"](mf["z"], mP["z"], mI["z"], mA["z"], this["tension"]));
                    return mM["set"](Fp["calc"](mw), Fk["calc"](mw), FU["calc"](mw)), mM;
                }),
                (Fq["prototype"]["copy"] = function (mN) {
                    Ff["prototype"]["copy"]["call"](this, mN), (this["points"] = []);
                    for (var mX = 0x0, mf = mN["points"]["length"]; mX < mf; mX++) {
                        var mP = mN["points"][mX];
                        this["points"]["push"](mP["clone"]());
                    }
                    return (this["closed"] = mN["closed"]), (this["curveType"] = mN["curveType"]), (this["tension"] = mN["tension"]), this;
                }),
                (Fq["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    mN["points"] = [];
                    for (var mX = 0x0, mf = this["points"]["length"]; mX < mf; mX++) {
                        var mP = this["points"][mX];
                        mN["points"]["push"](mP["toArray"]());
                    }
                    return (mN["closed"] = this["closed"]), (mN["curveType"] = this["curveType"]), (mN["tension"] = this["tension"]), mN;
                }),
                (Fq["prototype"]["fromJSON"] = function (mN) {
                    Ff["prototype"]["fromJSON"]["call"](this, mN), (this["points"] = []);
                    for (var mX = 0x0, mf = mN["points"]["length"]; mX < mf; mX++) {
                        var mP = mN["points"][mX];
                        this["points"]["push"](new Ed()["fromArray"](mP));
                    }
                    return (this["closed"] = mN["closed"]), (this["curveType"] = mN["curveType"]), (this["tension"] = mN["tension"]), this;
                }),
                (Fh["prototype"] = Object["create"](Ff["prototype"])),
                (Fh["prototype"]["constructor"] = Fh),
                (Fh["prototype"]["isCubicBezierCurve"] = !0x0),
                (Fh["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new E3(),
                        mP = this["v0"],
                        mI = this["v1"],
                        mA = this["v2"],
                        mM = this["v3"];
                    return mf["set"](Fj(mN, mP["x"], mI["x"], mA["x"], mM["x"]), Fj(mN, mP["y"], mI["y"], mA["y"], mM["y"])), mf;
                }),
                (Fh["prototype"]["copy"] = function (mN) {
                    return Ff["prototype"]["copy"]["call"](this, mN), this["v0"]["copy"](mN["v0"]), this["v1"]["copy"](mN["v1"]), this["v2"]["copy"](mN["v2"]), this["v3"]["copy"](mN["v3"]), this;
                }),
                (Fh["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (mN["v0"] = this["v0"]["toArray"]()), (mN["v1"] = this["v1"]["toArray"]()), (mN["v2"] = this["v2"]["toArray"]()), (mN["v3"] = this["v3"]["toArray"]()), mN;
                }),
                (Fh["prototype"]["fromJSON"] = function (mN) {
                    return Ff["prototype"]["fromJSON"]["call"](this, mN), this["v0"]["fromArray"](mN["v0"]), this["v1"]["fromArray"](mN["v1"]), this["v2"]["fromArray"](mN["v2"]), this["v3"]["fromArray"](mN["v3"]), this;
                }),
                (FS["prototype"] = Object["create"](Ff["prototype"])),
                (FS["prototype"]["constructor"] = FS),
                (FS["prototype"]["isCubicBezierCurve3"] = !0x0),
                (FS["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new Ed(),
                        mP = this["v0"],
                        mI = this["v1"],
                        mA = this["v2"],
                        mM = this["v3"];
                    return mf["set"](Fj(mN, mP["x"], mI["x"], mA["x"], mM["x"]), Fj(mN, mP["y"], mI["y"], mA["y"], mM["y"]), Fj(mN, mP["z"], mI["z"], mA["z"], mM["z"])), mf;
                }),
                (FS["prototype"]["copy"] = function (mN) {
                    return Ff["prototype"]["copy"]["call"](this, mN), this["v0"]["copy"](mN["v0"]), this["v1"]["copy"](mN["v1"]), this["v2"]["copy"](mN["v2"]), this["v3"]["copy"](mN["v3"]), this;
                }),
                (FS["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (mN["v0"] = this["v0"]["toArray"]()), (mN["v1"] = this["v1"]["toArray"]()), (mN["v2"] = this["v2"]["toArray"]()), (mN["v3"] = this["v3"]["toArray"]()), mN;
                }),
                (FS["prototype"]["fromJSON"] = function (mN) {
                    return Ff["prototype"]["fromJSON"]["call"](this, mN), this["v0"]["fromArray"](mN["v0"]), this["v1"]["fromArray"](mN["v1"]), this["v2"]["fromArray"](mN["v2"]), this["v3"]["fromArray"](mN["v3"]), this;
                }),
                (Fg["prototype"] = Object["create"](Ff["prototype"])),
                (Fg["prototype"]["constructor"] = Fg),
                (Fg["prototype"]["isLineCurve"] = !0x0),
                (Fg["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new E3();
                    return 0x1 === mN ? mf["copy"](this["v2"]) : (mf["copy"](this["v2"])["sub"](this["v1"]), mf["multiplyScalar"](mN)["add"](this["v1"])), mf;
                }),
                (Fg["prototype"]["getPointAt"] = function (mN, mX) {
                    return this["getPoint"](mN, mX);
                }),
                (Fg["prototype"]["getTangent"] = function (mN, mX) {
                    return (mX || new E3())["copy"](this["v2"])["sub"](this["v1"])["normalize"]();
                }),
                (Fg["prototype"]["copy"] = function (mN) {
                    return Ff["prototype"]["copy"]["call"](this, mN), this["v1"]["copy"](mN["v1"]), this["v2"]["copy"](mN["v2"]), this;
                }),
                (Fg["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (mN["v1"] = this["v1"]["toArray"]()), (mN["v2"] = this["v2"]["toArray"]()), mN;
                }),
                (Fg["prototype"]["fromJSON"] = function (mN) {
                    return Ff["prototype"]["fromJSON"]["call"](this, mN), this["v1"]["fromArray"](mN["v1"]), this["v2"]["fromArray"](mN["v2"]), this;
                }),
                (FW["prototype"] = Object["create"](Ff["prototype"])),
                (FW["prototype"]["constructor"] = FW),
                (FW["prototype"]["isLineCurve3"] = !0x0),
                (FW["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new Ed();
                    return 0x1 === mN ? mf["copy"](this["v2"]) : (mf["copy"](this["v2"])["sub"](this["v1"]), mf["multiplyScalar"](mN)["add"](this["v1"])), mf;
                }),
                (FW["prototype"]["getPointAt"] = function (mN, mX) {
                    return this["getPoint"](mN, mX);
                }),
                (FW["prototype"]["copy"] = function (mN) {
                    return Ff["prototype"]["copy"]["call"](this, mN), this["v1"]["copy"](mN["v1"]), this["v2"]["copy"](mN["v2"]), this;
                }),
                (FW["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (mN["v1"] = this["v1"]["toArray"]()), (mN["v2"] = this["v2"]["toArray"]()), mN;
                }),
                (FW["prototype"]["fromJSON"] = function (mN) {
                    return Ff["prototype"]["fromJSON"]["call"](this, mN), this["v1"]["fromArray"](mN["v1"]), this["v2"]["fromArray"](mN["v2"]), this;
                }),
                (FH["prototype"] = Object["create"](Ff["prototype"])),
                (FH["prototype"]["constructor"] = FH),
                (FH["prototype"]["isQuadraticBezierCurve"] = !0x0),
                (FH["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new E3(),
                        mP = this["v0"],
                        mI = this["v1"],
                        mA = this["v2"];
                    return mf["set"](FO(mN, mP["x"], mI["x"], mA["x"]), FO(mN, mP["y"], mI["y"], mA["y"])), mf;
                }),
                (FH["prototype"]["copy"] = function (mN) {
                    return Ff["prototype"]["copy"]["call"](this, mN), this["v0"]["copy"](mN["v0"]), this["v1"]["copy"](mN["v1"]), this["v2"]["copy"](mN["v2"]), this;
                }),
                (FH["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (mN["v0"] = this["v0"]["toArray"]()), (mN["v1"] = this["v1"]["toArray"]()), (mN["v2"] = this["v2"]["toArray"]()), mN;
                }),
                (FH["prototype"]["fromJSON"] = function (mN) {
                    return Ff["prototype"]["fromJSON"]["call"](this, mN), this["v0"]["fromArray"](mN["v0"]), this["v1"]["fromArray"](mN["v1"]), this["v2"]["fromArray"](mN["v2"]), this;
                }),
                (Fx["prototype"] = Object["create"](Ff["prototype"])),
                (Fx["prototype"]["constructor"] = Fx),
                (Fx["prototype"]["isQuadraticBezierCurve3"] = !0x0),
                (Fx["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new Ed(),
                        mP = this["v0"],
                        mI = this["v1"],
                        mA = this["v2"];
                    return mf["set"](FO(mN, mP["x"], mI["x"], mA["x"]), FO(mN, mP["y"], mI["y"], mA["y"]), FO(mN, mP["z"], mI["z"], mA["z"])), mf;
                }),
                (Fx["prototype"]["copy"] = function (mN) {
                    return Ff["prototype"]["copy"]["call"](this, mN), this["v0"]["copy"](mN["v0"]), this["v1"]["copy"](mN["v1"]), this["v2"]["copy"](mN["v2"]), this;
                }),
                (Fx["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    return (mN["v0"] = this["v0"]["toArray"]()), (mN["v1"] = this["v1"]["toArray"]()), (mN["v2"] = this["v2"]["toArray"]()), mN;
                }),
                (Fx["prototype"]["fromJSON"] = function (mN) {
                    return Ff["prototype"]["fromJSON"]["call"](this, mN), this["v0"]["fromArray"](mN["v0"]), this["v1"]["fromArray"](mN["v1"]), this["v2"]["fromArray"](mN["v2"]), this;
                }),
                (FK["prototype"] = Object["create"](Ff["prototype"])),
                (FK["prototype"]["constructor"] = FK),
                (FK["prototype"]["isSplineCurve"] = !0x0),
                (FK["prototype"]["getPoint"] = function (mN, mX) {
                    var mf = mX || new E3(),
                        mP = this["points"],
                        mI = (mP["length"] - 0x1) * mN,
                        mA = Math["floor"](mI),
                        mM = mI - mA,
                        mp = mP[0x0 === mA ? mA : mA - 0x1],
                        mk = mP[mA],
                        mU = mP[mA > mP["length"] - 0x2 ? mP["length"] - 0x1 : mA + 0x1],
                        mq = mP[mA > mP["length"] - 0x3 ? mP["length"] - 0x1 : mA + 0x2];
                    return mf["set"](Fw(mM, mp["x"], mk["x"], mU["x"], mq["x"]), Fw(mM, mp["y"], mk["y"], mU["y"], mq["y"])), mf;
                }),
                (FK["prototype"]["copy"] = function (mN) {
                    Ff["prototype"]["copy"]["call"](this, mN), (this["points"] = []);
                    for (var mX = 0x0, mf = mN["points"]["length"]; mX < mf; mX++) {
                        var mP = mN["points"][mX];
                        this["points"]["push"](mP["clone"]());
                    }
                    return this;
                }),
                (FK["prototype"]["toJSON"] = function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    mN["points"] = [];
                    for (var mX = 0x0, mf = this["points"]["length"]; mX < mf; mX++) {
                        var mP = this["points"][mX];
                        mN["points"]["push"](mP["toArray"]());
                    }
                    return mN;
                }),
                (FK["prototype"]["fromJSON"] = function (mN) {
                    Ff["prototype"]["fromJSON"]["call"](this, mN), (this["points"] = []);
                    for (var mX = 0x0, mf = mN["points"]["length"]; mX < mf; mX++) {
                        var mP = mN["points"][mX];
                        this["points"]["push"](new E3()["fromArray"](mP));
                    }
                    return this;
                });
            var FV = Object["freeze"]({
                __proto__: null,
                ArcCurve: FI,
                CatmullRomCurve3: Fq,
                CubicBezierCurve: Fh,
                CubicBezierCurve3: FS,
                EllipseCurve: FP,
                LineCurve: Fg,
                LineCurve3: FW,
                QuadraticBezierCurve: FH,
                QuadraticBezierCurve3: Fx,
                SplineCurve: FK,
            });
            function FJ() {
                Ff["call"](this), (this["type"] = "CurvePath"), (this["curves"] = []), (this["autoClose"] = !0x1);
            }
            function FG(mN) {
                FJ["call"](this), (this["type"] = "Path"), (this["currentPoint"] = new E3()), mN && this["setFromPoints"](mN);
            }
            function FL(mN) {
                FG["call"](this, mN), (this["uuid"] = E2["generateUUID"]()), (this["type"] = "Shape"), (this["holes"] = []);
            }
            function FQ(mN, mX) {
                Eg["call"](this), (this["type"] = "Light"), (this["color"] = new Rq(mN)), (this["intensity"] = void 0x0 !== mX ? mX : 0x1), (this["receiveShadow"] = void 0x0);
            }
            function Fz(mN, mX, mf) {
                FQ["call"](this, mN, mf), (this["type"] = "HemisphereLight"), (this["castShadow"] = void 0x0), this["position"]["copy"](Eg["DefaultUp"]), this["updateMatrix"](), (this["groundColor"] = new Rq(mX));
            }
            function b0(mN) {
                (this["camera"] = mN),
                    (this["bias"] = 0x0),
                    (this["radius"] = 0x1),
                    (this["mapSize"] = new E3(0x200, 0x200)),
                    (this["map"] = null),
                    (this["mapPass"] = null),
                    (this["matrix"] = new Ey()),
                    (this["_frustum"] = new Tz()),
                    (this["_frameExtents"] = new E3(0x1, 0x1)),
                    (this["_viewportCount"] = 0x1),
                    (this["_viewports"] = [new E8(0x0, 0x0, 0x1, 0x1)]);
            }
            function b1() {
                b0["call"](this, new Tx(0x32, 0x1, 0.5, 0x1f4));
            }
            function b2(mN, mX, mf, mP, mI, mA) {
                FQ["call"](this, mN, mX),
                    (this["type"] = "SpotLight"),
                    this["position"]["copy"](Eg["DefaultUp"]),
                    this["updateMatrix"](),
                    (this["target"] = new Eg()),
                    Object["defineProperty"](this, "power", {
                        get: function () {
                            return this["intensity"] * Math["PI"];
                        },
                        set: function (mM) {
                            this["intensity"] = mM / Math["PI"];
                        },
                    }),
                    (this["distance"] = void 0x0 !== mf ? mf : 0x0),
                    (this["angle"] = void 0x0 !== mP ? mP : Math["PI"] / 0x3),
                    (this["penumbra"] = void 0x0 !== mI ? mI : 0x0),
                    (this["decay"] = void 0x0 !== mA ? mA : 0x1),
                    (this["shadow"] = new b1());
            }
            function b3() {
                b0["call"](this, new Tx(0x5a, 0x1, 0.5, 0x1f4)),
                    (this["_frameExtents"] = new E3(0x4, 0x2)),
                    (this["_viewportCount"] = 0x6),
                    (this["_viewports"] = [new E8(0x2, 0x1, 0x1, 0x1), new E8(0x0, 0x1, 0x1, 0x1), new E8(0x3, 0x1, 0x1, 0x1), new E8(0x1, 0x1, 0x1, 0x1), new E8(0x3, 0x0, 0x1, 0x1), new E8(0x1, 0x0, 0x1, 0x1)]),
                    (this["_cubeDirections"] = [new Ed(0x1, 0x0, 0x0), new Ed(-0x1, 0x0, 0x0), new Ed(0x0, 0x0, 0x1), new Ed(0x0, 0x0, -0x1), new Ed(0x0, 0x1, 0x0), new Ed(0x0, -0x1, 0x0)]),
                    (this["_cubeUps"] = [new Ed(0x0, 0x1, 0x0), new Ed(0x0, 0x1, 0x0), new Ed(0x0, 0x1, 0x0), new Ed(0x0, 0x1, 0x0), new Ed(0x0, 0x0, 0x1), new Ed(0x0, 0x0, -0x1)]);
            }
            function b4(mN, mX, mf, mP) {
                FQ["call"](this, mN, mX),
                    (this["type"] = "PointLight"),
                    Object["defineProperty"](this, "power", {
                        get: function () {
                            return 0x4 * this["intensity"] * Math["PI"];
                        },
                        set: function (mI) {
                            this["intensity"] = mI / (0x4 * Math["PI"]);
                        },
                    }),
                    (this["distance"] = void 0x0 !== mf ? mf : 0x0),
                    (this["decay"] = void 0x0 !== mP ? mP : 0x1),
                    (this["shadow"] = new b3());
            }
            function b5(mN, mX, mf, mP, mI, mA) {
                TH["call"](this),
                    (this["type"] = "OrthographicCamera"),
                    (this["zoom"] = 0x1),
                    (this["view"] = null),
                    (this["left"] = void 0x0 !== mN ? mN : -0x1),
                    (this["right"] = void 0x0 !== mX ? mX : 0x1),
                    (this["top"] = void 0x0 !== mf ? mf : 0x1),
                    (this["bottom"] = void 0x0 !== mP ? mP : -0x1),
                    (this["near"] = void 0x0 !== mI ? mI : 0.1),
                    (this["far"] = void 0x0 !== mA ? mA : 0x7d0),
                    this["updateProjectionMatrix"]();
            }
            function b6() {
                b0["call"](this, new b5(-0x5, 0x5, 0x5, -0x5, 0.5, 0x1f4));
            }
            function b7(mN, mX) {
                FQ["call"](this, mN, mX), (this["type"] = "DirectionalLight"), this["position"]["copy"](Eg["DefaultUp"]), this["updateMatrix"](), (this["target"] = new Eg()), (this["shadow"] = new b6());
            }
            function b8(mN, mX) {
                FQ["call"](this, mN, mX), (this["type"] = "AmbientLight"), (this["castShadow"] = void 0x0);
            }
            function b9(mN, mX, mf, mP) {
                FQ["call"](this, mN, mX), (this["type"] = "RectAreaLight"), (this["width"] = void 0x0 !== mf ? mf : 0xa), (this["height"] = void 0x0 !== mP ? mP : 0xa);
            }
            function bE() {
                this["coefficients"] = [];
                for (var mN = 0x0; mN < 0x9; mN++) this["coefficients"]["push"](new Ed());
            }
            function bR(mN, mX) {
                FQ["call"](this, void 0x0, mX), (this["type"] = "LightProbe"), (this["sh"] = void 0x0 !== mN ? mN : new bE());
            }
            function bT(mN) {
                FF["call"](this, mN), (this["textures"] = {});
            }
            (FJ["prototype"] = Object["assign"](Object["create"](Ff["prototype"]), {
                constructor: FJ,
                add: function (mN) {
                    this["curves"]["push"](mN);
                },
                closePath: function () {
                    var mN = this["curves"][0x0]["getPoint"](0x0),
                        mX = this["curves"][this["curves"]["length"] - 0x1]["getPoint"](0x1);
                    mN["equals"](mX) || this["curves"]["push"](new Fg(mX, mN));
                },
                getPoint: function (mN) {
                    for (var mX = mN * this["getLength"](), mf = this["getCurveLengths"](), mP = 0x0; mP < mf["length"]; ) {
                        if (mf[mP] >= mX) {
                            var mI = mf[mP] - mX,
                                mA = this["curves"][mP],
                                mM = mA["getLength"](),
                                mp = 0x0 === mM ? 0x0 : 0x1 - mI / mM;
                            return mA["getPointAt"](mp);
                        }
                        mP++;
                    }
                    return null;
                },
                getLength: function () {
                    var mN = this["getCurveLengths"]();
                    return mN[mN["length"] - 0x1];
                },
                updateArcLengths: function () {
                    (this["needsUpdate"] = !0x0), (this["cacheLengths"] = null), this["getCurveLengths"]();
                },
                getCurveLengths: function () {
                    if (this["cacheLengths"] && this["cacheLengths"]["length"] === this["curves"]["length"]) return this["cacheLengths"];
                    for (var mN = [], mX = 0x0, mf = 0x0, mP = this["curves"]["length"]; mf < mP; mf++) (mX += this["curves"][mf]["getLength"]()), mN["push"](mX);
                    return (this["cacheLengths"] = mN), mN;
                },
                getSpacedPoints: function (mN) {
                    void 0x0 === mN && (mN = 0x28);
                    for (var mX = [], mf = 0x0; mf <= mN; mf++) mX["push"](this["getPoint"](mf / mN));
                    return this["autoClose"] && mX["push"](mX[0x0]), mX;
                },
                getPoints: function (mN) {
                    mN = mN || 0xc;
                    for (var mX, mf = [], mP = 0x0, mI = this["curves"]; mP < mI["length"]; mP++)
                        for (
                            var mA = mI[mP],
                                mM = mA && mA["isEllipseCurve"] ? 0x2 * mN : mA && (mA["isLineCurve"] || mA["isLineCurve3"]) ? 0x1 : mA && mA["isSplineCurve"] ? mN * mA["points"]["length"] : mN,
                                mp = mA["getPoints"](mM),
                                mk = 0x0;
                            mk < mp["length"];
                            mk++
                        ) {
                            var mU = mp[mk];
                            (mX && mX["equals"](mU)) || (mf["push"](mU), (mX = mU));
                        }
                    return this["autoClose"] && mf["length"] > 0x1 && !mf[mf["length"] - 0x1]["equals"](mf[0x0]) && mf["push"](mf[0x0]), mf;
                },
                copy: function (mN) {
                    Ff["prototype"]["copy"]["call"](this, mN), (this["curves"] = []);
                    for (var mX = 0x0, mf = mN["curves"]["length"]; mX < mf; mX++) {
                        var mP = mN["curves"][mX];
                        this["curves"]["push"](mP["clone"]());
                    }
                    return (this["autoClose"] = mN["autoClose"]), this;
                },
                toJSON: function () {
                    var mN = Ff["prototype"]["toJSON"]["call"](this);
                    (mN["autoClose"] = this["autoClose"]), (mN["curves"] = []);
                    for (var mX = 0x0, mf = this["curves"]["length"]; mX < mf; mX++) {
                        var mP = this["curves"][mX];
                        mN["curves"]["push"](mP["toJSON"]());
                    }
                    return mN;
                },
                fromJSON: function (mN) {
                    Ff["prototype"]["fromJSON"]["call"](this, mN), (this["autoClose"] = mN["autoClose"]), (this["curves"] = []);
                    for (var mX = 0x0, mf = mN["curves"]["length"]; mX < mf; mX++) {
                        var mP = mN["curves"][mX];
                        this["curves"]["push"](new FV[mP["type"]]()["fromJSON"](mP));
                    }
                    return this;
                },
            })),
                (FG["prototype"] = Object["assign"](Object["create"](FJ["prototype"]), {
                    constructor: FG,
                    setFromPoints: function (mN) {
                        this["moveTo"](mN[0x0]["x"], mN[0x0]["y"]);
                        for (var mX = 0x1, mf = mN["length"]; mX < mf; mX++) this["lineTo"](mN[mX]["x"], mN[mX]["y"]);
                        return this;
                    },
                    moveTo: function (mN, mX) {
                        return this["currentPoint"]["set"](mN, mX), this;
                    },
                    lineTo: function (mN, mX) {
                        var mf = new Fg(this["currentPoint"]["clone"](), new E3(mN, mX));
                        return this["curves"]["push"](mf), this["currentPoint"]["set"](mN, mX), this;
                    },
                    quadraticCurveTo: function (mN, mX, mf, mP) {
                        var mI = new FH(this["currentPoint"]["clone"](), new E3(mN, mX), new E3(mf, mP));
                        return this["curves"]["push"](mI), this["currentPoint"]["set"](mf, mP), this;
                    },
                    bezierCurveTo: function (mN, mX, mf, mP, mI, mA) {
                        var mM = new Fh(this["currentPoint"]["clone"](), new E3(mN, mX), new E3(mf, mP), new E3(mI, mA));
                        return this["curves"]["push"](mM), this["currentPoint"]["set"](mI, mA), this;
                    },
                    splineThru: function (mN) {
                        var mX = new FK([this["currentPoint"]["clone"]()]["concat"](mN));
                        return this["curves"]["push"](mX), this["currentPoint"]["copy"](mN[mN["length"] - 0x1]), this;
                    },
                    arc: function (mN, mX, mf, mP, mI, mA) {
                        var mM = this["currentPoint"]["x"],
                            mp = this["currentPoint"]["y"];
                        return this["absarc"](mN + mM, mX + mp, mf, mP, mI, mA), this;
                    },
                    absarc: function (mN, mX, mf, mP, mI, mA) {
                        return this["absellipse"](mN, mX, mf, mf, mP, mI, mA), this;
                    },
                    ellipse: function (mN, mX, mf, mP, mI, mA, mM, mp) {
                        var mk = this["currentPoint"]["x"],
                            mU = this["currentPoint"]["y"];
                        return this["absellipse"](mN + mk, mX + mU, mf, mP, mI, mA, mM, mp), this;
                    },
                    absellipse: function (mN, mX, mf, mP, mI, mA, mM, mp) {
                        var mk = new FP(mN, mX, mf, mP, mI, mA, mM, mp);
                        if (this["curves"]["length"] > 0x0) {
                            var mU = mk["getPoint"](0x0);
                            mU["equals"](this["currentPoint"]) || this["lineTo"](mU["x"], mU["y"]);
                        }
                        this["curves"]["push"](mk);
                        var mq = mk["getPoint"](0x1);
                        return this["currentPoint"]["copy"](mq), this;
                    },
                    copy: function (mN) {
                        return FJ["prototype"]["copy"]["call"](this, mN), this["currentPoint"]["copy"](mN["currentPoint"]), this;
                    },
                    toJSON: function () {
                        var mN = FJ["prototype"]["toJSON"]["call"](this);
                        return (mN["currentPoint"] = this["currentPoint"]["toArray"]()), mN;
                    },
                    fromJSON: function (mN) {
                        return FJ["prototype"]["fromJSON"]["call"](this, mN), this["currentPoint"]["fromArray"](mN["currentPoint"]), this;
                    },
                })),
                (FL["prototype"] = Object["assign"](Object["create"](FG["prototype"]), {
                    constructor: FL,
                    getPointsHoles: function (mN) {
                        for (var mX = [], mf = 0x0, mP = this["holes"]["length"]; mf < mP; mf++) mX[mf] = this["holes"][mf]["getPoints"](mN);
                        return mX;
                    },
                    extractPoints: function (mN) {
                        return { shape: this["getPoints"](mN), holes: this["getPointsHoles"](mN) };
                    },
                    copy: function (mN) {
                        FG["prototype"]["copy"]["call"](this, mN), (this["holes"] = []);
                        for (var mX = 0x0, mf = mN["holes"]["length"]; mX < mf; mX++) {
                            var mP = mN["holes"][mX];
                            this["holes"]["push"](mP["clone"]());
                        }
                        return this;
                    },
                    toJSON: function () {
                        var mN = FG["prototype"]["toJSON"]["call"](this);
                        (mN["uuid"] = this["uuid"]), (mN["holes"] = []);
                        for (var mX = 0x0, mf = this["holes"]["length"]; mX < mf; mX++) {
                            var mP = this["holes"][mX];
                            mN["holes"]["push"](mP["toJSON"]());
                        }
                        return mN;
                    },
                    fromJSON: function (mN) {
                        FG["prototype"]["fromJSON"]["call"](this, mN), (this["uuid"] = mN["uuid"]), (this["holes"] = []);
                        for (var mX = 0x0, mf = mN["holes"]["length"]; mX < mf; mX++) {
                            var mP = mN["holes"][mX];
                            this["holes"]["push"](new FG()["fromJSON"](mP));
                        }
                        return this;
                    },
                })),
                (FQ["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                    constructor: FQ,
                    isLight: !0x0,
                    copy: function (mN) {
                        return Eg["prototype"]["copy"]["call"](this, mN), this["color"]["copy"](mN["color"]), (this["intensity"] = mN["intensity"]), this;
                    },
                    toJSON: function (mN) {
                        var mX = Eg["prototype"]["toJSON"]["call"](this, mN);
                        return (
                            (mX["object"]["color"] = this["color"]["getHex"]()),
                            (mX["object"]["intensity"] = this["intensity"]),
                            void 0x0 !== this["groundColor"] && (mX["object"]["groundColor"] = this["groundColor"]["getHex"]()),
                            void 0x0 !== this["distance"] && (mX["object"]["distance"] = this["distance"]),
                            void 0x0 !== this["angle"] && (mX["object"]["angle"] = this["angle"]),
                            void 0x0 !== this["decay"] && (mX["object"]["decay"] = this["decay"]),
                            void 0x0 !== this["penumbra"] && (mX["object"]["penumbra"] = this["penumbra"]),
                            void 0x0 !== this["shadow"] && (mX["object"]["shadow"] = this["shadow"]["toJSON"]()),
                            mX
                        );
                    },
                })),
                (Fz["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), {
                    constructor: Fz,
                    isHemisphereLight: !0x0,
                    copy: function (mN) {
                        return FQ["prototype"]["copy"]["call"](this, mN), this["groundColor"]["copy"](mN["groundColor"]), this;
                    },
                })),
                Object["assign"](b0["prototype"], {
                    _projScreenMatrix: new Ey(),
                    _lightPositionWorld: new Ed(),
                    _lookTarget: new Ed(),
                    getViewportCount: function () {
                        return this["_viewportCount"];
                    },
                    getFrustum: function () {
                        return this["_frustum"];
                    },
                    updateMatrices: function (mN) {
                        var mX = this["camera"],
                            mf = this["matrix"],
                            mP = this["_projScreenMatrix"],
                            mI = this["_lookTarget"],
                            mA = this["_lightPositionWorld"];
                        mA["setFromMatrixPosition"](mN["matrixWorld"]),
                            mX["position"]["copy"](mA),
                            mI["setFromMatrixPosition"](mN["target"]["matrixWorld"]),
                            mX["lookAt"](mI),
                            mX["updateMatrixWorld"](),
                            mP["multiplyMatrices"](mX["projectionMatrix"], mX["matrixWorldInverse"]),
                            this["_frustum"]["setFromProjectionMatrix"](mP),
                            mf["set"](0.5, 0x0, 0x0, 0.5, 0x0, 0.5, 0x0, 0.5, 0x0, 0x0, 0.5, 0.5, 0x0, 0x0, 0x0, 0x1),
                            mf["multiply"](mX["projectionMatrix"]),
                            mf["multiply"](mX["matrixWorldInverse"]);
                    },
                    getViewport: function (mN) {
                        return this["_viewports"][mN];
                    },
                    getFrameExtents: function () {
                        return this["_frameExtents"];
                    },
                    copy: function (mN) {
                        return (this["camera"] = mN["camera"]["clone"]()), (this["bias"] = mN["bias"]), (this["radius"] = mN["radius"]), this["mapSize"]["copy"](mN["mapSize"]), this;
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    toJSON: function () {
                        var mN = {};
                        return (
                            0x0 !== this["bias"] && (mN["bias"] = this["bias"]),
                            0x1 !== this["radius"] && (mN["radius"] = this["radius"]),
                            (0x200 === this["mapSize"]["x"] && 0x200 === this["mapSize"]["y"]) || (mN["mapSize"] = this["mapSize"]["toArray"]()),
                            (mN["camera"] = this["camera"]["toJSON"](!0x1)["object"]),
                            delete mN["camera"]["matrix"],
                            mN
                        );
                    },
                }),
                (b1["prototype"] = Object["assign"](Object["create"](b0["prototype"]), {
                    constructor: b1,
                    isSpotLightShadow: !0x0,
                    updateMatrices: function (mN) {
                        var mX = this["camera"],
                            mf = 0x2 * E2["RAD2DEG"] * mN["angle"],
                            mP = this["mapSize"]["width"] / this["mapSize"]["height"],
                            mI = mN["distance"] || mX["far"];
                        (mf === mX["fov"] && mP === mX["aspect"] && mI === mX["far"]) || ((mX["fov"] = mf), (mX["aspect"] = mP), (mX["far"] = mI), mX["updateProjectionMatrix"]()), b0["prototype"]["updateMatrices"]["call"](this, mN);
                    },
                })),
                (b2["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), {
                    constructor: b2,
                    isSpotLight: !0x0,
                    copy: function (mN) {
                        return (
                            FQ["prototype"]["copy"]["call"](this, mN),
                            (this["distance"] = mN["distance"]),
                            (this["angle"] = mN["angle"]),
                            (this["penumbra"] = mN["penumbra"]),
                            (this["decay"] = mN["decay"]),
                            (this["target"] = mN["target"]["clone"]()),
                            (this["shadow"] = mN["shadow"]["clone"]()),
                            this
                        );
                    },
                })),
                (b3["prototype"] = Object["assign"](Object["create"](b0["prototype"]), {
                    constructor: b3,
                    isPointLightShadow: !0x0,
                    updateMatrices: function (mN, mX) {
                        void 0x0 === mX && (mX = 0x0);
                        var mf = this["camera"],
                            mP = this["matrix"],
                            mI = this["_lightPositionWorld"],
                            mA = this["_lookTarget"],
                            mM = this["_projScreenMatrix"];
                        mI["setFromMatrixPosition"](mN["matrixWorld"]),
                            mf["position"]["copy"](mI),
                            mA["copy"](mf["position"]),
                            mA["add"](this["_cubeDirections"][mX]),
                            mf["up"]["copy"](this["_cubeUps"][mX]),
                            mf["lookAt"](mA),
                            mf["updateMatrixWorld"](),
                            mP["makeTranslation"](-mI["x"], -mI["y"], -mI["z"]),
                            mM["multiplyMatrices"](mf["projectionMatrix"], mf["matrixWorldInverse"]),
                            this["_frustum"]["setFromProjectionMatrix"](mM);
                    },
                })),
                (b4["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), {
                    constructor: b4,
                    isPointLight: !0x0,
                    copy: function (mN) {
                        return FQ["prototype"]["copy"]["call"](this, mN), (this["distance"] = mN["distance"]), (this["decay"] = mN["decay"]), (this["shadow"] = mN["shadow"]["clone"]()), this;
                    },
                })),
                (b5["prototype"] = Object["assign"](Object["create"](TH["prototype"]), {
                    constructor: b5,
                    isOrthographicCamera: !0x0,
                    copy: function (mN, mX) {
                        return (
                            TH["prototype"]["copy"]["call"](this, mN, mX),
                            (this["left"] = mN["left"]),
                            (this["right"] = mN["right"]),
                            (this["top"] = mN["top"]),
                            (this["bottom"] = mN["bottom"]),
                            (this["near"] = mN["near"]),
                            (this["far"] = mN["far"]),
                            (this["zoom"] = mN["zoom"]),
                            (this["view"] = null === mN["view"] ? null : Object["assign"]({}, mN["view"])),
                            this
                        );
                    },
                    setViewOffset: function (mN, mX, mf, mP, mI, mA) {
                        null === this["view"] && (this["view"] = { enabled: !0x0, fullWidth: 0x1, fullHeight: 0x1, offsetX: 0x0, offsetY: 0x0, width: 0x1, height: 0x1 }),
                            (this["view"]["enabled"] = !0x0),
                            (this["view"]["fullWidth"] = mN),
                            (this["view"]["fullHeight"] = mX),
                            (this["view"]["offsetX"] = mf),
                            (this["view"]["offsetY"] = mP),
                            (this["view"]["width"] = mI),
                            (this["view"]["height"] = mA),
                            this["updateProjectionMatrix"]();
                    },
                    clearViewOffset: function () {
                        null !== this["view"] && (this["view"]["enabled"] = !0x1), this["updateProjectionMatrix"]();
                    },
                    updateProjectionMatrix: function () {
                        var mN = (this["right"] - this["left"]) / (0x2 * this["zoom"]),
                            mX = (this["top"] - this["bottom"]) / (0x2 * this["zoom"]),
                            mf = (this["right"] + this["left"]) / 0x2,
                            mP = (this["top"] + this["bottom"]) / 0x2,
                            mI = mf - mN,
                            mA = mf + mN,
                            mM = mP + mX,
                            mp = mP - mX;
                        if (null !== this["view"] && this["view"]["enabled"]) {
                            var mk = (this["right"] - this["left"]) / this["view"]["fullWidth"] / this["zoom"],
                                mU = (this["top"] - this["bottom"]) / this["view"]["fullHeight"] / this["zoom"];
                            (mA = (mI += mk * this["view"]["offsetX"]) + mk * this["view"]["width"]), (mp = (mM -= mU * this["view"]["offsetY"]) - mU * this["view"]["height"]);
                        }
                        this["projectionMatrix"]["makeOrthographic"](mI, mA, mM, mp, this["near"], this["far"]), this["projectionMatrixInverse"]["getInverse"](this["projectionMatrix"]);
                    },
                    toJSON: function (mN) {
                        var mX = Eg["prototype"]["toJSON"]["call"](this, mN);
                        return (
                            (mX["object"]["zoom"] = this["zoom"]),
                            (mX["object"]["left"] = this["left"]),
                            (mX["object"]["right"] = this["right"]),
                            (mX["object"]["top"] = this["top"]),
                            (mX["object"]["bottom"] = this["bottom"]),
                            (mX["object"]["near"] = this["near"]),
                            (mX["object"]["far"] = this["far"]),
                            null !== this["view"] && (mX["object"]["view"] = Object["assign"]({}, this["view"])),
                            mX
                        );
                    },
                })),
                (b6["prototype"] = Object["assign"](Object["create"](b0["prototype"]), {
                    constructor: b6,
                    isDirectionalLightShadow: !0x0,
                    updateMatrices: function (mN) {
                        b0["prototype"]["updateMatrices"]["call"](this, mN);
                    },
                })),
                (b7["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), {
                    constructor: b7,
                    isDirectionalLight: !0x0,
                    copy: function (mN) {
                        return FQ["prototype"]["copy"]["call"](this, mN), (this["target"] = mN["target"]["clone"]()), (this["shadow"] = mN["shadow"]["clone"]()), this;
                    },
                })),
                (b8["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), { constructor: b8, isAmbientLight: !0x0 })),
                (b9["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), {
                    constructor: b9,
                    isRectAreaLight: !0x0,
                    copy: function (mN) {
                        return FQ["prototype"]["copy"]["call"](this, mN), (this["width"] = mN["width"]), (this["height"] = mN["height"]), this;
                    },
                    toJSON: function (mN) {
                        var mX = FQ["prototype"]["toJSON"]["call"](this, mN);
                        return (mX["object"]["width"] = this["width"]), (mX["object"]["height"] = this["height"]), mX;
                    },
                })),
                Object["assign"](bE["prototype"], {
                    isSphericalHarmonics3: !0x0,
                    set: function (mN) {
                        for (var mX = 0x0; mX < 0x9; mX++) this["coefficients"][mX]["copy"](mN[mX]);
                        return this;
                    },
                    zero: function () {
                        for (var mN = 0x0; mN < 0x9; mN++) this["coefficients"][mN]["set"](0x0, 0x0, 0x0);
                        return this;
                    },
                    getAt: function (mN, mX) {
                        var mf = mN["x"],
                            mP = mN["y"],
                            mI = mN["z"],
                            mA = this["coefficients"];
                        return (
                            mX["copy"](mA[0x0])["multiplyScalar"](0.282095),
                            mX["addScaledVector"](mA[0x1], 0.488603 * mP),
                            mX["addScaledVector"](mA[0x2], 0.488603 * mI),
                            mX["addScaledVector"](mA[0x3], 0.488603 * mf),
                            mX["addScaledVector"](mA[0x4], mf * mP * 1.092548),
                            mX["addScaledVector"](mA[0x5], mP * mI * 1.092548),
                            mX["addScaledVector"](mA[0x6], 0.315392 * (0x3 * mI * mI - 0x1)),
                            mX["addScaledVector"](mA[0x7], mf * mI * 1.092548),
                            mX["addScaledVector"](mA[0x8], 0.546274 * (mf * mf - mP * mP)),
                            mX
                        );
                    },
                    getIrradianceAt: function (mN, mX) {
                        var mf = mN["x"],
                            mP = mN["y"],
                            mI = mN["z"],
                            mA = this["coefficients"];
                        return (
                            mX["copy"](mA[0x0])["multiplyScalar"](0.886227),
                            mX["addScaledVector"](mA[0x1], 1.023328 * mP),
                            mX["addScaledVector"](mA[0x2], 1.023328 * mI),
                            mX["addScaledVector"](mA[0x3], 1.023328 * mf),
                            mX["addScaledVector"](mA[0x4], 0.858086 * mf * mP),
                            mX["addScaledVector"](mA[0x5], 0.858086 * mP * mI),
                            mX["addScaledVector"](mA[0x6], 0.743125 * mI * mI - 0.247708),
                            mX["addScaledVector"](mA[0x7], 0.858086 * mf * mI),
                            mX["addScaledVector"](mA[0x8], 0.429043 * (mf * mf - mP * mP)),
                            mX
                        );
                    },
                    add: function (mN) {
                        for (var mX = 0x0; mX < 0x9; mX++) this["coefficients"][mX]["add"](mN["coefficients"][mX]);
                        return this;
                    },
                    addScaledSH: function (mN, mX) {
                        for (var mf = 0x0; mf < 0x9; mf++) this["coefficients"][mf]["addScaledVector"](mN["coefficients"][mf], mX);
                        return this;
                    },
                    scale: function (mN) {
                        for (var mX = 0x0; mX < 0x9; mX++) this["coefficients"][mX]["multiplyScalar"](mN);
                        return this;
                    },
                    lerp: function (mN, mX) {
                        for (var mf = 0x0; mf < 0x9; mf++) this["coefficients"][mf]["lerp"](mN["coefficients"][mf], mX);
                        return this;
                    },
                    equals: function (mN) {
                        for (var mX = 0x0; mX < 0x9; mX++) if (!this["coefficients"][mX]["equals"](mN["coefficients"][mX])) return !0x1;
                        return !0x0;
                    },
                    copy: function (mN) {
                        return this["set"](mN["coefficients"]);
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    fromArray: function (mN, mX) {
                        void 0x0 === mX && (mX = 0x0);
                        for (var mf = this["coefficients"], mP = 0x0; mP < 0x9; mP++) mf[mP]["fromArray"](mN, mX + 0x3 * mP);
                        return this;
                    },
                    toArray: function (mN, mX) {
                        void 0x0 === mN && (mN = []), void 0x0 === mX && (mX = 0x0);
                        for (var mf = this["coefficients"], mP = 0x0; mP < 0x9; mP++) mf[mP]["toArray"](mN, mX + 0x3 * mP);
                        return mN;
                    },
                }),
                Object["assign"](bE, {
                    getBasisAt: function (mN, mX) {
                        var mf = mN["x"],
                            mP = mN["y"],
                            mI = mN["z"];
                        (mX[0x0] = 0.282095),
                            (mX[0x1] = 0.488603 * mP),
                            (mX[0x2] = 0.488603 * mI),
                            (mX[0x3] = 0.488603 * mf),
                            (mX[0x4] = 1.092548 * mf * mP),
                            (mX[0x5] = 1.092548 * mP * mI),
                            (mX[0x6] = 0.315392 * (0x3 * mI * mI - 0x1)),
                            (mX[0x7] = 1.092548 * mf * mI),
                            (mX[0x8] = 0.546274 * (mf * mf - mP * mP));
                    },
                }),
                (bR["prototype"] = Object["assign"](Object["create"](FQ["prototype"]), {
                    constructor: bR,
                    isLightProbe: !0x0,
                    copy: function (mN) {
                        return FQ["prototype"]["copy"]["call"](this, mN), this["sh"]["copy"](mN["sh"]), this;
                    },
                    fromJSON: function (mN) {
                        return (this["intensity"] = mN["intensity"]), this["sh"]["fromArray"](mN["sh"]), this;
                    },
                    toJSON: function (mN) {
                        var mX = FQ["prototype"]["toJSON"]["call"](this, mN);
                        return (mX["object"]["sh"] = this["sh"]["toArray"]()), mX;
                    },
                })),
                (bT["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: bT,
                    load: function (mN, mX, mf, mP) {
                        var mI = this,
                            mA = new FZ(mI["manager"]);
                        mA["setPath"](mI["path"]),
                            mA["load"](
                                mN,
                                function (mM) {
                                    try {
                                        mX(mI["parse"](JSON["parse"](mM)));
                                    } catch (mp) {
                                        mP ? mP(mp) : console["error"](mp), mI["manager"]["itemError"](mN);
                                    }
                                },
                                mf,
                                mP
                            );
                    },
                    parse: function (mN) {
                        var mX = this["textures"];
                        function mf(mk) {
                            return void 0x0 === mX[mk] && console["warn"]("THREE.MaterialLoader:\x20Undefined\x20texture", mk), mX[mk];
                        }
                        var mP = new BQ[mN["type"]]();
                        if (
                            (void 0x0 !== mN["uuid"] && (mP["uuid"] = mN["uuid"]),
                            void 0x0 !== mN["name"] && (mP["name"] = mN["name"]),
                            void 0x0 !== mN["color"] && mP["color"]["setHex"](mN["color"]),
                            void 0x0 !== mN["roughness"] && (mP["roughness"] = mN["roughness"]),
                            void 0x0 !== mN["metalness"] && (mP["metalness"] = mN["metalness"]),
                            void 0x0 !== mN["sheen"] && (mP["sheen"] = new Rq()["setHex"](mN["sheen"])),
                            void 0x0 !== mN["emissive"] && mP["emissive"]["setHex"](mN["emissive"]),
                            void 0x0 !== mN["specular"] && mP["specular"]["setHex"](mN["specular"]),
                            void 0x0 !== mN["shininess"] && (mP["shininess"] = mN["shininess"]),
                            void 0x0 !== mN["clearcoat"] && (mP["clearcoat"] = mN["clearcoat"]),
                            void 0x0 !== mN["clearcoatRoughness"] && (mP["clearcoatRoughness"] = mN["clearcoatRoughness"]),
                            void 0x0 !== mN["fog"] && (mP["fog"] = mN["fog"]),
                            void 0x0 !== mN["flatShading"] && (mP["flatShading"] = mN["flatShading"]),
                            void 0x0 !== mN["blending"] && (mP["blending"] = mN["blending"]),
                            void 0x0 !== mN["combine"] && (mP["combine"] = mN["combine"]),
                            void 0x0 !== mN["side"] && (mP["side"] = mN["side"]),
                            void 0x0 !== mN["opacity"] && (mP["opacity"] = mN["opacity"]),
                            void 0x0 !== mN["transparent"] && (mP["transparent"] = mN["transparent"]),
                            void 0x0 !== mN["alphaTest"] && (mP["alphaTest"] = mN["alphaTest"]),
                            void 0x0 !== mN["depthTest"] && (mP["depthTest"] = mN["depthTest"]),
                            void 0x0 !== mN["depthWrite"] && (mP["depthWrite"] = mN["depthWrite"]),
                            void 0x0 !== mN["colorWrite"] && (mP["colorWrite"] = mN["colorWrite"]),
                            void 0x0 !== mN["stencilWrite"] && (mP["stencilWrite"] = mN["stencilWrite"]),
                            void 0x0 !== mN["stencilWriteMask"] && (mP["stencilWriteMask"] = mN["stencilWriteMask"]),
                            void 0x0 !== mN["stencilFunc"] && (mP["stencilFunc"] = mN["stencilFunc"]),
                            void 0x0 !== mN["stencilRef"] && (mP["stencilRef"] = mN["stencilRef"]),
                            void 0x0 !== mN["stencilFuncMask"] && (mP["stencilFuncMask"] = mN["stencilFuncMask"]),
                            void 0x0 !== mN["stencilFail"] && (mP["stencilFail"] = mN["stencilFail"]),
                            void 0x0 !== mN["stencilZFail"] && (mP["stencilZFail"] = mN["stencilZFail"]),
                            void 0x0 !== mN["stencilZPass"] && (mP["stencilZPass"] = mN["stencilZPass"]),
                            void 0x0 !== mN["wireframe"] && (mP["wireframe"] = mN["wireframe"]),
                            void 0x0 !== mN["wireframeLinewidth"] && (mP["wireframeLinewidth"] = mN["wireframeLinewidth"]),
                            void 0x0 !== mN["wireframeLinecap"] && (mP["wireframeLinecap"] = mN["wireframeLinecap"]),
                            void 0x0 !== mN["wireframeLinejoin"] && (mP["wireframeLinejoin"] = mN["wireframeLinejoin"]),
                            void 0x0 !== mN["rotation"] && (mP["rotation"] = mN["rotation"]),
                            0x1 !== mN["linewidth"] && (mP["linewidth"] = mN["linewidth"]),
                            void 0x0 !== mN["dashSize"] && (mP["dashSize"] = mN["dashSize"]),
                            void 0x0 !== mN["gapSize"] && (mP["gapSize"] = mN["gapSize"]),
                            void 0x0 !== mN["scale"] && (mP["scale"] = mN["scale"]),
                            void 0x0 !== mN["polygonOffset"] && (mP["polygonOffset"] = mN["polygonOffset"]),
                            void 0x0 !== mN["polygonOffsetFactor"] && (mP["polygonOffsetFactor"] = mN["polygonOffsetFactor"]),
                            void 0x0 !== mN["polygonOffsetUnits"] && (mP["polygonOffsetUnits"] = mN["polygonOffsetUnits"]),
                            void 0x0 !== mN["skinning"] && (mP["skinning"] = mN["skinning"]),
                            void 0x0 !== mN["morphTargets"] && (mP["morphTargets"] = mN["morphTargets"]),
                            void 0x0 !== mN["morphNormals"] && (mP["morphNormals"] = mN["morphNormals"]),
                            void 0x0 !== mN["dithering"] && (mP["dithering"] = mN["dithering"]),
                            void 0x0 !== mN["vertexTangents"] && (mP["vertexTangents"] = mN["vertexTangents"]),
                            void 0x0 !== mN["visible"] && (mP["visible"] = mN["visible"]),
                            void 0x0 !== mN["toneMapped"] && (mP["toneMapped"] = mN["toneMapped"]),
                            void 0x0 !== mN["userData"] && (mP["userData"] = mN["userData"]),
                            void 0x0 !== mN["vertexColors"] && ("number" == typeof mN["vertexColors"] ? (mP["vertexColors"] = mN["vertexColors"] > 0x0) : (mP["vertexColors"] = mN["vertexColors"])),
                            void 0x0 !== mN["uniforms"])
                        )
                            for (var mI in mN["uniforms"]) {
                                var mA = mN["uniforms"][mI];
                                switch (((mP["uniforms"][mI] = {}), mA["type"])) {
                                    case "t":
                                        mP["uniforms"][mI]["value"] = mf(mA["value"]);
                                        break;
                                    case "c":
                                        mP["uniforms"][mI]["value"] = new Rq()["setHex"](mA["value"]);
                                        break;
                                    case "v2":
                                        mP["uniforms"][mI]["value"] = new E3()["fromArray"](mA["value"]);
                                        break;
                                    case "v3":
                                        mP["uniforms"][mI]["value"] = new Ed()["fromArray"](mA["value"]);
                                        break;
                                    case "v4":
                                        mP["uniforms"][mI]["value"] = new E8()["fromArray"](mA["value"]);
                                        break;
                                    case "m3":
                                        mP["uniforms"][mI]["value"] = new E4()["fromArray"](mA["value"]);
                                    case "m4":
                                        mP["uniforms"][mI]["value"] = new Ey()["fromArray"](mA["value"]);
                                        break;
                                    default:
                                        mP["uniforms"][mI]["value"] = mA["value"];
                                }
                            }
                        if (
                            (void 0x0 !== mN["defines"] && (mP["defines"] = mN["defines"]),
                            void 0x0 !== mN["vertexShader"] && (mP["vertexShader"] = mN["vertexShader"]),
                            void 0x0 !== mN["fragmentShader"] && (mP["fragmentShader"] = mN["fragmentShader"]),
                            void 0x0 !== mN["extensions"])
                        ) {
                            for (var mM in mN["extensions"]) mP["extensions"][mM] = mN["extensions"][mM];
                        }
                        if (
                            (void 0x0 !== mN["shading"] && (mP["flatShading"] = 0x1 === mN["shading"]),
                            void 0x0 !== mN["size"] && (mP["size"] = mN["size"]),
                            void 0x0 !== mN["sizeAttenuation"] && (mP["sizeAttenuation"] = mN["sizeAttenuation"]),
                            void 0x0 !== mN["map"] && (mP["map"] = mf(mN["map"])),
                            void 0x0 !== mN["matcap"] && (mP["matcap"] = mf(mN["matcap"])),
                            void 0x0 !== mN["alphaMap"] && (mP["alphaMap"] = mf(mN["alphaMap"])),
                            void 0x0 !== mN["bumpMap"] && (mP["bumpMap"] = mf(mN["bumpMap"])),
                            void 0x0 !== mN["bumpScale"] && (mP["bumpScale"] = mN["bumpScale"]),
                            void 0x0 !== mN["normalMap"] && (mP["normalMap"] = mf(mN["normalMap"])),
                            void 0x0 !== mN["normalMapType"] && (mP["normalMapType"] = mN["normalMapType"]),
                            void 0x0 !== mN["normalScale"])
                        ) {
                            var mp = mN["normalScale"];
                            !0x1 === Array["isArray"](mp) && (mp = [mp, mp]), (mP["normalScale"] = new E3()["fromArray"](mp));
                        }
                        return (
                            void 0x0 !== mN["displacementMap"] && (mP["displacementMap"] = mf(mN["displacementMap"])),
                            void 0x0 !== mN["displacementScale"] && (mP["displacementScale"] = mN["displacementScale"]),
                            void 0x0 !== mN["displacementBias"] && (mP["displacementBias"] = mN["displacementBias"]),
                            void 0x0 !== mN["roughnessMap"] && (mP["roughnessMap"] = mf(mN["roughnessMap"])),
                            void 0x0 !== mN["metalnessMap"] && (mP["metalnessMap"] = mf(mN["metalnessMap"])),
                            void 0x0 !== mN["emissiveMap"] && (mP["emissiveMap"] = mf(mN["emissiveMap"])),
                            void 0x0 !== mN["emissiveIntensity"] && (mP["emissiveIntensity"] = mN["emissiveIntensity"]),
                            void 0x0 !== mN["specularMap"] && (mP["specularMap"] = mf(mN["specularMap"])),
                            void 0x0 !== mN["envMap"] && (mP["envMap"] = mf(mN["envMap"])),
                            void 0x0 !== mN["envMapIntensity"] && (mP["envMapIntensity"] = mN["envMapIntensity"]),
                            void 0x0 !== mN["reflectivity"] && (mP["reflectivity"] = mN["reflectivity"]),
                            void 0x0 !== mN["refractionRatio"] && (mP["refractionRatio"] = mN["refractionRatio"]),
                            void 0x0 !== mN["lightMap"] && (mP["lightMap"] = mf(mN["lightMap"])),
                            void 0x0 !== mN["lightMapIntensity"] && (mP["lightMapIntensity"] = mN["lightMapIntensity"]),
                            void 0x0 !== mN["aoMap"] && (mP["aoMap"] = mf(mN["aoMap"])),
                            void 0x0 !== mN["aoMapIntensity"] && (mP["aoMapIntensity"] = mN["aoMapIntensity"]),
                            void 0x0 !== mN["gradientMap"] && (mP["gradientMap"] = mf(mN["gradientMap"])),
                            void 0x0 !== mN["clearcoatMap"] && (mP["clearcoatMap"] = mf(mN["clearcoatMap"])),
                            void 0x0 !== mN["clearcoatRoughnessMap"] && (mP["clearcoatRoughnessMap"] = mf(mN["clearcoatRoughnessMap"])),
                            void 0x0 !== mN["clearcoatNormalMap"] && (mP["clearcoatNormalMap"] = mf(mN["clearcoatNormalMap"])),
                            void 0x0 !== mN["clearcoatNormalScale"] && (mP["clearcoatNormalScale"] = new E3()["fromArray"](mN["clearcoatNormalScale"])),
                            mP
                        );
                    },
                    setTextures: function (mN) {
                        return (this["textures"] = mN), this;
                    },
                }));
            var bC = {
                decodeText: function (mN) {
                    if ("undefined" != typeof TextDecoder) return new TextDecoder()["decode"](mN);
                    for (var mX = "", mf = 0x0, mP = mN["length"]; mf < mP; mf++) mX += String["fromCharCode"](mN[mf]);
                    try {
                        return decodeURIComponent(escape(mX));
                    } catch (mI) {
                        return mX;
                    }
                },
                extractUrlBase: function (mN) {
                    var mX = mN["lastIndexOf"]("/");
                    return -0x1 === mX ? "./" : mN["substr"](0x0, mX + 0x1);
                },
            };
            function bd() {
                TR["call"](this), (this["type"] = "InstancedBufferGeometry"), (this["instanceCount"] = 0x1 / 0x0);
            }
            function bY(mN, mX, mf, mP) {
                "number" == typeof mf && ((mP = mf), (mf = !0x1), console["error"]("THREE.InstancedBufferAttribute:\x20The\x20constructor\x20now\x20expects\x20normalized\x20as\x20the\x20third\x20argument.")),
                    Rx["call"](this, mN, mX, mf),
                    (this["meshPerAttribute"] = mP || 0x1);
            }
            function bB(mN) {
                FF["call"](this, mN);
            }
            (bd["prototype"] = Object["assign"](Object["create"](TR["prototype"]), {
                constructor: bd,
                isInstancedBufferGeometry: !0x0,
                copy: function (mN) {
                    return TR["prototype"]["copy"]["call"](this, mN), (this["instanceCount"] = mN["instanceCount"]), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                toJSON: function () {
                    var mN = TR["prototype"]["toJSON"]["call"](this);
                    return (mN["instanceCount"] = this["instanceCount"]), (mN["isInstancedBufferGeometry"] = !0x0), mN;
                },
            })),
                (bY["prototype"] = Object["assign"](Object["create"](Rx["prototype"]), {
                    constructor: bY,
                    isInstancedBufferAttribute: !0x0,
                    copy: function (mN) {
                        return Rx["prototype"]["copy"]["call"](this, mN), (this["meshPerAttribute"] = mN["meshPerAttribute"]), this;
                    },
                    toJSON: function () {
                        var mN = Rx["prototype"]["toJSON"]["call"](this);
                        return (mN["meshPerAttribute"] = this["meshPerAttribute"]), (mN["isInstancedBufferAttribute"] = !0x0), mN;
                    },
                })),
                (bB["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: bB,
                    load: function (mN, mX, mf, mP) {
                        var mI = this,
                            mA = new FZ(mI["manager"]);
                        mA["setPath"](mI["path"]),
                            mA["load"](
                                mN,
                                function (mM) {
                                    try {
                                        mX(mI["parse"](JSON["parse"](mM)));
                                    } catch (mp) {
                                        mP ? mP(mp) : console["error"](mp), mI["manager"]["itemError"](mN);
                                    }
                                },
                                mf,
                                mP
                            );
                    },
                    parse: function (mN) {
                        var mX = mN["isInstancedBufferGeometry"] ? new bd() : new TR(),
                            mf = mN["data"]["index"];
                        if (void 0x0 !== mf) {
                            var mP = new bF[mf["type"]](mf["array"]);
                            mX["setIndex"](new Rx(mP, 0x1));
                        }
                        var mI = mN["data"]["attributes"];
                        for (var mA in mI) {
                            var mM = mI[mA],
                                mp = ((mP = new bF[mM["type"]](mM["array"])), new (mM["isInstancedBufferAttribute"] ? bY : Rx)(mP, mM["itemSize"], mM["normalized"]));
                            void 0x0 !== mM["name"] && (mp["name"] = mM["name"]), mX["setAttribute"](mA, mp);
                        }
                        var mk = mN["data"]["morphAttributes"];
                        if (mk)
                            for (var mA in mk) {
                                for (var mU = mk[mA], mq = [], mw = 0x0, mO = mU["length"]; mw < mO; mw++) {
                                    (mM = mU[mw]), (mp = new Rx((mP = new bF[mM["type"]](mM["array"])), mM["itemSize"], mM["normalized"])), (void 0x0 !== mM["name"] && (mp["name"] = mM["name"]), mq["push"](mp));
                                }
                                mX["morphAttributes"][mA] = mq;
                            }
                        mN["data"]["morphTargetsRelative"] && (mX["morphTargetsRelative"] = !0x0);
                        var mj = mN["data"]["groups"] || mN["data"]["drawcalls"] || mN["data"]["offsets"];
                        if (void 0x0 !== mj) {
                            mw = 0x0;
                            for (var mh = mj["length"]; mw !== mh; ++mw) {
                                var mS = mj[mw];
                                mX["addGroup"](mS["start"], mS["count"], mS["materialIndex"]);
                            }
                        }
                        var mg = mN["data"]["boundingSphere"];
                        if (void 0x0 !== mg) {
                            var mW = new Ed();
                            void 0x0 !== mg["center"] && mW["fromArray"](mg["center"]), (mX["boundingSphere"] = new R7(mW, mg["radius"]));
                        }
                        return mN["name"] && (mX["name"] = mN["name"]), mN["userData"] && (mX["userData"] = mN["userData"]), mX;
                    },
                }));
            var bF = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array,
            };
            function bb(mN) {
                FF["call"](this, mN);
            }
            bb["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                constructor: bb,
                load: function (mN, mX, mf, mP) {
                    var mI = this,
                        mA = "" === this["path"] ? bC["extractUrlBase"](mN) : this["path"];
                    this["resourcePath"] = this["resourcePath"] || mA;
                    var mM = new FZ(mI["manager"]);
                    mM["setPath"](this["path"]),
                        mM["load"](
                            mN,
                            function (mp) {
                                var mk = null;
                                try {
                                    mk = JSON["parse"](mp);
                                } catch (mq) {
                                    return void 0x0 !== mP && mP(mq), void console["error"]("THREE:ObjectLoader:\x20Can\x27t\x20parse\x20" + mN + ".", mq["message"]);
                                }
                                var mU = mk["metadata"];
                                void 0x0 !== mU && void 0x0 !== mU["type"] && "geometry" !== mU["type"]["toLowerCase"]() ? mI["parse"](mk, mX) : console["error"]("THREE.ObjectLoader:\x20Can\x27t\x20load\x20" + mN);
                            },
                            mf,
                            mP
                        );
                },
                parse: function (mN, mX) {
                    var mf = this["parseShape"](mN["shapes"]),
                        mP = this["parseGeometries"](mN["geometries"], mf),
                        mI = this["parseImages"](mN["images"], function () {
                            void 0x0 !== mX && mX(mp);
                        }),
                        mA = this["parseTextures"](mN["textures"], mI),
                        mM = this["parseMaterials"](mN["materials"], mA),
                        mp = this["parseObject"](mN["object"], mP, mM);
                    return mN["animations"] && (mp["animations"] = this["parseAnimations"](mN["animations"])), (void 0x0 !== mN["images"] && 0x0 !== mN["images"]["length"]) || (void 0x0 !== mX && mX(mp)), mp;
                },
                parseShape: function (mN) {
                    var mX = {};
                    if (void 0x0 !== mN)
                        for (var mf = 0x0, mP = mN["length"]; mf < mP; mf++) {
                            var mI = new FL()["fromJSON"](mN[mf]);
                            mX[mI["uuid"]] = mI;
                        }
                    return mX;
                },
                parseGeometries: function (mN, mX) {
                    var mf = {};
                    if (void 0x0 !== mN)
                        for (var mP = new bB(), mI = 0x0, mA = mN["length"]; mI < mA; mI++) {
                            var mM,
                                mp = mN[mI];
                            switch (mp["type"]) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["width"], mp["height"], mp["widthSegments"], mp["heightSegments"]);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    mM = new Bh[mp["type"]](mp["width"], mp["height"], mp["depth"], mp["widthSegments"], mp["heightSegments"], mp["depthSegments"]);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radius"], mp["segments"], mp["thetaStart"], mp["thetaLength"]);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radiusTop"], mp["radiusBottom"], mp["height"], mp["radialSegments"], mp["heightSegments"], mp["openEnded"], mp["thetaStart"], mp["thetaLength"]);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radius"], mp["height"], mp["radialSegments"], mp["heightSegments"], mp["openEnded"], mp["thetaStart"], mp["thetaLength"]);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radius"], mp["widthSegments"], mp["heightSegments"], mp["phiStart"], mp["phiLength"], mp["thetaStart"], mp["thetaLength"]);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radius"], mp["detail"]);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["innerRadius"], mp["outerRadius"], mp["thetaSegments"], mp["phiSegments"], mp["thetaStart"], mp["thetaLength"]);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radius"], mp["tube"], mp["radialSegments"], mp["tubularSegments"], mp["arc"]);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["radius"], mp["tube"], mp["tubularSegments"], mp["radialSegments"], mp["p"], mp["q"]);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    mM = new Bh[mp["type"]](new FV[mp["path"]["type"]]()["fromJSON"](mp["path"]), mp["tubularSegments"], mp["radius"], mp["radialSegments"], mp["closed"]);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["points"], mp["segments"], mp["phiStart"], mp["phiLength"]);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    mM = new Bh[mp["type"]](mp["vertices"], mp["indices"], mp["radius"], mp["details"]);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var mk = [], mU = 0x0, mq = mp["shapes"]["length"]; mU < mq; mU++) {
                                        var mw = mX[mp["shapes"][mU]];
                                        mk["push"](mw);
                                    }
                                    mM = new Bh[mp["type"]](mk, mp["curveSegments"]);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (mk = [], mU = 0x0, mq = mp["shapes"]["length"]; mU < mq; mU++) {
                                        (mw = mX[mp["shapes"][mU]]), mk["push"](mw);
                                    }
                                    var mO = mp["options"]["extrudePath"];
                                    void 0x0 !== mO && (mp["options"]["extrudePath"] = new FV[mO["type"]]()["fromJSON"](mO)), (mM = new Bh[mp["type"]](mk, mp["options"]));
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    mM = mP["parse"](mp);
                                    break;
                                case "Geometry":
                                    console["error"]("THREE.ObjectLoader:\x20Loading\x20\x22Geometry\x22\x20is\x20not\x20supported\x20anymore.");
                                    break;
                                default:
                                    console["warn"]("THREE.ObjectLoader:\x20Unsupported\x20geometry\x20type\x20\x22" + mp["type"] + "\x22");
                                    continue;
                            }
                            (mM["uuid"] = mp["uuid"]), void 0x0 !== mp["name"] && (mM["name"] = mp["name"]), !0x0 === mM["isBufferGeometry"] && void 0x0 !== mp["userData"] && (mM["userData"] = mp["userData"]), (mf[mp["uuid"]] = mM);
                        }
                    return mf;
                },
                parseMaterials: function (mN, mX) {
                    var mf = {},
                        mP = {};
                    if (void 0x0 !== mN) {
                        var mI = new bT();
                        mI["setTextures"](mX);
                        for (var mA = 0x0, mM = mN["length"]; mA < mM; mA++) {
                            var mp = mN[mA];
                            if ("MultiMaterial" === mp["type"]) {
                                for (var mk = [], mU = 0x0; mU < mp["materials"]["length"]; mU++) {
                                    var mq = mp["materials"][mU];
                                    void 0x0 === mf[mq["uuid"]] && (mf[mq["uuid"]] = mI["parse"](mq)), mk["push"](mf[mq["uuid"]]);
                                }
                                mP[mp["uuid"]] = mk;
                            } else void 0x0 === mf[mp["uuid"]] && (mf[mp["uuid"]] = mI["parse"](mp)), (mP[mp["uuid"]] = mf[mp["uuid"]]);
                        }
                    }
                    return mP;
                },
                parseAnimations: function (mN) {
                    for (var mX = [], mf = 0x0; mf < mN["length"]; mf++) {
                        var mP = mN[mf],
                            mI = FT["parse"](mP);
                        void 0x0 !== mP["uuid"] && (mI["uuid"] = mP["uuid"]), mX["push"](mI);
                    }
                    return mX;
                },
                parseImages: function (mN, mX) {
                    var mf = this,
                        mP = {};
                    function mI(mh) {
                        return (
                            mf["manager"]["itemStart"](mh),
                            mA["load"](
                                mh,
                                function () {
                                    mf["manager"]["itemEnd"](mh);
                                },
                                void 0x0,
                                function () {
                                    mf["manager"]["itemError"](mh), mf["manager"]["itemEnd"](mh);
                                }
                            )
                        );
                    }
                    if (void 0x0 !== mN && mN["length"] > 0x0) {
                        var mA = new FD(new FY(mX));
                        mA["setCrossOrigin"](this["crossOrigin"]);
                        for (var mM = 0x0, mp = mN["length"]; mM < mp; mM++) {
                            var mk = mN[mM],
                                mU = mk["url"];
                            if (Array["isArray"](mU)) {
                                mP[mk["uuid"]] = [];
                                for (var mq = 0x0, mw = mU["length"]; mq < mw; mq++) {
                                    var mO = mU[mq],
                                        mj = /^(\/\/)|([a-z]+:(\/\/)?)/i["test"](mO) ? mO : mf["resourcePath"] + mO;
                                    mP[mk["uuid"]]["push"](mI(mj));
                                }
                            } else (mj = /^(\/\/)|([a-z]+:(\/\/)?)/i["test"](mk["url"]) ? mk["url"] : mf["resourcePath"] + mk["url"]), (mP[mk["uuid"]] = mI(mj));
                        }
                    }
                    return mP;
                },
                parseTextures: function (mN, mX) {
                    function mf(mk, mU) {
                        return "number" == typeof mk ? mk : (console["warn"]("THREE.ObjectLoader.parseTexture:\x20Constant\x20should\x20be\x20in\x20numeric\x20form.", mk), mU[mk]);
                    }
                    var mP = {};
                    if (void 0x0 !== mN)
                        for (var mI = 0x0, mA = mN["length"]; mI < mA; mI++) {
                            var mM,
                                mp = mN[mI];
                            void 0x0 === mp["image"] && console["warn"]("THREE.ObjectLoader:\x20No\x20\x22image\x22\x20specified\x20for", mp["uuid"]),
                                void 0x0 === mX[mp["image"]] && console["warn"]("THREE.ObjectLoader:\x20Undefined\x20image", mp["image"]),
                                ((mM = Array["isArray"](mX[mp["image"]]) ? new Cb(mX[mp["image"]]) : new E7(mX[mp["image"]]))["needsUpdate"] = !0x0),
                                (mM["uuid"] = mp["uuid"]),
                                void 0x0 !== mp["name"] && (mM["name"] = mp["name"]),
                                void 0x0 !== mp["mapping"] && (mM["mapping"] = mf(mp["mapping"], bm)),
                                void 0x0 !== mp["offset"] && mM["offset"]["fromArray"](mp["offset"]),
                                void 0x0 !== mp["repeat"] && mM["repeat"]["fromArray"](mp["repeat"]),
                                void 0x0 !== mp["center"] && mM["center"]["fromArray"](mp["center"]),
                                void 0x0 !== mp["rotation"] && (mM["rotation"] = mp["rotation"]),
                                void 0x0 !== mp["wrap"] && ((mM["wrapS"] = mf(mp["wrap"][0x0], bv)), (mM["wrapT"] = mf(mp["wrap"][0x1], bv))),
                                void 0x0 !== mp["format"] && (mM["format"] = mp["format"]),
                                void 0x0 !== mp["type"] && (mM["type"] = mp["type"]),
                                void 0x0 !== mp["encoding"] && (mM["encoding"] = mp["encoding"]),
                                void 0x0 !== mp["minFilter"] && (mM["minFilter"] = mf(mp["minFilter"], by)),
                                void 0x0 !== mp["magFilter"] && (mM["magFilter"] = mf(mp["magFilter"], by)),
                                void 0x0 !== mp["anisotropy"] && (mM["anisotropy"] = mp["anisotropy"]),
                                void 0x0 !== mp["flipY"] && (mM["flipY"] = mp["flipY"]),
                                void 0x0 !== mp["premultiplyAlpha"] && (mM["premultiplyAlpha"] = mp["premultiplyAlpha"]),
                                void 0x0 !== mp["unpackAlignment"] && (mM["unpackAlignment"] = mp["unpackAlignment"]),
                                (mP[mp["uuid"]] = mM);
                        }
                    return mP;
                },
                parseObject: function (mN, mX, mf) {
                    var mP;
                    function mI(mg) {
                        return void 0x0 === mX[mg] && console["warn"]("THREE.ObjectLoader:\x20Undefined\x20geometry", mg), mX[mg];
                    }
                    function mA(mg) {
                        if (void 0x0 !== mg) {
                            if (Array["isArray"](mg)) {
                                for (var mW = [], mH = 0x0, mx = mg["length"]; mH < mx; mH++) {
                                    var mK = mg[mH];
                                    void 0x0 === mf[mK] && console["warn"]("THREE.ObjectLoader:\x20Undefined\x20material", mK), mW["push"](mf[mK]);
                                }
                                return mW;
                            }
                            return void 0x0 === mf[mg] && console["warn"]("THREE.ObjectLoader:\x20Undefined\x20material", mg), mf[mg];
                        }
                    }
                    switch (mN["type"]) {
                        case "Scene":
                            (mP = new EW()),
                                void 0x0 !== mN["background"] && Number["isInteger"](mN["background"]) && (mP["background"] = new Rq(mN["background"])),
                                void 0x0 !== mN["fog"] &&
                                    ("Fog" === mN["fog"]["type"]
                                        ? (mP["fog"] = new YT(mN["fog"]["color"], mN["fog"]["near"], mN["fog"]["far"]))
                                        : "FogExp2" === mN["fog"]["type"] && (mP["fog"] = new YR(mN["fog"]["color"], mN["fog"]["density"])));
                            break;
                        case "PerspectiveCamera":
                            (mP = new Tx(mN["fov"], mN["aspect"], mN["near"], mN["far"])),
                                void 0x0 !== mN["focus"] && (mP["focus"] = mN["focus"]),
                                void 0x0 !== mN["zoom"] && (mP["zoom"] = mN["zoom"]),
                                void 0x0 !== mN["filmGauge"] && (mP["filmGauge"] = mN["filmGauge"]),
                                void 0x0 !== mN["filmOffset"] && (mP["filmOffset"] = mN["filmOffset"]),
                                void 0x0 !== mN["view"] && (mP["view"] = Object["assign"]({}, mN["view"]));
                            break;
                        case "OrthographicCamera":
                            (mP = new b5(mN["left"], mN["right"], mN["top"], mN["bottom"], mN["near"], mN["far"])),
                                void 0x0 !== mN["zoom"] && (mP["zoom"] = mN["zoom"]),
                                void 0x0 !== mN["view"] && (mP["view"] = Object["assign"]({}, mN["view"]));
                            break;
                        case "AmbientLight":
                            mP = new b8(mN["color"], mN["intensity"]);
                            break;
                        case "DirectionalLight":
                            mP = new b7(mN["color"], mN["intensity"]);
                            break;
                        case "PointLight":
                            mP = new b4(mN["color"], mN["intensity"], mN["distance"], mN["decay"]);
                            break;
                        case "RectAreaLight":
                            mP = new b9(mN["color"], mN["intensity"], mN["width"], mN["height"]);
                            break;
                        case "SpotLight":
                            mP = new b2(mN["color"], mN["intensity"], mN["distance"], mN["angle"], mN["penumbra"], mN["decay"]);
                            break;
                        case "HemisphereLight":
                            mP = new Fz(mN["color"], mN["groundColor"], mN["intensity"]);
                            break;
                        case "LightProbe":
                            mP = new bR()["fromJSON"](mN);
                            break;
                        case "SkinnedMesh":
                            console["warn"]("THREE.ObjectLoader.parseObject()\x20does\x20not\x20support\x20SkinnedMesh\x20yet.");
                        case "Mesh":
                            mP = new TA((mM = mI(mN["geometry"])), (mp = mA(mN["material"])));
                            break;
                        case "InstancedMesh":
                            var mM = mI(mN["geometry"]),
                                mp = mA(mN["material"]),
                                mk = mN["count"],
                                mU = mN["instanceMatrix"];
                            (mP = new YL(mM, mp, mk))["instanceMatrix"] = new Rx(new Float32Array(mU["array"]), 0x10);
                            break;
                        case "LOD":
                            mP = new Yh();
                            break;
                        case "Line":
                            mP = new n4(mI(mN["geometry"]), mA(mN["material"]), mN["mode"]);
                            break;
                        case "LineLoop":
                            mP = new n8(mI(mN["geometry"]), mA(mN["material"]));
                            break;
                        case "LineSegments":
                            mP = new n7(mI(mN["geometry"]), mA(mN["material"]));
                            break;
                        case "PointCloud":
                        case "Points":
                            mP = new nd(mI(mN["geometry"]), mA(mN["material"]));
                            break;
                        case "Sprite":
                            mP = new YM(mA(mN["material"]));
                            break;
                        case "Group":
                            mP = new Y6();
                            break;
                        default:
                            mP = new Eg();
                    }
                    if (
                        ((mP["uuid"] = mN["uuid"]),
                        void 0x0 !== mN["name"] && (mP["name"] = mN["name"]),
                        void 0x0 !== mN["matrix"]
                            ? (mP["matrix"]["fromArray"](mN["matrix"]),
                              void 0x0 !== mN["matrixAutoUpdate"] && (mP["matrixAutoUpdate"] = mN["matrixAutoUpdate"]),
                              mP["matrixAutoUpdate"] && mP["matrix"]["decompose"](mP["position"], mP["quaternion"], mP["scale"]))
                            : (void 0x0 !== mN["position"] && mP["position"]["fromArray"](mN["position"]),
                              void 0x0 !== mN["rotation"] && mP["rotation"]["fromArray"](mN["rotation"]),
                              void 0x0 !== mN["quaternion"] && mP["quaternion"]["fromArray"](mN["quaternion"]),
                              void 0x0 !== mN["scale"] && mP["scale"]["fromArray"](mN["scale"])),
                        void 0x0 !== mN["castShadow"] && (mP["castShadow"] = mN["castShadow"]),
                        void 0x0 !== mN["receiveShadow"] && (mP["receiveShadow"] = mN["receiveShadow"]),
                        mN["shadow"] &&
                            (void 0x0 !== mN["shadow"]["bias"] && (mP["shadow"]["bias"] = mN["shadow"]["bias"]),
                            void 0x0 !== mN["shadow"]["radius"] && (mP["shadow"]["radius"] = mN["shadow"]["radius"]),
                            void 0x0 !== mN["shadow"]["mapSize"] && mP["shadow"]["mapSize"]["fromArray"](mN["shadow"]["mapSize"]),
                            void 0x0 !== mN["shadow"]["camera"] && (mP["shadow"]["camera"] = this["parseObject"](mN["shadow"]["camera"]))),
                        void 0x0 !== mN["visible"] && (mP["visible"] = mN["visible"]),
                        void 0x0 !== mN["frustumCulled"] && (mP["frustumCulled"] = mN["frustumCulled"]),
                        void 0x0 !== mN["renderOrder"] && (mP["renderOrder"] = mN["renderOrder"]),
                        void 0x0 !== mN["userData"] && (mP["userData"] = mN["userData"]),
                        void 0x0 !== mN["layers"] && (mP["layers"]["mask"] = mN["layers"]),
                        void 0x0 !== mN["children"])
                    ) {
                        for (var mq = mN["children"], mw = 0x0; mw < mq["length"]; mw++) mP["add"](this["parseObject"](mq[mw], mX, mf));
                    }
                    if ("LOD" === mN["type"]) {
                        void 0x0 !== mN["autoUpdate"] && (mP["autoUpdate"] = mN["autoUpdate"]);
                        for (var mO = mN["levels"], mj = 0x0; mj < mO["length"]; mj++) {
                            var mh = mO[mj],
                                mS = mP["getObjectByProperty"]("uuid", mh["object"]);
                            void 0x0 !== mS && mP["addLevel"](mS, mh["distance"]);
                        }
                    }
                    return mP;
                },
            });
            var bZ,
                bm = {
                    UVMapping: 0x12c,
                    CubeReflectionMapping: 0x12d,
                    CubeRefractionMapping: 0x12e,
                    EquirectangularReflectionMapping: 0x12f,
                    EquirectangularRefractionMapping: 0x130,
                    SphericalReflectionMapping: 0x131,
                    CubeUVReflectionMapping: r9,
                    CubeUVRefractionMapping: 0x133,
                },
                bv = { RepeatWrapping: rE, ClampToEdgeWrapping: rR, MirroredRepeatWrapping: rT },
                by = { NearestFilter: rC, NearestMipmapNearestFilter: rd, NearestMipmapLinearFilter: rY, LinearFilter: rB, LinearMipmapNearestFilter: rF, LinearMipmapLinearFilter: rb };
            function bD(mN) {
                "undefined" == typeof createImageBitmap && console["warn"]("THREE.ImageBitmapLoader:\x20createImageBitmap()\x20not\x20supported."),
                    "undefined" == typeof fetch && console["warn"]("THREE.ImageBitmapLoader:\x20fetch()\x20not\x20supported."),
                    FF["call"](this, mN),
                    (this["options"] = void 0x0);
            }
            function bN() {
                (this["type"] = "ShapePath"), (this["color"] = new Rq()), (this["subPaths"] = []), (this["currentPath"] = null);
            }
            function bX(mN) {
                (this["type"] = "Font"), (this["data"] = mN);
            }
            function bf(mN, mX, mf, mP, mI) {
                var mA = mI["glyphs"][mN] || mI["glyphs"]["?"];
                if (mA) {
                    var mM,
                        mp,
                        mk,
                        mU,
                        mq,
                        mw,
                        mO,
                        mj,
                        mh = new bN();
                    if (mA["o"])
                        for (var mS = mA["_cachedOutline"] || (mA["_cachedOutline"] = mA["o"]["split"]("\x20")), mg = 0x0, mW = mS["length"]; mg < mW; ) {
                            switch (mS[mg++]) {
                                case "m":
                                    (mM = mS[mg++] * mX + mf), (mp = mS[mg++] * mX + mP), mh["moveTo"](mM, mp);
                                    break;
                                case "l":
                                    (mM = mS[mg++] * mX + mf), (mp = mS[mg++] * mX + mP), mh["lineTo"](mM, mp);
                                    break;
                                case "q":
                                    (mk = mS[mg++] * mX + mf), (mU = mS[mg++] * mX + mP), (mq = mS[mg++] * mX + mf), (mw = mS[mg++] * mX + mP), mh["quadraticCurveTo"](mq, mw, mk, mU);
                                    break;
                                case "b":
                                    (mk = mS[mg++] * mX + mf),
                                        (mU = mS[mg++] * mX + mP),
                                        (mq = mS[mg++] * mX + mf),
                                        (mw = mS[mg++] * mX + mP),
                                        (mO = mS[mg++] * mX + mf),
                                        (mj = mS[mg++] * mX + mP),
                                        mh["bezierCurveTo"](mq, mw, mO, mj, mk, mU);
                            }
                        }
                    return { offsetX: mA["ha"] * mX, path: mh };
                }
                console["error"]("THREE.Font:\x20character\x20\x22" + mN + "\x22\x20does\x20not\x20exists\x20in\x20font\x20family\x20" + mI["familyName"] + ".");
            }
            function bP(mN) {
                FF["call"](this, mN);
            }
            (bD["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                constructor: bD,
                setOptions: function (mN) {
                    return (this["options"] = mN), this;
                },
                load: function (mN, mX, mf, mP) {
                    void 0x0 === mN && (mN = ""), void 0x0 !== this["path"] && (mN = this["path"] + mN), (mN = this["manager"]["resolveURL"](mN));
                    var mI = this,
                        mA = Fd["get"](mN);
                    if (void 0x0 !== mA)
                        return (
                            mI["manager"]["itemStart"](mN),
                            setTimeout(function () {
                                mX && mX(mA), mI["manager"]["itemEnd"](mN);
                            }, 0x0),
                            mA
                        );
                    fetch(mN)
                        ["then"](function (mM) {
                            return mM["blob"]();
                        })
                        ["then"](function (mM) {
                            return void 0x0 === mI["options"] ? createImageBitmap(mM) : createImageBitmap(mM, mI["options"]);
                        })
                        ["then"](function (mM) {
                            Fd["add"](mN, mM), mX && mX(mM), mI["manager"]["itemEnd"](mN);
                        })
                        ["catch"](function (mM) {
                            mP && mP(mM), mI["manager"]["itemError"](mN), mI["manager"]["itemEnd"](mN);
                        }),
                        mI["manager"]["itemStart"](mN);
                },
            })),
                Object["assign"](bN["prototype"], {
                    moveTo: function (mN, mX) {
                        return (this["currentPath"] = new FG()), this["subPaths"]["push"](this["currentPath"]), this["currentPath"]["moveTo"](mN, mX), this;
                    },
                    lineTo: function (mN, mX) {
                        return this["currentPath"]["lineTo"](mN, mX), this;
                    },
                    quadraticCurveTo: function (mN, mX, mf, mP) {
                        return this["currentPath"]["quadraticCurveTo"](mN, mX, mf, mP), this;
                    },
                    bezierCurveTo: function (mN, mX, mf, mP, mI, mA) {
                        return this["currentPath"]["bezierCurveTo"](mN, mX, mf, mP, mI, mA), this;
                    },
                    splineThru: function (mN) {
                        return this["currentPath"]["splineThru"](mN), this;
                    },
                    toShapes: function (mN, mX) {
                        function mf(v4) {
                            for (var v5 = [], v6 = 0x0, v7 = v4["length"]; v6 < v7; v6++) {
                                var v8 = v4[v6],
                                    v9 = new FL();
                                (v9["curves"] = v8["curves"]), v5["push"](v9);
                            }
                            return v5;
                        }
                        function mP(v4, v5) {
                            for (var v6 = v5["length"], v7 = !0x1, v8 = v6 - 0x1, v9 = 0x0; v9 < v6; v8 = v9++) {
                                var vE = v5[v8],
                                    vR = v5[v9],
                                    vT = vR["x"] - vE["x"],
                                    vC = vR["y"] - vE["y"];
                                if (Math["abs"](vC) > Number["EPSILON"]) {
                                    if ((vC < 0x0 && ((vE = v5[v9]), (vT = -vT), (vR = v5[v8]), (vC = -vC)), v4["y"] < vE["y"] || v4["y"] > vR["y"])) continue;
                                    if (v4["y"] === vE["y"]) {
                                        if (v4["x"] === vE["x"]) return !0x0;
                                    } else {
                                        var vd = vC * (v4["x"] - vE["x"]) - vT * (v4["y"] - vE["y"]);
                                        if (0x0 === vd) return !0x0;
                                        if (vd < 0x0) continue;
                                        v7 = !v7;
                                    }
                                } else {
                                    if (v4["y"] !== vE["y"]) continue;
                                    if ((vR["x"] <= v4["x"] && v4["x"] <= vE["x"]) || (vE["x"] <= v4["x"] && v4["x"] <= vR["x"])) return !0x0;
                                }
                            }
                            return v7;
                        }
                        var mI = BC["isClockWise"],
                            mA = this["subPaths"];
                        if (0x0 === mA["length"]) return [];
                        if (!0x0 === mX) return mf(mA);
                        var mM,
                            mp,
                            mk,
                            mU = [];
                        if (0x1 === mA["length"]) return (mp = mA[0x0]), ((mk = new FL())["curves"] = mp["curves"]), mU["push"](mk), mU;
                        var mq = !mI(mA[0x0]["getPoints"]());
                        mq = mN ? !mq : mq;
                        var mw,
                            mO,
                            mj = [],
                            mh = [],
                            mS = [],
                            mg = 0x0;
                        (mh[mg] = void 0x0), (mS[mg] = []);
                        for (var mW = 0x0, mH = mA["length"]; mW < mH; mW++)
                            (mM = mI((mw = (mp = mA[mW])["getPoints"]()))),
                                (mM = mN ? !mM : mM) ? (!mq && mh[mg] && mg++, (mh[mg] = { s: new FL(), p: mw }), (mh[mg]["s"]["curves"] = mp["curves"]), mq && mg++, (mS[mg] = [])) : mS[mg]["push"]({ h: mp, p: mw[0x0] });
                        if (!mh[0x0]) return mf(mA);
                        if (mh["length"] > 0x1) {
                            for (var mx = !0x1, mK = [], mV = 0x0, mJ = mh["length"]; mV < mJ; mV++) mj[mV] = [];
                            for (mV = 0x0, mJ = mh["length"]; mV < mJ; mV++)
                                for (var mG = mS[mV], mL = 0x0; mL < mG["length"]; mL++) {
                                    for (var mQ = mG[mL], mz = !0x0, v0 = 0x0; v0 < mh["length"]; v0++)
                                        mP(mQ["p"], mh[v0]["p"]) && (mV !== v0 && mK["push"]({ froms: mV, tos: v0, hole: mL }), mz ? ((mz = !0x1), mj[v0]["push"](mQ)) : (mx = !0x0));
                                    mz && mj[mV]["push"](mQ);
                                }
                            mK["length"] > 0x0 && (mx || (mS = mj));
                        }
                        mW = 0x0;
                        for (var v1 = mh["length"]; mW < v1; mW++) {
                            (mk = mh[mW]["s"]), mU["push"](mk);
                            for (var v2 = 0x0, v3 = (mO = mS[mW])["length"]; v2 < v3; v2++) mk["holes"]["push"](mO[v2]["h"]);
                        }
                        return mU;
                    },
                }),
                Object["assign"](bX["prototype"], {
                    isFont: !0x0,
                    generateShapes: function (mN, mX) {
                        void 0x0 === mX && (mX = 0x64);
                        for (
                            var mf = [],
                                mP = (function (mM, mp, mk) {
                                    for (
                                        var mU = Array["from"] ? Array["from"](mM) : String(mM)["split"](""),
                                            mq = mp / mk["resolution"],
                                            mw = (mk["boundingBox"]["yMax"] - mk["boundingBox"]["yMin"] + mk["underlineThickness"]) * mq,
                                            mO = [],
                                            mj = 0x0,
                                            mh = 0x0,
                                            mS = 0x0;
                                        mS < mU["length"];
                                        mS++
                                    ) {
                                        var mg = mU[mS];
                                        if ("\x0a" === mg) (mj = 0x0), (mh -= mw);
                                        else {
                                            var mW = bf(mg, mq, mj, mh, mk);
                                            (mj += mW["offsetX"]), mO["push"](mW["path"]);
                                        }
                                    }
                                    return mO;
                                })(mN, mX, this["data"]),
                                mI = 0x0,
                                mA = mP["length"];
                            mI < mA;
                            mI++
                        )
                            Array["prototype"]["push"]["apply"](mf, mP[mI]["toShapes"]());
                        return mf;
                    },
                }),
                (bP["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                    constructor: bP,
                    load: function (mN, mX, mf, mP) {
                        var mI = this,
                            mA = new FZ(this["manager"]);
                        mA["setPath"](this["path"]),
                            mA["load"](
                                mN,
                                function (mM) {
                                    var mp;
                                    try {
                                        mp = JSON["parse"](mM);
                                    } catch (mU) {
                                        console["warn"]("THREE.FontLoader:\x20typeface.js\x20support\x20is\x20being\x20deprecated.\x20Use\x20typeface.json\x20instead."), (mp = JSON["parse"](mM["substring"](0x41, mM["length"] - 0x2)));
                                    }
                                    var mk = mI["parse"](mp);
                                    mX && mX(mk);
                                },
                                mf,
                                mP
                            );
                    },
                    parse: function (mN) {
                        return new bX(mN);
                    },
                }));
            var bI = {
                getContext: function () {
                    return void 0x0 === bZ && (bZ = new (window["AudioContext"] || window["webkitAudioContext"])()), bZ;
                },
                setContext: function (mN) {
                    bZ = mN;
                },
            };
            function bA(mN) {
                FF["call"](this, mN);
            }
            function bM(mN, mX, mf) {
                bR["call"](this, void 0x0, mf);
                var mP = new Rq()["set"](mN),
                    mI = new Rq()["set"](mX),
                    mA = new Ed(mP["r"], mP["g"], mP["b"]),
                    mM = new Ed(mI["r"], mI["g"], mI["b"]),
                    mp = Math["sqrt"](Math["PI"]),
                    mk = mp * Math["sqrt"](0.75);
                this["sh"]["coefficients"][0x0]["copy"](mA)["add"](mM)["multiplyScalar"](mp), this["sh"]["coefficients"][0x1]["copy"](mA)["sub"](mM)["multiplyScalar"](mk);
            }
            function bp(mN, mX) {
                bR["call"](this, void 0x0, mX);
                var mf = new Rq()["set"](mN);
                this["sh"]["coefficients"][0x0]["set"](mf["r"], mf["g"], mf["b"])["multiplyScalar"](0x2 * Math["sqrt"](Math["PI"]));
            }
            (bA["prototype"] = Object["assign"](Object["create"](FF["prototype"]), {
                constructor: bA,
                load: function (mN, mX, mf, mP) {
                    var mI = this,
                        mA = new FZ(mI["manager"]);
                    mA["setResponseType"]("arraybuffer"),
                        mA["setPath"](mI["path"]),
                        mA["load"](
                            mN,
                            function (mM) {
                                try {
                                    var mp = mM["slice"](0x0);
                                    bI["getContext"]()["decodeAudioData"](mp, function (mk) {
                                        mX(mk);
                                    });
                                } catch (mk) {
                                    mP ? mP(mk) : console["error"](mk), mI["manager"]["itemError"](mN);
                                }
                            },
                            mf,
                            mP
                        );
                },
            })),
                (bM["prototype"] = Object["assign"](Object["create"](bR["prototype"]), {
                    constructor: bM,
                    isHemisphereLightProbe: !0x0,
                    copy: function (mN) {
                        return bR["prototype"]["copy"]["call"](this, mN), this;
                    },
                    toJSON: function (mN) {
                        return bR["prototype"]["toJSON"]["call"](this, mN);
                    },
                })),
                (bp["prototype"] = Object["assign"](Object["create"](bR["prototype"]), {
                    constructor: bp,
                    isAmbientLightProbe: !0x0,
                    copy: function (mN) {
                        return bR["prototype"]["copy"]["call"](this, mN), this;
                    },
                    toJSON: function (mN) {
                        return bR["prototype"]["toJSON"]["call"](this, mN);
                    },
                }));
            var bk = new Ey(),
                bU = new Ey();
            function bq(mN) {
                (this["autoStart"] = void 0x0 === mN || mN), (this["startTime"] = 0x0), (this["oldTime"] = 0x0), (this["elapsedTime"] = 0x0), (this["running"] = !0x1);
            }
            Object["assign"](
                function () {
                    (this["type"] = "StereoCamera"),
                        (this["aspect"] = 0x1),
                        (this["eyeSep"] = 0.064),
                        (this["cameraL"] = new Tx()),
                        this["cameraL"]["layers"]["enable"](0x1),
                        (this["cameraL"]["matrixAutoUpdate"] = !0x1),
                        (this["cameraR"] = new Tx()),
                        this["cameraR"]["layers"]["enable"](0x2),
                        (this["cameraR"]["matrixAutoUpdate"] = !0x1),
                        (this["_cache"] = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null });
                }["prototype"],
                {
                    update: function (mN) {
                        var mX = this["_cache"];
                        if (
                            mX["focus"] !== mN["focus"] ||
                            mX["fov"] !== mN["fov"] ||
                            mX["aspect"] !== mN["aspect"] * this["aspect"] ||
                            mX["near"] !== mN["near"] ||
                            mX["far"] !== mN["far"] ||
                            mX["zoom"] !== mN["zoom"] ||
                            mX["eyeSep"] !== this["eyeSep"]
                        ) {
                            (mX["focus"] = mN["focus"]),
                                (mX["fov"] = mN["fov"]),
                                (mX["aspect"] = mN["aspect"] * this["aspect"]),
                                (mX["near"] = mN["near"]),
                                (mX["far"] = mN["far"]),
                                (mX["zoom"] = mN["zoom"]),
                                (mX["eyeSep"] = this["eyeSep"]);
                            var mf,
                                mP,
                                mI = mN["projectionMatrix"]["clone"](),
                                mA = mX["eyeSep"] / 0x2,
                                mM = (mA * mX["near"]) / mX["focus"],
                                mp = (mX["near"] * Math["tan"](E2["DEG2RAD"] * mX["fov"] * 0.5)) / mX["zoom"];
                            (bU["elements"][0xc] = -mA),
                                (bk["elements"][0xc] = mA),
                                (mf = -mp * mX["aspect"] + mM),
                                (mP = mp * mX["aspect"] + mM),
                                (mI["elements"][0x0] = (0x2 * mX["near"]) / (mP - mf)),
                                (mI["elements"][0x8] = (mP + mf) / (mP - mf)),
                                this["cameraL"]["projectionMatrix"]["copy"](mI),
                                (mf = -mp * mX["aspect"] - mM),
                                (mP = mp * mX["aspect"] - mM),
                                (mI["elements"][0x0] = (0x2 * mX["near"]) / (mP - mf)),
                                (mI["elements"][0x8] = (mP + mf) / (mP - mf)),
                                this["cameraR"]["projectionMatrix"]["copy"](mI);
                        }
                        this["cameraL"]["matrixWorld"]["copy"](mN["matrixWorld"])["multiply"](bU), this["cameraR"]["matrixWorld"]["copy"](mN["matrixWorld"])["multiply"](bk);
                    },
                }
            ),
                Object["assign"](bq["prototype"], {
                    start: function () {
                        (this["startTime"] = ("undefined" == typeof performance ? Date : performance)["now"]()), (this["oldTime"] = this["startTime"]), (this["elapsedTime"] = 0x0), (this["running"] = !0x0);
                    },
                    stop: function () {
                        this["getElapsedTime"](), (this["running"] = !0x1), (this["autoStart"] = !0x1);
                    },
                    getElapsedTime: function () {
                        return this["getDelta"](), this["elapsedTime"];
                    },
                    getDelta: function () {
                        var mN = 0x0;
                        if (this["autoStart"] && !this["running"]) return this["start"](), 0x0;
                        if (this["running"]) {
                            var mX = ("undefined" == typeof performance ? Date : performance)["now"]();
                            (mN = (mX - this["oldTime"]) / 0x3e8), (this["oldTime"] = mX), (this["elapsedTime"] += mN);
                        }
                        return mN;
                    },
                });
            var bw = new Ed(),
                bO = new ER(),
                bj = new Ed(),
                bh = new Ed();
            function bS() {
                Eg["call"](this),
                    (this["type"] = "AudioListener"),
                    (this["context"] = bI["getContext"]()),
                    (this["gain"] = this["context"]["createGain"]()),
                    this["gain"]["connect"](this["context"]["destination"]),
                    (this["filter"] = null),
                    (this["timeDelta"] = 0x0),
                    (this["_clock"] = new bq());
            }
            function bg(mN) {
                Eg["call"](this),
                    (this["type"] = "Audio"),
                    (this["listener"] = mN),
                    (this["context"] = mN["context"]),
                    (this["gain"] = this["context"]["createGain"]()),
                    this["gain"]["connect"](mN["getInput"]()),
                    (this["autoplay"] = !0x1),
                    (this["buffer"] = null),
                    (this["detune"] = 0x0),
                    (this["loop"] = !0x1),
                    (this["loopStart"] = 0x0),
                    (this["loopEnd"] = 0x0),
                    (this["offset"] = 0x0),
                    (this["duration"] = void 0x0),
                    (this["playbackRate"] = 0x1),
                    (this["isPlaying"] = !0x1),
                    (this["hasPlaybackControl"] = !0x0),
                    (this["sourceType"] = "empty"),
                    (this["_startedAt"] = 0x0),
                    (this["_progress"] = 0x0),
                    (this["filters"] = []);
            }
            (bS["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                constructor: bS,
                getInput: function () {
                    return this["gain"];
                },
                removeFilter: function () {
                    return (
                        null !== this["filter"] && (this["gain"]["disconnect"](this["filter"]), this["filter"]["disconnect"](this["context"]["destination"]), this["gain"]["connect"](this["context"]["destination"]), (this["filter"] = null)),
                        this
                    );
                },
                getFilter: function () {
                    return this["filter"];
                },
                setFilter: function (mN) {
                    return (
                        null !== this["filter"] ? (this["gain"]["disconnect"](this["filter"]), this["filter"]["disconnect"](this["context"]["destination"])) : this["gain"]["disconnect"](this["context"]["destination"]),
                        (this["filter"] = mN),
                        this["gain"]["connect"](this["filter"]),
                        this["filter"]["connect"](this["context"]["destination"]),
                        this
                    );
                },
                getMasterVolume: function () {
                    return this["gain"]["gain"]["value"];
                },
                setMasterVolume: function (mN) {
                    return this["gain"]["gain"]["setTargetAtTime"](mN, this["context"]["currentTime"], 0.01), this;
                },
                updateMatrixWorld: function (mN) {
                    Eg["prototype"]["updateMatrixWorld"]["call"](this, mN);
                    var mX = this["context"]["listener"],
                        mf = this["up"];
                    if (((this["timeDelta"] = this["_clock"]["getDelta"]()), this["matrixWorld"]["decompose"](bw, bO, bj), bh["set"](0x0, 0x0, -0x1)["applyQuaternion"](bO), mX["positionX"])) {
                        var mP = this["context"]["currentTime"] + this["timeDelta"];
                        mX["positionX"]["linearRampToValueAtTime"](bw["x"], mP),
                            mX["positionY"]["linearRampToValueAtTime"](bw["y"], mP),
                            mX["positionZ"]["linearRampToValueAtTime"](bw["z"], mP),
                            mX["forwardX"]["linearRampToValueAtTime"](bh["x"], mP),
                            mX["forwardY"]["linearRampToValueAtTime"](bh["y"], mP),
                            mX["forwardZ"]["linearRampToValueAtTime"](bh["z"], mP),
                            mX["upX"]["linearRampToValueAtTime"](mf["x"], mP),
                            mX["upY"]["linearRampToValueAtTime"](mf["y"], mP),
                            mX["upZ"]["linearRampToValueAtTime"](mf["z"], mP);
                    } else mX["setPosition"](bw["x"], bw["y"], bw["z"]), mX["setOrientation"](bh["x"], bh["y"], bh["z"], mf["x"], mf["y"], mf["z"]);
                },
            })),
                (bg["prototype"] = Object["assign"](Object["create"](Eg["prototype"]), {
                    constructor: bg,
                    getOutput: function () {
                        return this["gain"];
                    },
                    setNodeSource: function (mN) {
                        return (this["hasPlaybackControl"] = !0x1), (this["sourceType"] = "audioNode"), (this["source"] = mN), this["connect"](), this;
                    },
                    setMediaElementSource: function (mN) {
                        return (this["hasPlaybackControl"] = !0x1), (this["sourceType"] = "mediaNode"), (this["source"] = this["context"]["createMediaElementSource"](mN)), this["connect"](), this;
                    },
                    setMediaStreamSource: function (mN) {
                        return (this["hasPlaybackControl"] = !0x1), (this["sourceType"] = "mediaStreamNode"), (this["source"] = this["context"]["createMediaStreamSource"](mN)), this["connect"](), this;
                    },
                    setBuffer: function (mN) {
                        return (this["buffer"] = mN), (this["sourceType"] = "buffer"), this["autoplay"] && this["play"](), this;
                    },
                    play: function (mN) {
                        if ((void 0x0 === mN && (mN = 0x0), !0x0 !== this["isPlaying"])) {
                            if (!0x1 !== this["hasPlaybackControl"]) {
                                this["_startedAt"] = this["context"]["currentTime"] + mN;
                                var mX = this["context"]["createBufferSource"]();
                                return (
                                    (mX["buffer"] = this["buffer"]),
                                    (mX["loop"] = this["loop"]),
                                    (mX["loopStart"] = this["loopStart"]),
                                    (mX["loopEnd"] = this["loopEnd"]),
                                    (mX["onended"] = this["onEnded"]["bind"](this)),
                                    mX["start"](this["_startedAt"], this["_progress"] + this["offset"], this["duration"]),
                                    (this["isPlaying"] = !0x0),
                                    (this["source"] = mX),
                                    this["setDetune"](this["detune"]),
                                    this["setPlaybackRate"](this["playbackRate"]),
                                    this["connect"]()
                                );
                            }
                            console["warn"]("THREE.Audio:\x20this\x20Audio\x20has\x20no\x20playback\x20control.");
                        } else console["warn"]("THREE.Audio:\x20Audio\x20is\x20already\x20playing.");
                    },
                    pause: function () {
                        if (!0x1 !== this["hasPlaybackControl"])
                            return (
                                !0x0 === this["isPlaying"] &&
                                    ((this["_progress"] += Math["max"](this["context"]["currentTime"] - this["_startedAt"], 0x0) * this["playbackRate"]),
                                    !0x0 === this["loop"] && (this["_progress"] = this["_progress"] % (this["duration"] || this["buffer"]["duration"])),
                                    this["source"]["stop"](),
                                    (this["source"]["onended"] = null),
                                    (this["isPlaying"] = !0x1)),
                                this
                            );
                        console["warn"]("THREE.Audio:\x20this\x20Audio\x20has\x20no\x20playback\x20control.");
                    },
                    stop: function () {
                        if (!0x1 !== this["hasPlaybackControl"]) return (this["_progress"] = 0x0), this["source"]["stop"](), (this["source"]["onended"] = null), (this["isPlaying"] = !0x1), this;
                        console["warn"]("THREE.Audio:\x20this\x20Audio\x20has\x20no\x20playback\x20control.");
                    },
                    connect: function () {
                        if (this["filters"]["length"] > 0x0) {
                            this["source"]["connect"](this["filters"][0x0]);
                            for (var mN = 0x1, mX = this["filters"]["length"]; mN < mX; mN++) this["filters"][mN - 0x1]["connect"](this["filters"][mN]);
                            this["filters"][this["filters"]["length"] - 0x1]["connect"](this["getOutput"]());
                        } else this["source"]["connect"](this["getOutput"]());
                        return this;
                    },
                    disconnect: function () {
                        if (this["filters"]["length"] > 0x0) {
                            this["source"]["disconnect"](this["filters"][0x0]);
                            for (var mN = 0x1, mX = this["filters"]["length"]; mN < mX; mN++) this["filters"][mN - 0x1]["disconnect"](this["filters"][mN]);
                            this["filters"][this["filters"]["length"] - 0x1]["disconnect"](this["getOutput"]());
                        } else this["source"]["disconnect"](this["getOutput"]());
                        return this;
                    },
                    getFilters: function () {
                        return this["filters"];
                    },
                    setFilters: function (mN) {
                        return mN || (mN = []), !0x0 === this["isPlaying"] ? (this["disconnect"](), (this["filters"] = mN), this["connect"]()) : (this["filters"] = mN), this;
                    },
                    setDetune: function (mN) {
                        if (((this["detune"] = mN), void 0x0 !== this["source"]["detune"])) return !0x0 === this["isPlaying"] && this["source"]["detune"]["setTargetAtTime"](this["detune"], this["context"]["currentTime"], 0.01), this;
                    },
                    getDetune: function () {
                        return this["detune"];
                    },
                    getFilter: function () {
                        return this["getFilters"]()[0x0];
                    },
                    setFilter: function (mN) {
                        return this["setFilters"](mN ? [mN] : []);
                    },
                    setPlaybackRate: function (mN) {
                        if (!0x1 !== this["hasPlaybackControl"])
                            return (this["playbackRate"] = mN), !0x0 === this["isPlaying"] && this["source"]["playbackRate"]["setTargetAtTime"](this["playbackRate"], this["context"]["currentTime"], 0.01), this;
                        console["warn"]("THREE.Audio:\x20this\x20Audio\x20has\x20no\x20playback\x20control.");
                    },
                    getPlaybackRate: function () {
                        return this["playbackRate"];
                    },
                    onEnded: function () {
                        this["isPlaying"] = !0x1;
                    },
                    getLoop: function () {
                        return !0x1 === this["hasPlaybackControl"] ? (console["warn"]("THREE.Audio:\x20this\x20Audio\x20has\x20no\x20playback\x20control."), !0x1) : this["loop"];
                    },
                    setLoop: function (mN) {
                        if (!0x1 !== this["hasPlaybackControl"]) return (this["loop"] = mN), !0x0 === this["isPlaying"] && (this["source"]["loop"] = this["loop"]), this;
                        console["warn"]("THREE.Audio:\x20this\x20Audio\x20has\x20no\x20playback\x20control.");
                    },
                    setLoopStart: function (mN) {
                        return (this["loopStart"] = mN), this;
                    },
                    setLoopEnd: function (mN) {
                        return (this["loopEnd"] = mN), this;
                    },
                    getVolume: function () {
                        return this["gain"]["gain"]["value"];
                    },
                    setVolume: function (mN) {
                        return this["gain"]["gain"]["setTargetAtTime"](mN, this["context"]["currentTime"], 0.01), this;
                    },
                }));
            var bW = new Ed(),
                bH = new ER(),
                bx = new Ed(),
                bK = new Ed();
            function bV(mN) {
                bg["call"](this, mN), (this["panner"] = this["context"]["createPanner"]()), (this["panner"]["panningModel"] = "HRTF"), this["panner"]["connect"](this["gain"]);
            }
            function bJ(mN, mX) {
                (this["analyser"] = mN["context"]["createAnalyser"]()),
                    (this["analyser"]["fftSize"] = void 0x0 !== mX ? mX : 0x800),
                    (this["data"] = new Uint8Array(this["analyser"]["frequencyBinCount"])),
                    mN["getOutput"]()["connect"](this["analyser"]);
            }
            function bG(mN, mX, mf) {
                var mP, mI, mA;
                switch (((this["binding"] = mN), (this["valueSize"] = mf), mX)) {
                    case "quaternion":
                        (mP = this["_slerp"]), (mI = this["_slerpAdditive"]), (mA = this["_setAdditiveIdentityQuaternion"]), (this["buffer"] = new Float64Array(0x6 * mf)), (this["_workIndex"] = 0x5);
                        break;
                    case "string":
                    case "bool":
                        (mP = this["_select"]), (mI = this["_select"]), (mA = this["_setAdditiveIdentityOther"]), (this["buffer"] = new Array(0x5 * mf));
                        break;
                    default:
                        (mP = this["_lerp"]), (mI = this["_lerpAdditive"]), (mA = this["_setAdditiveIdentityNumeric"]), (this["buffer"] = new Float64Array(0x5 * mf));
                }
                (this["_mixBufferRegion"] = mP),
                    (this["_mixBufferRegionAdditive"] = mI),
                    (this["_setIdentity"] = mA),
                    (this["_origIndex"] = 0x3),
                    (this["_addIndex"] = 0x4),
                    (this["cumulativeWeight"] = 0x0),
                    (this["cumulativeWeightAdditive"] = 0x0),
                    (this["useCount"] = 0x0),
                    (this["referenceCount"] = 0x0);
            }
            (bV["prototype"] = Object["assign"](Object["create"](bg["prototype"]), {
                constructor: bV,
                getOutput: function () {
                    return this["panner"];
                },
                getRefDistance: function () {
                    return this["panner"]["refDistance"];
                },
                setRefDistance: function (mN) {
                    return (this["panner"]["refDistance"] = mN), this;
                },
                getRolloffFactor: function () {
                    return this["panner"]["rolloffFactor"];
                },
                setRolloffFactor: function (mN) {
                    return (this["panner"]["rolloffFactor"] = mN), this;
                },
                getDistanceModel: function () {
                    return this["panner"]["distanceModel"];
                },
                setDistanceModel: function (mN) {
                    return (this["panner"]["distanceModel"] = mN), this;
                },
                getMaxDistance: function () {
                    return this["panner"]["maxDistance"];
                },
                setMaxDistance: function (mN) {
                    return (this["panner"]["maxDistance"] = mN), this;
                },
                setDirectionalCone: function (mN, mX, mf) {
                    return (this["panner"]["coneInnerAngle"] = mN), (this["panner"]["coneOuterAngle"] = mX), (this["panner"]["coneOuterGain"] = mf), this;
                },
                updateMatrixWorld: function (mN) {
                    if ((Eg["prototype"]["updateMatrixWorld"]["call"](this, mN), !0x0 !== this["hasPlaybackControl"] || !0x1 !== this["isPlaying"])) {
                        this["matrixWorld"]["decompose"](bW, bH, bx), bK["set"](0x0, 0x0, 0x1)["applyQuaternion"](bH);
                        var mX = this["panner"];
                        if (mX["positionX"]) {
                            var mf = this["context"]["currentTime"] + this["listener"]["timeDelta"];
                            mX["positionX"]["linearRampToValueAtTime"](bW["x"], mf),
                                mX["positionY"]["linearRampToValueAtTime"](bW["y"], mf),
                                mX["positionZ"]["linearRampToValueAtTime"](bW["z"], mf),
                                mX["orientationX"]["linearRampToValueAtTime"](bK["x"], mf),
                                mX["orientationY"]["linearRampToValueAtTime"](bK["y"], mf),
                                mX["orientationZ"]["linearRampToValueAtTime"](bK["z"], mf);
                        } else mX["setPosition"](bW["x"], bW["y"], bW["z"]), mX["setOrientation"](bK["x"], bK["y"], bK["z"]);
                    }
                },
            })),
                Object["assign"](bJ["prototype"], {
                    getFrequencyData: function () {
                        return this["analyser"]["getByteFrequencyData"](this["data"]), this["data"];
                    },
                    getAverageFrequency: function () {
                        for (var mN = 0x0, mX = this["getFrequencyData"](), mf = 0x0; mf < mX["length"]; mf++) mN += mX[mf];
                        return mN / mX["length"];
                    },
                }),
                Object["assign"](bG["prototype"], {
                    accumulate: function (mN, mX) {
                        var mf = this["buffer"],
                            mP = this["valueSize"],
                            mI = mN * mP + mP,
                            mA = this["cumulativeWeight"];
                        if (0x0 === mA) {
                            for (var mM = 0x0; mM !== mP; ++mM) mf[mI + mM] = mf[mM];
                            mA = mX;
                        } else {
                            var mp = mX / (mA += mX);
                            this["_mixBufferRegion"](mf, mI, 0x0, mp, mP);
                        }
                        this["cumulativeWeight"] = mA;
                    },
                    accumulateAdditive: function (mN) {
                        var mX = this["buffer"],
                            mf = this["valueSize"],
                            mP = mf * this["_addIndex"];
                        0x0 === this["cumulativeWeightAdditive"] && this["_setIdentity"](), this["_mixBufferRegionAdditive"](mX, mP, 0x0, mN, mf), (this["cumulativeWeightAdditive"] += mN);
                    },
                    apply: function (mN) {
                        var mX = this["valueSize"],
                            mf = this["buffer"],
                            mP = mN * mX + mX,
                            mI = this["cumulativeWeight"],
                            mA = this["cumulativeWeightAdditive"],
                            mM = this["binding"];
                        if (((this["cumulativeWeight"] = 0x0), (this["cumulativeWeightAdditive"] = 0x0), mI < 0x1)) {
                            var mp = mX * this["_origIndex"];
                            this["_mixBufferRegion"](mf, mP, mp, 0x1 - mI, mX);
                        }
                        mA > 0x0 && this["_mixBufferRegionAdditive"](mf, mP, this["_addIndex"] * mX, 0x1, mX);
                        for (var mk = mX, mU = mX + mX; mk !== mU; ++mk)
                            if (mf[mk] !== mf[mk + mX]) {
                                mM["setValue"](mf, mP);
                                break;
                            }
                    },
                    saveOriginalState: function () {
                        var mN = this["binding"],
                            mX = this["buffer"],
                            mf = this["valueSize"],
                            mP = mf * this["_origIndex"];
                        mN["getValue"](mX, mP);
                        for (var mI = mf, mA = mP; mI !== mA; ++mI) mX[mI] = mX[mP + (mI % mf)];
                        this["_setIdentity"](), (this["cumulativeWeight"] = 0x0), (this["cumulativeWeightAdditive"] = 0x0);
                    },
                    restoreOriginalState: function () {
                        var mN = 0x3 * this["valueSize"];
                        this["binding"]["setValue"](this["buffer"], mN);
                    },
                    _setAdditiveIdentityNumeric: function () {
                        for (var mN = this["_addIndex"] * this["valueSize"], mX = mN + this["valueSize"], mf = mN; mf < mX; mf++) this["buffer"][mf] = 0x0;
                    },
                    _setAdditiveIdentityQuaternion: function () {
                        this["_setAdditiveIdentityNumeric"](), (this["buffer"][0x4 * this["_addIndex"] + 0x3] = 0x1);
                    },
                    _setAdditiveIdentityOther: function () {
                        for (var mN = this["_origIndex"] * this["valueSize"], mX = this["_addIndex"] * this["valueSize"], mf = 0x0; mf < this["valueSize"]; mf++) this["buffer"][mX + mf] = this["buffer"][mN + mf];
                    },
                    _select: function (mN, mX, mf, mP, mI) {
                        if (mP >= 0.5) {
                            for (var mA = 0x0; mA !== mI; ++mA) mN[mX + mA] = mN[mf + mA];
                        }
                    },
                    _slerp: function (mN, mX, mf, mP) {
                        ER["slerpFlat"](mN, mX, mN, mX, mN, mf, mP);
                    },
                    _slerpAdditive: function (mN, mX, mf, mP, mI) {
                        var mA = this["_workIndex"] * mI;
                        ER["multiplyQuaternionsFlat"](mN, mA, mN, mX, mN, mf), ER["slerpFlat"](mN, mX, mN, mX, mN, mA, mP);
                    },
                    _lerp: function (mN, mX, mf, mP, mI) {
                        for (var mA = 0x1 - mP, mM = 0x0; mM !== mI; ++mM) {
                            var mp = mX + mM;
                            mN[mp] = mN[mp] * mA + mN[mf + mM] * mP;
                        }
                    },
                    _lerpAdditive: function (mN, mX, mf, mP, mI) {
                        for (var mA = 0x0; mA !== mI; ++mA) {
                            var mM = mX + mA;
                            mN[mM] = mN[mM] + mN[mf + mA] * mP;
                        }
                    },
                });
            var bL = "\x5c[\x5c]\x5c.:\x5c/",
                bQ = new RegExp("[\x5c[\x5c]\x5c.:\x5c/]", "g"),
                bz = "[^\x5c[\x5c]\x5c.:\x5c/]",
                Z0 = "[^" + bL["replace"]("\x5c.", "") + "]",
                Z1 = /((?:WC+[\/:])*)/["source"]["replace"]("WC", bz),
                Z2 = /(WCOD+)?/["source"]["replace"]("WCOD", Z0),
                Z3 = /(?:\.(WC+)(?:\[(.+)\])?)?/["source"]["replace"]("WC", bz),
                Z4 = /\.(WC+)(?:\[(.+)\])?/["source"]["replace"]("WC", bz),
                Z5 = new RegExp("^" + Z1 + Z2 + Z3 + Z4 + "$"),
                Z6 = ["material", "materials", "bones"];
            function Z7(mN, mX, mf) {
                var mP = mf || Z8["parseTrackName"](mX);
                (this["_targetGroup"] = mN), (this["_bindings"] = mN["subscribe_"](mX, mP));
            }
            function Z8(mN, mX, mf) {
                (this["path"] = mX), (this["parsedPath"] = mf || Z8["parseTrackName"](mX)), (this["node"] = Z8["findNode"](mN, this["parsedPath"]["nodeName"]) || mN), (this["rootNode"] = mN);
            }
            function Z9(mN, mX, mf, mP) {
                (this["_mixer"] = mN), (this["_clip"] = mX), (this["_localRoot"] = mf || null), (this["blendMode"] = mP || mX["blendMode"]);
                for (var mI = mX["tracks"], mA = mI["length"], mM = new Array(mA), mp = { endingStart: rw, endingEnd: rw }, mk = 0x0; mk !== mA; ++mk) {
                    var mU = mI[mk]["createInterpolant"](null);
                    (mM[mk] = mU), (mU["settings"] = mp);
                }
                (this["_interpolantSettings"] = mp),
                    (this["_interpolants"] = mM),
                    (this["_propertyBindings"] = new Array(mA)),
                    (this["_cacheIndex"] = null),
                    (this["_byClipCacheIndex"] = null),
                    (this["_timeScaleInterpolant"] = null),
                    (this["_weightInterpolant"] = null),
                    (this["loop"] = rp),
                    (this["_loopCount"] = -0x1),
                    (this["_startTime"] = null),
                    (this["time"] = 0x0),
                    (this["timeScale"] = 0x1),
                    (this["_effectiveTimeScale"] = 0x1),
                    (this["weight"] = 0x1),
                    (this["_effectiveWeight"] = 0x1),
                    (this["repetitions"] = 0x1 / 0x0),
                    (this["paused"] = !0x1),
                    (this["enabled"] = !0x0),
                    (this["clampWhenFinished"] = !0x1),
                    (this["zeroSlopeAtStart"] = !0x0),
                    (this["zeroSlopeAtEnd"] = !0x0);
            }
            function ZE(mN) {
                (this["_root"] = mN), this["_initMemoryManager"](), (this["_accuIndex"] = 0x0), (this["time"] = 0x0), (this["timeScale"] = 0x1);
            }
            function ZR(mN) {
                "string" == typeof mN && (console["warn"]("THREE.Uniform:\x20Type\x20parameter\x20is\x20no\x20longer\x20needed."), (mN = arguments[0x1])), (this["value"] = mN);
            }
            function ZT(mN, mX, mf) {
                YC["call"](this, mN, mX), (this["meshPerAttribute"] = mf || 0x1);
            }
            function ZC(mN, mX, mf, mP) {
                (this["ray"] = new RY(mN, mX)),
                    (this["near"] = mf || 0x0),
                    (this["far"] = mP || 0x1 / 0x0),
                    (this["camera"] = null),
                    (this["layers"] = new Ef()),
                    (this["params"] = { Mesh: {}, Line: { threshold: 0x1 }, LOD: {}, Points: { threshold: 0x1 }, Sprite: {} }),
                    Object["defineProperties"](this["params"], {
                        PointCloud: {
                            get: function () {
                                return console["warn"]("THREE.Raycaster:\x20params.PointCloud\x20has\x20been\x20renamed\x20to\x20params.Points."), this["Points"];
                            },
                        },
                    });
            }
            function Zd(mN, mX) {
                return mN["distance"] - mX["distance"];
            }
            function ZY(mN, mX, mf, mP) {
                if ((mN["layers"]["test"](mX["layers"]) && mN["raycast"](mX, mf), !0x0 === mP)) {
                    for (var mI = mN["children"], mA = 0x0, mM = mI["length"]; mA < mM; mA++) ZY(mI[mA], mX, mf, !0x0);
                }
            }
            function ZB(mN, mX, mf) {
                return (this["radius"] = void 0x0 !== mN ? mN : 0x1), (this["phi"] = void 0x0 !== mX ? mX : 0x0), (this["theta"] = void 0x0 !== mf ? mf : 0x0), this;
            }
            Object["assign"](Z7["prototype"], {
                getValue: function (mN, mX) {
                    this["bind"]();
                    var mf = this["_targetGroup"]["nCachedObjects_"],
                        mP = this["_bindings"][mf];
                    void 0x0 !== mP && mP["getValue"](mN, mX);
                },
                setValue: function (mN, mX) {
                    for (var mf = this["_bindings"], mP = this["_targetGroup"]["nCachedObjects_"], mI = mf["length"]; mP !== mI; ++mP) mf[mP]["setValue"](mN, mX);
                },
                bind: function () {
                    for (var mN = this["_bindings"], mX = this["_targetGroup"]["nCachedObjects_"], mf = mN["length"]; mX !== mf; ++mX) mN[mX]["bind"]();
                },
                unbind: function () {
                    for (var mN = this["_bindings"], mX = this["_targetGroup"]["nCachedObjects_"], mf = mN["length"]; mX !== mf; ++mX) mN[mX]["unbind"]();
                },
            }),
                Object["assign"](Z8, {
                    Composite: Z7,
                    create: function (mN, mX, mf) {
                        return mN && mN["isAnimationObjectGroup"] ? new Z8["Composite"](mN, mX, mf) : new Z8(mN, mX, mf);
                    },
                    sanitizeNodeName: function (mN) {
                        return mN["replace"](/\s/g, "_")["replace"](bQ, "");
                    },
                    parseTrackName: function (mN) {
                        var mX = Z5["exec"](mN);
                        if (!mX) throw new Error("PropertyBinding:\x20Cannot\x20parse\x20trackName:\x20" + mN);
                        var mf = { nodeName: mX[0x2], objectName: mX[0x3], objectIndex: mX[0x4], propertyName: mX[0x5], propertyIndex: mX[0x6] },
                            mP = mf["nodeName"] && mf["nodeName"]["lastIndexOf"](".");
                        if (void 0x0 !== mP && -0x1 !== mP) {
                            var mI = mf["nodeName"]["substring"](mP + 0x1);
                            -0x1 !== Z6["indexOf"](mI) && ((mf["nodeName"] = mf["nodeName"]["substring"](0x0, mP)), (mf["objectName"] = mI));
                        }
                        if (null === mf["propertyName"] || 0x0 === mf["propertyName"]["length"]) throw new Error("PropertyBinding:\x20can\x20not\x20parse\x20propertyName\x20from\x20trackName:\x20" + mN);
                        return mf;
                    },
                    findNode: function (mN, mX) {
                        if (!mX || "" === mX || "." === mX || -0x1 === mX || mX === mN["name"] || mX === mN["uuid"]) return mN;
                        if (mN["skeleton"]) {
                            var mf = mN["skeleton"]["getBoneByName"](mX);
                            if (void 0x0 !== mf) return mf;
                        }
                        if (mN["children"]) {
                            var mP = function (mA) {
                                    for (var mM = 0x0; mM < mA["length"]; mM++) {
                                        var mp = mA[mM];
                                        if (mp["name"] === mX || mp["uuid"] === mX) return mp;
                                        var mk = mP(mp["children"]);
                                        if (mk) return mk;
                                    }
                                    return null;
                                },
                                mI = mP(mN["children"]);
                            if (mI) return mI;
                        }
                        return null;
                    },
                }),
                Object["assign"](Z8["prototype"], {
                    _getValue_unavailable: function () {},
                    _setValue_unavailable: function () {},
                    BindingType: { Direct: 0x0, EntireArray: 0x1, ArrayElement: 0x2, HasFromToArray: 0x3 },
                    Versioning: { None: 0x0, NeedsUpdate: 0x1, MatrixWorldNeedsUpdate: 0x2 },
                    GetterByBindingType: [
                        function (mN, mX) {
                            mN[mX] = this["node"][this["propertyName"]];
                        },
                        function (mN, mX) {
                            for (var mf = this["resolvedProperty"], mP = 0x0, mI = mf["length"]; mP !== mI; ++mP) mN[mX++] = mf[mP];
                        },
                        function (mN, mX) {
                            mN[mX] = this["resolvedProperty"][this["propertyIndex"]];
                        },
                        function (mN, mX) {
                            this["resolvedProperty"]["toArray"](mN, mX);
                        },
                    ],
                    SetterByBindingTypeAndVersioning: [
                        [
                            function (mN, mX) {
                                this["targetObject"][this["propertyName"]] = mN[mX];
                            },
                            function (mN, mX) {
                                (this["targetObject"][this["propertyName"]] = mN[mX]), (this["targetObject"]["needsUpdate"] = !0x0);
                            },
                            function (mN, mX) {
                                (this["targetObject"][this["propertyName"]] = mN[mX]), (this["targetObject"]["matrixWorldNeedsUpdate"] = !0x0);
                            },
                        ],
                        [
                            function (mN, mX) {
                                for (var mf = this["resolvedProperty"], mP = 0x0, mI = mf["length"]; mP !== mI; ++mP) mf[mP] = mN[mX++];
                            },
                            function (mN, mX) {
                                for (var mf = this["resolvedProperty"], mP = 0x0, mI = mf["length"]; mP !== mI; ++mP) mf[mP] = mN[mX++];
                                this["targetObject"]["needsUpdate"] = !0x0;
                            },
                            function (mN, mX) {
                                for (var mf = this["resolvedProperty"], mP = 0x0, mI = mf["length"]; mP !== mI; ++mP) mf[mP] = mN[mX++];
                                this["targetObject"]["matrixWorldNeedsUpdate"] = !0x0;
                            },
                        ],
                        [
                            function (mN, mX) {
                                this["resolvedProperty"][this["propertyIndex"]] = mN[mX];
                            },
                            function (mN, mX) {
                                (this["resolvedProperty"][this["propertyIndex"]] = mN[mX]), (this["targetObject"]["needsUpdate"] = !0x0);
                            },
                            function (mN, mX) {
                                (this["resolvedProperty"][this["propertyIndex"]] = mN[mX]), (this["targetObject"]["matrixWorldNeedsUpdate"] = !0x0);
                            },
                        ],
                        [
                            function (mN, mX) {
                                this["resolvedProperty"]["fromArray"](mN, mX);
                            },
                            function (mN, mX) {
                                this["resolvedProperty"]["fromArray"](mN, mX), (this["targetObject"]["needsUpdate"] = !0x0);
                            },
                            function (mN, mX) {
                                this["resolvedProperty"]["fromArray"](mN, mX), (this["targetObject"]["matrixWorldNeedsUpdate"] = !0x0);
                            },
                        ],
                    ],
                    getValue: function (mN, mX) {
                        this["bind"](), this["getValue"](mN, mX);
                    },
                    setValue: function (mN, mX) {
                        this["bind"](), this["setValue"](mN, mX);
                    },
                    bind: function () {
                        var mN = this["node"],
                            mX = this["parsedPath"],
                            mf = mX["objectName"],
                            mP = mX["propertyName"],
                            mI = mX["propertyIndex"];
                        if (
                            (mN || ((mN = Z8["findNode"](this["rootNode"], mX["nodeName"]) || this["rootNode"]), (this["node"] = mN)),
                            (this["getValue"] = this["_getValue_unavailable"]),
                            (this["setValue"] = this["_setValue_unavailable"]),
                            mN)
                        ) {
                            if (mf) {
                                var mA = mX["objectIndex"];
                                switch (mf) {
                                    case "materials":
                                        if (!mN["material"]) return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20material\x20as\x20node\x20does\x20not\x20have\x20a\x20material.", this);
                                        if (!mN["material"]["materials"])
                                            return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20material.materials\x20as\x20node.material\x20does\x20not\x20have\x20a\x20materials\x20array.", this);
                                        mN = mN["material"]["materials"];
                                        break;
                                    case "bones":
                                        if (!mN["skeleton"]) return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20bones\x20as\x20node\x20does\x20not\x20have\x20a\x20skeleton.", this);
                                        mN = mN["skeleton"]["bones"];
                                        for (var mM = 0x0; mM < mN["length"]; mM++)
                                            if (mN[mM]["name"] === mA) {
                                                mA = mM;
                                                break;
                                            }
                                        break;
                                    default:
                                        if (void 0x0 === mN[mf]) return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20objectName\x20of\x20node\x20undefined.", this);
                                        mN = mN[mf];
                                }
                                if (void 0x0 !== mA) {
                                    if (void 0x0 === mN[mA]) return void console["error"]("THREE.PropertyBinding:\x20Trying\x20to\x20bind\x20to\x20objectIndex\x20of\x20objectName,\x20but\x20is\x20undefined.", this, mN);
                                    mN = mN[mA];
                                }
                            }
                            var mp = mN[mP];
                            if (void 0x0 !== mp) {
                                var mk = this["Versioning"]["None"];
                                (this["targetObject"] = mN), void 0x0 !== mN["needsUpdate"] ? (mk = this["Versioning"]["NeedsUpdate"]) : void 0x0 !== mN["matrixWorldNeedsUpdate"] && (mk = this["Versioning"]["MatrixWorldNeedsUpdate"]);
                                var mU = this["BindingType"]["Direct"];
                                if (void 0x0 !== mI) {
                                    if ("morphTargetInfluences" === mP) {
                                        if (!mN["geometry"]) return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20morphTargetInfluences\x20because\x20node\x20does\x20not\x20have\x20a\x20geometry.", this);
                                        if (!mN["geometry"]["isBufferGeometry"])
                                            return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20morphTargetInfluences\x20on\x20THREE.Geometry.\x20Use\x20THREE.BufferGeometry\x20instead.", this);
                                        if (!mN["geometry"]["morphAttributes"])
                                            return void console["error"]("THREE.PropertyBinding:\x20Can\x20not\x20bind\x20to\x20morphTargetInfluences\x20because\x20node\x20does\x20not\x20have\x20a\x20geometry.morphAttributes.", this);
                                        void 0x0 !== mN["morphTargetDictionary"][mI] && (mI = mN["morphTargetDictionary"][mI]);
                                    }
                                    (mU = this["BindingType"]["ArrayElement"]), (this["resolvedProperty"] = mp), (this["propertyIndex"] = mI);
                                } else
                                    void 0x0 !== mp["fromArray"] && void 0x0 !== mp["toArray"]
                                        ? ((mU = this["BindingType"]["HasFromToArray"]), (this["resolvedProperty"] = mp))
                                        : Array["isArray"](mp)
                                        ? ((mU = this["BindingType"]["EntireArray"]), (this["resolvedProperty"] = mp))
                                        : (this["propertyName"] = mP);
                                (this["getValue"] = this["GetterByBindingType"][mU]), (this["setValue"] = this["SetterByBindingTypeAndVersioning"][mU][mk]);
                            } else {
                                var mq = mX["nodeName"];
                                console["error"]("THREE.PropertyBinding:\x20Trying\x20to\x20update\x20property\x20for\x20track:\x20" + mq + "." + mP + "\x20but\x20it\x20wasn\x27t\x20found.", mN);
                            }
                        } else console["error"]("THREE.PropertyBinding:\x20Trying\x20to\x20update\x20node\x20for\x20track:\x20" + this["path"] + "\x20but\x20it\x20wasn\x27t\x20found.");
                    },
                    unbind: function () {
                        (this["node"] = null), (this["getValue"] = this["_getValue_unbound"]), (this["setValue"] = this["_setValue_unbound"]);
                    },
                }),
                Object["assign"](Z8["prototype"], { _getValue_unbound: Z8["prototype"]["getValue"], _setValue_unbound: Z8["prototype"]["setValue"] }),
                Object["assign"](
                    function () {
                        (this["uuid"] = E2["generateUUID"]()), (this["_objects"] = Array["prototype"]["slice"]["call"](arguments)), (this["nCachedObjects_"] = 0x0);
                        var mN = {};
                        this["_indicesByUUID"] = mN;
                        for (var mX = 0x0, mf = arguments["length"]; mX !== mf; ++mX) mN[arguments[mX]["uuid"]] = mX;
                        (this["_paths"] = []), (this["_parsedPaths"] = []), (this["_bindings"] = []), (this["_bindingsIndicesByPath"] = {});
                        var mP = this;
                        this["stats"] = {
                            objects: {
                                get total() {
                                    return mP["_objects"]["length"];
                                },
                                get inUse() {
                                    return this["total"] - mP["nCachedObjects_"];
                                },
                            },
                            get bindingsPerObject() {
                                return mP["_bindings"]["length"];
                            },
                        };
                    }["prototype"],
                    {
                        isAnimationObjectGroup: !0x0,
                        add: function () {
                            for (
                                var mN = this["_objects"],
                                    mX = mN["length"],
                                    mf = this["nCachedObjects_"],
                                    mP = this["_indicesByUUID"],
                                    mI = this["_paths"],
                                    mA = this["_parsedPaths"],
                                    mM = this["_bindings"],
                                    mp = mM["length"],
                                    mk = void 0x0,
                                    mU = 0x0,
                                    mq = arguments["length"];
                                mU !== mq;
                                ++mU
                            ) {
                                var mw = arguments[mU],
                                    mO = mw["uuid"],
                                    mj = mP[mO];
                                if (void 0x0 === mj) {
                                    (mj = mX++), (mP[mO] = mj), mN["push"](mw);
                                    for (var mh = 0x0, mS = mp; mh !== mS; ++mh) mM[mh]["push"](new Z8(mw, mI[mh], mA[mh]));
                                } else {
                                    if (mj < mf) {
                                        mk = mN[mj];
                                        var mg = --mf,
                                            mW = mN[mg];
                                        (mP[mW["uuid"]] = mj), (mN[mj] = mW), (mP[mO] = mg), (mN[mg] = mw);
                                        for (mh = 0x0, mS = mp; mh !== mS; ++mh) {
                                            var mH = mM[mh],
                                                mx = mH[mg],
                                                mK = mH[mj];
                                            (mH[mj] = mx), void 0x0 === mK && (mK = new Z8(mw, mI[mh], mA[mh])), (mH[mg] = mK);
                                        }
                                    } else
                                        mN[mj] !== mk &&
                                            console["error"](
                                                "THREE.AnimationObjectGroup:\x20Different\x20objects\x20with\x20the\x20same\x20UUID\x20detected.\x20Clean\x20the\x20caches\x20or\x20recreate\x20your\x20infrastructure\x20when\x20reloading\x20scenes."
                                            );
                                }
                            }
                            this["nCachedObjects_"] = mf;
                        },
                        remove: function () {
                            for (var mN = this["_objects"], mX = this["nCachedObjects_"], mf = this["_indicesByUUID"], mP = this["_bindings"], mI = mP["length"], mA = 0x0, mM = arguments["length"]; mA !== mM; ++mA) {
                                var mp = arguments[mA],
                                    mk = mp["uuid"],
                                    mU = mf[mk];
                                if (void 0x0 !== mU && mU >= mX) {
                                    var mq = mX++,
                                        mw = mN[mq];
                                    (mf[mw["uuid"]] = mU), (mN[mU] = mw), (mf[mk] = mq), (mN[mq] = mp);
                                    for (var mO = 0x0, mj = mI; mO !== mj; ++mO) {
                                        var mh = mP[mO],
                                            mS = mh[mq],
                                            mg = mh[mU];
                                        (mh[mU] = mS), (mh[mq] = mg);
                                    }
                                }
                            }
                            this["nCachedObjects_"] = mX;
                        },
                        uncache: function () {
                            for (var mN = this["_objects"], mX = mN["length"], mf = this["nCachedObjects_"], mP = this["_indicesByUUID"], mI = this["_bindings"], mA = mI["length"], mM = 0x0, mp = arguments["length"]; mM !== mp; ++mM) {
                                var mk = arguments[mM],
                                    mU = mk["uuid"],
                                    mq = mP[mU];
                                if (void 0x0 !== mq) {
                                    if ((delete mP[mU], mq < mf)) {
                                        var mw = --mf,
                                            mO = mN[mw],
                                            mj = mN[(mH = --mX)];
                                        (mP[mO["uuid"]] = mq), (mN[mq] = mO), (mP[mj["uuid"]] = mw), (mN[mw] = mj), mN["pop"]();
                                        for (var mh = 0x0, mS = mA; mh !== mS; ++mh) {
                                            var mg = (mx = mI[mh])[mw],
                                                mW = mx[mH];
                                            (mx[mq] = mg), (mx[mw] = mW), mx["pop"]();
                                        }
                                    } else {
                                        var mH;
                                        (mP[(mj = mN[(mH = --mX)])["uuid"]] = mq), (mN[mq] = mj), mN["pop"]();
                                        for (mh = 0x0, mS = mA; mh !== mS; ++mh) {
                                            var mx;
                                            ((mx = mI[mh])[mq] = mx[mH]), mx["pop"]();
                                        }
                                    }
                                }
                            }
                            this["nCachedObjects_"] = mf;
                        },
                        subscribe_: function (mN, mX) {
                            var mf = this["_bindingsIndicesByPath"],
                                mP = mf[mN],
                                mI = this["_bindings"];
                            if (void 0x0 !== mP) return mI[mP];
                            var mA = this["_paths"],
                                mM = this["_parsedPaths"],
                                mp = this["_objects"],
                                mk = mp["length"],
                                mU = this["nCachedObjects_"],
                                mq = new Array(mk);
                            (mP = mI["length"]), (mf[mN] = mP), mA["push"](mN), mM["push"](mX), mI["push"](mq);
                            for (var mw = mU, mO = mp["length"]; mw !== mO; ++mw) {
                                var mj = mp[mw];
                                mq[mw] = new Z8(mj, mN, mX);
                            }
                            return mq;
                        },
                        unsubscribe_: function (mN) {
                            var mX = this["_bindingsIndicesByPath"],
                                mf = mX[mN];
                            if (void 0x0 !== mf) {
                                var mP = this["_paths"],
                                    mI = this["_parsedPaths"],
                                    mA = this["_bindings"],
                                    mM = mA["length"] - 0x1,
                                    mp = mA[mM];
                                (mX[mN[mM]] = mf), (mA[mf] = mp), mA["pop"](), (mI[mf] = mI[mM]), mI["pop"](), (mP[mf] = mP[mM]), mP["pop"]();
                            }
                        },
                    }
                ),
                Object["assign"](Z9["prototype"], {
                    play: function () {
                        return this["_mixer"]["_activateAction"](this), this;
                    },
                    stop: function () {
                        return this["_mixer"]["_deactivateAction"](this), this["reset"]();
                    },
                    reset: function () {
                        return (this["paused"] = !0x1), (this["enabled"] = !0x0), (this["time"] = 0x0), (this["_loopCount"] = -0x1), (this["_startTime"] = null), this["stopFading"]()["stopWarping"]();
                    },
                    isRunning: function () {
                        return this["enabled"] && !this["paused"] && 0x0 !== this["timeScale"] && null === this["_startTime"] && this["_mixer"]["_isActiveAction"](this);
                    },
                    isScheduled: function () {
                        return this["_mixer"]["_isActiveAction"](this);
                    },
                    startAt: function (mN) {
                        return (this["_startTime"] = mN), this;
                    },
                    setLoop: function (mN, mX) {
                        return (this["loop"] = mN), (this["repetitions"] = mX), this;
                    },
                    setEffectiveWeight: function (mN) {
                        return (this["weight"] = mN), (this["_effectiveWeight"] = this["enabled"] ? mN : 0x0), this["stopFading"]();
                    },
                    getEffectiveWeight: function () {
                        return this["_effectiveWeight"];
                    },
                    fadeIn: function (mN) {
                        return this["_scheduleFading"](mN, 0x0, 0x1);
                    },
                    fadeOut: function (mN) {
                        return this["_scheduleFading"](mN, 0x1, 0x0);
                    },
                    crossFadeFrom: function (mN, mX, mf) {
                        if ((mN["fadeOut"](mX), this["fadeIn"](mX), mf)) {
                            var mP = this["_clip"]["duration"],
                                mI = mN["_clip"]["duration"],
                                mA = mI / mP,
                                mM = mP / mI;
                            mN["warp"](0x1, mA, mX), this["warp"](mM, 0x1, mX);
                        }
                        return this;
                    },
                    crossFadeTo: function (mN, mX, mf) {
                        return mN["crossFadeFrom"](this, mX, mf);
                    },
                    stopFading: function () {
                        var mN = this["_weightInterpolant"];
                        return null !== mN && ((this["_weightInterpolant"] = null), this["_mixer"]["_takeBackControlInterpolant"](mN)), this;
                    },
                    setEffectiveTimeScale: function (mN) {
                        return (this["timeScale"] = mN), (this["_effectiveTimeScale"] = this["paused"] ? 0x0 : mN), this["stopWarping"]();
                    },
                    getEffectiveTimeScale: function () {
                        return this["_effectiveTimeScale"];
                    },
                    setDuration: function (mN) {
                        return (this["timeScale"] = this["_clip"]["duration"] / mN), this["stopWarping"]();
                    },
                    syncWith: function (mN) {
                        return (this["time"] = mN["time"]), (this["timeScale"] = mN["timeScale"]), this["stopWarping"]();
                    },
                    halt: function (mN) {
                        return this["warp"](this["_effectiveTimeScale"], 0x0, mN);
                    },
                    warp: function (mN, mX, mf) {
                        var mP = this["_mixer"],
                            mI = mP["time"],
                            mA = this["_timeScaleInterpolant"],
                            mM = this["timeScale"];
                        null === mA && ((mA = mP["_lendControlInterpolant"]()), (this["_timeScaleInterpolant"] = mA));
                        var mp = mA["parameterPositions"],
                            mk = mA["sampleValues"];
                        return (mp[0x0] = mI), (mp[0x1] = mI + mf), (mk[0x0] = mN / mM), (mk[0x1] = mX / mM), this;
                    },
                    stopWarping: function () {
                        var mN = this["_timeScaleInterpolant"];
                        return null !== mN && ((this["_timeScaleInterpolant"] = null), this["_mixer"]["_takeBackControlInterpolant"](mN)), this;
                    },
                    getMixer: function () {
                        return this["_mixer"];
                    },
                    getClip: function () {
                        return this["_clip"];
                    },
                    getRoot: function () {
                        return this["_localRoot"] || this["_mixer"]["_root"];
                    },
                    _update: function (mN, mX, mf, mP) {
                        if (this["enabled"]) {
                            var mI = this["_startTime"];
                            if (null !== mI) {
                                var mA = (mN - mI) * mf;
                                if (mA < 0x0 || 0x0 === mf) return;
                                (this["_startTime"] = null), (mX = mf * mA);
                            }
                            mX *= this["_updateTimeScale"](mN);
                            var mM = this["_updateTime"](mX),
                                mp = this["_updateWeight"](mN);
                            if (mp > 0x0) {
                                var mk = this["_interpolants"],
                                    mU = this["_propertyBindings"];
                                if (0x9c5 === this["blendMode"]) {
                                    for (var mq = 0x0, mw = mk["length"]; mq !== mw; ++mq) mk[mq]["evaluate"](mM), mU[mq]["accumulateAdditive"](mp);
                                } else {
                                    for (mq = 0x0, mw = mk["length"]; mq !== mw; ++mq) mk[mq]["evaluate"](mM), mU[mq]["accumulate"](mP, mp);
                                }
                            }
                        } else this["_updateWeight"](mN);
                    },
                    _updateWeight: function (mN) {
                        var mX = 0x0;
                        if (this["enabled"]) {
                            mX = this["weight"];
                            var mf = this["_weightInterpolant"];
                            if (null !== mf) {
                                var mP = mf["evaluate"](mN)[0x0];
                                (mX *= mP), mN > mf["parameterPositions"][0x1] && (this["stopFading"](), 0x0 === mP && (this["enabled"] = !0x1));
                            }
                        }
                        return (this["_effectiveWeight"] = mX), mX;
                    },
                    _updateTimeScale: function (mN) {
                        var mX = 0x0;
                        if (!this["paused"]) {
                            mX = this["timeScale"];
                            var mf = this["_timeScaleInterpolant"];
                            if (null !== mf) (mX *= mf["evaluate"](mN)[0x0]), mN > mf["parameterPositions"][0x1] && (this["stopWarping"](), 0x0 === mX ? (this["paused"] = !0x0) : (this["timeScale"] = mX));
                        }
                        return (this["_effectiveTimeScale"] = mX), mX;
                    },
                    _updateTime: function (mN) {
                        var mX = this["time"] + mN,
                            mf = this["_clip"]["duration"],
                            mP = this["loop"],
                            mI = this["_loopCount"],
                            mA = 0x89a === mP;
                        if (0x0 === mN) return -0x1 === mI ? mX : mA && 0x1 == (0x1 & mI) ? mf - mX : mX;
                        if (mP === rM) {
                            -0x1 === mI && ((this["_loopCount"] = 0x0), this["_setEndings"](!0x0, !0x0, !0x1));
                            mU: {
                                if (mX >= mf) mX = mf;
                                else {
                                    if (!(mX < 0x0)) {
                                        this["time"] = mX;
                                        break mU;
                                    }
                                    mX = 0x0;
                                }
                                this["clampWhenFinished"] ? (this["paused"] = !0x0) : (this["enabled"] = !0x1), (this["time"] = mX), this["_mixer"]["dispatchEvent"]({ type: "finished", action: this, direction: mN < 0x0 ? -0x1 : 0x1 });
                            }
                        } else {
                            if ((-0x1 === mI && (mN >= 0x0 ? ((mI = 0x0), this["_setEndings"](!0x0, 0x0 === this["repetitions"], mA)) : this["_setEndings"](0x0 === this["repetitions"], !0x0, mA)), mX >= mf || mX < 0x0)) {
                                var mM = Math["floor"](mX / mf);
                                (mX -= mf * mM), (mI += Math["abs"](mM));
                                var mp = this["repetitions"] - mI;
                                if (mp <= 0x0)
                                    this["clampWhenFinished"] ? (this["paused"] = !0x0) : (this["enabled"] = !0x1),
                                        (mX = mN > 0x0 ? mf : 0x0),
                                        (this["time"] = mX),
                                        this["_mixer"]["dispatchEvent"]({ type: "finished", action: this, direction: mN > 0x0 ? 0x1 : -0x1 });
                                else {
                                    if (0x1 === mp) {
                                        var mk = mN < 0x0;
                                        this["_setEndings"](mk, !mk, mA);
                                    } else this["_setEndings"](!0x1, !0x1, mA);
                                    (this["_loopCount"] = mI), (this["time"] = mX), this["_mixer"]["dispatchEvent"]({ type: "loop", action: this, loopDelta: mM });
                                }
                            } else this["time"] = mX;
                            if (mA && 0x1 == (0x1 & mI)) return mf - mX;
                        }
                        return mX;
                    },
                    _setEndings: function (mN, mX, mf) {
                        var mP = this["_interpolantSettings"];
                        mf ? ((mP["endingStart"] = rO), (mP["endingEnd"] = rO)) : ((mP["endingStart"] = mN ? (this["zeroSlopeAtStart"] ? rO : rw) : rj), (mP["endingEnd"] = mX ? (this["zeroSlopeAtEnd"] ? rO : rw) : rj));
                    },
                    _scheduleFading: function (mN, mX, mf) {
                        var mP = this["_mixer"],
                            mI = mP["time"],
                            mA = this["_weightInterpolant"];
                        null === mA && ((mA = mP["_lendControlInterpolant"]()), (this["_weightInterpolant"] = mA));
                        var mM = mA["parameterPositions"],
                            mp = mA["sampleValues"];
                        return (mM[0x0] = mI), (mp[0x0] = mX), (mM[0x1] = mI + mN), (mp[0x1] = mf), this;
                    },
                }),
                (ZE["prototype"] = Object["assign"](Object["create"](rQ["prototype"]), {
                    constructor: ZE,
                    _bindAction: function (mN, mX) {
                        var mf = mN["_localRoot"] || this["_root"],
                            mP = mN["_clip"]["tracks"],
                            mI = mP["length"],
                            mA = mN["_propertyBindings"],
                            mM = mN["_interpolants"],
                            mp = mf["uuid"],
                            mk = this["_bindingsByRootAndName"],
                            mU = mk[mp];
                        void 0x0 === mU && ((mU = {}), (mk[mp] = mU));
                        for (var mq = 0x0; mq !== mI; ++mq) {
                            var mw = mP[mq],
                                mO = mw["name"],
                                mj = mU[mO];
                            if (void 0x0 !== mj) mA[mq] = mj;
                            else {
                                if (void 0x0 !== (mj = mA[mq])) {
                                    null === mj["_cacheIndex"] && (++mj["referenceCount"], this["_addInactiveBinding"](mj, mp, mO));
                                    continue;
                                }
                                var mh = mX && mX["_propertyBindings"][mq]["binding"]["parsedPath"];
                                ++(mj = new bG(Z8["create"](mf, mO, mh), mw["ValueTypeName"], mw["getValueSize"]()))["referenceCount"], this["_addInactiveBinding"](mj, mp, mO), (mA[mq] = mj);
                            }
                            mM[mq]["resultBuffer"] = mj["buffer"];
                        }
                    },
                    _activateAction: function (mN) {
                        if (!this["_isActiveAction"](mN)) {
                            if (null === mN["_cacheIndex"]) {
                                var mX = (mN["_localRoot"] || this["_root"])["uuid"],
                                    mf = mN["_clip"]["uuid"],
                                    mP = this["_actionsByClip"][mf];
                                this["_bindAction"](mN, mP && mP["knownActions"][0x0]), this["_addInactiveAction"](mN, mf, mX);
                            }
                            for (var mI = mN["_propertyBindings"], mA = 0x0, mM = mI["length"]; mA !== mM; ++mA) {
                                var mp = mI[mA];
                                0x0 == mp["useCount"]++ && (this["_lendBinding"](mp), mp["saveOriginalState"]());
                            }
                            this["_lendAction"](mN);
                        }
                    },
                    _deactivateAction: function (mN) {
                        if (this["_isActiveAction"](mN)) {
                            for (var mX = mN["_propertyBindings"], mf = 0x0, mP = mX["length"]; mf !== mP; ++mf) {
                                var mI = mX[mf];
                                0x0 == --mI["useCount"] && (mI["restoreOriginalState"](), this["_takeBackBinding"](mI));
                            }
                            this["_takeBackAction"](mN);
                        }
                    },
                    _initMemoryManager: function () {
                        (this["_actions"] = []),
                            (this["_nActiveActions"] = 0x0),
                            (this["_actionsByClip"] = {}),
                            (this["_bindings"] = []),
                            (this["_nActiveBindings"] = 0x0),
                            (this["_bindingsByRootAndName"] = {}),
                            (this["_controlInterpolants"] = []),
                            (this["_nActiveControlInterpolants"] = 0x0);
                        var mN = this;
                        this["stats"] = {
                            actions: {
                                get total() {
                                    return mN["_actions"]["length"];
                                },
                                get inUse() {
                                    return mN["_nActiveActions"];
                                },
                            },
                            bindings: {
                                get total() {
                                    return mN["_bindings"]["length"];
                                },
                                get inUse() {
                                    return mN["_nActiveBindings"];
                                },
                            },
                            controlInterpolants: {
                                get total() {
                                    return mN["_controlInterpolants"]["length"];
                                },
                                get inUse() {
                                    return mN["_nActiveControlInterpolants"];
                                },
                            },
                        };
                    },
                    _isActiveAction: function (mN) {
                        var mX = mN["_cacheIndex"];
                        return null !== mX && mX < this["_nActiveActions"];
                    },
                    _addInactiveAction: function (mN, mX, mf) {
                        var mP = this["_actions"],
                            mI = this["_actionsByClip"],
                            mA = mI[mX];
                        if (void 0x0 === mA) (mA = { knownActions: [mN], actionByRoot: {} }), (mN["_byClipCacheIndex"] = 0x0), (mI[mX] = mA);
                        else {
                            var mM = mA["knownActions"];
                            (mN["_byClipCacheIndex"] = mM["length"]), mM["push"](mN);
                        }
                        (mN["_cacheIndex"] = mP["length"]), mP["push"](mN), (mA["actionByRoot"][mf] = mN);
                    },
                    _removeInactiveAction: function (mN) {
                        var mX = this["_actions"],
                            mf = mX[mX["length"] - 0x1],
                            mP = mN["_cacheIndex"];
                        (mf["_cacheIndex"] = mP), (mX[mP] = mf), mX["pop"](), (mN["_cacheIndex"] = null);
                        var mI = mN["_clip"]["uuid"],
                            mA = this["_actionsByClip"],
                            mM = mA[mI],
                            mp = mM["knownActions"],
                            mk = mp[mp["length"] - 0x1],
                            mU = mN["_byClipCacheIndex"];
                        (mk["_byClipCacheIndex"] = mU),
                            (mp[mU] = mk),
                            mp["pop"](),
                            (mN["_byClipCacheIndex"] = null),
                            delete mM["actionByRoot"][(mN["_localRoot"] || this["_root"])["uuid"]],
                            0x0 === mp["length"] && delete mA[mI],
                            this["_removeInactiveBindingsForAction"](mN);
                    },
                    _removeInactiveBindingsForAction: function (mN) {
                        for (var mX = mN["_propertyBindings"], mf = 0x0, mP = mX["length"]; mf !== mP; ++mf) {
                            var mI = mX[mf];
                            0x0 == --mI["referenceCount"] && this["_removeInactiveBinding"](mI);
                        }
                    },
                    _lendAction: function (mN) {
                        var mX = this["_actions"],
                            mf = mN["_cacheIndex"],
                            mP = this["_nActiveActions"]++,
                            mI = mX[mP];
                        (mN["_cacheIndex"] = mP), (mX[mP] = mN), (mI["_cacheIndex"] = mf), (mX[mf] = mI);
                    },
                    _takeBackAction: function (mN) {
                        var mX = this["_actions"],
                            mf = mN["_cacheIndex"],
                            mP = --this["_nActiveActions"],
                            mI = mX[mP];
                        (mN["_cacheIndex"] = mP), (mX[mP] = mN), (mI["_cacheIndex"] = mf), (mX[mf] = mI);
                    },
                    _addInactiveBinding: function (mN, mX, mf) {
                        var mP = this["_bindingsByRootAndName"],
                            mI = mP[mX],
                            mA = this["_bindings"];
                        void 0x0 === mI && ((mI = {}), (mP[mX] = mI)), (mI[mf] = mN), (mN["_cacheIndex"] = mA["length"]), mA["push"](mN);
                    },
                    _removeInactiveBinding: function (mN) {
                        var mX = this["_bindings"],
                            mf = mN["binding"],
                            mP = mf["rootNode"]["uuid"],
                            mI = mf["path"],
                            mA = this["_bindingsByRootAndName"],
                            mM = mA[mP],
                            mp = mX[mX["length"] - 0x1],
                            mk = mN["_cacheIndex"];
                        (mp["_cacheIndex"] = mk), (mX[mk] = mp), mX["pop"](), delete mM[mI], 0x0 === Object["keys"](mM)["length"] && delete mA[mP];
                    },
                    _lendBinding: function (mN) {
                        var mX = this["_bindings"],
                            mf = mN["_cacheIndex"],
                            mP = this["_nActiveBindings"]++,
                            mI = mX[mP];
                        (mN["_cacheIndex"] = mP), (mX[mP] = mN), (mI["_cacheIndex"] = mf), (mX[mf] = mI);
                    },
                    _takeBackBinding: function (mN) {
                        var mX = this["_bindings"],
                            mf = mN["_cacheIndex"],
                            mP = --this["_nActiveBindings"],
                            mI = mX[mP];
                        (mN["_cacheIndex"] = mP), (mX[mP] = mN), (mI["_cacheIndex"] = mf), (mX[mf] = mI);
                    },
                    _lendControlInterpolant: function () {
                        var mN = this["_controlInterpolants"],
                            mX = this["_nActiveControlInterpolants"]++,
                            mf = mN[mX];
                        return void 0x0 === mf && (((mf = new F2(new Float32Array(0x2), new Float32Array(0x2), 0x1, this["_controlInterpolantsResultBuffer"]))["__cacheIndex"] = mX), (mN[mX] = mf)), mf;
                    },
                    _takeBackControlInterpolant: function (mN) {
                        var mX = this["_controlInterpolants"],
                            mf = mN["__cacheIndex"],
                            mP = --this["_nActiveControlInterpolants"],
                            mI = mX[mP];
                        (mN["__cacheIndex"] = mP), (mX[mP] = mN), (mI["__cacheIndex"] = mf), (mX[mf] = mI);
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(0x1),
                    clipAction: function (mN, mX, mf) {
                        var mP = mX || this["_root"],
                            mI = mP["uuid"],
                            mA = "string" == typeof mN ? FT["findByName"](mP, mN) : mN,
                            mM = null !== mA ? mA["uuid"] : mN,
                            mp = this["_actionsByClip"][mM],
                            mk = null;
                        if ((void 0x0 === mf && (mf = null !== mA ? mA["blendMode"] : rh), void 0x0 !== mp)) {
                            var mU = mp["actionByRoot"][mI];
                            if (void 0x0 !== mU && mU["blendMode"] === mf) return mU;
                            (mk = mp["knownActions"][0x0]), null === mA && (mA = mk["_clip"]);
                        }
                        if (null === mA) return null;
                        var mq = new Z9(this, mA, mX, mf);
                        return this["_bindAction"](mq, mk), this["_addInactiveAction"](mq, mM, mI), mq;
                    },
                    existingAction: function (mN, mX) {
                        var mf = mX || this["_root"],
                            mP = mf["uuid"],
                            mI = "string" == typeof mN ? FT["findByName"](mf, mN) : mN,
                            mA = mI ? mI["uuid"] : mN,
                            mM = this["_actionsByClip"][mA];
                        return (void 0x0 !== mM && mM["actionByRoot"][mP]) || null;
                    },
                    stopAllAction: function () {
                        for (var mN = this["_actions"], mX = this["_nActiveActions"] - 0x1; mX >= 0x0; --mX) mN[mX]["stop"]();
                        return this;
                    },
                    update: function (mN) {
                        mN *= this["timeScale"];
                        for (var mX = this["_actions"], mf = this["_nActiveActions"], mP = (this["time"] += mN), mI = Math["sign"](mN), mA = (this["_accuIndex"] ^= 0x1), mM = 0x0; mM !== mf; ++mM) {
                            mX[mM]["_update"](mP, mN, mI, mA);
                        }
                        var mp = this["_bindings"],
                            mk = this["_nActiveBindings"];
                        for (mM = 0x0; mM !== mk; ++mM) mp[mM]["apply"](mA);
                        return this;
                    },
                    setTime: function (mN) {
                        this["time"] = 0x0;
                        for (var mX = 0x0; mX < this["_actions"]["length"]; mX++) this["_actions"][mX]["time"] = 0x0;
                        return this["update"](mN);
                    },
                    getRoot: function () {
                        return this["_root"];
                    },
                    uncacheClip: function (mN) {
                        var mX = this["_actions"],
                            mf = mN["uuid"],
                            mP = this["_actionsByClip"],
                            mI = mP[mf];
                        if (void 0x0 !== mI) {
                            for (var mA = mI["knownActions"], mM = 0x0, mp = mA["length"]; mM !== mp; ++mM) {
                                var mk = mA[mM];
                                this["_deactivateAction"](mk);
                                var mU = mk["_cacheIndex"],
                                    mq = mX[mX["length"] - 0x1];
                                (mk["_cacheIndex"] = null), (mk["_byClipCacheIndex"] = null), (mq["_cacheIndex"] = mU), (mX[mU] = mq), mX["pop"](), this["_removeInactiveBindingsForAction"](mk);
                            }
                            delete mP[mf];
                        }
                    },
                    uncacheRoot: function (mN) {
                        var mX = mN["uuid"],
                            mf = this["_actionsByClip"];
                        for (var mP in mf) {
                            var mI = mf[mP]["actionByRoot"][mX];
                            void 0x0 !== mI && (this["_deactivateAction"](mI), this["_removeInactiveAction"](mI));
                        }
                        var mA = this["_bindingsByRootAndName"][mX];
                        if (void 0x0 !== mA)
                            for (var mM in mA) {
                                var mp = mA[mM];
                                mp["restoreOriginalState"](), this["_removeInactiveBinding"](mp);
                            }
                    },
                    uncacheAction: function (mN, mX) {
                        var mf = this["existingAction"](mN, mX);
                        null !== mf && (this["_deactivateAction"](mf), this["_removeInactiveAction"](mf));
                    },
                })),
                (ZR["prototype"]["clone"] = function () {
                    return new ZR(void 0x0 === this["value"]["clone"] ? this["value"] : this["value"]["clone"]());
                }),
                (ZT["prototype"] = Object["assign"](Object["create"](YC["prototype"]), {
                    constructor: ZT,
                    isInstancedInterleavedBuffer: !0x0,
                    copy: function (mN) {
                        return YC["prototype"]["copy"]["call"](this, mN), (this["meshPerAttribute"] = mN["meshPerAttribute"]), this;
                    },
                })),
                Object["assign"](ZC["prototype"], {
                    set: function (mN, mX) {
                        this["ray"]["set"](mN, mX);
                    },
                    setFromCamera: function (mN, mX) {
                        mX && mX["isPerspectiveCamera"]
                            ? (this["ray"]["origin"]["setFromMatrixPosition"](mX["matrixWorld"]), this["ray"]["direction"]["set"](mN["x"], mN["y"], 0.5)["unproject"](mX)["sub"](this["ray"]["origin"])["normalize"](), (this["camera"] = mX))
                            : mX && mX["isOrthographicCamera"]
                            ? (this["ray"]["origin"]["set"](mN["x"], mN["y"], (mX["near"] + mX["far"]) / (mX["near"] - mX["far"]))["unproject"](mX),
                              this["ray"]["direction"]["set"](0x0, 0x0, -0x1)["transformDirection"](mX["matrixWorld"]),
                              (this["camera"] = mX))
                            : console["error"]("THREE.Raycaster:\x20Unsupported\x20camera\x20type.");
                    },
                    intersectObject: function (mN, mX, mf) {
                        var mP = mf || [];
                        return ZY(mN, this, mP, mX), mP["sort"](Zd), mP;
                    },
                    intersectObjects: function (mN, mX, mf) {
                        var mP = mf || [];
                        if (!0x1 === Array["isArray"](mN)) return console["warn"]("THREE.Raycaster.intersectObjects:\x20objects\x20is\x20not\x20an\x20Array."), mP;
                        for (var mI = 0x0, mA = mN["length"]; mI < mA; mI++) ZY(mN[mI], this, mP, mX);
                        return mP["sort"](Zd), mP;
                    },
                }),
                Object["assign"](ZB["prototype"], {
                    set: function (mN, mX, mf) {
                        return (this["radius"] = mN), (this["phi"] = mX), (this["theta"] = mf), this;
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                    copy: function (mN) {
                        return (this["radius"] = mN["radius"]), (this["phi"] = mN["phi"]), (this["theta"] = mN["theta"]), this;
                    },
                    makeSafe: function () {
                        var mN = 0.000001;
                        return (this["phi"] = Math["max"](mN, Math["min"](Math["PI"] - mN, this["phi"]))), this;
                    },
                    setFromVector3: function (mN) {
                        return this["setFromCartesianCoords"](mN["x"], mN["y"], mN["z"]);
                    },
                    setFromCartesianCoords: function (mN, mX, mf) {
                        return (
                            (this["radius"] = Math["sqrt"](mN * mN + mX * mX + mf * mf)),
                            0x0 === this["radius"] ? ((this["theta"] = 0x0), (this["phi"] = 0x0)) : ((this["theta"] = Math["atan2"](mN, mf)), (this["phi"] = Math["acos"](E2["clamp"](mX / this["radius"], -0x1, 0x1)))),
                            this
                        );
                    },
                }),
                Object["assign"](
                    function (mN, mX, mf) {
                        return (this["radius"] = void 0x0 !== mN ? mN : 0x1), (this["theta"] = void 0x0 !== mX ? mX : 0x0), (this["y"] = void 0x0 !== mf ? mf : 0x0), this;
                    }["prototype"],
                    {
                        set: function (mN, mX, mf) {
                            return (this["radius"] = mN), (this["theta"] = mX), (this["y"] = mf), this;
                        },
                        clone: function () {
                            return new this["constructor"]()["copy"](this);
                        },
                        copy: function (mN) {
                            return (this["radius"] = mN["radius"]), (this["theta"] = mN["theta"]), (this["y"] = mN["y"]), this;
                        },
                        setFromVector3: function (mN) {
                            return this["setFromCartesianCoords"](mN["x"], mN["y"], mN["z"]);
                        },
                        setFromCartesianCoords: function (mN, mX, mf) {
                            return (this["radius"] = Math["sqrt"](mN * mN + mf * mf)), (this["theta"] = Math["atan2"](mN, mf)), (this["y"] = mX), this;
                        },
                    }
                );
            var ZF = new E3();
            function Zb(mN, mX) {
                (this["min"] = void 0x0 !== mN ? mN : new E3(0x1 / 0x0, 0x1 / 0x0)), (this["max"] = void 0x0 !== mX ? mX : new E3(-0x1 / 0x0, -0x1 / 0x0));
            }
            Object["assign"](Zb["prototype"], {
                set: function (mN, mX) {
                    return this["min"]["copy"](mN), this["max"]["copy"](mX), this;
                },
                setFromPoints: function (mN) {
                    this["makeEmpty"]();
                    for (var mX = 0x0, mf = mN["length"]; mX < mf; mX++) this["expandByPoint"](mN[mX]);
                    return this;
                },
                setFromCenterAndSize: function (mN, mX) {
                    var mf = ZF["copy"](mX)["multiplyScalar"](0.5);
                    return this["min"]["copy"](mN)["sub"](mf), this["max"]["copy"](mN)["add"](mf), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    return this["min"]["copy"](mN["min"]), this["max"]["copy"](mN["max"]), this;
                },
                makeEmpty: function () {
                    return (this["min"]["x"] = this["min"]["y"] = 0x1 / 0x0), (this["max"]["x"] = this["max"]["y"] = -0x1 / 0x0), this;
                },
                isEmpty: function () {
                    return this["max"]["x"] < this["min"]["x"] || this["max"]["y"] < this["min"]["y"];
                },
                getCenter: function (mN) {
                    return (
                        void 0x0 === mN && (console["warn"]("THREE.Box2:\x20.getCenter()\x20target\x20is\x20now\x20required"), (mN = new E3())),
                        this["isEmpty"]() ? mN["set"](0x0, 0x0) : mN["addVectors"](this["min"], this["max"])["multiplyScalar"](0.5)
                    );
                },
                getSize: function (mN) {
                    return void 0x0 === mN && (console["warn"]("THREE.Box2:\x20.getSize()\x20target\x20is\x20now\x20required"), (mN = new E3())), this["isEmpty"]() ? mN["set"](0x0, 0x0) : mN["subVectors"](this["max"], this["min"]);
                },
                expandByPoint: function (mN) {
                    return this["min"]["min"](mN), this["max"]["max"](mN), this;
                },
                expandByVector: function (mN) {
                    return this["min"]["sub"](mN), this["max"]["add"](mN), this;
                },
                expandByScalar: function (mN) {
                    return this["min"]["addScalar"](-mN), this["max"]["addScalar"](mN), this;
                },
                containsPoint: function (mN) {
                    return !(mN["x"] < this["min"]["x"] || mN["x"] > this["max"]["x"] || mN["y"] < this["min"]["y"] || mN["y"] > this["max"]["y"]);
                },
                containsBox: function (mN) {
                    return this["min"]["x"] <= mN["min"]["x"] && mN["max"]["x"] <= this["max"]["x"] && this["min"]["y"] <= mN["min"]["y"] && mN["max"]["y"] <= this["max"]["y"];
                },
                getParameter: function (mN, mX) {
                    return (
                        void 0x0 === mX && (console["warn"]("THREE.Box2:\x20.getParameter()\x20target\x20is\x20now\x20required"), (mX = new E3())),
                        mX["set"]((mN["x"] - this["min"]["x"]) / (this["max"]["x"] - this["min"]["x"]), (mN["y"] - this["min"]["y"]) / (this["max"]["y"] - this["min"]["y"]))
                    );
                },
                intersectsBox: function (mN) {
                    return !(mN["max"]["x"] < this["min"]["x"] || mN["min"]["x"] > this["max"]["x"] || mN["max"]["y"] < this["min"]["y"] || mN["min"]["y"] > this["max"]["y"]);
                },
                clampPoint: function (mN, mX) {
                    return void 0x0 === mX && (console["warn"]("THREE.Box2:\x20.clampPoint()\x20target\x20is\x20now\x20required"), (mX = new E3())), mX["copy"](mN)["clamp"](this["min"], this["max"]);
                },
                distanceToPoint: function (mN) {
                    return ZF["copy"](mN)["clamp"](this["min"], this["max"])["sub"](mN)["length"]();
                },
                intersect: function (mN) {
                    return this["min"]["max"](mN["min"]), this["max"]["min"](mN["max"]), this;
                },
                union: function (mN) {
                    return this["min"]["min"](mN["min"]), this["max"]["max"](mN["max"]), this;
                },
                translate: function (mN) {
                    return this["min"]["add"](mN), this["max"]["add"](mN), this;
                },
                equals: function (mN) {
                    return mN["min"]["equals"](this["min"]) && mN["max"]["equals"](this["max"]);
                },
            });
            var ZZ = new Ed(),
                Zm = new Ed();
            function Zv(mN, mX) {
                (this["start"] = void 0x0 !== mN ? mN : new Ed()), (this["end"] = void 0x0 !== mX ? mX : new Ed());
            }
            function Zy(mN) {
                Eg["call"](this),
                    (this["material"] = mN),
                    (this["render"] = function () {}),
                    (this["hasPositions"] = !0x1),
                    (this["hasNormals"] = !0x1),
                    (this["hasColors"] = !0x1),
                    (this["hasUvs"] = !0x1),
                    (this["positionArray"] = null),
                    (this["normalArray"] = null),
                    (this["colorArray"] = null),
                    (this["uvArray"] = null),
                    (this["count"] = 0x0);
            }
            Object["assign"](Zv["prototype"], {
                set: function (mN, mX) {
                    return this["start"]["copy"](mN), this["end"]["copy"](mX), this;
                },
                clone: function () {
                    return new this["constructor"]()["copy"](this);
                },
                copy: function (mN) {
                    return this["start"]["copy"](mN["start"]), this["end"]["copy"](mN["end"]), this;
                },
                getCenter: function (mN) {
                    return void 0x0 === mN && (console["warn"]("THREE.Line3:\x20.getCenter()\x20target\x20is\x20now\x20required"), (mN = new Ed())), mN["addVectors"](this["start"], this["end"])["multiplyScalar"](0.5);
                },
                delta: function (mN) {
                    return void 0x0 === mN && (console["warn"]("THREE.Line3:\x20.delta()\x20target\x20is\x20now\x20required"), (mN = new Ed())), mN["subVectors"](this["end"], this["start"]);
                },
                distanceSq: function () {
                    return this["start"]["distanceToSquared"](this["end"]);
                },
                distance: function () {
                    return this["start"]["distanceTo"](this["end"]);
                },
                at: function (mN, mX) {
                    return void 0x0 === mX && (console["warn"]("THREE.Line3:\x20.at()\x20target\x20is\x20now\x20required"), (mX = new Ed())), this["delta"](mX)["multiplyScalar"](mN)["add"](this["start"]);
                },
                closestPointToPointParameter: function (mN, mX) {
                    ZZ["subVectors"](mN, this["start"]), Zm["subVectors"](this["end"], this["start"]);
                    var mf = Zm["dot"](Zm),
                        mP = Zm["dot"](ZZ) / mf;
                    return mX && (mP = E2["clamp"](mP, 0x0, 0x1)), mP;
                },
                closestPointToPoint: function (mN, mX, mf) {
                    var mP = this["closestPointToPointParameter"](mN, mX);
                    return void 0x0 === mf && (console["warn"]("THREE.Line3:\x20.closestPointToPoint()\x20target\x20is\x20now\x20required"), (mf = new Ed())), this["delta"](mf)["multiplyScalar"](mP)["add"](this["start"]);
                },
                applyMatrix4: function (mN) {
                    return this["start"]["applyMatrix4"](mN), this["end"]["applyMatrix4"](mN), this;
                },
                equals: function (mN) {
                    return mN["start"]["equals"](this["start"]) && mN["end"]["equals"](this["end"]);
                },
            }),
                (Zy["prototype"] = Object["create"](Eg["prototype"])),
                (Zy["prototype"]["constructor"] = Zy),
                (Zy["prototype"]["isImmediateRenderObject"] = !0x0);
            var ZD = new Ed();
            function ZN(mN, mX) {
                Eg["call"](this), (this["light"] = mN), this["light"]["updateMatrixWorld"](), (this["matrix"] = mN["matrixWorld"]), (this["matrixAutoUpdate"] = !0x1), (this["color"] = mX);
                for (
                    var mf = new TR(), mP = [0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, -0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, -0x1, 0x1], mI = 0x0, mA = 0x1;
                    mI < 0x20;
                    mI++, mA++
                ) {
                    var mM = (mI / 0x20) * Math["PI"] * 0x2,
                        mp = (mA / 0x20) * Math["PI"] * 0x2;
                    mP["push"](Math["cos"](mM), Math["sin"](mM), 0x1, Math["cos"](mp), Math["sin"](mp), 0x1);
                }
                mf["setAttribute"]("position", new T0(mP, 0x3));
                var mk = new YQ({ fog: !0x1, toneMapped: !0x1 });
                (this["cone"] = new n7(mf, mk)), this["add"](this["cone"]), this["update"]();
            }
            (ZN["prototype"] = Object["create"](Eg["prototype"])),
                (ZN["prototype"]["constructor"] = ZN),
                (ZN["prototype"]["dispose"] = function () {
                    this["cone"]["geometry"]["dispose"](), this["cone"]["material"]["dispose"]();
                }),
                (ZN["prototype"]["update"] = function () {
                    this["light"]["updateMatrixWorld"]();
                    var mN = this["light"]["distance"] ? this["light"]["distance"] : 0x3e8,
                        mX = mN * Math["tan"](this["light"]["angle"]);
                    this["cone"]["scale"]["set"](mX, mX, mN),
                        ZD["setFromMatrixPosition"](this["light"]["target"]["matrixWorld"]),
                        this["cone"]["lookAt"](ZD),
                        void 0x0 !== this["color"] ? this["cone"]["material"]["color"]["set"](this["color"]) : this["cone"]["material"]["color"]["copy"](this["light"]["color"]);
                });
            var ZX = new Ed(),
                Zf = new Ey(),
                ZP = new Ey();
            function ZI(mN) {
                var mX = [];
                mN && mN["isBone"] && mX["push"](mN);
                for (var mf = 0x0; mf < mN["children"]["length"]; mf++) mX["push"]["apply"](mX, ZI(mN["children"][mf]));
                return mX;
            }
            function ZA(mN) {
                for (var mX = ZI(mN), mf = new TR(), mP = [], mI = [], mA = new Rq(0x0, 0x0, 0x1), mM = new Rq(0x0, 0x1, 0x0), mp = 0x0; mp < mX["length"]; mp++) {
                    var mk = mX[mp];
                    mk["parent"] && mk["parent"]["isBone"] && (mP["push"](0x0, 0x0, 0x0), mP["push"](0x0, 0x0, 0x0), mI["push"](mA["r"], mA["g"], mA["b"]), mI["push"](mM["r"], mM["g"], mM["b"]));
                }
                mf["setAttribute"]("position", new T0(mP, 0x3)), mf["setAttribute"]("color", new T0(mI, 0x3));
                var mU = new YQ({ vertexColors: !0x0, depthTest: !0x1, depthWrite: !0x1, toneMapped: !0x1, transparent: !0x0 });
                n7["call"](this, mf, mU), (this["type"] = "SkeletonHelper"), (this["root"] = mN), (this["bones"] = mX), (this["matrix"] = mN["matrixWorld"]), (this["matrixAutoUpdate"] = !0x1);
            }
            function ZM(mN, mX, mf) {
                (this["light"] = mN), this["light"]["updateMatrixWorld"](), (this["color"] = mf);
                var mP = new BD(mX, 0x4, 0x2),
                    mI = new RW({ wireframe: !0x0, fog: !0x1, toneMapped: !0x1 });
                TA["call"](this, mP, mI), (this["type"] = "PointLightHelper"), (this["matrix"] = this["light"]["matrixWorld"]), (this["matrixAutoUpdate"] = !0x1), this["update"]();
            }
            (ZA["prototype"] = Object["create"](n7["prototype"])),
                (ZA["prototype"]["constructor"] = ZA),
                (ZA["prototype"]["isSkeletonHelper"] = !0x0),
                (ZA["prototype"]["updateMatrixWorld"] = function (mN) {
                    var mX = this["bones"],
                        mf = this["geometry"],
                        mP = mf["getAttribute"]("position");
                    ZP["getInverse"](this["root"]["matrixWorld"]);
                    for (var mI = 0x0, mA = 0x0; mI < mX["length"]; mI++) {
                        var mM = mX[mI];
                        mM["parent"] &&
                            mM["parent"]["isBone"] &&
                            (Zf["multiplyMatrices"](ZP, mM["matrixWorld"]),
                            ZX["setFromMatrixPosition"](Zf),
                            mP["setXYZ"](mA, ZX["x"], ZX["y"], ZX["z"]),
                            Zf["multiplyMatrices"](ZP, mM["parent"]["matrixWorld"]),
                            ZX["setFromMatrixPosition"](Zf),
                            mP["setXYZ"](mA + 0x1, ZX["x"], ZX["y"], ZX["z"]),
                            (mA += 0x2));
                    }
                    (mf["getAttribute"]("position")["needsUpdate"] = !0x0), Eg["prototype"]["updateMatrixWorld"]["call"](this, mN);
                }),
                (ZM["prototype"] = Object["create"](TA["prototype"])),
                (ZM["prototype"]["constructor"] = ZM),
                (ZM["prototype"]["dispose"] = function () {
                    this["geometry"]["dispose"](), this["material"]["dispose"]();
                }),
                (ZM["prototype"]["update"] = function () {
                    void 0x0 !== this["color"] ? this["material"]["color"]["set"](this["color"]) : this["material"]["color"]["copy"](this["light"]["color"]);
                });
            var Zp = new Ed(),
                Zk = new Rq(),
                Zl = new Rq();
            function ZU(mN, mX, mf) {
                Eg["call"](this), (this["light"] = mN), this["light"]["updateMatrixWorld"](), (this["matrix"] = mN["matrixWorld"]), (this["matrixAutoUpdate"] = !0x1), (this["color"] = mf);
                var mP = new nI(mX);
                mP["rotateY"](0.5 * Math["PI"]), (this["material"] = new RW({ wireframe: !0x0, fog: !0x1, toneMapped: !0x1 })), void 0x0 === this["color"] && (this["material"]["vertexColors"] = !0x0);
                var mI = mP["getAttribute"]("position"),
                    mA = new Float32Array(0x3 * mI["count"]);
                mP["setAttribute"]("color", new Rx(mA, 0x3)), this["add"](new TA(mP, this["material"])), this["update"]();
            }
            function Zq(mN, mX, mf, mP) {
                (mN = mN || 0xa), (mX = mX || 0xa), (mf = new Rq(void 0x0 !== mf ? mf : 0x444444)), (mP = new Rq(void 0x0 !== mP ? mP : 0x888888));
                for (var mI = mX / 0x2, mA = mN / mX, mM = mN / 0x2, mp = [], mk = [], mU = 0x0, mq = 0x0, mw = -mM; mU <= mX; mU++, mw += mA) {
                    mp["push"](-mM, 0x0, mw, mM, 0x0, mw), mp["push"](mw, 0x0, -mM, mw, 0x0, mM);
                    var mO = mU === mI ? mf : mP;
                    mO["toArray"](mk, mq), (mq += 0x3), mO["toArray"](mk, mq), (mq += 0x3), mO["toArray"](mk, mq), (mq += 0x3), mO["toArray"](mk, mq), (mq += 0x3);
                }
                var mj = new TR();
                mj["setAttribute"]("position", new T0(mp, 0x3)), mj["setAttribute"]("color", new T0(mk, 0x3));
                var mh = new YQ({ vertexColors: !0x0, toneMapped: !0x1 });
                n7["call"](this, mj, mh), (this["type"] = "GridHelper");
            }
            function Zw(mN, mX, mf, mP, mI, mA) {
                (mN = mN || 0xa), (mX = mX || 0x10), (mf = mf || 0x8), (mP = mP || 0x40), (mI = new Rq(void 0x0 !== mI ? mI : 0x444444)), (mA = new Rq(void 0x0 !== mA ? mA : 0x888888));
                var mM,
                    mp,
                    mk,
                    mU,
                    mq,
                    mw,
                    mO,
                    mj = [],
                    mh = [];
                for (mU = 0x0; mU <= mX; mU++)
                    (mk = (mU / mX) * (0x2 * Math["PI"])),
                        (mM = Math["sin"](mk) * mN),
                        (mp = Math["cos"](mk) * mN),
                        mj["push"](0x0, 0x0, 0x0),
                        mj["push"](mM, 0x0, mp),
                        (mO = 0x1 & mU ? mI : mA),
                        mh["push"](mO["r"], mO["g"], mO["b"]),
                        mh["push"](mO["r"], mO["g"], mO["b"]);
                for (mU = 0x0; mU <= mf; mU++)
                    for (mO = 0x1 & mU ? mI : mA, mw = mN - (mN / mf) * mU, mq = 0x0; mq < mP; mq++)
                        (mk = (mq / mP) * (0x2 * Math["PI"])),
                            (mM = Math["sin"](mk) * mw),
                            (mp = Math["cos"](mk) * mw),
                            mj["push"](mM, 0x0, mp),
                            mh["push"](mO["r"], mO["g"], mO["b"]),
                            (mk = ((mq + 0x1) / mP) * (0x2 * Math["PI"])),
                            (mM = Math["sin"](mk) * mw),
                            (mp = Math["cos"](mk) * mw),
                            mj["push"](mM, 0x0, mp),
                            mh["push"](mO["r"], mO["g"], mO["b"]);
                var mS = new TR();
                mS["setAttribute"]("position", new T0(mj, 0x3)), mS["setAttribute"]("color", new T0(mh, 0x3));
                var mg = new YQ({ vertexColors: !0x0, toneMapped: !0x1 });
                n7["call"](this, mS, mg), (this["type"] = "PolarGridHelper");
            }
            (ZU["prototype"] = Object["create"](Eg["prototype"])),
                (ZU["prototype"]["constructor"] = ZU),
                (ZU["prototype"]["dispose"] = function () {
                    this["children"][0x0]["geometry"]["dispose"](), this["children"][0x0]["material"]["dispose"]();
                }),
                (ZU["prototype"]["update"] = function () {
                    var mN = this["children"][0x0];
                    if (void 0x0 !== this["color"]) this["material"]["color"]["set"](this["color"]);
                    else {
                        var mX = mN["geometry"]["getAttribute"]("color");
                        Zk["copy"](this["light"]["color"]), Zl["copy"](this["light"]["groundColor"]);
                        for (var mf = 0x0, mP = mX["count"]; mf < mP; mf++) {
                            var mI = mf < mP / 0x2 ? Zk : Zl;
                            mX["setXYZ"](mf, mI["r"], mI["g"], mI["b"]);
                        }
                        mX["needsUpdate"] = !0x0;
                    }
                    mN["lookAt"](Zp["setFromMatrixPosition"](this["light"]["matrixWorld"])["negate"]());
                }),
                (Zq["prototype"] = Object["assign"](Object["create"](n7["prototype"]), {
                    constructor: Zq,
                    copy: function (mN) {
                        return n7["prototype"]["copy"]["call"](this, mN), this["geometry"]["copy"](mN["geometry"]), this["material"]["copy"](mN["material"]), this;
                    },
                    clone: function () {
                        return new this["constructor"]()["copy"](this);
                    },
                })),
                (Zw["prototype"] = Object["create"](n7["prototype"])),
                (Zw["prototype"]["constructor"] = Zw);
            var ZO = new Ed(),
                Zj = new Ed(),
                Zh = new Ed();
            function ZS(mN, mX, mf) {
                Eg["call"](this), (this["light"] = mN), this["light"]["updateMatrixWorld"](), (this["matrix"] = mN["matrixWorld"]), (this["matrixAutoUpdate"] = !0x1), (this["color"] = mf), void 0x0 === mX && (mX = 0x1);
                var mP = new TR();
                mP["setAttribute"]("position", new T0([-mX, mX, 0x0, mX, mX, 0x0, mX, -mX, 0x0, -mX, -mX, 0x0, -mX, mX, 0x0], 0x3));
                var mI = new YQ({ fog: !0x1, toneMapped: !0x1 });
                (this["lightPlane"] = new n4(mP, mI)),
                    this["add"](this["lightPlane"]),
                    (mP = new TR())["setAttribute"]("position", new T0([0x0, 0x0, 0x0, 0x0, 0x0, 0x1], 0x3)),
                    (this["targetLine"] = new n4(mP, mI)),
                    this["add"](this["targetLine"]),
                    this["update"]();
            }
            (ZS["prototype"] = Object["create"](Eg["prototype"])),
                (ZS["prototype"]["constructor"] = ZS),
                (ZS["prototype"]["dispose"] = function () {
                    this["lightPlane"]["geometry"]["dispose"](), this["lightPlane"]["material"]["dispose"](), this["targetLine"]["geometry"]["dispose"](), this["targetLine"]["material"]["dispose"]();
                }),
                (ZS["prototype"]["update"] = function () {
                    ZO["setFromMatrixPosition"](this["light"]["matrixWorld"]),
                        Zj["setFromMatrixPosition"](this["light"]["target"]["matrixWorld"]),
                        Zh["subVectors"](Zj, ZO),
                        this["lightPlane"]["lookAt"](Zj),
                        void 0x0 !== this["color"]
                            ? (this["lightPlane"]["material"]["color"]["set"](this["color"]), this["targetLine"]["material"]["color"]["set"](this["color"]))
                            : (this["lightPlane"]["material"]["color"]["copy"](this["light"]["color"]), this["targetLine"]["material"]["color"]["copy"](this["light"]["color"])),
                        this["targetLine"]["lookAt"](Zj),
                        (this["targetLine"]["scale"]["z"] = Zh["length"]());
                });
            var Zg = new Ed(),
                ZW = new TH();
            function ZH(mN) {
                var mX = new TR(),
                    mf = new YQ({ color: 0xffffff, vertexColors: !0x0, toneMapped: !0x1 }),
                    mP = [],
                    mI = [],
                    mA = {},
                    mM = new Rq(0xffaa00),
                    mp = new Rq(0xff0000),
                    mk = new Rq(0xaaff),
                    mU = new Rq(0xffffff),
                    mq = new Rq(0x333333);
                function mw(mj, mh, mS) {
                    mO(mj, mS), mO(mh, mS);
                }
                function mO(mj, mh) {
                    mP["push"](0x0, 0x0, 0x0), mI["push"](mh["r"], mh["g"], mh["b"]), void 0x0 === mA[mj] && (mA[mj] = []), mA[mj]["push"](mP["length"] / 0x3 - 0x1);
                }
                mw("n1", "n2", mM),
                    mw("n2", "n4", mM),
                    mw("n4", "n3", mM),
                    mw("n3", "n1", mM),
                    mw("f1", "f2", mM),
                    mw("f2", "f4", mM),
                    mw("f4", "f3", mM),
                    mw("f3", "f1", mM),
                    mw("n1", "f1", mM),
                    mw("n2", "f2", mM),
                    mw("n3", "f3", mM),
                    mw("n4", "f4", mM),
                    mw("p", "n1", mp),
                    mw("p", "n2", mp),
                    mw("p", "n3", mp),
                    mw("p", "n4", mp),
                    mw("u1", "u2", mk),
                    mw("u2", "u3", mk),
                    mw("u3", "u1", mk),
                    mw("c", "t", mU),
                    mw("p", "c", mq),
                    mw("cn1", "cn2", mq),
                    mw("cn3", "cn4", mq),
                    mw("cf1", "cf2", mq),
                    mw("cf3", "cf4", mq),
                    mX["setAttribute"]("position", new T0(mP, 0x3)),
                    mX["setAttribute"]("color", new T0(mI, 0x3)),
                    n7["call"](this, mX, mf),
                    (this["type"] = "CameraHelper"),
                    (this["camera"] = mN),
                    this["camera"]["updateProjectionMatrix"] && this["camera"]["updateProjectionMatrix"](),
                    (this["matrix"] = mN["matrixWorld"]),
                    (this["matrixAutoUpdate"] = !0x1),
                    (this["pointMap"] = mA),
                    this["update"]();
            }
            function Zx(mN, mX, mf, mP, mI, mA, mM) {
                Zg["set"](mI, mA, mM)["unproject"](mP);
                var mp = mX[mN];
                if (void 0x0 !== mp) {
                    for (var mk = mf["getAttribute"]("position"), mU = 0x0, mq = mp["length"]; mU < mq; mU++) mk["setXYZ"](mp[mU], Zg["x"], Zg["y"], Zg["z"]);
                }
            }
            (ZH["prototype"] = Object["create"](n7["prototype"])),
                (ZH["prototype"]["constructor"] = ZH),
                (ZH["prototype"]["update"] = function () {
                    var mN = this["geometry"],
                        mX = this["pointMap"];
                    ZW["projectionMatrixInverse"]["copy"](this["camera"]["projectionMatrixInverse"]),
                        Zx("c", mX, mN, ZW, 0x0, 0x0, -0x1),
                        Zx("t", mX, mN, ZW, 0x0, 0x0, 0x1),
                        Zx("n1", mX, mN, ZW, -0x1, -0x1, -0x1),
                        Zx("n2", mX, mN, ZW, 0x1, -0x1, -0x1),
                        Zx("n3", mX, mN, ZW, -0x1, 0x1, -0x1),
                        Zx("n4", mX, mN, ZW, 0x1, 0x1, -0x1),
                        Zx("f1", mX, mN, ZW, -0x1, -0x1, 0x1),
                        Zx("f2", mX, mN, ZW, 0x1, -0x1, 0x1),
                        Zx("f3", mX, mN, ZW, -0x1, 0x1, 0x1),
                        Zx("f4", mX, mN, ZW, 0x1, 0x1, 0x1),
                        Zx("u1", mX, mN, ZW, 0.7, 1.1, -0x1),
                        Zx("u2", mX, mN, ZW, -0.7, 1.1, -0x1),
                        Zx("u3", mX, mN, ZW, 0x0, 0x2, -0x1),
                        Zx("cf1", mX, mN, ZW, -0x1, 0x0, 0x1),
                        Zx("cf2", mX, mN, ZW, 0x1, 0x0, 0x1),
                        Zx("cf3", mX, mN, ZW, 0x0, -0x1, 0x1),
                        Zx("cf4", mX, mN, ZW, 0x0, 0x1, 0x1),
                        Zx("cn1", mX, mN, ZW, -0x1, 0x0, -0x1),
                        Zx("cn2", mX, mN, ZW, 0x1, 0x0, -0x1),
                        Zx("cn3", mX, mN, ZW, 0x0, -0x1, -0x1),
                        Zx("cn4", mX, mN, ZW, 0x0, 0x1, -0x1),
                        (mN["getAttribute"]("position")["needsUpdate"] = !0x0);
                });
            var ZK = new R4();
            function ZV(mN, mX) {
                (this["object"] = mN), void 0x0 === mX && (mX = 0xffff00);
                var mf = new Uint16Array([0x0, 0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x0, 0x4, 0x5, 0x5, 0x6, 0x6, 0x7, 0x7, 0x4, 0x0, 0x4, 0x1, 0x5, 0x2, 0x6, 0x3, 0x7]),
                    mP = new Float32Array(0x18),
                    mI = new TR();
                mI["setIndex"](new Rx(mf, 0x1)),
                    mI["setAttribute"]("position", new Rx(mP, 0x3)),
                    n7["call"](this, mI, new YQ({ color: mX, toneMapped: !0x1 })),
                    (this["type"] = "BoxHelper"),
                    (this["matrixAutoUpdate"] = !0x1),
                    this["update"]();
            }
            function ZJ(mN, mX) {
                (this["type"] = "Box3Helper"), (this["box"] = mN), (mX = mX || 0xffff00);
                var mf = new Uint16Array([0x0, 0x1, 0x1, 0x2, 0x2, 0x3, 0x3, 0x0, 0x4, 0x5, 0x5, 0x6, 0x6, 0x7, 0x7, 0x4, 0x0, 0x4, 0x1, 0x5, 0x2, 0x6, 0x3, 0x7]),
                    mP = new TR();
                mP["setIndex"](new Rx(mf, 0x1)),
                    mP["setAttribute"]("position", new T0([0x1, 0x1, 0x1, -0x1, 0x1, 0x1, -0x1, -0x1, 0x1, 0x1, -0x1, 0x1, 0x1, 0x1, -0x1, -0x1, 0x1, -0x1, -0x1, -0x1, -0x1, 0x1, -0x1, -0x1], 0x3)),
                    n7["call"](this, mP, new YQ({ color: mX, toneMapped: !0x1 })),
                    (this["type"] = "Box3Helper"),
                    this["geometry"]["computeBoundingSphere"]();
            }
            function ZG(mN, mX, mf) {
                (this["plane"] = mN), (this["size"] = void 0x0 === mX ? 0x1 : mX);
                var mP = void 0x0 !== mf ? mf : 0xffff00,
                    mI = new TR();
                mI["setAttribute"]("position", new T0([0x1, -0x1, 0x1, -0x1, 0x1, 0x1, -0x1, -0x1, 0x1, 0x1, 0x1, 0x1, -0x1, 0x1, 0x1, -0x1, -0x1, 0x1, 0x1, -0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0], 0x3)),
                    mI["computeBoundingSphere"](),
                    n4["call"](this, mI, new YQ({ color: mP, toneMapped: !0x1 })),
                    (this["type"] = "PlaneHelper");
                var mA = new TR();
                mA["setAttribute"]("position", new T0([0x1, 0x1, 0x1, -0x1, 0x1, 0x1, -0x1, -0x1, 0x1, 0x1, 0x1, 0x1, -0x1, -0x1, 0x1, 0x1, -0x1, 0x1], 0x3)),
                    mA["computeBoundingSphere"](),
                    this["add"](new TA(mA, new RW({ color: mP, opacity: 0.2, transparent: !0x0, depthWrite: !0x1, toneMapped: !0x1 })));
            }
            (ZV["prototype"] = Object["create"](n7["prototype"])),
                (ZV["prototype"]["constructor"] = ZV),
                (ZV["prototype"]["update"] = function (mN) {
                    if ((void 0x0 !== mN && console["warn"]("THREE.BoxHelper:\x20.update()\x20has\x20no\x20longer\x20arguments."), void 0x0 !== this["object"] && ZK["setFromObject"](this["object"]), !ZK["isEmpty"]())) {
                        var mX = ZK["min"],
                            mf = ZK["max"],
                            mP = this["geometry"]["attributes"]["position"],
                            mI = mP["array"];
                        (mI[0x0] = mf["x"]),
                            (mI[0x1] = mf["y"]),
                            (mI[0x2] = mf["z"]),
                            (mI[0x3] = mX["x"]),
                            (mI[0x4] = mf["y"]),
                            (mI[0x5] = mf["z"]),
                            (mI[0x6] = mX["x"]),
                            (mI[0x7] = mX["y"]),
                            (mI[0x8] = mf["z"]),
                            (mI[0x9] = mf["x"]),
                            (mI[0xa] = mX["y"]),
                            (mI[0xb] = mf["z"]),
                            (mI[0xc] = mf["x"]),
                            (mI[0xd] = mf["y"]),
                            (mI[0xe] = mX["z"]),
                            (mI[0xf] = mX["x"]),
                            (mI[0x10] = mf["y"]),
                            (mI[0x11] = mX["z"]),
                            (mI[0x12] = mX["x"]),
                            (mI[0x13] = mX["y"]),
                            (mI[0x14] = mX["z"]),
                            (mI[0x15] = mf["x"]),
                            (mI[0x16] = mX["y"]),
                            (mI[0x17] = mX["z"]),
                            (mP["needsUpdate"] = !0x0),
                            this["geometry"]["computeBoundingSphere"]();
                    }
                }),
                (ZV["prototype"]["setFromObject"] = function (mN) {
                    return (this["object"] = mN), this["update"](), this;
                }),
                (ZV["prototype"]["copy"] = function (mN) {
                    return n7["prototype"]["copy"]["call"](this, mN), (this["object"] = mN["object"]), this;
                }),
                (ZV["prototype"]["clone"] = function () {
                    return new this["constructor"]()["copy"](this);
                }),
                (ZJ["prototype"] = Object["create"](n7["prototype"])),
                (ZJ["prototype"]["constructor"] = ZJ),
                (ZJ["prototype"]["updateMatrixWorld"] = function (mN) {
                    var mX = this["box"];
                    mX["isEmpty"]() || (mX["getCenter"](this["position"]), mX["getSize"](this["scale"]), this["scale"]["multiplyScalar"](0.5), Eg["prototype"]["updateMatrixWorld"]["call"](this, mN));
                }),
                (ZG["prototype"] = Object["create"](n4["prototype"])),
                (ZG["prototype"]["constructor"] = ZG),
                (ZG["prototype"]["updateMatrixWorld"] = function (mN) {
                    var mX = -this["plane"]["constant"];
                    Math["abs"](mX) < 1e-8 && (mX = 1e-8),
                        this["scale"]["set"](0.5 * this["size"], 0.5 * this["size"], mX),
                        (this["children"][0x0]["material"]["side"] = mX < 0x0 ? 0x1 : r5),
                        this["lookAt"](this["plane"]["normal"]),
                        Eg["prototype"]["updateMatrixWorld"]["call"](this, mN);
                });
            var ZL,
                ZQ,
                Zz = new Ed();
            function m0(mN, mX, mf, mP, mI, mA) {
                Eg["call"](this),
                    (this["type"] = "ArrowHelper"),
                    void 0x0 === mN && (mN = new Ed(0x0, 0x0, 0x1)),
                    void 0x0 === mX && (mX = new Ed(0x0, 0x0, 0x0)),
                    void 0x0 === mf && (mf = 0x1),
                    void 0x0 === mP && (mP = 0xffff00),
                    void 0x0 === mI && (mI = 0.2 * mf),
                    void 0x0 === mA && (mA = 0.2 * mI),
                    void 0x0 === ZL && ((ZL = new TR())["setAttribute"]("position", new T0([0x0, 0x0, 0x0, 0x0, 0x1, 0x0], 0x3)), (ZQ = new BU(0x0, 0.5, 0x1, 0x5, 0x1))["translate"](0x0, -0.5, 0x0)),
                    this["position"]["copy"](mX),
                    (this["line"] = new n4(ZL, new YQ({ color: mP, toneMapped: !0x1 }))),
                    (this["line"]["matrixAutoUpdate"] = !0x1),
                    this["add"](this["line"]),
                    (this["cone"] = new TA(ZQ, new RW({ color: mP, toneMapped: !0x1 }))),
                    (this["cone"]["matrixAutoUpdate"] = !0x1),
                    this["add"](this["cone"]),
                    this["setDirection"](mN),
                    this["setLength"](mf, mI, mA);
            }
            function m1(mN) {
                var mX = [0x0, 0x0, 0x0, (mN = mN || 0x1), 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, mN, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, mN],
                    mf = new TR();
                mf["setAttribute"]("position", new T0(mX, 0x3)), mf["setAttribute"]("color", new T0([0x1, 0x0, 0x0, 0x1, 0.6, 0x0, 0x0, 0x1, 0x0, 0.6, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0.6, 0x1], 0x3));
                var mP = new YQ({ vertexColors: !0x0, toneMapped: !0x1 });
                n7["call"](this, mf, mP), (this["type"] = "AxesHelper");
            }
            (m0["prototype"] = Object["create"](Eg["prototype"])),
                (m0["prototype"]["constructor"] = m0),
                (m0["prototype"]["setDirection"] = function (mN) {
                    if (mN["y"] > 0.99999) this["quaternion"]["set"](0x0, 0x0, 0x0, 0x1);
                    else {
                        if (mN["y"] < -0.99999) this["quaternion"]["set"](0x1, 0x0, 0x0, 0x0);
                        else {
                            Zz["set"](mN["z"], 0x0, -mN["x"])["normalize"]();
                            var mX = Math["acos"](mN["y"]);
                            this["quaternion"]["setFromAxisAngle"](Zz, mX);
                        }
                    }
                }),
                (m0["prototype"]["setLength"] = function (mN, mX, mf) {
                    void 0x0 === mX && (mX = 0.2 * mN),
                        void 0x0 === mf && (mf = 0.2 * mX),
                        this["line"]["scale"]["set"](0x1, Math["max"](0.0001, mN - mX), 0x1),
                        this["line"]["updateMatrix"](),
                        this["cone"]["scale"]["set"](mf, mX, mf),
                        (this["cone"]["position"]["y"] = mN),
                        this["cone"]["updateMatrix"]();
                }),
                (m0["prototype"]["setColor"] = function (mN) {
                    this["line"]["material"]["color"]["set"](mN), this["cone"]["material"]["color"]["set"](mN);
                }),
                (m0["prototype"]["copy"] = function (mN) {
                    return Eg["prototype"]["copy"]["call"](this, mN, !0x1), this["line"]["copy"](mN["line"]), this["cone"]["copy"](mN["cone"]), this;
                }),
                (m0["prototype"]["clone"] = function () {
                    return new this["constructor"]()["copy"](this);
                }),
                (m1["prototype"] = Object["create"](n7["prototype"])),
                (m1["prototype"]["constructor"] = m1);
            var m2 = Math["pow"](0x2, 0x8),
                m3 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                m4 = 0x5 + m3["length"],
                m5 = 0x14,
                m6 = { [rW]: 0x0, [rH]: 0x1, [rK]: 0x2, 0xbbc: 0x3, 0xbbd: 0x4, 0xbbe: 0x5, [rx]: 0x6 },
                m7 = new b5(),
                { _lodPlanes: m8, _sizeLods: m9, _sigmas: mE } = (function () {
                    for (var mN = [], mX = [], mf = [], mP = 0x8, mI = 0x0; mI < m4; mI++) {
                        var mA = Math["pow"](0x2, mP);
                        mX["push"](mA);
                        var mM = 0x1 / mA;
                        mI > 0x4 ? (mM = m3[mI - 0x8 + 0x4 - 0x1]) : 0x0 == mI && (mM = 0x0), mf["push"](mM);
                        for (
                            var mp = 0x1 / (mA - 0x1),
                                mk = -mp / 0x2,
                                mU = 0x1 + mp / 0x2,
                                mq = [mk, mk, mU, mk, mU, mU, mk, mk, mU, mU, mk, mU],
                                mw = new Float32Array(0x6c),
                                mO = new Float32Array(0x48),
                                mj = new Float32Array(0x24),
                                mh = 0x0;
                            mh < 0x6;
                            mh++
                        ) {
                            var mS = ((mh % 0x3) * 0x2) / 0x3 - 0x1,
                                mg = mh > 0x2 ? 0x0 : -0x1,
                                mW = [mS, mg, 0x0, mS + 0x2 / 0x3, mg, 0x0, mS + 0x2 / 0x3, mg + 0x1, 0x0, mS, mg, 0x0, mS + 0x2 / 0x3, mg + 0x1, 0x0, mS, mg + 0x1, 0x0];
                            mw["set"](mW, 0x12 * mh), mO["set"](mq, 0xc * mh);
                            var mH = [mh, mh, mh, mh, mh, mh];
                            mj["set"](mH, 0x6 * mh);
                        }
                        var mx = new TR();
                        mx["setAttribute"]("position", new Rx(mw, 0x3)), mx["setAttribute"]("uv", new Rx(mO, 0x2)), mx["setAttribute"]("faceIndex", new Rx(mj, 0x1)), mN["push"](mx), mP > 0x4 && mP--;
                    }
                    return { _lodPlanes: mN, _sizeLods: mX, _sigmas: mf };
                })(),
                mR = null,
                mT = (0x1 + Math["sqrt"](0x5)) / 0x2,
                mC = 0x1 / mT,
                md = [
                    new Ed(0x1, 0x1, 0x1),
                    new Ed(-0x1, 0x1, 0x1),
                    new Ed(0x1, 0x1, -0x1),
                    new Ed(-0x1, 0x1, -0x1),
                    new Ed(0x0, mT, mC),
                    new Ed(0x0, mT, -mC),
                    new Ed(mC, 0x0, mT),
                    new Ed(-mC, 0x0, mT),
                    new Ed(mT, mC, 0x0),
                    new Ed(-mT, mC, 0x0),
                ];
            function mY(mN) {
                var mX, mf, mP, mI;
                (this["_renderer"] = mN),
                    (this["_pingPongRenderTarget"] = null),
                    (this["_blurMaterial"] =
                        ((mX = m5),
                        (mf = new Float32Array(mX)),
                        (mP = new Ed(0x0, 0x1, 0x0)),
                        ((mI = new Bg({
                            defines: { n: mX },
                            uniforms: {
                                envMap: { value: null },
                                samples: { value: 0x1 },
                                weights: { value: mf },
                                latitudinal: { value: !0x1 },
                                dTheta: { value: 0x0 },
                                mipInt: { value: 0x0 },
                                poleAxis: { value: mP },
                                inputEncoding: { value: m6[0xbb8] },
                                outputEncoding: { value: m6[0xbb8] },
                            },
                            vertexShader: mv(),
                            fragmentShader:
                                "\x0aprecision\x20mediump\x20float;\x0aprecision\x20mediump\x20int;\x0avarying\x20vec3\x20vOutputDirection;\x0auniform\x20sampler2D\x20envMap;\x0auniform\x20int\x20samples;\x0auniform\x20float\x20weights[n];\x0auniform\x20bool\x20latitudinal;\x0auniform\x20float\x20dTheta;\x0auniform\x20float\x20mipInt;\x0auniform\x20vec3\x20poleAxis;\x0a\x0a" +
                                my() +
                                "\x0a\x0a#define\x20ENVMAP_TYPE_CUBE_UV\x0a#include\x20<cube_uv_reflection_fragment>\x0a\x0avec3\x20getSample(float\x20theta,\x20vec3\x20axis)\x20{\x0a\x09float\x20cosTheta\x20=\x20cos(theta);\x0a\x09//\x20Rodrigues\x27\x20axis-angle\x20rotation\x0a\x09vec3\x20sampleDirection\x20=\x20vOutputDirection\x20*\x20cosTheta\x0a\x09\x09+\x20cross(axis,\x20vOutputDirection)\x20*\x20sin(theta)\x0a\x09\x09+\x20axis\x20*\x20dot(axis,\x20vOutputDirection)\x20*\x20(1.0\x20-\x20cosTheta);\x0a\x09return\x20bilinearCubeUV(envMap,\x20sampleDirection,\x20mipInt);\x0a}\x0a\x0avoid\x20main()\x20{\x0a\x09vec3\x20axis\x20=\x20latitudinal\x20?\x20poleAxis\x20:\x20cross(poleAxis,\x20vOutputDirection);\x0a\x09if\x20(all(equal(axis,\x20vec3(0.0))))\x0a\x09\x09axis\x20=\x20vec3(vOutputDirection.z,\x200.0,\x20-\x20vOutputDirection.x);\x0a\x09axis\x20=\x20normalize(axis);\x0a\x09gl_FragColor\x20=\x20vec4(0.0);\x0a\x09gl_FragColor.rgb\x20+=\x20weights[0]\x20*\x20getSample(0.0,\x20axis);\x0a\x09for\x20(int\x20i\x20=\x201;\x20i\x20<\x20n;\x20i++)\x20{\x0a\x09\x09if\x20(i\x20>=\x20samples)\x0a\x09\x09\x09break;\x0a\x09\x09float\x20theta\x20=\x20dTheta\x20*\x20float(i);\x0a\x09\x09gl_FragColor.rgb\x20+=\x20weights[i]\x20*\x20getSample(-1.0\x20*\x20theta,\x20axis);\x0a\x09\x09gl_FragColor.rgb\x20+=\x20weights[i]\x20*\x20getSample(theta,\x20axis);\x0a\x09}\x0a\x09gl_FragColor\x20=\x20linearToOutputTexel(gl_FragColor);\x0a}\x0a\x09\x09",
                            blending: 0x0,
                            depthTest: !0x1,
                            depthWrite: !0x1,
                        }))["type"] = "SphericalGaussianBlur"),
                        mI)),
                    (this["_equirectShader"] = null),
                    (this["_cubemapShader"] = null),
                    this["_compileMaterial"](this["_blurMaterial"]);
            }
            function mB(mN) {
                return void 0x0 !== mN && mN["type"] === rZ && (mN["encoding"] === rW || mN["encoding"] === rH || mN["encoding"] === rx);
            }
            function mF(mN) {
                var mX = new E9(0x3 * m2, 0x3 * m2, mN);
                return (mX["texture"]["mapping"] = r9), (mX["texture"]["name"] = "PMREM.cubeUv"), (mX["scissorTest"] = !0x0), mX;
            }
            function mb(mN, mX, mf, mP, mI) {
                mN["viewport"]["set"](mX, mf, mP, mI), mN["scissor"]["set"](mX, mf, mP, mI);
            }
            function mZ() {
                var mN = new Bg({
                    uniforms: { envMap: { value: null }, texelSize: { value: new E3(0x1, 0x1) }, inputEncoding: { value: m6[0xbb8] }, outputEncoding: { value: m6[0xbb8] } },
                    vertexShader: mv(),
                    fragmentShader:
                        "\x0aprecision\x20mediump\x20float;\x0aprecision\x20mediump\x20int;\x0avarying\x20vec3\x20vOutputDirection;\x0auniform\x20sampler2D\x20envMap;\x0auniform\x20vec2\x20texelSize;\x0a\x0a" +
                        my() +
                        "\x0a\x0a#include\x20<common>\x0a\x0avoid\x20main()\x20{\x0a\x09gl_FragColor\x20=\x20vec4(0.0);\x0a\x09vec3\x20outputDirection\x20=\x20normalize(vOutputDirection);\x0a\x09vec2\x20uv\x20=\x20equirectUv(\x20outputDirection\x20);\x0a\x09vec2\x20f\x20=\x20fract(uv\x20/\x20texelSize\x20-\x200.5);\x0a\x09uv\x20-=\x20f\x20*\x20texelSize;\x0a\x09vec3\x20tl\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x09uv.x\x20+=\x20texelSize.x;\x0a\x09vec3\x20tr\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x09uv.y\x20+=\x20texelSize.y;\x0a\x09vec3\x20br\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x09uv.x\x20-=\x20texelSize.x;\x0a\x09vec3\x20bl\x20=\x20envMapTexelToLinear(texture2D(envMap,\x20uv)).rgb;\x0a\x09vec3\x20tm\x20=\x20mix(tl,\x20tr,\x20f.x);\x0a\x09vec3\x20bm\x20=\x20mix(bl,\x20br,\x20f.x);\x0a\x09gl_FragColor.rgb\x20=\x20mix(tm,\x20bm,\x20f.y);\x0a\x09gl_FragColor\x20=\x20linearToOutputTexel(gl_FragColor);\x0a}\x0a\x09\x09",
                    blending: 0x0,
                    depthTest: !0x1,
                    depthWrite: !0x1,
                });
                return (mN["type"] = "EquirectangularToCubeUV"), mN;
            }
            function mm() {
                var mN = new Bg({
                    uniforms: { envMap: { value: null }, inputEncoding: { value: m6[0xbb8] }, outputEncoding: { value: m6[0xbb8] } },
                    vertexShader: mv(),
                    fragmentShader:
                        "\x0aprecision\x20mediump\x20float;\x0aprecision\x20mediump\x20int;\x0avarying\x20vec3\x20vOutputDirection;\x0auniform\x20samplerCube\x20envMap;\x0a\x0a" +
                        my() +
                        "\x0a\x0avoid\x20main()\x20{\x0a\x09gl_FragColor\x20=\x20vec4(0.0);\x0a\x09gl_FragColor.rgb\x20=\x20envMapTexelToLinear(textureCube(envMap,\x20vec3(\x20-\x20vOutputDirection.x,\x20vOutputDirection.yz\x20))).rgb;\x0a\x09gl_FragColor\x20=\x20linearToOutputTexel(gl_FragColor);\x0a}\x0a\x09\x09",
                    blending: 0x0,
                    depthTest: !0x1,
                    depthWrite: !0x1,
                });
                return (mN["type"] = "CubemapToCubeUV"), mN;
            }
            function mv() {
                return "\x0aprecision\x20mediump\x20float;\x0aprecision\x20mediump\x20int;\x0aattribute\x20vec3\x20position;\x0aattribute\x20vec2\x20uv;\x0aattribute\x20float\x20faceIndex;\x0avarying\x20vec3\x20vOutputDirection;\x0a\x0a//\x20RH\x20coordinate\x20system;\x20PMREM\x20face-indexing\x20convention\x0avec3\x20getDirection(vec2\x20uv,\x20float\x20face)\x20{\x0a\x09uv\x20=\x202.0\x20*\x20uv\x20-\x201.0;\x0a\x09vec3\x20direction\x20=\x20vec3(uv,\x201.0);\x0a\x09if\x20(face\x20==\x200.0)\x20{\x0a\x09\x09direction\x20=\x20direction.zyx;\x20//\x20(\x201,\x20v,\x20u\x20)\x20pos\x20x\x0a\x09}\x20else\x20if\x20(face\x20==\x201.0)\x20{\x0a\x09\x09direction\x20=\x20direction.xzy;\x0a\x09\x09direction.xz\x20*=\x20-1.0;\x20//\x20(\x20-u,\x201,\x20-v\x20)\x20pos\x20y\x0a\x09}\x20else\x20if\x20(face\x20==\x202.0)\x20{\x0a\x09\x09direction.x\x20*=\x20-1.0;\x20//\x20(\x20-u,\x20v,\x201\x20)\x20pos\x20z\x0a\x09}\x20else\x20if\x20(face\x20==\x203.0)\x20{\x0a\x09\x09direction\x20=\x20direction.zyx;\x0a\x09\x09direction.xz\x20*=\x20-1.0;\x20//\x20(\x20-1,\x20v,\x20-u\x20)\x20neg\x20x\x0a\x09}\x20else\x20if\x20(face\x20==\x204.0)\x20{\x0a\x09\x09direction\x20=\x20direction.xzy;\x0a\x09\x09direction.xy\x20*=\x20-1.0;\x20//\x20(\x20-u,\x20-1,\x20v\x20)\x20neg\x20y\x0a\x09}\x20else\x20if\x20(face\x20==\x205.0)\x20{\x0a\x09\x09direction.z\x20*=\x20-1.0;\x20//\x20(\x20u,\x20v,\x20-1\x20)\x20neg\x20z\x0a\x09}\x0a\x09return\x20direction;\x0a}\x0a\x0avoid\x20main()\x20{\x0a\x09vOutputDirection\x20=\x20getDirection(uv,\x20faceIndex);\x0a\x09gl_Position\x20=\x20vec4(\x20position,\x201.0\x20);\x0a}\x0a\x09";
            }
            function my() {
                return "\x0auniform\x20int\x20inputEncoding;\x0auniform\x20int\x20outputEncoding;\x0a\x0a#include\x20<encodings_pars_fragment>\x0a\x0avec4\x20inputTexelToLinear(vec4\x20value){\x0a\x09if(inputEncoding\x20==\x200){\x0a\x09\x09return\x20value;\x0a\x09}else\x20if(inputEncoding\x20==\x201){\x0a\x09\x09return\x20sRGBToLinear(value);\x0a\x09}else\x20if(inputEncoding\x20==\x202){\x0a\x09\x09return\x20RGBEToLinear(value);\x0a\x09}else\x20if(inputEncoding\x20==\x203){\x0a\x09\x09return\x20RGBMToLinear(value,\x207.0);\x0a\x09}else\x20if(inputEncoding\x20==\x204){\x0a\x09\x09return\x20RGBMToLinear(value,\x2016.0);\x0a\x09}else\x20if(inputEncoding\x20==\x205){\x0a\x09\x09return\x20RGBDToLinear(value,\x20256.0);\x0a\x09}else{\x0a\x09\x09return\x20GammaToLinear(value,\x202.2);\x0a\x09}\x0a}\x0a\x0avec4\x20linearToOutputTexel(vec4\x20value){\x0a\x09if(outputEncoding\x20==\x200){\x0a\x09\x09return\x20value;\x0a\x09}else\x20if(outputEncoding\x20==\x201){\x0a\x09\x09return\x20LinearTosRGB(value);\x0a\x09}else\x20if(outputEncoding\x20==\x202){\x0a\x09\x09return\x20LinearToRGBE(value);\x0a\x09}else\x20if(outputEncoding\x20==\x203){\x0a\x09\x09return\x20LinearToRGBM(value,\x207.0);\x0a\x09}else\x20if(outputEncoding\x20==\x204){\x0a\x09\x09return\x20LinearToRGBM(value,\x2016.0);\x0a\x09}else\x20if(outputEncoding\x20==\x205){\x0a\x09\x09return\x20LinearToRGBD(value,\x20256.0);\x0a\x09}else{\x0a\x09\x09return\x20LinearToGamma(value,\x202.2);\x0a\x09}\x0a}\x0a\x0avec4\x20envMapTexelToLinear(vec4\x20color)\x20{\x0a\x09return\x20inputTexelToLinear(color);\x0a}\x0a\x09";
            }
            mY["prototype"] = {
                constructor: mY,
                fromScene: function (mN, mX = 0x0, mf = 0.1, mP = 0x64) {
                    mR = this["_renderer"]["getRenderTarget"]();
                    var mI = this["_allocateTargets"]();
                    return this["_sceneToCubeUV"](mN, mf, mP, mI), mX > 0x0 && this["_blur"](mI, 0x0, 0x0, mX), this["_applyPMREM"](mI), this["_cleanup"](mI), mI;
                },
                fromEquirectangular: function (mN) {
                    return (mN["magFilter"] = rC), (mN["minFilter"] = rC), (mN["generateMipmaps"] = !0x1), this["fromCubemap"](mN);
                },
                fromCubemap: function (mN) {
                    mR = this["_renderer"]["getRenderTarget"]();
                    var mX = this["_allocateTargets"](mN);
                    return this["_textureToCubeUV"](mN, mX), this["_applyPMREM"](mX), this["_cleanup"](mX), mX;
                },
                compileCubemapShader: function () {
                    null === this["_cubemapShader"] && ((this["_cubemapShader"] = mm()), this["_compileMaterial"](this["_cubemapShader"]));
                },
                compileEquirectangularShader: function () {
                    null === this["_equirectShader"] && ((this["_equirectShader"] = mZ()), this["_compileMaterial"](this["_equirectShader"]));
                },
                dispose: function () {
                    this["_blurMaterial"]["dispose"](), null !== this["_cubemapShader"] && this["_cubemapShader"]["dispose"](), null !== this["_equirectShader"] && this["_equirectShader"]["dispose"]();
                    for (var mN = 0x0; mN < m8["length"]; mN++) m8[mN]["dispose"]();
                },
                _cleanup: function (mN) {
                    this["_pingPongRenderTarget"]["dispose"](), this["_renderer"]["setRenderTarget"](mR), (mN["scissorTest"] = !0x1), mN["setSize"](mN["width"], mN["height"]);
                },
                _allocateTargets: function (mN) {
                    var mX = { magFilter: rC, minFilter: rC, generateMipmaps: !0x1, type: rZ, format: rP, encoding: mB(mN) ? mN["encoding"] : rK, depthBuffer: !0x1, stencilBuffer: !0x1 },
                        mf = mF(mX);
                    return (mf["depthBuffer"] = !mN), (this["_pingPongRenderTarget"] = mF(mX)), mf;
                },
                _compileMaterial: function (mN) {
                    var mX = new TA(m8[0x0], mN);
                    this["_renderer"]["compile"](mX, m7);
                },
                _sceneToCubeUV: function (mN, mX, mf, mP) {
                    var mI = new Tx(0x5a, 0x1, mX, mf),
                        mA = [0x1, -0x1, 0x1, 0x1, 0x1, 0x1],
                        mM = [0x1, 0x1, 0x1, -0x1, -0x1, -0x1],
                        mp = this["_renderer"],
                        mk = mp["outputEncoding"],
                        mU = mp["toneMapping"],
                        mq = mp["toneMappingExposure"],
                        mw = mp["getClearColor"](),
                        mO = mp["getClearAlpha"]();
                    (mp["toneMapping"] = 0x1), (mp["toneMappingExposure"] = 0x1), (mp["outputEncoding"] = rW);
                    var mj = mN["background"];
                    if (mj && mj["isColor"]) {
                        mj["convertSRGBToLinear"]();
                        var mh = Math["max"](mj["r"], mj["g"], mj["b"]),
                            mS = Math["min"](Math["max"](Math["ceil"](Math["log2"](mh)), -0x80), 0x7f);
                        mj = mj["multiplyScalar"](Math["pow"](0x2, -mS));
                        var mg = (mS + 0x80) / 0xff;
                        mp["setClearColor"](mj, mg), (mN["background"] = null);
                    }
                    for (var mW = 0x0; mW < 0x6; mW++) {
                        var mH = mW % 0x3;
                        0x0 == mH
                            ? (mI["up"]["set"](0x0, mA[mW], 0x0), mI["lookAt"](mM[mW], 0x0, 0x0))
                            : 0x1 == mH
                            ? (mI["up"]["set"](0x0, 0x0, mA[mW]), mI["lookAt"](0x0, mM[mW], 0x0))
                            : (mI["up"]["set"](0x0, mA[mW], 0x0), mI["lookAt"](0x0, 0x0, mM[mW])),
                            mb(mP, mH * m2, mW > 0x2 ? m2 : 0x0, m2, m2),
                            mp["setRenderTarget"](mP),
                            mp["render"](mN, mI);
                    }
                    (mp["toneMapping"] = mU), (mp["toneMappingExposure"] = mq), (mp["outputEncoding"] = mk), mp["setClearColor"](mw, mO);
                },
                _textureToCubeUV: function (mN, mX) {
                    var mf = this["_renderer"];
                    mN["isCubeTexture"] ? null == this["_cubemapShader"] && (this["_cubemapShader"] = mm()) : null == this["_equirectShader"] && (this["_equirectShader"] = mZ());
                    var mP = mN["isCubeTexture"] ? this["_cubemapShader"] : this["_equirectShader"],
                        mI = new TA(m8[0x0], mP),
                        mA = mP["uniforms"];
                    (mA["envMap"]["value"] = mN),
                        mN["isCubeTexture"] || mA["texelSize"]["value"]["set"](0x1 / mN["image"]["width"], 0x1 / mN["image"]["height"]),
                        (mA["inputEncoding"]["value"] = m6[mN["encoding"]]),
                        (mA["outputEncoding"]["value"] = m6[mX["texture"]["encoding"]]),
                        mb(mX, 0x0, 0x0, 0x3 * m2, 0x2 * m2),
                        mf["setRenderTarget"](mX),
                        mf["render"](mI, m7);
                },
                _applyPMREM: function (mN) {
                    var mX = this["_renderer"],
                        mf = mX["autoClear"];
                    mX["autoClear"] = !0x1;
                    for (var mP = 0x1; mP < m4; mP++) {
                        var mI = Math["sqrt"](mE[mP] * mE[mP] - mE[mP - 0x1] * mE[mP - 0x1]),
                            mA = md[(mP - 0x1) % md["length"]];
                        this["_blur"](mN, mP - 0x1, mP, mI, mA);
                    }
                    mX["autoClear"] = mf;
                },
                _blur: function (mN, mX, mf, mP, mI) {
                    var mA = this["_pingPongRenderTarget"];
                    this["_halfBlur"](mN, mA, mX, mf, mP, "latitudinal", mI), this["_halfBlur"](mA, mN, mf, mf, mP, "longitudinal", mI);
                },
                _halfBlur: function (mN, mX, mf, mP, mI, mA, mM) {
                    var mp = this["_renderer"],
                        mk = this["_blurMaterial"];
                    "latitudinal" !== mA && "longitudinal" !== mA && console["error"]("blur\x20direction\x20must\x20be\x20either\x20latitudinal\x20or\x20longitudinal!");
                    var mU = new TA(m8[mP], mk),
                        mq = mk["uniforms"],
                        mw = m9[mf] - 0x1,
                        mO = isFinite(mI) ? Math["PI"] / (0x2 * mw) : (0x2 * Math["PI"]) / 0x27,
                        mj = mI / mO,
                        mh = isFinite(mI) ? 0x1 + Math["floor"](0x3 * mj) : m5;
                    mh > m5 && console["warn"]("sigmaRadians,\x20" + mI + ",\x20is\x20too\x20large\x20and\x20will\x20clip,\x20as\x20it\x20requested\x20" + mh + "\x20samples\x20when\x20the\x20maximum\x20is\x20set\x20to\x2020");
                    for (var mS = [], mg = 0x0, mW = 0x0; mW < m5; ++mW) {
                        var mH = mW / mj,
                            mx = Math["exp"]((-mH * mH) / 0x2);
                        mS["push"](mx), 0x0 == mW ? (mg += mx) : mW < mh && (mg += 0x2 * mx);
                    }
                    for (mW = 0x0; mW < mS["length"]; mW++) mS[mW] = mS[mW] / mg;
                    (mq["envMap"]["value"] = mN["texture"]),
                        (mq["samples"]["value"] = mh),
                        (mq["weights"]["value"] = mS),
                        (mq["latitudinal"]["value"] = "latitudinal" === mA),
                        mM && (mq["poleAxis"]["value"] = mM),
                        (mq["dTheta"]["value"] = mO),
                        (mq["mipInt"]["value"] = 0x8 - mf),
                        (mq["inputEncoding"]["value"] = m6[mN["texture"]["encoding"]]),
                        (mq["outputEncoding"]["value"] = m6[mN["texture"]["encoding"]]);
                    var mK = m9[mP];
                    mb(mX, (mH = 0x3 * Math["max"](0x0, m2 - 0x2 * mK)), (0x0 === mP ? 0x0 : 0x2 * m2) + 0x2 * mK * (mP > 0x4 ? mP - 0x8 + 0x4 : 0x0), 0x3 * mK, 0x2 * mK), mp["setRenderTarget"](mX), mp["render"](mU, m7);
                },
            };
            function mD(mN) {
                console["warn"]("THREE.Spline\x20has\x20been\x20removed.\x20Use\x20THREE.CatmullRomCurve3\x20instead."), Fq["call"](this, mN), (this["type"] = "catmullrom");
            }
            (Ff["create"] = function (mN, mX) {
                return console["log"]("THREE.Curve.create()\x20has\x20been\x20deprecated"), (mN["prototype"] = Object["create"](Ff["prototype"])), (mN["prototype"]["constructor"] = mN), (mN["prototype"]["getPoint"] = mX), mN;
            }),
                Object["assign"](FJ["prototype"], {
                    createPointsGeometry: function (mN) {
                        console["warn"]("THREE.CurvePath:\x20.createPointsGeometry()\x20has\x20been\x20removed.\x20Use\x20new\x20THREE.Geometry().setFromPoints(\x20points\x20)\x20instead.");
                        var mX = this["getPoints"](mN);
                        return this["createGeometry"](mX);
                    },
                    createSpacedPointsGeometry: function (mN) {
                        console["warn"]("THREE.CurvePath:\x20.createSpacedPointsGeometry()\x20has\x20been\x20removed.\x20Use\x20new\x20THREE.Geometry().setFromPoints(\x20points\x20)\x20instead.");
                        var mX = this["getSpacedPoints"](mN);
                        return this["createGeometry"](mX);
                    },
                    createGeometry: function (mN) {
                        console["warn"]("THREE.CurvePath:\x20.createGeometry()\x20has\x20been\x20removed.\x20Use\x20new\x20THREE.Geometry().setFromPoints(\x20points\x20)\x20instead.");
                        for (var mX = new TO(), mf = 0x0, mP = mN["length"]; mf < mP; mf++) {
                            var mI = mN[mf];
                            mX["vertices"]["push"](new Ed(mI["x"], mI["y"], mI["z"] || 0x0));
                        }
                        return mX;
                    },
                }),
                Object["assign"](FG["prototype"], {
                    fromPoints: function (mN) {
                        return console["warn"]("THREE.Path:\x20.fromPoints()\x20has\x20been\x20renamed\x20to\x20.setFromPoints()."), this["setFromPoints"](mN);
                    },
                }),
                Object["create"](Fq["prototype"]),
                Object["create"](Fq["prototype"]),
                (mD["prototype"] = Object["create"](Fq["prototype"])),
                Object["assign"](mD["prototype"], {
                    initFromArray: function () {
                        console["error"]("THREE.Spline:\x20.initFromArray()\x20has\x20been\x20removed.");
                    },
                    getControlPointsArray: function () {
                        console["error"]("THREE.Spline:\x20.getControlPointsArray()\x20has\x20been\x20removed.");
                    },
                    reparametrizeByArcLength: function () {
                        console["error"]("THREE.Spline:\x20.reparametrizeByArcLength()\x20has\x20been\x20removed.");
                    },
                }),
                (Zq["prototype"]["setColors"] = function () {
                    console["error"]("THREE.GridHelper:\x20setColors()\x20has\x20been\x20deprecated,\x20pass\x20them\x20in\x20the\x20constructor\x20instead.");
                }),
                (ZA["prototype"]["update"] = function () {
                    console["error"]("THREE.SkeletonHelper:\x20update()\x20no\x20longer\x20needs\x20to\x20be\x20called.");
                }),
                Object["assign"](FF["prototype"], {
                    extractUrlBase: function (mN) {
                        return console["warn"]("THREE.Loader:\x20.extractUrlBase()\x20has\x20been\x20deprecated.\x20Use\x20THREE.LoaderUtils.extractUrlBase()\x20instead."), bC["extractUrlBase"](mN);
                    },
                }),
                (FF["Handlers"] = {
                    add: function () {
                        console["error"]("THREE.Loader:\x20Handlers.add()\x20has\x20been\x20removed.\x20Use\x20LoadingManager.addHandler()\x20instead.");
                    },
                    get: function () {
                        console["error"]("THREE.Loader:\x20Handlers.get()\x20has\x20been\x20removed.\x20Use\x20LoadingManager.getHandler()\x20instead.");
                    },
                }),
                Object["assign"](bb["prototype"], {
                    setTexturePath: function (mN) {
                        return console["warn"]("THREE.ObjectLoader:\x20.setTexturePath()\x20has\x20been\x20renamed\x20to\x20.setResourcePath()."), this["setResourcePath"](mN);
                    },
                }),
                Object["assign"](Zb["prototype"], {
                    center: function (mN) {
                        return console["warn"]("THREE.Box2:\x20.center()\x20has\x20been\x20renamed\x20to\x20.getCenter()."), this["getCenter"](mN);
                    },
                    empty: function () {
                        return console["warn"]("THREE.Box2:\x20.empty()\x20has\x20been\x20renamed\x20to\x20.isEmpty()."), this["isEmpty"]();
                    },
                    isIntersectionBox: function (mN) {
                        return console["warn"]("THREE.Box2:\x20.isIntersectionBox()\x20has\x20been\x20renamed\x20to\x20.intersectsBox()."), this["intersectsBox"](mN);
                    },
                    size: function (mN) {
                        return console["warn"]("THREE.Box2:\x20.size()\x20has\x20been\x20renamed\x20to\x20.getSize()."), this["getSize"](mN);
                    },
                }),
                Object["assign"](R4["prototype"], {
                    center: function (mN) {
                        return console["warn"]("THREE.Box3:\x20.center()\x20has\x20been\x20renamed\x20to\x20.getCenter()."), this["getCenter"](mN);
                    },
                    empty: function () {
                        return console["warn"]("THREE.Box3:\x20.empty()\x20has\x20been\x20renamed\x20to\x20.isEmpty()."), this["isEmpty"]();
                    },
                    isIntersectionBox: function (mN) {
                        return console["warn"]("THREE.Box3:\x20.isIntersectionBox()\x20has\x20been\x20renamed\x20to\x20.intersectsBox()."), this["intersectsBox"](mN);
                    },
                    isIntersectionSphere: function (mN) {
                        return console["warn"]("THREE.Box3:\x20.isIntersectionSphere()\x20has\x20been\x20renamed\x20to\x20.intersectsSphere()."), this["intersectsSphere"](mN);
                    },
                    size: function (mN) {
                        return console["warn"]("THREE.Box3:\x20.size()\x20has\x20been\x20renamed\x20to\x20.getSize()."), this["getSize"](mN);
                    },
                }),
                Object["assign"](R7["prototype"], {
                    empty: function () {
                        return console["warn"]("THREE.Sphere:\x20.empty()\x20has\x20been\x20renamed\x20to\x20.isEmpty()."), this["isEmpty"]();
                    },
                }),
                (Tz["prototype"]["setFromMatrix"] = function (mN) {
                    return console["warn"]("THREE.Frustum:\x20.setFromMatrix()\x20has\x20been\x20renamed\x20to\x20.setFromProjectionMatrix()."), this["setFromProjectionMatrix"](mN);
                }),
                (Zv["prototype"]["center"] = function (mN) {
                    return console["warn"]("THREE.Line3:\x20.center()\x20has\x20been\x20renamed\x20to\x20.getCenter()."), this["getCenter"](mN);
                }),
                Object["assign"](E2, {
                    random16: function () {
                        return console["warn"]("THREE.Math:\x20.random16()\x20has\x20been\x20deprecated.\x20Use\x20Math.random()\x20instead."), Math["random"]();
                    },
                    nearestPowerOfTwo: function (mN) {
                        return console["warn"]("THREE.Math:\x20.nearestPowerOfTwo()\x20has\x20been\x20renamed\x20to\x20.floorPowerOfTwo()."), E2["floorPowerOfTwo"](mN);
                    },
                    nextPowerOfTwo: function (mN) {
                        return console["warn"]("THREE.Math:\x20.nextPowerOfTwo()\x20has\x20been\x20renamed\x20to\x20.ceilPowerOfTwo()."), E2["ceilPowerOfTwo"](mN);
                    },
                }),
                Object["assign"](E4["prototype"], {
                    flattenToArrayOffset: function (mN, mX) {
                        return console["warn"]("THREE.Matrix3:\x20.flattenToArrayOffset()\x20has\x20been\x20deprecated.\x20Use\x20.toArray()\x20instead."), this["toArray"](mN, mX);
                    },
                    multiplyVector3: function (mN) {
                        return console["warn"]("THREE.Matrix3:\x20.multiplyVector3()\x20has\x20been\x20removed.\x20Use\x20vector.applyMatrix3(\x20matrix\x20)\x20instead."), mN["applyMatrix3"](this);
                    },
                    multiplyVector3Array: function () {
                        console["error"]("THREE.Matrix3:\x20.multiplyVector3Array()\x20has\x20been\x20removed.");
                    },
                    applyToBufferAttribute: function (mN) {
                        return console["warn"]("THREE.Matrix3:\x20.applyToBufferAttribute()\x20has\x20been\x20removed.\x20Use\x20attribute.applyMatrix3(\x20matrix\x20)\x20instead."), mN["applyMatrix3"](this);
                    },
                    applyToVector3Array: function () {
                        console["error"]("THREE.Matrix3:\x20.applyToVector3Array()\x20has\x20been\x20removed.");
                    },
                }),
                Object["assign"](Ey["prototype"], {
                    extractPosition: function (mN) {
                        return console["warn"]("THREE.Matrix4:\x20.extractPosition()\x20has\x20been\x20renamed\x20to\x20.copyPosition()."), this["copyPosition"](mN);
                    },
                    flattenToArrayOffset: function (mN, mX) {
                        return console["warn"]("THREE.Matrix4:\x20.flattenToArrayOffset()\x20has\x20been\x20deprecated.\x20Use\x20.toArray()\x20instead."), this["toArray"](mN, mX);
                    },
                    getPosition: function () {
                        return console["warn"]("THREE.Matrix4:\x20.getPosition()\x20has\x20been\x20removed.\x20Use\x20Vector3.setFromMatrixPosition(\x20matrix\x20)\x20instead."), new Ed()["setFromMatrixColumn"](this, 0x3);
                    },
                    setRotationFromQuaternion: function (mN) {
                        return console["warn"]("THREE.Matrix4:\x20.setRotationFromQuaternion()\x20has\x20been\x20renamed\x20to\x20.makeRotationFromQuaternion()."), this["makeRotationFromQuaternion"](mN);
                    },
                    multiplyToArray: function () {
                        console["warn"]("THREE.Matrix4:\x20.multiplyToArray()\x20has\x20been\x20removed.");
                    },
                    multiplyVector3: function (mN) {
                        return console["warn"]("THREE.Matrix4:\x20.multiplyVector3()\x20has\x20been\x20removed.\x20Use\x20vector.applyMatrix4(\x20matrix\x20)\x20instead."), mN["applyMatrix4"](this);
                    },
                    multiplyVector4: function (mN) {
                        return console["warn"]("THREE.Matrix4:\x20.multiplyVector4()\x20has\x20been\x20removed.\x20Use\x20vector.applyMatrix4(\x20matrix\x20)\x20instead."), mN["applyMatrix4"](this);
                    },
                    multiplyVector3Array: function () {
                        console["error"]("THREE.Matrix4:\x20.multiplyVector3Array()\x20has\x20been\x20removed.");
                    },
                    rotateAxis: function (mN) {
                        console["warn"]("THREE.Matrix4:\x20.rotateAxis()\x20has\x20been\x20removed.\x20Use\x20Vector3.transformDirection(\x20matrix\x20)\x20instead."), mN["transformDirection"](this);
                    },
                    crossVector: function (mN) {
                        return console["warn"]("THREE.Matrix4:\x20.crossVector()\x20has\x20been\x20removed.\x20Use\x20vector.applyMatrix4(\x20matrix\x20)\x20instead."), mN["applyMatrix4"](this);
                    },
                    translate: function () {
                        console["error"]("THREE.Matrix4:\x20.translate()\x20has\x20been\x20removed.");
                    },
                    rotateX: function () {
                        console["error"]("THREE.Matrix4:\x20.rotateX()\x20has\x20been\x20removed.");
                    },
                    rotateY: function () {
                        console["error"]("THREE.Matrix4:\x20.rotateY()\x20has\x20been\x20removed.");
                    },
                    rotateZ: function () {
                        console["error"]("THREE.Matrix4:\x20.rotateZ()\x20has\x20been\x20removed.");
                    },
                    rotateByAxis: function () {
                        console["error"]("THREE.Matrix4:\x20.rotateByAxis()\x20has\x20been\x20removed.");
                    },
                    applyToBufferAttribute: function (mN) {
                        return console["warn"]("THREE.Matrix4:\x20.applyToBufferAttribute()\x20has\x20been\x20removed.\x20Use\x20attribute.applyMatrix4(\x20matrix\x20)\x20instead."), mN["applyMatrix4"](this);
                    },
                    applyToVector3Array: function () {
                        console["error"]("THREE.Matrix4:\x20.applyToVector3Array()\x20has\x20been\x20removed.");
                    },
                    makeFrustum: function (mN, mX, mf, mP, mI, mA) {
                        return (
                            console["warn"]("THREE.Matrix4:\x20.makeFrustum()\x20has\x20been\x20removed.\x20Use\x20.makePerspective(\x20left,\x20right,\x20top,\x20bottom,\x20near,\x20far\x20)\x20instead."),
                            this["makePerspective"](mN, mX, mP, mf, mI, mA)
                        );
                    },
                }),
                (RZ["prototype"]["isIntersectionLine"] = function (mN) {
                    return console["warn"]("THREE.Plane:\x20.isIntersectionLine()\x20has\x20been\x20renamed\x20to\x20.intersectsLine()."), this["intersectsLine"](mN);
                }),
                (ER["prototype"]["multiplyVector3"] = function (mN) {
                    return console["warn"]("THREE.Quaternion:\x20.multiplyVector3()\x20has\x20been\x20removed.\x20Use\x20is\x20now\x20vector.applyQuaternion(\x20quaternion\x20)\x20instead."), mN["applyQuaternion"](this);
                }),
                Object["assign"](RY["prototype"], {
                    isIntersectionBox: function (mN) {
                        return console["warn"]("THREE.Ray:\x20.isIntersectionBox()\x20has\x20been\x20renamed\x20to\x20.intersectsBox()."), this["intersectsBox"](mN);
                    },
                    isIntersectionPlane: function (mN) {
                        return console["warn"]("THREE.Ray:\x20.isIntersectionPlane()\x20has\x20been\x20renamed\x20to\x20.intersectsPlane()."), this["intersectsPlane"](mN);
                    },
                    isIntersectionSphere: function (mN) {
                        return console["warn"]("THREE.Ray:\x20.isIntersectionSphere()\x20has\x20been\x20renamed\x20to\x20.intersectsSphere()."), this["intersectsSphere"](mN);
                    },
                }),
                Object["assign"](RM["prototype"], {
                    area: function () {
                        return console["warn"]("THREE.Triangle:\x20.area()\x20has\x20been\x20renamed\x20to\x20.getArea()."), this["getArea"]();
                    },
                    barycoordFromPoint: function (mN, mX) {
                        return console["warn"]("THREE.Triangle:\x20.barycoordFromPoint()\x20has\x20been\x20renamed\x20to\x20.getBarycoord()."), this["getBarycoord"](mN, mX);
                    },
                    midpoint: function (mN) {
                        return console["warn"]("THREE.Triangle:\x20.midpoint()\x20has\x20been\x20renamed\x20to\x20.getMidpoint()."), this["getMidpoint"](mN);
                    },
                    normal: function (mN) {
                        return console["warn"]("THREE.Triangle:\x20.normal()\x20has\x20been\x20renamed\x20to\x20.getNormal()."), this["getNormal"](mN);
                    },
                    plane: function (mN) {
                        return console["warn"]("THREE.Triangle:\x20.plane()\x20has\x20been\x20renamed\x20to\x20.getPlane()."), this["getPlane"](mN);
                    },
                }),
                Object["assign"](RM, {
                    barycoordFromPoint: function (mN, mX, mf, mP, mI) {
                        return console["warn"]("THREE.Triangle:\x20.barycoordFromPoint()\x20has\x20been\x20renamed\x20to\x20.getBarycoord()."), RM["getBarycoord"](mN, mX, mf, mP, mI);
                    },
                    normal: function (mN, mX, mf, mP) {
                        return console["warn"]("THREE.Triangle:\x20.normal()\x20has\x20been\x20renamed\x20to\x20.getNormal()."), RM["getNormal"](mN, mX, mf, mP);
                    },
                }),
                Object["assign"](FL["prototype"], {
                    extractAllPoints: function (mN) {
                        return console["warn"]("THREE.Shape:\x20.extractAllPoints()\x20has\x20been\x20removed.\x20Use\x20.extractPoints()\x20instead."), this["extractPoints"](mN);
                    },
                    extrude: function (mN) {
                        return console["warn"]("THREE.Shape:\x20.extrude()\x20has\x20been\x20removed.\x20Use\x20ExtrudeGeometry()\x20instead."), new BB(this, mN);
                    },
                    makeGeometry: function (mN) {
                        return console["warn"]("THREE.Shape:\x20.makeGeometry()\x20has\x20been\x20removed.\x20Use\x20ShapeGeometry()\x20instead."), new BI(this, mN);
                    },
                }),
                Object["assign"](E3["prototype"], {
                    fromAttribute: function (mN, mX, mf) {
                        return console["warn"]("THREE.Vector2:\x20.fromAttribute()\x20has\x20been\x20renamed\x20to\x20.fromBufferAttribute()."), this["fromBufferAttribute"](mN, mX, mf);
                    },
                    distanceToManhattan: function (mN) {
                        return console["warn"]("THREE.Vector2:\x20.distanceToManhattan()\x20has\x20been\x20renamed\x20to\x20.manhattanDistanceTo()."), this["manhattanDistanceTo"](mN);
                    },
                    lengthManhattan: function () {
                        return console["warn"]("THREE.Vector2:\x20.lengthManhattan()\x20has\x20been\x20renamed\x20to\x20.manhattanLength()."), this["manhattanLength"]();
                    },
                }),
                Object["assign"](Ed["prototype"], {
                    setEulerFromRotationMatrix: function () {
                        console["error"]("THREE.Vector3:\x20.setEulerFromRotationMatrix()\x20has\x20been\x20removed.\x20Use\x20Euler.setFromRotationMatrix()\x20instead.");
                    },
                    setEulerFromQuaternion: function () {
                        console["error"]("THREE.Vector3:\x20.setEulerFromQuaternion()\x20has\x20been\x20removed.\x20Use\x20Euler.setFromQuaternion()\x20instead.");
                    },
                    getPositionFromMatrix: function (mN) {
                        return console["warn"]("THREE.Vector3:\x20.getPositionFromMatrix()\x20has\x20been\x20renamed\x20to\x20.setFromMatrixPosition()."), this["setFromMatrixPosition"](mN);
                    },
                    getScaleFromMatrix: function (mN) {
                        return console["warn"]("THREE.Vector3:\x20.getScaleFromMatrix()\x20has\x20been\x20renamed\x20to\x20.setFromMatrixScale()."), this["setFromMatrixScale"](mN);
                    },
                    getColumnFromMatrix: function (mN, mX) {
                        return console["warn"]("THREE.Vector3:\x20.getColumnFromMatrix()\x20has\x20been\x20renamed\x20to\x20.setFromMatrixColumn()."), this["setFromMatrixColumn"](mX, mN);
                    },
                    applyProjection: function (mN) {
                        return console["warn"]("THREE.Vector3:\x20.applyProjection()\x20has\x20been\x20removed.\x20Use\x20.applyMatrix4(\x20m\x20)\x20instead."), this["applyMatrix4"](mN);
                    },
                    fromAttribute: function (mN, mX, mf) {
                        return console["warn"]("THREE.Vector3:\x20.fromAttribute()\x20has\x20been\x20renamed\x20to\x20.fromBufferAttribute()."), this["fromBufferAttribute"](mN, mX, mf);
                    },
                    distanceToManhattan: function (mN) {
                        return console["warn"]("THREE.Vector3:\x20.distanceToManhattan()\x20has\x20been\x20renamed\x20to\x20.manhattanDistanceTo()."), this["manhattanDistanceTo"](mN);
                    },
                    lengthManhattan: function () {
                        return console["warn"]("THREE.Vector3:\x20.lengthManhattan()\x20has\x20been\x20renamed\x20to\x20.manhattanLength()."), this["manhattanLength"]();
                    },
                }),
                Object["assign"](E8["prototype"], {
                    fromAttribute: function (mN, mX, mf) {
                        return console["warn"]("THREE.Vector4:\x20.fromAttribute()\x20has\x20been\x20renamed\x20to\x20.fromBufferAttribute()."), this["fromBufferAttribute"](mN, mX, mf);
                    },
                    lengthManhattan: function () {
                        return console["warn"]("THREE.Vector4:\x20.lengthManhattan()\x20has\x20been\x20renamed\x20to\x20.manhattanLength()."), this["manhattanLength"]();
                    },
                }),
                Object["assign"](TO["prototype"], {
                    computeTangents: function () {
                        console["error"]("THREE.Geometry:\x20.computeTangents()\x20has\x20been\x20removed.");
                    },
                    computeLineDistances: function () {
                        console["error"]("THREE.Geometry:\x20.computeLineDistances()\x20has\x20been\x20removed.\x20Use\x20THREE.Line.computeLineDistances()\x20instead.");
                    },
                    applyMatrix: function (mN) {
                        return console["warn"]("THREE.Geometry:\x20.applyMatrix()\x20has\x20been\x20renamed\x20to\x20.applyMatrix4()."), this["applyMatrix4"](mN);
                    },
                }),
                Object["assign"](Eg["prototype"], {
                    getChildByName: function (mN) {
                        return console["warn"]("THREE.Object3D:\x20.getChildByName()\x20has\x20been\x20renamed\x20to\x20.getObjectByName()."), this["getObjectByName"](mN);
                    },
                    renderDepth: function () {
                        console["warn"]("THREE.Object3D:\x20.renderDepth\x20has\x20been\x20removed.\x20Use\x20.renderOrder,\x20instead.");
                    },
                    translate: function (mN, mX) {
                        return console["warn"]("THREE.Object3D:\x20.translate()\x20has\x20been\x20removed.\x20Use\x20.translateOnAxis(\x20axis,\x20distance\x20)\x20instead."), this["translateOnAxis"](mX, mN);
                    },
                    getWorldRotation: function () {
                        console["error"]("THREE.Object3D:\x20.getWorldRotation()\x20has\x20been\x20removed.\x20Use\x20THREE.Object3D.getWorldQuaternion(\x20target\x20)\x20instead.");
                    },
                    applyMatrix: function (mN) {
                        return console["warn"]("THREE.Object3D:\x20.applyMatrix()\x20has\x20been\x20renamed\x20to\x20.applyMatrix4()."), this["applyMatrix4"](mN);
                    },
                }),
                Object["defineProperties"](Eg["prototype"], {
                    eulerOrder: {
                        get: function () {
                            return console["warn"]("THREE.Object3D:\x20.eulerOrder\x20is\x20now\x20.rotation.order."), this["rotation"]["order"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.Object3D:\x20.eulerOrder\x20is\x20now\x20.rotation.order."), (this["rotation"]["order"] = mN);
                        },
                    },
                    useQuaternion: {
                        get: function () {
                            console["warn"]("THREE.Object3D:\x20.useQuaternion\x20has\x20been\x20removed.\x20The\x20library\x20now\x20uses\x20quaternions\x20by\x20default.");
                        },
                        set: function () {
                            console["warn"]("THREE.Object3D:\x20.useQuaternion\x20has\x20been\x20removed.\x20The\x20library\x20now\x20uses\x20quaternions\x20by\x20default.");
                        },
                    },
                }),
                Object["assign"](TA["prototype"], {
                    setDrawMode: function () {
                        console["error"](
                            "THREE.Mesh:\x20.setDrawMode()\x20has\x20been\x20removed.\x20The\x20renderer\x20now\x20always\x20assumes\x20THREE.TrianglesDrawMode.\x20Transform\x20your\x20geometry\x20via\x20BufferGeometryUtils.toTrianglesDrawMode()\x20if\x20necessary."
                        );
                    },
                }),
                Object["defineProperties"](TA["prototype"], {
                    drawMode: {
                        get: function () {
                            return console["error"]("THREE.Mesh:\x20.drawMode\x20has\x20been\x20removed.\x20The\x20renderer\x20now\x20always\x20assumes\x20THREE.TrianglesDrawMode."), 0x0;
                        },
                        set: function () {
                            console["error"](
                                "THREE.Mesh:\x20.drawMode\x20has\x20been\x20removed.\x20The\x20renderer\x20now\x20always\x20assumes\x20THREE.TrianglesDrawMode.\x20Transform\x20your\x20geometry\x20via\x20BufferGeometryUtils.toTrianglesDrawMode()\x20if\x20necessary."
                            );
                        },
                    },
                }),
                Object["defineProperties"](Yh["prototype"], {
                    objects: {
                        get: function () {
                            return console["warn"]("THREE.LOD:\x20.objects\x20has\x20been\x20renamed\x20to\x20.levels."), this["levels"];
                        },
                    },
                }),
                Object["defineProperty"](YH["prototype"], "useVertexTexture", {
                    get: function () {
                        console["warn"]("THREE.Skeleton:\x20useVertexTexture\x20has\x20been\x20removed.");
                    },
                    set: function () {
                        console["warn"]("THREE.Skeleton:\x20useVertexTexture\x20has\x20been\x20removed.");
                    },
                }),
                (YS["prototype"]["initBones"] = function () {
                    console["error"]("THREE.SkinnedMesh:\x20initBones()\x20has\x20been\x20removed.");
                }),
                Object["defineProperty"](Ff["prototype"], "__arcLengthDivisions", {
                    get: function () {
                        return console["warn"]("THREE.Curve:\x20.__arcLengthDivisions\x20is\x20now\x20.arcLengthDivisions."), this["arcLengthDivisions"];
                    },
                    set: function (mN) {
                        console["warn"]("THREE.Curve:\x20.__arcLengthDivisions\x20is\x20now\x20.arcLengthDivisions."), (this["arcLengthDivisions"] = mN);
                    },
                }),
                (Tx["prototype"]["setLens"] = function (mN, mX) {
                    console["warn"]("THREE.PerspectiveCamera.setLens\x20is\x20deprecated.\x20Use\x20.setFocalLength\x20and\x20.filmGauge\x20for\x20a\x20photographic\x20setup."),
                        void 0x0 !== mX && (this["filmGauge"] = mX),
                        this["setFocalLength"](mN);
                }),
                Object["defineProperties"](FQ["prototype"], {
                    onlyShadow: {
                        set: function () {
                            console["warn"]("THREE.Light:\x20.onlyShadow\x20has\x20been\x20removed.");
                        },
                    },
                    shadowCameraFov: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraFov\x20is\x20now\x20.shadow.camera.fov."), (this["shadow"]["camera"]["fov"] = mN);
                        },
                    },
                    shadowCameraLeft: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraLeft\x20is\x20now\x20.shadow.camera.left."), (this["shadow"]["camera"]["left"] = mN);
                        },
                    },
                    shadowCameraRight: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraRight\x20is\x20now\x20.shadow.camera.right."), (this["shadow"]["camera"]["right"] = mN);
                        },
                    },
                    shadowCameraTop: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraTop\x20is\x20now\x20.shadow.camera.top."), (this["shadow"]["camera"]["top"] = mN);
                        },
                    },
                    shadowCameraBottom: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraBottom\x20is\x20now\x20.shadow.camera.bottom."), (this["shadow"]["camera"]["bottom"] = mN);
                        },
                    },
                    shadowCameraNear: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraNear\x20is\x20now\x20.shadow.camera.near."), (this["shadow"]["camera"]["near"] = mN);
                        },
                    },
                    shadowCameraFar: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowCameraFar\x20is\x20now\x20.shadow.camera.far."), (this["shadow"]["camera"]["far"] = mN);
                        },
                    },
                    shadowCameraVisible: {
                        set: function () {
                            console["warn"]("THREE.Light:\x20.shadowCameraVisible\x20has\x20been\x20removed.\x20Use\x20new\x20THREE.CameraHelper(\x20light.shadow.camera\x20)\x20instead.");
                        },
                    },
                    shadowBias: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowBias\x20is\x20now\x20.shadow.bias."), (this["shadow"]["bias"] = mN);
                        },
                    },
                    shadowDarkness: {
                        set: function () {
                            console["warn"]("THREE.Light:\x20.shadowDarkness\x20has\x20been\x20removed.");
                        },
                    },
                    shadowMapWidth: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowMapWidth\x20is\x20now\x20.shadow.mapSize.width."), (this["shadow"]["mapSize"]["width"] = mN);
                        },
                    },
                    shadowMapHeight: {
                        set: function (mN) {
                            console["warn"]("THREE.Light:\x20.shadowMapHeight\x20is\x20now\x20.shadow.mapSize.height."), (this["shadow"]["mapSize"]["height"] = mN);
                        },
                    },
                }),
                Object["defineProperties"](Rx["prototype"], {
                    length: {
                        get: function () {
                            return console["warn"]("THREE.BufferAttribute:\x20.length\x20has\x20been\x20deprecated.\x20Use\x20.count\x20instead."), this["array"]["length"];
                        },
                    },
                    dynamic: {
                        get: function () {
                            return console["warn"]("THREE.BufferAttribute:\x20.dynamic\x20has\x20been\x20deprecated.\x20Use\x20.usage\x20instead."), this["usage"] === rL;
                        },
                        set: function () {
                            console["warn"]("THREE.BufferAttribute:\x20.dynamic\x20has\x20been\x20deprecated.\x20Use\x20.usage\x20instead."), this["setUsage"](rL);
                        },
                    },
                }),
                Object["assign"](Rx["prototype"], {
                    setDynamic: function (mN) {
                        return console["warn"]("THREE.BufferAttribute:\x20.setDynamic()\x20has\x20been\x20deprecated.\x20Use\x20.setUsage()\x20instead."), this["setUsage"](!0x0 === mN ? rL : rG), this;
                    },
                    copyIndicesArray: function () {
                        console["error"]("THREE.BufferAttribute:\x20.copyIndicesArray()\x20has\x20been\x20removed.");
                    },
                    setArray: function () {
                        console["error"]("THREE.BufferAttribute:\x20.setArray\x20has\x20been\x20removed.\x20Use\x20BufferGeometry\x20.setAttribute\x20to\x20replace/resize\x20attribute\x20buffers");
                    },
                }),
                Object["assign"](TR["prototype"], {
                    addIndex: function (mN) {
                        console["warn"]("THREE.BufferGeometry:\x20.addIndex()\x20has\x20been\x20renamed\x20to\x20.setIndex()."), this["setIndex"](mN);
                    },
                    addAttribute: function (mN, mX) {
                        return (
                            console["warn"]("THREE.BufferGeometry:\x20.addAttribute()\x20has\x20been\x20renamed\x20to\x20.setAttribute()."),
                            (mX && mX["isBufferAttribute"]) || (mX && mX["isInterleavedBufferAttribute"])
                                ? "index" === mN
                                    ? (console["warn"]("THREE.BufferGeometry.addAttribute:\x20Use\x20.setIndex()\x20for\x20index\x20attribute."), this["setIndex"](mX), this)
                                    : this["setAttribute"](mN, mX)
                                : (console["warn"]("THREE.BufferGeometry:\x20.addAttribute()\x20now\x20expects\x20(\x20name,\x20attribute\x20)."), this["setAttribute"](mN, new Rx(arguments[0x1], arguments[0x2])))
                        );
                    },
                    addDrawCall: function (mN, mX, mf) {
                        void 0x0 !== mf && console["warn"]("THREE.BufferGeometry:\x20.addDrawCall()\x20no\x20longer\x20supports\x20indexOffset."),
                            console["warn"]("THREE.BufferGeometry:\x20.addDrawCall()\x20is\x20now\x20.addGroup()."),
                            this["addGroup"](mN, mX);
                    },
                    clearDrawCalls: function () {
                        console["warn"]("THREE.BufferGeometry:\x20.clearDrawCalls()\x20is\x20now\x20.clearGroups()."), this["clearGroups"]();
                    },
                    computeTangents: function () {
                        console["warn"]("THREE.BufferGeometry:\x20.computeTangents()\x20has\x20been\x20removed.");
                    },
                    computeOffsets: function () {
                        console["warn"]("THREE.BufferGeometry:\x20.computeOffsets()\x20has\x20been\x20removed.");
                    },
                    removeAttribute: function (mN) {
                        return console["warn"]("THREE.BufferGeometry:\x20.removeAttribute()\x20has\x20been\x20renamed\x20to\x20.deleteAttribute()."), this["deleteAttribute"](mN);
                    },
                    applyMatrix: function (mN) {
                        return console["warn"]("THREE.BufferGeometry:\x20.applyMatrix()\x20has\x20been\x20renamed\x20to\x20.applyMatrix4()."), this["applyMatrix4"](mN);
                    },
                }),
                Object["defineProperties"](TR["prototype"], {
                    drawcalls: {
                        get: function () {
                            return console["error"]("THREE.BufferGeometry:\x20.drawcalls\x20has\x20been\x20renamed\x20to\x20.groups."), this["groups"];
                        },
                    },
                    offsets: {
                        get: function () {
                            return console["warn"]("THREE.BufferGeometry:\x20.offsets\x20has\x20been\x20renamed\x20to\x20.groups."), this["groups"];
                        },
                    },
                }),
                Object["defineProperties"](bd["prototype"], {
                    maxInstancedCount: {
                        get: function () {
                            return console["warn"]("THREE.InstancedBufferGeometry:\x20.maxInstancedCount\x20has\x20been\x20renamed\x20to\x20.instanceCount."), this["instanceCount"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.InstancedBufferGeometry:\x20.maxInstancedCount\x20has\x20been\x20renamed\x20to\x20.instanceCount."), (this["instanceCount"] = mN);
                        },
                    },
                }),
                Object["defineProperties"](ZC["prototype"], {
                    linePrecision: {
                        get: function () {
                            return console["warn"]("THREE.Raycaster:\x20.linePrecision\x20has\x20been\x20deprecated.\x20Use\x20.params.Line.threshold\x20instead."), this["params"]["Line"]["threshold"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.Raycaster:\x20.linePrecision\x20has\x20been\x20deprecated.\x20Use\x20.params.Line.threshold\x20instead."), (this["params"]["Line"]["threshold"] = mN);
                        },
                    },
                }),
                Object["defineProperties"](YC["prototype"], {
                    dynamic: {
                        get: function () {
                            return console["warn"]("THREE.InterleavedBuffer:\x20.length\x20has\x20been\x20deprecated.\x20Use\x20.usage\x20instead."), this["usage"] === rL;
                        },
                        set: function (mN) {
                            console["warn"]("THREE.InterleavedBuffer:\x20.length\x20has\x20been\x20deprecated.\x20Use\x20.usage\x20instead."), this["setUsage"](mN);
                        },
                    },
                }),
                Object["assign"](YC["prototype"], {
                    setDynamic: function (mN) {
                        return console["warn"]("THREE.InterleavedBuffer:\x20.setDynamic()\x20has\x20been\x20deprecated.\x20Use\x20.setUsage()\x20instead."), this["setUsage"](!0x0 === mN ? rL : rG), this;
                    },
                    setArray: function () {
                        console["error"]("THREE.InterleavedBuffer:\x20.setArray\x20has\x20been\x20removed.\x20Use\x20BufferGeometry\x20.setAttribute\x20to\x20replace/resize\x20attribute\x20buffers");
                    },
                }),
                Object["assign"](BF["prototype"], {
                    getArrays: function () {
                        console["error"]("THREE.ExtrudeBufferGeometry:\x20.getArrays()\x20has\x20been\x20removed.");
                    },
                    addShapeList: function () {
                        console["error"]("THREE.ExtrudeBufferGeometry:\x20.addShapeList()\x20has\x20been\x20removed.");
                    },
                    addShape: function () {
                        console["error"]("THREE.ExtrudeBufferGeometry:\x20.addShape()\x20has\x20been\x20removed.");
                    },
                }),
                Object["defineProperties"](ZR["prototype"], {
                    dynamic: {
                        set: function () {
                            console["warn"]("THREE.Uniform:\x20.dynamic\x20has\x20been\x20removed.\x20Use\x20object.onBeforeRender()\x20instead.");
                        },
                    },
                    onUpdate: {
                        value: function () {
                            return console["warn"]("THREE.Uniform:\x20.onUpdate()\x20has\x20been\x20removed.\x20Use\x20object.onBeforeRender()\x20instead."), this;
                        },
                    },
                }),
                Object["defineProperties"](Rg["prototype"], {
                    wrapAround: {
                        get: function () {
                            console["warn"]("THREE.Material:\x20.wrapAround\x20has\x20been\x20removed.");
                        },
                        set: function () {
                            console["warn"]("THREE.Material:\x20.wrapAround\x20has\x20been\x20removed.");
                        },
                    },
                    overdraw: {
                        get: function () {
                            console["warn"]("THREE.Material:\x20.overdraw\x20has\x20been\x20removed.");
                        },
                        set: function () {
                            console["warn"]("THREE.Material:\x20.overdraw\x20has\x20been\x20removed.");
                        },
                    },
                    wrapRGB: {
                        get: function () {
                            return console["warn"]("THREE.Material:\x20.wrapRGB\x20has\x20been\x20removed."), new Rq();
                        },
                    },
                    shading: {
                        get: function () {
                            console["error"]("THREE." + this["type"] + ":\x20.shading\x20has\x20been\x20removed.\x20Use\x20the\x20boolean\x20.flatShading\x20instead.");
                        },
                        set: function (mN) {
                            console["warn"]("THREE." + this["type"] + ":\x20.shading\x20has\x20been\x20removed.\x20Use\x20the\x20boolean\x20.flatShading\x20instead."), (this["flatShading"] = 0x1 === mN);
                        },
                    },
                    stencilMask: {
                        get: function () {
                            return console["warn"]("THREE." + this["type"] + ":\x20.stencilMask\x20has\x20been\x20removed.\x20Use\x20.stencilFuncMask\x20instead."), this["stencilFuncMask"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE." + this["type"] + ":\x20.stencilMask\x20has\x20been\x20removed.\x20Use\x20.stencilFuncMask\x20instead."), (this["stencilFuncMask"] = mN);
                        },
                    },
                }),
                Object["defineProperties"](Bx["prototype"], {
                    metal: {
                        get: function () {
                            return console["warn"]("THREE.MeshPhongMaterial:\x20.metal\x20has\x20been\x20removed.\x20Use\x20THREE.MeshStandardMaterial\x20instead."), !0x1;
                        },
                        set: function () {
                            console["warn"]("THREE.MeshPhongMaterial:\x20.metal\x20has\x20been\x20removed.\x20Use\x20THREE.MeshStandardMaterial\x20instead");
                        },
                    },
                }),
                Object["defineProperties"](TW["prototype"], {
                    derivatives: {
                        get: function () {
                            return console["warn"]("THREE.ShaderMaterial:\x20.derivatives\x20has\x20been\x20moved\x20to\x20.extensions.derivatives."), this["extensions"]["derivatives"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.\x20ShaderMaterial:\x20.derivatives\x20has\x20been\x20moved\x20to\x20.extensions.derivatives."), (this["extensions"]["derivatives"] = mN);
                        },
                    },
                }),
                Object["assign"](YE["prototype"], {
                    clearTarget: function (mN, mX, mf, mP) {
                        console["warn"]("THREE.WebGLRenderer:\x20.clearTarget()\x20has\x20been\x20deprecated.\x20Use\x20.setRenderTarget()\x20and\x20.clear()\x20instead."), this["setRenderTarget"](mN), this["clear"](mX, mf, mP);
                    },
                    animate: function (mN) {
                        console["warn"]("THREE.WebGLRenderer:\x20.animate()\x20is\x20now\x20.setAnimationLoop()."), this["setAnimationLoop"](mN);
                    },
                    getCurrentRenderTarget: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.getCurrentRenderTarget()\x20is\x20now\x20.getRenderTarget()."), this["getRenderTarget"]();
                    },
                    getMaxAnisotropy: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.getMaxAnisotropy()\x20is\x20now\x20.capabilities.getMaxAnisotropy()."), this["capabilities"]["getMaxAnisotropy"]();
                    },
                    getPrecision: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.getPrecision()\x20is\x20now\x20.capabilities.precision."), this["capabilities"]["precision"];
                    },
                    resetGLState: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.resetGLState()\x20is\x20now\x20.state.reset()."), this["state"]["reset"]();
                    },
                    supportsFloatTextures: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.supportsFloatTextures()\x20is\x20now\x20.extensions.get(\x20\x27OES_texture_float\x27\x20)."), this["extensions"]["get"]("OES_texture_float");
                    },
                    supportsHalfFloatTextures: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.supportsHalfFloatTextures()\x20is\x20now\x20.extensions.get(\x20\x27OES_texture_half_float\x27\x20)."), this["extensions"]["get"]("OES_texture_half_float");
                    },
                    supportsStandardDerivatives: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.supportsStandardDerivatives()\x20is\x20now\x20.extensions.get(\x20\x27OES_standard_derivatives\x27\x20)."), this["extensions"]["get"]("OES_standard_derivatives");
                    },
                    supportsCompressedTextureS3TC: function () {
                        return (
                            console["warn"]("THREE.WebGLRenderer:\x20.supportsCompressedTextureS3TC()\x20is\x20now\x20.extensions.get(\x20\x27WEBGL_compressed_texture_s3tc\x27\x20)."),
                            this["extensions"]["get"]("WEBGL_compressed_texture_s3tc")
                        );
                    },
                    supportsCompressedTexturePVRTC: function () {
                        return (
                            console["warn"]("THREE.WebGLRenderer:\x20.supportsCompressedTexturePVRTC()\x20is\x20now\x20.extensions.get(\x20\x27WEBGL_compressed_texture_pvrtc\x27\x20)."),
                            this["extensions"]["get"]("WEBGL_compressed_texture_pvrtc")
                        );
                    },
                    supportsBlendMinMax: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.supportsBlendMinMax()\x20is\x20now\x20.extensions.get(\x20\x27EXT_blend_minmax\x27\x20)."), this["extensions"]["get"]("EXT_blend_minmax");
                    },
                    supportsVertexTextures: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.supportsVertexTextures()\x20is\x20now\x20.capabilities.vertexTextures."), this["capabilities"]["vertexTextures"];
                    },
                    supportsInstancedArrays: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.supportsInstancedArrays()\x20is\x20now\x20.extensions.get(\x20\x27ANGLE_instanced_arrays\x27\x20)."), this["extensions"]["get"]("ANGLE_instanced_arrays");
                    },
                    enableScissorTest: function (mN) {
                        console["warn"]("THREE.WebGLRenderer:\x20.enableScissorTest()\x20is\x20now\x20.setScissorTest()."), this["setScissorTest"](mN);
                    },
                    initMaterial: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.initMaterial()\x20has\x20been\x20removed.");
                    },
                    addPrePlugin: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.addPrePlugin()\x20has\x20been\x20removed.");
                    },
                    addPostPlugin: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.addPostPlugin()\x20has\x20been\x20removed.");
                    },
                    updateShadowMap: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.updateShadowMap()\x20has\x20been\x20removed.");
                    },
                    setFaceCulling: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.setFaceCulling()\x20has\x20been\x20removed.");
                    },
                    allocTextureUnit: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.allocTextureUnit()\x20has\x20been\x20removed.");
                    },
                    setTexture: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.setTexture()\x20has\x20been\x20removed.");
                    },
                    setTexture2D: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.setTexture2D()\x20has\x20been\x20removed.");
                    },
                    setTextureCube: function () {
                        console["warn"]("THREE.WebGLRenderer:\x20.setTextureCube()\x20has\x20been\x20removed.");
                    },
                    getActiveMipMapLevel: function () {
                        return console["warn"]("THREE.WebGLRenderer:\x20.getActiveMipMapLevel()\x20is\x20now\x20.getActiveMipmapLevel()."), this["getActiveMipmapLevel"]();
                    },
                }),
                Object["defineProperties"](YE["prototype"], {
                    shadowMapEnabled: {
                        get: function () {
                            return this["shadowMap"]["enabled"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMapEnabled\x20is\x20now\x20.shadowMap.enabled."), (this["shadowMap"]["enabled"] = mN);
                        },
                    },
                    shadowMapType: {
                        get: function () {
                            return this["shadowMap"]["type"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMapType\x20is\x20now\x20.shadowMap.type."), (this["shadowMap"]["type"] = mN);
                        },
                    },
                    shadowMapCullFace: {
                        get: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMapCullFace\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                        set: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMapCullFace\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                    },
                    context: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderer:\x20.context\x20has\x20been\x20removed.\x20Use\x20.getContext()\x20instead."), this["getContext"]();
                        },
                    },
                    vr: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderer:\x20.vr\x20has\x20been\x20renamed\x20to\x20.xr"), this["xr"];
                        },
                    },
                    gammaInput: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderer:\x20.gammaInput\x20has\x20been\x20removed.\x20Set\x20the\x20encoding\x20for\x20textures\x20via\x20Texture.encoding\x20instead."), !0x1;
                        },
                        set: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.gammaInput\x20has\x20been\x20removed.\x20Set\x20the\x20encoding\x20for\x20textures\x20via\x20Texture.encoding\x20instead.");
                        },
                    },
                    gammaOutput: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderer:\x20.gammaOutput\x20has\x20been\x20removed.\x20Set\x20WebGLRenderer.outputEncoding\x20instead."), !0x1;
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderer:\x20.gammaOutput\x20has\x20been\x20removed.\x20Set\x20WebGLRenderer.outputEncoding\x20instead."), (this["outputEncoding"] = !0x0 === mN ? rH : rW);
                        },
                    },
                }),
                Object["defineProperties"](Y1["prototype"], {
                    cullFace: {
                        get: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMap.cullFace\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                        set: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMap.cullFace\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                    },
                    renderReverseSided: {
                        get: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMap.renderReverseSided\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                        set: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMap.renderReverseSided\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                    },
                    renderSingleSided: {
                        get: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMap.renderSingleSided\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                        set: function () {
                            console["warn"]("THREE.WebGLRenderer:\x20.shadowMap.renderSingleSided\x20has\x20been\x20removed.\x20Set\x20Material.shadowSide\x20instead.");
                        },
                    },
                }),
                Object["defineProperties"](E9["prototype"], {
                    wrapS: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.wrapS\x20is\x20now\x20.texture.wrapS."), this["texture"]["wrapS"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.wrapS\x20is\x20now\x20.texture.wrapS."), (this["texture"]["wrapS"] = mN);
                        },
                    },
                    wrapT: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.wrapT\x20is\x20now\x20.texture.wrapT."), this["texture"]["wrapT"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.wrapT\x20is\x20now\x20.texture.wrapT."), (this["texture"]["wrapT"] = mN);
                        },
                    },
                    magFilter: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.magFilter\x20is\x20now\x20.texture.magFilter."), this["texture"]["magFilter"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.magFilter\x20is\x20now\x20.texture.magFilter."), (this["texture"]["magFilter"] = mN);
                        },
                    },
                    minFilter: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.minFilter\x20is\x20now\x20.texture.minFilter."), this["texture"]["minFilter"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.minFilter\x20is\x20now\x20.texture.minFilter."), (this["texture"]["minFilter"] = mN);
                        },
                    },
                    anisotropy: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.anisotropy\x20is\x20now\x20.texture.anisotropy."), this["texture"]["anisotropy"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.anisotropy\x20is\x20now\x20.texture.anisotropy."), (this["texture"]["anisotropy"] = mN);
                        },
                    },
                    offset: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.offset\x20is\x20now\x20.texture.offset."), this["texture"]["offset"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.offset\x20is\x20now\x20.texture.offset."), (this["texture"]["offset"] = mN);
                        },
                    },
                    repeat: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.repeat\x20is\x20now\x20.texture.repeat."), this["texture"]["repeat"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.repeat\x20is\x20now\x20.texture.repeat."), (this["texture"]["repeat"] = mN);
                        },
                    },
                    format: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.format\x20is\x20now\x20.texture.format."), this["texture"]["format"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.format\x20is\x20now\x20.texture.format."), (this["texture"]["format"] = mN);
                        },
                    },
                    type: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.type\x20is\x20now\x20.texture.type."), this["texture"]["type"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.type\x20is\x20now\x20.texture.type."), (this["texture"]["type"] = mN);
                        },
                    },
                    generateMipmaps: {
                        get: function () {
                            return console["warn"]("THREE.WebGLRenderTarget:\x20.generateMipmaps\x20is\x20now\x20.texture.generateMipmaps."), this["texture"]["generateMipmaps"];
                        },
                        set: function (mN) {
                            console["warn"]("THREE.WebGLRenderTarget:\x20.generateMipmaps\x20is\x20now\x20.texture.generateMipmaps."), (this["texture"]["generateMipmaps"] = mN);
                        },
                    },
                }),
                Object["defineProperties"](bg["prototype"], {
                    load: {
                        value: function (mN) {
                            console["warn"]("THREE.Audio:\x20.load\x20has\x20been\x20deprecated.\x20Use\x20THREE.AudioLoader\x20instead.");
                            var mX = this;
                            return (
                                new bA()["load"](mN, function (mf) {
                                    mX["setBuffer"](mf);
                                }),
                                this
                            );
                        },
                    },
                    startTime: {
                        set: function () {
                            console["warn"]("THREE.Audio:\x20.startTime\x20is\x20now\x20.play(\x20delay\x20).");
                        },
                    },
                }),
                (bJ["prototype"]["getData"] = function () {
                    return console["warn"]("THREE.AudioAnalyser:\x20.getData()\x20is\x20now\x20.getFrequencyData()."), this["getFrequencyData"]();
                }),
                (TV["prototype"]["updateCubeMap"] = function (mN, mX) {
                    return console["warn"]("THREE.CubeCamera:\x20.updateCubeMap()\x20is\x20now\x20.update()."), this["update"](mN, mX);
                }),
                ((E5["crossOrigin"] = void 0x0),
                (E5["loadTexture"] = function (mN, mX, mf, mP) {
                    console["warn"]("THREE.ImageUtils.loadTexture\x20has\x20been\x20deprecated.\x20Use\x20THREE.TextureLoader()\x20instead.");
                    var mI = new FX();
                    mI["setCrossOrigin"](this["crossOrigin"]);
                    var mA = mI["load"](mN, mf, void 0x0, mP);
                    return mX && (mA["mapping"] = mX), mA;
                }),
                (E5["loadTextureCube"] = function (mN, mX, mf, mP) {
                    console["warn"]("THREE.ImageUtils.loadTextureCube\x20has\x20been\x20deprecated.\x20Use\x20THREE.CubeTextureLoader()\x20instead.");
                    var mI = new FN();
                    mI["setCrossOrigin"](this["crossOrigin"]);
                    var mA = mI["load"](mN, mf, void 0x0, mP);
                    return mX && (mA["mapping"] = mX), mA;
                }),
                (E5["loadCompressedTexture"] = function () {
                    console["error"]("THREE.ImageUtils.loadCompressedTexture\x20has\x20been\x20removed.\x20Use\x20THREE.DDSLoader\x20instead.");
                }),
                (E5["loadCompressedTextureCube"] = function () {
                    console["error"]("THREE.ImageUtils.loadCompressedTextureCube\x20has\x20been\x20removed.\x20Use\x20THREE.DDSLoader\x20instead.");
                })),
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__["dispatchEvent"](new CustomEvent("register", { detail: { revision: "117" } }));
        },
        0x881: function (E, R, T) {
            "use strict";
            T["d"](R, {
                Z: function () {
                    return d;
                },
            });
            var C = "Invariant\x20failed";
            function d(Y, B) {
                if (!Y) throw new Error(C);
            }
        },
        0x14169: function (E) {
            "use strict";
            var R,
                T = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_"["split"](""),
                C = {},
                d = 0x0,
                Y = 0x0;
            function B(b) {
                var Z = "";
                do {
                    (Z = T[b % 0x40] + Z), (b = Math["floor"](b / 0x40));
                } while (b > 0x0);
                return Z;
            }
            function F() {
                var b = B(+new Date());
                return b !== R ? ((d = 0x0), (R = b)) : b + "." + B(d++);
            }
            for (; Y < 0x40; Y++) C[T[Y]] = Y;
            (F["encode"] = B),
                (F["decode"] = function (b) {
                    var Z = 0x0;
                    for (Y = 0x0; Y < b["length"]; Y++) Z = 0x40 * Z + C[b["charAt"](Y)];
                    return Z;
                }),
                (E["exports"] = F);
        },
        0x3df5: function (E, R, T) {
            "use strict";
            function C(Y, B, F, b, Z, m, v) {
                try {
                    var y = Y[m](v),
                        D = y["value"];
                } catch (N) {
                    return void F(N);
                }
                y["done"] ? B(D) : Promise["resolve"](D)["then"](b, Z);
            }
            function d(Y) {
                return function () {
                    var B = this,
                        F = arguments;
                    return new Promise(function (b, Z) {
                        var m = Y["apply"](B, F);
                        function v(D) {
                            C(m, b, Z, v, y, "next", D);
                        }
                        function y(D) {
                            C(m, b, Z, v, y, "throw", D);
                        }
                        v(void 0x0);
                    });
                };
            }
            T["d"](R, {
                Z: function () {
                    return d;
                },
            });
        },
        0x155a6: function (r, E, R) {
            "use strict";
            function T() {
                return (
                    (T =
                        Object["assign"] ||
                        function (C) {
                            for (var d = 0x1; d < arguments["length"]; d++) {
                                var Y = arguments[d];
                                for (var B in Y) Object["prototype"]["hasOwnProperty"]["call"](Y, B) && (C[B] = Y[B]);
                            }
                            return C;
                        }),
                    T["apply"](this, arguments)
                );
            }
            R["d"](E, {
                Z: function () {
                    return T;
                },
            });
        },
        0xca09: function (E, R, T) {
            "use strict";
            function C(Y, B) {
                return (
                    (C =
                        Object["setPrototypeOf"] ||
                        function (F, b) {
                            return (F["__proto__"] = b), F;
                        }),
                    C(Y, B)
                );
            }
            function d(Y, B) {
                (Y["prototype"] = Object["create"](B["prototype"])), (Y["prototype"]["constructor"] = Y), C(Y, B);
            }
            T["d"](R, {
                Z: function () {
                    return d;
                },
            });
        },
        0xf786: function (r, E, R) {
            "use strict";
            function T(C, d) {
                if (null == C) return {};
                var Y,
                    B,
                    F = {},
                    b = Object["keys"](C);
                for (B = 0x0; B < b["length"]; B++) (Y = b[B]), d["indexOf"](Y) >= 0x0 || (F[Y] = C[Y]);
                return F;
            }
            R["d"](E, {
                Z: function () {
                    return T;
                },
            });
        },
        0x1219c: function (r0, r1, r2) {
            "use strict";
            r2["d"](r1, {
                io: function () {
                    return E2;
                },
            });
            var r3 = {};
            r2["r"](r3),
                r2["d"](r3, {
                    Decoder: function () {
                        return rs;
                    },
                    Encoder: function () {
                        return rV;
                    },
                    PacketType: function () {
                        return rK;
                    },
                    protocol: function () {
                        return rx;
                    },
                });
            var r4 = r2(0xfabb),
                r5 = r2(0x94aa),
                r6 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return\x20this")();
            function r7(E3) {
                const E4 = E3["xdomain"];
                try {
                    if ("undefined" != typeof XMLHttpRequest && (!E4 || r5)) return new XMLHttpRequest();
                } catch (E5) {}
                if (!E4)
                    try {
                        return new r6[["Active"]["concat"]("Object")["join"]("X")]("Microsoft.XMLHTTP");
                    } catch (E6) {}
            }
            function r8(E3, ...E4) {
                return E4["reduce"]((E5, E6) => (E3["hasOwnProperty"](E6) && (E5[E6] = E3[E6]), E5), {});
            }
            const r9 = setTimeout,
                rr = clearTimeout;
            function rE(E3, E4) {
                E4["useNativeTimers"] ? ((E3["setTimeoutFn"] = r9["bind"](r6)), (E3["clearTimeoutFn"] = rr["bind"](r6))) : ((E3["setTimeoutFn"] = setTimeout["bind"](r6)), (E3["clearTimeoutFn"] = clearTimeout["bind"](r6)));
            }
            var rR = r2(0xa837);
            const rT = Object["create"](null);
            (rT["open"] = "0"), (rT["close"] = "1"), (rT["ping"] = "2"), (rT["pong"] = "3"), (rT["message"] = "4"), (rT["upgrade"] = "5"), (rT["noop"] = "6");
            const rC = Object["create"](null);
            Object["keys"](rT)["forEach"]((E3) => {
                rC[rT[E3]] = E3;
            });
            const rd = { type: "error", data: "parser\x20error" },
                rY = "function" == typeof Blob || ("undefined" != typeof Blob && "[object\x20BlobConstructor]" === Object["prototype"]["toString"]["call"](Blob)),
                rn = "function" == typeof ArrayBuffer,
                rB = (E3, E4) => {
                    const E5 = new FileReader();
                    return (
                        (E5["onload"] = function () {
                            const E6 = E5["result"]["split"](",")[0x1];
                            E4("b" + E6);
                        }),
                        E5["readAsDataURL"](E3)
                    );
                };
            for (
                var rF = async ({ type: E3, data: E4 }, E5, E6) => {
                        return rY && E4 instanceof Blob
                            ? E5
                                ? E6(E4)
                                : rB(E4, E6)
                            : rn && (E4 instanceof ArrayBuffer || ((E7 = E4), "function" == typeof ArrayBuffer["isView"] ? ArrayBuffer["isView"](E7) : E7 && E7["buffer"] instanceof ArrayBuffer))
                            ? E5
                                ? E6(E4)
                                : rB(new Blob([E4]), E6)
                            : E6(rT[E3] + (E4 || ""));
                        var E7;
                    },
                    rb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    rZ = "undefined" == typeof Uint8Array ? [] : new Uint8Array(0x100),
                    rm = 0x0;
                rm < rb["length"];
                rm++
            )
                rZ[rb["charCodeAt"](rm)] = rm;
            const rv = "function" == typeof ArrayBuffer,
                ru = (E3, E4) => {
                    if (rv) {
                        const E5 = (function (E6) {
                            var E7,
                                E8,
                                E9,
                                Er,
                                EE,
                                ER = 0.75 * E6["length"],
                                ET = E6["length"],
                                EC = 0x0;
                            "=" === E6[E6["length"] - 0x1] && (ER--, "=" === E6[E6["length"] - 0x2] && ER--);
                            var Ed = new ArrayBuffer(ER),
                                EY = new Uint8Array(Ed);
                            for (E7 = 0x0; E7 < ET; E7 += 0x4)
                                (E8 = rZ[E6["charCodeAt"](E7)]),
                                    (E9 = rZ[E6["charCodeAt"](E7 + 0x1)]),
                                    (Er = rZ[E6["charCodeAt"](E7 + 0x2)]),
                                    (EE = rZ[E6["charCodeAt"](E7 + 0x3)]),
                                    (EY[EC++] = (E8 << 0x2) | (E9 >> 0x4)),
                                    (EY[EC++] = ((0xf & E9) << 0x4) | (Er >> 0x2)),
                                    (EY[EC++] = ((0x3 & Er) << 0x6) | (0x3f & EE));
                            return Ed;
                        })(E3);
                        return ry(E5, E4);
                    }
                    return { base64: !0x0, data: E3 };
                },
                ry = (E3, E4) => ("blob" === E4 && E3 instanceof ArrayBuffer ? new Blob([E3]) : E3);
            var rD = (E3, E4) => {
                if ("string" != typeof E3) return { type: "message", data: ry(E3, E4) };
                const E5 = E3["charAt"](0x0);
                if ("b" === E5) return { type: "message", data: ru(E3["substring"](0x1), E4) };
                return rC[E5] ? (E3["length"] > 0x1 ? { type: rC[E5], data: E3["substring"](0x1) } : { type: rC[E5] }) : rd;
            };
            const rN = String["fromCharCode"](0x1e);
            class rX extends rR["Q"] {
                constructor(E3) {
                    super(), (this["writable"] = !0x1), rE(this, E3), (this["opts"] = E3), (this["query"] = E3["query"]), (this["readyState"] = ""), (this["socket"] = E3["socket"]);
                }
                ["onError"](E3, E4) {
                    const E5 = new Error(E3);
                    return (E5["type"] = "TransportError"), (E5["description"] = E4), super["emit"]("error", E5), this;
                }
                ["open"]() {
                    return ("closed" !== this["readyState"] && "" !== this["readyState"]) || ((this["readyState"] = "opening"), this["doOpen"]()), this;
                }
                ["close"]() {
                    return ("opening" !== this["readyState"] && "open" !== this["readyState"]) || (this["doClose"](), this["onClose"]()), this;
                }
                ["send"](E3) {
                    "open" === this["readyState"] && this["write"](E3);
                }
                ["onOpen"]() {
                    (this["readyState"] = "open"), (this["writable"] = !0x0), super["emit"]("open");
                }
                ["onData"](E3) {
                    const E4 = rD(E3, this["socket"]["binaryType"]);
                    this["onPacket"](E4);
                }
                ["onPacket"](E3) {
                    super["emit"]("packet", E3);
                }
                ["onClose"]() {
                    (this["readyState"] = "closed"), super["emit"]("close");
                }
            }
            var rf = r2(0x14169),
                rP = r2(0x13fa6);
            class rI extends rX {
                constructor() {
                    super(...arguments), (this["polling"] = !0x1);
                }
                get ["name"]() {
                    return "polling";
                }
                ["doOpen"]() {
                    this["poll"]();
                }
                ["pause"](E3) {
                    this["readyState"] = "pausing";
                    const E4 = () => {
                        (this["readyState"] = "paused"), E3();
                    };
                    if (this["polling"] || !this["writable"]) {
                        let E5 = 0x0;
                        this["polling"] &&
                            (E5++,
                            this["once"]("pollComplete", function () {
                                --E5 || E4();
                            })),
                            this["writable"] ||
                                (E5++,
                                this["once"]("drain", function () {
                                    --E5 || E4();
                                }));
                    } else E4();
                }
                ["poll"]() {
                    (this["polling"] = !0x0), this["doPoll"](), this["emit"]("poll");
                }
                ["onData"](E3) {
                    ((E4, E5) => {
                        const E6 = E4["split"](rN),
                            E7 = [];
                        for (let E8 = 0x0; E8 < E6["length"]; E8++) {
                            const E9 = rD(E6[E8], E5);
                            if ((E7["push"](E9), "error" === E9["type"])) break;
                        }
                        return E7;
                    })(E3, this["socket"]["binaryType"])["forEach"]((E4) => {
                        if (("opening" === this["readyState"] && "open" === E4["type"] && this["onOpen"](), "close" === E4["type"])) return this["onClose"](), !0x1;
                        this["onPacket"](E4);
                    }),
                        "closed" !== this["readyState"] && ((this["polling"] = !0x1), this["emit"]("pollComplete"), "open" === this["readyState"] && this["poll"]());
                }
                ["doClose"]() {
                    const E3 = () => {
                        this["write"]([{ type: "close" }]);
                    };
                    "open" === this["readyState"] ? E3() : this["once"]("open", E3);
                }
                ["write"](E3) {
                    (this["writable"] = !0x1),
                        ((E4, E5) => {
                            const E6 = E4["length"],
                                E7 = new Array(E6);
                            let E8 = 0x0;
                            E4["forEach"]((E9, Er) => {
                                rF(E9, !0x1, (EE) => {
                                    (E7[Er] = EE), ++E8 === E6 && E5(E7["join"](rN));
                                });
                            });
                        })(E3, (E4) => {
                            this["doWrite"](E4, () => {
                                (this["writable"] = !0x0), this["emit"]("drain");
                            });
                        });
                }
                ["uri"]() {
                    let E3 = this["query"] || {};
                    const E4 = this["opts"]["secure"] ? "https" : "http";
                    let E5 = "";
                    !0x1 !== this["opts"]["timestampRequests"] && (E3[this["opts"]["timestampParam"]] = rf()),
                        this["supportsBinary"] || E3["sid"] || (E3["b64"] = 0x1),
                        this["opts"]["port"] && (("https" === E4 && 0x1bb !== Number(this["opts"]["port"])) || ("http" === E4 && 0x50 !== Number(this["opts"]["port"]))) && (E5 = ":" + this["opts"]["port"]);
                    const E6 = rP["encode"](E3);
                    return E4 + "://" + (-0x1 !== this["opts"]["hostname"]["indexOf"](":") ? "[" + this["opts"]["hostname"] + "]" : this["opts"]["hostname"]) + E5 + this["opts"]["path"] + (E6["length"] ? "?" + E6 : "");
                }
            }
            function rA() {}
            const rM = null != new r7({ xdomain: !0x1 })["responseType"];
            class ro extends rR["Q"] {
                constructor(E3, E4) {
                    super(),
                        rE(this, E4),
                        (this["opts"] = E4),
                        (this["method"] = E4["method"] || "GET"),
                        (this["uri"] = E3),
                        (this["async"] = !0x1 !== E4["async"]),
                        (this["data"] = void 0x0 !== E4["data"] ? E4["data"] : null),
                        this["create"]();
                }
                ["create"]() {
                    const E3 = r8(this["opts"], "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
                    (E3["xdomain"] = !!this["opts"]["xd"]), (E3["xscheme"] = !!this["opts"]["xs"]);
                    const E4 = (this["xhr"] = new r7(E3));
                    try {
                        E4["open"](this["method"], this["uri"], this["async"]);
                        try {
                            if (this["opts"]["extraHeaders"]) {
                                E4["setDisableHeaderCheck"] && E4["setDisableHeaderCheck"](!0x0);
                                for (let E5 in this["opts"]["extraHeaders"]) this["opts"]["extraHeaders"]["hasOwnProperty"](E5) && E4["setRequestHeader"](E5, this["opts"]["extraHeaders"][E5]);
                            }
                        } catch (E6) {}
                        if ("POST" === this["method"])
                            try {
                                E4["setRequestHeader"]("Content-type", "text/plain;charset=UTF-8");
                            } catch (E7) {}
                        try {
                            E4["setRequestHeader"]("Accept", "*/*");
                        } catch (E8) {}
                        "withCredentials" in E4 && (E4["withCredentials"] = this["opts"]["withCredentials"]),
                            this["opts"]["requestTimeout"] && (E4["timeout"] = this["opts"]["requestTimeout"]),
                            (E4["onreadystatechange"] = () => {
                                0x4 === E4["readyState"] &&
                                    (0xc8 === E4["status"] || 0x4c7 === E4["status"]
                                        ? this["onLoad"]()
                                        : this["setTimeoutFn"](() => {
                                              this["onError"]("number" == typeof E4["status"] ? E4["status"] : 0x0);
                                          }, 0x0));
                            }),
                            E4["send"](this["data"]);
                    } catch (E9) {
                        return void this["setTimeoutFn"](() => {
                            this["onError"](E9);
                        }, 0x0);
                    }
                    "undefined" != typeof document && ((this["index"] = ro["requestsCount"]++), (ro["requests"][this["index"]] = this));
                }
                ["onSuccess"]() {
                    this["emit"]("success"), this["cleanup"]();
                }
                ["onData"](E3) {
                    this["emit"]("data", E3), this["onSuccess"]();
                }
                ["onError"](E3) {
                    this["emit"]("error", E3), this["cleanup"](!0x0);
                }
                ["cleanup"](E3) {
                    if (void 0x0 !== this["xhr"] && null !== this["xhr"]) {
                        if (((this["xhr"]["onreadystatechange"] = rA), E3))
                            try {
                                this["xhr"]["abort"]();
                            } catch (E4) {}
                        "undefined" != typeof document && delete ro["requests"][this["index"]], (this["xhr"] = null);
                    }
                }
                ["onLoad"]() {
                    const E3 = this["xhr"]["responseText"];
                    null !== E3 && this["onData"](E3);
                }
                ["abort"]() {
                    this["cleanup"]();
                }
            }
            if (((ro["requestsCount"] = 0x0), (ro["requests"] = {}), "undefined" != typeof document)) {
                if ("function" == typeof attachEvent) attachEvent("onunload", rp);
                else "function" == typeof addEventListener && addEventListener("onpagehide" in r6 ? "pagehide" : "unload", rp, !0x1);
            }
            function rp() {
                for (let E3 in ro["requests"]) ro["requests"]["hasOwnProperty"](E3) && ro["requests"][E3]["abort"]();
            }
            const rk = "function" == typeof Promise && "function" == typeof Promise["resolve"] ? (E3) => Promise["resolve"]()["then"](E3) : (E3, E4) => E4(E3, 0x0),
                re = r6["WebSocket"] || r6["MozWebSocket"],
                rl = "undefined" != typeof navigator && "string" == typeof navigator["product"] && "reactnative" === navigator["product"]["toLowerCase"]();
            class rU extends rX {
                constructor(E3) {
                    super(E3), (this["supportsBinary"] = !E3["forceBase64"]);
                }
                get ["name"]() {
                    return "websocket";
                }
                ["doOpen"]() {
                    if (!this["check"]()) return;
                    const E3 = this["uri"](),
                        E4 = this["opts"]["protocols"],
                        E5 = rl
                            ? {}
                            : r8(
                                  this["opts"],
                                  "agent",
                                  "perMessageDeflate",
                                  "pfx",
                                  "key",
                                  "passphrase",
                                  "cert",
                                  "ca",
                                  "ciphers",
                                  "rejectUnauthorized",
                                  "localAddress",
                                  "protocolVersion",
                                  "origin",
                                  "maxPayload",
                                  "family",
                                  "checkServerIdentity"
                              );
                    this["opts"]["extraHeaders"] && (E5["headers"] = this["opts"]["extraHeaders"]);
                    try {
                        this["ws"] = rl ? new re(E3, E4, E5) : E4 ? new re(E3, E4) : new re(E3);
                    } catch (E6) {
                        return this["emit"]("error", E6);
                    }
                    (this["ws"]["binaryType"] = this["socket"]["binaryType"] || "arraybuffer"), this["addEventListeners"]();
                }
                ["addEventListeners"]() {
                    (this["ws"]["onopen"] = () => {
                        this["opts"]["autoUnref"] && this["ws"]["_socket"]["unref"](), this["onOpen"]();
                    }),
                        (this["ws"]["onclose"] = this["onClose"]["bind"](this)),
                        (this["ws"]["onmessage"] = (E3) => this["onData"](E3["data"])),
                        (this["ws"]["onerror"] = (E3) => this["onError"]("websocket\x20error", E3));
                }
                ["write"](E3) {
                    this["writable"] = !0x1;
                    for (let E4 = 0x0; E4 < E3["length"]; E4++) {
                        const E5 = E3[E4],
                            E6 = E4 === E3["length"] - 0x1;
                        rF(E5, this["supportsBinary"], (E7) => {
                            try {
                                this["ws"]["send"](E7);
                            } catch (E8) {}
                            E6 &&
                                rk(() => {
                                    (this["writable"] = !0x0), this["emit"]("drain");
                                }, this["setTimeoutFn"]);
                        });
                    }
                }
                ["doClose"]() {
                    void 0x0 !== this["ws"] && (this["ws"]["close"](), (this["ws"] = null));
                }
                ["uri"]() {
                    let E3 = this["query"] || {};
                    const E4 = this["opts"]["secure"] ? "wss" : "ws";
                    let E5 = "";
                    this["opts"]["port"] && (("wss" === E4 && 0x1bb !== Number(this["opts"]["port"])) || ("ws" === E4 && 0x50 !== Number(this["opts"]["port"]))) && (E5 = ":" + this["opts"]["port"]),
                        this["opts"]["timestampRequests"] && (E3[this["opts"]["timestampParam"]] = rf()),
                        this["supportsBinary"] || (E3["b64"] = 0x1);
                    const E6 = rP["encode"](E3);
                    return E4 + "://" + (-0x1 !== this["opts"]["hostname"]["indexOf"](":") ? "[" + this["opts"]["hostname"] + "]" : this["opts"]["hostname"]) + E5 + this["opts"]["path"] + (E6["length"] ? "?" + E6 : "");
                }
                ["check"]() {
                    return !(!re || ("__initialize" in re && this["name"] === rU["prototype"]["name"]));
                }
            }
            const rq = {
                websocket: rU,
                polling: class extends rI {
                    constructor(E3) {
                        if ((super(E3), "undefined" != typeof location)) {
                            const E5 = "https:" === location["protocol"];
                            let E6 = location["port"];
                            E6 || (E6 = E5 ? "443" : "80"), (this["xd"] = ("undefined" != typeof location && E3["hostname"] !== location["hostname"]) || E6 !== E3["port"]), (this["xs"] = E3["secure"] !== E5);
                        }
                        const E4 = E3 && E3["forceBase64"];
                        this["supportsBinary"] = rM && !E4;
                    }
                    ["request"](E3 = {}) {
                        return Object["assign"](E3, { xd: this["xd"], xs: this["xs"] }, this["opts"]), new ro(this["uri"](), E3);
                    }
                    ["doWrite"](E3, E4) {
                        const E5 = this["request"]({ method: "POST", data: E3 });
                        E5["on"]("success", E4),
                            E5["on"]("error", (E6) => {
                                this["onError"]("xhr\x20post\x20error", E6);
                            });
                    }
                    ["doPoll"]() {
                        const E3 = this["request"]();
                        E3["on"]("data", this["onData"]["bind"](this)),
                            E3["on"]("error", (E4) => {
                                this["onError"]("xhr\x20poll\x20error", E4);
                            }),
                            (this["pollXhr"] = E3);
                    }
                },
            };
            class rw extends rR["Q"] {
                constructor(E3, E4 = {}) {
                    super(),
                        E3 && "object" == typeof E3 && ((E4 = E3), (E3 = null)),
                        E3
                            ? ((E3 = r4(E3)), (E4["hostname"] = E3["host"]), (E4["secure"] = "https" === E3["protocol"] || "wss" === E3["protocol"]), (E4["port"] = E3["port"]), E3["query"] && (E4["query"] = E3["query"]))
                            : E4["host"] && (E4["hostname"] = r4(E4["host"])["host"]),
                        rE(this, E4),
                        (this["secure"] = null != E4["secure"] ? E4["secure"] : "undefined" != typeof location && "https:" === location["protocol"]),
                        E4["hostname"] && !E4["port"] && (E4["port"] = this["secure"] ? "443" : "80"),
                        (this["hostname"] = E4["hostname"] || ("undefined" != typeof location ? location["hostname"] : "localhost")),
                        (this["port"] = E4["port"] || ("undefined" != typeof location && location["port"] ? location["port"] : this["secure"] ? "443" : "80")),
                        (this["transports"] = E4["transports"] || ["polling", "websocket"]),
                        (this["readyState"] = ""),
                        (this["writeBuffer"] = []),
                        (this["prevBufferLen"] = 0x0),
                        (this["opts"] = Object["assign"](
                            {
                                path: "/engine.io",
                                agent: !0x1,
                                withCredentials: !0x1,
                                upgrade: !0x0,
                                timestampParam: "t",
                                rememberUpgrade: !0x1,
                                rejectUnauthorized: !0x0,
                                perMessageDeflate: { threshold: 0x400 },
                                transportOptions: {},
                                closeOnBeforeunload: !0x0,
                            },
                            E4
                        )),
                        (this["opts"]["path"] = this["opts"]["path"]["replace"](/\/$/, "") + "/"),
                        "string" == typeof this["opts"]["query"] && (this["opts"]["query"] = rP["decode"](this["opts"]["query"])),
                        (this["id"] = null),
                        (this["upgrades"] = null),
                        (this["pingInterval"] = null),
                        (this["pingTimeout"] = null),
                        (this["pingTimeoutTimer"] = null),
                        "function" == typeof addEventListener &&
                            (this["opts"]["closeOnBeforeunload"] &&
                                addEventListener(
                                    "beforeunload",
                                    () => {
                                        this["transport"] && (this["transport"]["removeAllListeners"](), this["transport"]["close"]());
                                    },
                                    !0x1
                                ),
                            "localhost" !== this["hostname"] &&
                                ((this["offlineEventListener"] = () => {
                                    this["onClose"]("transport\x20close");
                                }),
                                addEventListener("offline", this["offlineEventListener"], !0x1))),
                        this["open"]();
                }
                ["createTransport"](E3) {
                    const E4 = (function (E6) {
                        const E7 = {};
                        for (let E8 in E6) E6["hasOwnProperty"](E8) && (E7[E8] = E6[E8]);
                        return E7;
                    })(this["opts"]["query"]);
                    (E4["EIO"] = 0x4), (E4["transport"] = E3), this["id"] && (E4["sid"] = this["id"]);
                    const E5 = Object["assign"]({}, this["opts"]["transportOptions"][E3], this["opts"], { query: E4, socket: this, hostname: this["hostname"], secure: this["secure"], port: this["port"] });
                    return new rq[E3](E5);
                }
                ["open"]() {
                    let E3;
                    if (this["opts"]["rememberUpgrade"] && rw["priorWebsocketSuccess"] && -0x1 !== this["transports"]["indexOf"]("websocket")) E3 = "websocket";
                    else {
                        if (0x0 === this["transports"]["length"])
                            return void this["setTimeoutFn"](() => {
                                this["emitReserved"]("error", "No\x20transports\x20available");
                            }, 0x0);
                        E3 = this["transports"][0x0];
                    }
                    this["readyState"] = "opening";
                    try {
                        E3 = this["createTransport"](E3);
                    } catch (E4) {
                        return this["transports"]["shift"](), void this["open"]();
                    }
                    E3["open"](), this["setTransport"](E3);
                }
                ["setTransport"](E3) {
                    this["transport"] && this["transport"]["removeAllListeners"](),
                        (this["transport"] = E3),
                        E3["on"]("drain", this["onDrain"]["bind"](this))
                            ["on"]("packet", this["onPacket"]["bind"](this))
                            ["on"]("error", this["onError"]["bind"](this))
                            ["on"]("close", () => {
                                this["onClose"]("transport\x20close");
                            });
                }
                ["probe"](E3) {
                    let E4 = this["createTransport"](E3),
                        E5 = !0x1;
                    rw["priorWebsocketSuccess"] = !0x1;
                    const E6 = () => {
                        E5 ||
                            (E4["send"]([{ type: "ping", data: "probe" }]),
                            E4["once"]("packet", (ET) => {
                                if (!E5) {
                                    if ("pong" === ET["type"] && "probe" === ET["data"]) {
                                        if (((this["upgrading"] = !0x0), this["emitReserved"]("upgrading", E4), !E4)) return;
                                        (rw["priorWebsocketSuccess"] = "websocket" === E4["name"]),
                                            this["transport"]["pause"](() => {
                                                E5 ||
                                                    ("closed" !== this["readyState"] &&
                                                        (ER(), this["setTransport"](E4), E4["send"]([{ type: "upgrade" }]), this["emitReserved"]("upgrade", E4), (E4 = null), (this["upgrading"] = !0x1), this["flush"]()));
                                            });
                                    } else {
                                        const EC = new Error("probe\x20error");
                                        (EC["transport"] = E4["name"]), this["emitReserved"]("upgradeError", EC);
                                    }
                                }
                            }));
                    };
                    function E7() {
                        E5 || ((E5 = !0x0), ER(), E4["close"](), (E4 = null));
                    }
                    const E8 = (ET) => {
                        const EC = new Error("probe\x20error:\x20" + ET);
                        (EC["transport"] = E4["name"]), E7(), this["emitReserved"]("upgradeError", EC);
                    };
                    function E9() {
                        E8("transport\x20closed");
                    }
                    function Er() {
                        E8("socket\x20closed");
                    }
                    function EE(ET) {
                        E4 && ET["name"] !== E4["name"] && E7();
                    }
                    const ER = () => {
                        E4["removeListener"]("open", E6), E4["removeListener"]("error", E8), E4["removeListener"]("close", E9), this["off"]("close", Er), this["off"]("upgrading", EE);
                    };
                    E4["once"]("open", E6), E4["once"]("error", E8), E4["once"]("close", E9), this["once"]("close", Er), this["once"]("upgrading", EE), E4["open"]();
                }
                ["onOpen"]() {
                    if (
                        ((this["readyState"] = "open"),
                        (rw["priorWebsocketSuccess"] = "websocket" === this["transport"]["name"]),
                        this["emitReserved"]("open"),
                        this["flush"](),
                        "open" === this["readyState"] && this["opts"]["upgrade"] && this["transport"]["pause"])
                    ) {
                        let E3 = 0x0;
                        const E4 = this["upgrades"]["length"];
                        for (; E3 < E4; E3++) this["probe"](this["upgrades"][E3]);
                    }
                }
                ["onPacket"](E3) {
                    if ("opening" === this["readyState"] || "open" === this["readyState"] || "closing" === this["readyState"])
                        switch ((this["emitReserved"]("packet", E3), this["emitReserved"]("heartbeat"), E3["type"])) {
                            case "open":
                                this["onHandshake"](JSON["parse"](E3["data"]));
                                break;
                            case "ping":
                                this["resetPingTimeout"](), this["sendPacket"]("pong"), this["emitReserved"]("ping"), this["emitReserved"]("pong");
                                break;
                            case "error":
                                const E4 = new Error("server\x20error");
                                (E4["code"] = E3["data"]), this["onError"](E4);
                                break;
                            case "message":
                                this["emitReserved"]("data", E3["data"]), this["emitReserved"]("message", E3["data"]);
                        }
                }
                ["onHandshake"](E3) {
                    this["emitReserved"]("handshake", E3),
                        (this["id"] = E3["sid"]),
                        (this["transport"]["query"]["sid"] = E3["sid"]),
                        (this["upgrades"] = this["filterUpgrades"](E3["upgrades"])),
                        (this["pingInterval"] = E3["pingInterval"]),
                        (this["pingTimeout"] = E3["pingTimeout"]),
                        this["onOpen"](),
                        "closed" !== this["readyState"] && this["resetPingTimeout"]();
                }
                ["resetPingTimeout"]() {
                    this["clearTimeoutFn"](this["pingTimeoutTimer"]),
                        (this["pingTimeoutTimer"] = this["setTimeoutFn"](() => {
                            this["onClose"]("ping\x20timeout");
                        }, this["pingInterval"] + this["pingTimeout"])),
                        this["opts"]["autoUnref"] && this["pingTimeoutTimer"]["unref"]();
                }
                ["onDrain"]() {
                    this["writeBuffer"]["splice"](0x0, this["prevBufferLen"]), (this["prevBufferLen"] = 0x0), 0x0 === this["writeBuffer"]["length"] ? this["emitReserved"]("drain") : this["flush"]();
                }
                ["flush"]() {
                    "closed" !== this["readyState"] &&
                        this["transport"]["writable"] &&
                        !this["upgrading"] &&
                        this["writeBuffer"]["length"] &&
                        (this["transport"]["send"](this["writeBuffer"]), (this["prevBufferLen"] = this["writeBuffer"]["length"]), this["emitReserved"]("flush"));
                }
                ["write"](E3, E4, E5) {
                    return this["sendPacket"]("message", E3, E4, E5), this;
                }
                ["send"](E3, E4, E5) {
                    return this["sendPacket"]("message", E3, E4, E5), this;
                }
                ["sendPacket"](E3, E4, E5, E6) {
                    if (("function" == typeof E4 && ((E6 = E4), (E4 = void 0x0)), "function" == typeof E5 && ((E6 = E5), (E5 = null)), "closing" === this["readyState"] || "closed" === this["readyState"])) return;
                    (E5 = E5 || {})["compress"] = !0x1 !== E5["compress"];
                    const E7 = { type: E3, data: E4, options: E5 };
                    this["emitReserved"]("packetCreate", E7), this["writeBuffer"]["push"](E7), E6 && this["once"]("flush", E6), this["flush"]();
                }
                ["close"]() {
                    const E3 = () => {
                            this["onClose"]("forced\x20close"), this["transport"]["close"]();
                        },
                        E4 = () => {
                            this["off"]("upgrade", E4), this["off"]("upgradeError", E4), E3();
                        },
                        E5 = () => {
                            this["once"]("upgrade", E4), this["once"]("upgradeError", E4);
                        };
                    return (
                        ("opening" !== this["readyState"] && "open" !== this["readyState"]) ||
                            ((this["readyState"] = "closing"),
                            this["writeBuffer"]["length"]
                                ? this["once"]("drain", () => {
                                      this["upgrading"] ? E5() : E3();
                                  })
                                : this["upgrading"]
                                ? E5()
                                : E3()),
                        this
                    );
                }
                ["onError"](E3) {
                    (rw["priorWebsocketSuccess"] = !0x1), this["emitReserved"]("error", E3), this["onClose"]("transport\x20error", E3);
                }
                ["onClose"](E3, E4) {
                    ("opening" !== this["readyState"] && "open" !== this["readyState"] && "closing" !== this["readyState"]) ||
                        (this["clearTimeoutFn"](this["pingTimeoutTimer"]),
                        this["transport"]["removeAllListeners"]("close"),
                        this["transport"]["close"](),
                        this["transport"]["removeAllListeners"](),
                        "function" == typeof removeEventListener && removeEventListener("offline", this["offlineEventListener"], !0x1),
                        (this["readyState"] = "closed"),
                        (this["id"] = null),
                        this["emitReserved"]("close", E3, E4),
                        (this["writeBuffer"] = []),
                        (this["prevBufferLen"] = 0x0));
                }
                ["filterUpgrades"](E3) {
                    const E4 = [];
                    let E5 = 0x0;
                    const E6 = E3["length"];
                    for (; E5 < E6; E5++) ~this["transports"]["indexOf"](E3[E5]) && E4["push"](E3[E5]);
                    return E4;
                }
            }
            (rw["protocol"] = 0x4), rw["protocol"];
            const rO = "function" == typeof ArrayBuffer,
                rj = Object["prototype"]["toString"],
                ri = "function" == typeof Blob || ("undefined" != typeof Blob && "[object\x20BlobConstructor]" === rj["call"](Blob)),
                rh = "function" == typeof File || ("undefined" != typeof File && "[object\x20FileConstructor]" === rj["call"](File));
            function ra(E3) {
                return (
                    (rO && (E3 instanceof ArrayBuffer || ((E4) => ("function" == typeof ArrayBuffer["isView"] ? ArrayBuffer["isView"](E4) : E4["buffer"] instanceof ArrayBuffer))(E3))) ||
                    (ri && E3 instanceof Blob) ||
                    (rh && E3 instanceof File)
                );
            }
            function rc(E3, E4) {
                if (!E3 || "object" != typeof E3) return !0x1;
                if (Array["isArray"](E3)) {
                    for (let E5 = 0x0, E6 = E3["length"]; E5 < E6; E5++) if (rc(E3[E5])) return !0x0;
                    return !0x1;
                }
                if (ra(E3)) return !0x0;
                if (E3["toJSON"] && "function" == typeof E3["toJSON"] && 0x1 === arguments["length"]) return rc(E3["toJSON"](), !0x0);
                for (const E7 in E3) if (Object["prototype"]["hasOwnProperty"]["call"](E3, E7) && rc(E3[E7])) return !0x0;
                return !0x1;
            }
            function rS(E3) {
                const E4 = [],
                    E5 = E3["data"],
                    E6 = E3;
                return (E6["data"] = rg(E5, E4)), (E6["attachments"] = E4["length"]), { packet: E6, buffers: E4 };
            }
            function rg(E3, E4) {
                if (!E3) return E3;
                if (ra(E3)) {
                    const E5 = { _placeholder: !0x0, num: E4["length"] };
                    return E4["push"](E3), E5;
                }
                if (Array["isArray"](E3)) {
                    const E6 = new Array(E3["length"]);
                    for (let E7 = 0x0; E7 < E3["length"]; E7++) E6[E7] = rg(E3[E7], E4);
                    return E6;
                }
                if ("object" == typeof E3 && !(E3 instanceof Date)) {
                    const E8 = {};
                    for (const E9 in E3) E3["hasOwnProperty"](E9) && (E8[E9] = rg(E3[E9], E4));
                    return E8;
                }
                return E3;
            }
            function rW(E3, E4) {
                return (E3["data"] = rH(E3["data"], E4)), (E3["attachments"] = void 0x0), E3;
            }
            function rH(E3, E4) {
                if (!E3) return E3;
                if (E3 && E3["_placeholder"]) return E4[E3["num"]];
                if (Array["isArray"](E3)) {
                    for (let E5 = 0x0; E5 < E3["length"]; E5++) E3[E5] = rH(E3[E5], E4);
                } else {
                    if ("object" == typeof E3) {
                        for (const E6 in E3) E3["hasOwnProperty"](E6) && (E3[E6] = rH(E3[E6], E4));
                    }
                }
                return E3;
            }
            const rx = 0x5;
            var rK;
            !(function (E3) {
                (E3[(E3["CONNECT"] = 0x0)] = "CONNECT"),
                    (E3[(E3["DISCONNECT"] = 0x1)] = "DISCONNECT"),
                    (E3[(E3["EVENT"] = 0x2)] = "EVENT"),
                    (E3[(E3["ACK"] = 0x3)] = "ACK"),
                    (E3[(E3["CONNECT_ERROR"] = 0x4)] = "CONNECT_ERROR"),
                    (E3[(E3["BINARY_EVENT"] = 0x5)] = "BINARY_EVENT"),
                    (E3[(E3["BINARY_ACK"] = 0x6)] = "BINARY_ACK");
            })(rK || (rK = {}));
            class rV {
                ["encode"](E3) {
                    return (E3["type"] !== rK["EVENT"] && E3["type"] !== rK["ACK"]) || !rc(E3) ? [this["encodeAsString"](E3)] : ((E3["type"] = E3["type"] === rK["EVENT"] ? rK["BINARY_EVENT"] : rK["BINARY_ACK"]), this["encodeAsBinary"](E3));
                }
                ["encodeAsString"](E3) {
                    let E4 = "" + E3["type"];
                    return (
                        (E3["type"] !== rK["BINARY_EVENT"] && E3["type"] !== rK["BINARY_ACK"]) || (E4 += E3["attachments"] + "-"),
                        E3["nsp"] && "/" !== E3["nsp"] && (E4 += E3["nsp"] + ","),
                        null != E3["id"] && (E4 += E3["id"]),
                        null != E3["data"] && (E4 += JSON["stringify"](E3["data"])),
                        E4
                    );
                }
                ["encodeAsBinary"](E3) {
                    const E4 = rS(E3),
                        E5 = this["encodeAsString"](E4["packet"]),
                        E6 = E4["buffers"];
                    return E6["unshift"](E5), E6;
                }
            }
            class rs extends rR["Q"] {
                constructor() {
                    super();
                }
                ["add"](E3) {
                    let E4;
                    if ("string" == typeof E3)
                        (E4 = this["decodeString"](E3)),
                            E4["type"] === rK["BINARY_EVENT"] || E4["type"] === rK["BINARY_ACK"]
                                ? ((this["reconstructor"] = new rJ(E4)), 0x0 === E4["attachments"] && super["emitReserved"]("decoded", E4))
                                : super["emitReserved"]("decoded", E4);
                    else {
                        if (!ra(E3) && !E3["base64"]) throw new Error("Unknown\x20type:\x20" + E3);
                        if (!this["reconstructor"]) throw new Error("got\x20binary\x20data\x20when\x20not\x20reconstructing\x20a\x20packet");
                        (E4 = this["reconstructor"]["takeBinaryData"](E3)), E4 && ((this["reconstructor"] = null), super["emitReserved"]("decoded", E4));
                    }
                }
                ["decodeString"](E3) {
                    let E4 = 0x0;
                    const E5 = { type: Number(E3["charAt"](0x0)) };
                    if (void 0x0 === rK[E5["type"]]) throw new Error("unknown\x20packet\x20type\x20" + E5["type"]);
                    if (E5["type"] === rK["BINARY_EVENT"] || E5["type"] === rK["BINARY_ACK"]) {
                        const E7 = E4 + 0x1;
                        for (; "-" !== E3["charAt"](++E4) && E4 != E3["length"]; );
                        const E8 = E3["substring"](E7, E4);
                        if (E8 != Number(E8) || "-" !== E3["charAt"](E4)) throw new Error("Illegal\x20attachments");
                        E5["attachments"] = Number(E8);
                    }
                    if ("/" === E3["charAt"](E4 + 0x1)) {
                        const E9 = E4 + 0x1;
                        for (; ++E4; ) {
                            if ("," === E3["charAt"](E4)) break;
                            if (E4 === E3["length"]) break;
                        }
                        E5["nsp"] = E3["substring"](E9, E4);
                    } else E5["nsp"] = "/";
                    const E6 = E3["charAt"](E4 + 0x1);
                    if ("" !== E6 && Number(E6) == E6) {
                        const Er = E4 + 0x1;
                        for (; ++E4; ) {
                            const EE = E3["charAt"](E4);
                            if (null == EE || Number(EE) != EE) {
                                --E4;
                                break;
                            }
                            if (E4 === E3["length"]) break;
                        }
                        E5["id"] = Number(E3["substring"](Er, E4 + 0x1));
                    }
                    if (E3["charAt"](++E4)) {
                        const ER = (function (ET) {
                            try {
                                return JSON["parse"](ET);
                            } catch (EC) {
                                return !0x1;
                            }
                        })(E3["substr"](E4));
                        if (!rs["isPayloadValid"](E5["type"], ER)) throw new Error("invalid\x20payload");
                        E5["data"] = ER;
                    }
                    return E5;
                }
                static ["isPayloadValid"](E3, E4) {
                    switch (E3) {
                        case rK["CONNECT"]:
                            return "object" == typeof E4;
                        case rK["DISCONNECT"]:
                            return void 0x0 === E4;
                        case rK["CONNECT_ERROR"]:
                            return "string" == typeof E4 || "object" == typeof E4;
                        case rK["EVENT"]:
                        case rK["BINARY_EVENT"]:
                            return Array["isArray"](E4) && E4["length"] > 0x0;
                        case rK["ACK"]:
                        case rK["BINARY_ACK"]:
                            return Array["isArray"](E4);
                    }
                }
                ["destroy"]() {
                    this["reconstructor"] && this["reconstructor"]["finishedReconstruction"]();
                }
            }
            class rJ {
                constructor(E3) {
                    (this["packet"] = E3), (this["buffers"] = []), (this["reconPack"] = E3);
                }
                ["takeBinaryData"](E3) {
                    if ((this["buffers"]["push"](E3), this["buffers"]["length"] === this["reconPack"]["attachments"])) {
                        const E4 = rW(this["reconPack"], this["buffers"]);
                        return this["finishedReconstruction"](), E4;
                    }
                    return null;
                }
                ["finishedReconstruction"]() {
                    (this["reconPack"] = null), (this["buffers"] = []);
                }
            }
            function rG(E3, E4, E5) {
                return (
                    E3["on"](E4, E5),
                    function () {
                        E3["off"](E4, E5);
                    }
                );
            }
            const rL = Object["freeze"]({ connect: 0x1, connect_error: 0x1, disconnect: 0x1, disconnecting: 0x1, newListener: 0x1, removeListener: 0x1 });
            class rQ extends rR["Q"] {
                constructor(E3, E4, E5) {
                    super(),
                        (this["connected"] = !0x1),
                        (this["disconnected"] = !0x0),
                        (this["receiveBuffer"] = []),
                        (this["sendBuffer"] = []),
                        (this["ids"] = 0x0),
                        (this["acks"] = {}),
                        (this["flags"] = {}),
                        (this["io"] = E3),
                        (this["nsp"] = E4),
                        E5 && E5["auth"] && (this["auth"] = E5["auth"]),
                        this["io"]["_autoConnect"] && this["open"]();
                }
                ["subEvents"]() {
                    if (this["subs"]) return;
                    const E3 = this["io"];
                    this["subs"] = [rG(E3, "open", this["onopen"]["bind"](this)), rG(E3, "packet", this["onpacket"]["bind"](this)), rG(E3, "error", this["onerror"]["bind"](this)), rG(E3, "close", this["onclose"]["bind"](this))];
                }
                get ["active"]() {
                    return !!this["subs"];
                }
                ["connect"]() {
                    return this["connected"] || (this["subEvents"](), this["io"]["_reconnecting"] || this["io"]["open"](), "open" === this["io"]["_readyState"] && this["onopen"]()), this;
                }
                ["open"]() {
                    return this["connect"]();
                }
                ["send"](...E3) {
                    return E3["unshift"]("message"), this["emit"]["apply"](this, E3), this;
                }
                ["emit"](E3, ...E4) {
                    if (rL["hasOwnProperty"](E3)) throw new Error("\x22" + E3 + "\x22\x20is\x20a\x20reserved\x20event\x20name");
                    E4["unshift"](E3);
                    const E5 = { type: rK["EVENT"], data: E4, options: {} };
                    if (((E5["options"]["compress"] = !0x1 !== this["flags"]["compress"]), "function" == typeof E4[E4["length"] - 0x1])) {
                        const E7 = this["ids"]++,
                            E8 = E4["pop"]();
                        this["_registerAckCallback"](E7, E8), (E5["id"] = E7);
                    }
                    const E6 = this["io"]["engine"] && this["io"]["engine"]["transport"] && this["io"]["engine"]["transport"]["writable"];
                    return (this["flags"]["volatile"] && (!E6 || !this["connected"])) || (this["connected"] ? this["packet"](E5) : this["sendBuffer"]["push"](E5)), (this["flags"] = {}), this;
                }
                ["_registerAckCallback"](E3, E4) {
                    const E5 = this["flags"]["timeout"];
                    if (void 0x0 === E5) return void (this["acks"][E3] = E4);
                    const E6 = this["io"]["setTimeoutFn"](() => {
                        delete this["acks"][E3];
                        for (let E7 = 0x0; E7 < this["sendBuffer"]["length"]; E7++) this["sendBuffer"][E7]["id"] === E3 && this["sendBuffer"]["splice"](E7, 0x1);
                        E4["call"](this, new Error("operation\x20has\x20timed\x20out"));
                    }, E5);
                    this["acks"][E3] = (...E7) => {
                        this["io"]["clearTimeoutFn"](E6), E4["apply"](this, [null, ...E7]);
                    };
                }
                ["packet"](E3) {
                    (E3["nsp"] = this["nsp"]), this["io"]["_packet"](E3);
                }
                ["onopen"]() {
                    "function" == typeof this["auth"]
                        ? this["auth"]((E3) => {
                              this["packet"]({ type: rK["CONNECT"], data: E3 });
                          })
                        : this["packet"]({ type: rK["CONNECT"], data: this["auth"] });
                }
                ["onerror"](E3) {
                    this["connected"] || this["emitReserved"]("connect_error", E3);
                }
                ["onclose"](E3) {
                    (this["connected"] = !0x1), (this["disconnected"] = !0x0), delete this["id"], this["emitReserved"]("disconnect", E3);
                }
                ["onpacket"](E3) {
                    if (E3["nsp"] === this["nsp"])
                        switch (E3["type"]) {
                            case rK["CONNECT"]:
                                if (E3["data"] && E3["data"]["sid"]) {
                                    const E5 = E3["data"]["sid"];
                                    this["onconnect"](E5);
                                } else
                                    this["emitReserved"](
                                        "connect_error",
                                        new Error(
                                            "It\x20seems\x20you\x20are\x20trying\x20to\x20reach\x20a\x20Socket.IO\x20server\x20in\x20v2.x\x20with\x20a\x20v3.x\x20client,\x20but\x20they\x20are\x20not\x20compatible\x20(more\x20information\x20here:\x20https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
                                        )
                                    );
                                break;
                            case rK["EVENT"]:
                            case rK["BINARY_EVENT"]:
                                this["onevent"](E3);
                                break;
                            case rK["ACK"]:
                            case rK["BINARY_ACK"]:
                                this["onack"](E3);
                                break;
                            case rK["DISCONNECT"]:
                                this["ondisconnect"]();
                                break;
                            case rK["CONNECT_ERROR"]:
                                this["destroy"]();
                                const E4 = new Error(E3["data"]["message"]);
                                (E4["data"] = E3["data"]["data"]), this["emitReserved"]("connect_error", E4);
                        }
                }
                ["onevent"](E3) {
                    const E4 = E3["data"] || [];
                    null != E3["id"] && E4["push"](this["ack"](E3["id"])), this["connected"] ? this["emitEvent"](E4) : this["receiveBuffer"]["push"](Object["freeze"](E4));
                }
                ["emitEvent"](E3) {
                    if (this["_anyListeners"] && this["_anyListeners"]["length"]) {
                        const E4 = this["_anyListeners"]["slice"]();
                        for (const E5 of E4) E5["apply"](this, E3);
                    }
                    super["emit"]["apply"](this, E3);
                }
                ["ack"](E3) {
                    const E4 = this;
                    let E5 = !0x1;
                    return function (...E6) {
                        E5 || ((E5 = !0x0), E4["packet"]({ type: rK["ACK"], id: E3, data: E6 }));
                    };
                }
                ["onack"](E3) {
                    const E4 = this["acks"][E3["id"]];
                    "function" == typeof E4 && (E4["apply"](this, E3["data"]), delete this["acks"][E3["id"]]);
                }
                ["onconnect"](E3) {
                    (this["id"] = E3), (this["connected"] = !0x0), (this["disconnected"] = !0x1), this["emitBuffered"](), this["emitReserved"]("connect");
                }
                ["emitBuffered"]() {
                    this["receiveBuffer"]["forEach"]((E3) => this["emitEvent"](E3)), (this["receiveBuffer"] = []), this["sendBuffer"]["forEach"]((E3) => this["packet"](E3)), (this["sendBuffer"] = []);
                }
                ["ondisconnect"]() {
                    this["destroy"](), this["onclose"]("io\x20server\x20disconnect");
                }
                ["destroy"]() {
                    this["subs"] && (this["subs"]["forEach"]((E3) => E3()), (this["subs"] = void 0x0)), this["io"]["_destroy"](this);
                }
                ["disconnect"]() {
                    return this["connected"] && this["packet"]({ type: rK["DISCONNECT"] }), this["destroy"](), this["connected"] && this["onclose"]("io\x20client\x20disconnect"), this;
                }
                ["close"]() {
                    return this["disconnect"]();
                }
                ["compress"](E3) {
                    return (this["flags"]["compress"] = E3), this;
                }
                get ["volatile"]() {
                    return (this["flags"]["volatile"] = !0x0), this;
                }
                ["timeout"](E3) {
                    return (this["flags"]["timeout"] = E3), this;
                }
                ["onAny"](E3) {
                    return (this["_anyListeners"] = this["_anyListeners"] || []), this["_anyListeners"]["push"](E3), this;
                }
                ["prependAny"](E3) {
                    return (this["_anyListeners"] = this["_anyListeners"] || []), this["_anyListeners"]["unshift"](E3), this;
                }
                ["offAny"](E3) {
                    if (!this["_anyListeners"]) return this;
                    if (E3) {
                        const E4 = this["_anyListeners"];
                        for (let E5 = 0x0; E5 < E4["length"]; E5++) if (E3 === E4[E5]) return E4["splice"](E5, 0x1), this;
                    } else this["_anyListeners"] = [];
                    return this;
                }
                ["listenersAny"]() {
                    return this["_anyListeners"] || [];
                }
            }
            var rz = r2(0xa802);
            class E0 extends rR["Q"] {
                constructor(E3, E4) {
                    var E5;
                    super(),
                        (this["nsps"] = {}),
                        (this["subs"] = []),
                        E3 && "object" == typeof E3 && ((E4 = E3), (E3 = void 0x0)),
                        ((E4 = E4 || {})["path"] = E4["path"] || "/socket.io"),
                        (this["opts"] = E4),
                        rE(this, E4),
                        this["reconnection"](!0x1 !== E4["reconnection"]),
                        this["reconnectionAttempts"](E4["reconnectionAttempts"] || 0x1 / 0x0),
                        this["reconnectionDelay"](E4["reconnectionDelay"] || 0x3e8),
                        this["reconnectionDelayMax"](E4["reconnectionDelayMax"] || 0x1388),
                        this["randomizationFactor"](null !== (E5 = E4["randomizationFactor"]) && void 0x0 !== E5 ? E5 : 0.5),
                        (this["backoff"] = new rz({ min: this["reconnectionDelay"](), max: this["reconnectionDelayMax"](), jitter: this["randomizationFactor"]() })),
                        this["timeout"](null == E4["timeout"] ? 0x4e20 : E4["timeout"]),
                        (this["_readyState"] = "closed"),
                        (this["uri"] = E3);
                    const E6 = E4["parser"] || r3;
                    (this["encoder"] = new E6["Encoder"]()), (this["decoder"] = new E6["Decoder"]()), (this["_autoConnect"] = !0x1 !== E4["autoConnect"]), this["_autoConnect"] && this["open"]();
                }
                ["reconnection"](E3) {
                    return arguments["length"] ? ((this["_reconnection"] = !!E3), this) : this["_reconnection"];
                }
                ["reconnectionAttempts"](E3) {
                    return void 0x0 === E3 ? this["_reconnectionAttempts"] : ((this["_reconnectionAttempts"] = E3), this);
                }
                ["reconnectionDelay"](E3) {
                    var E4;
                    return void 0x0 === E3 ? this["_reconnectionDelay"] : ((this["_reconnectionDelay"] = E3), null === (E4 = this["backoff"]) || void 0x0 === E4 || E4["setMin"](E3), this);
                }
                ["randomizationFactor"](E3) {
                    var E4;
                    return void 0x0 === E3 ? this["_randomizationFactor"] : ((this["_randomizationFactor"] = E3), null === (E4 = this["backoff"]) || void 0x0 === E4 || E4["setJitter"](E3), this);
                }
                ["reconnectionDelayMax"](E3) {
                    var E4;
                    return void 0x0 === E3 ? this["_reconnectionDelayMax"] : ((this["_reconnectionDelayMax"] = E3), null === (E4 = this["backoff"]) || void 0x0 === E4 || E4["setMax"](E3), this);
                }
                ["timeout"](E3) {
                    return arguments["length"] ? ((this["_timeout"] = E3), this) : this["_timeout"];
                }
                ["maybeReconnectOnOpen"]() {
                    !this["_reconnecting"] && this["_reconnection"] && 0x0 === this["backoff"]["attempts"] && this["reconnect"]();
                }
                ["open"](E3) {
                    if (~this["_readyState"]["indexOf"]("open")) return this;
                    this["engine"] = new rw(this["uri"], this["opts"]);
                    const E4 = this["engine"],
                        E5 = this;
                    (this["_readyState"] = "opening"), (this["skipReconnect"] = !0x1);
                    const E6 = rG(E4, "open", function () {
                            E5["onopen"](), E3 && E3();
                        }),
                        E7 = rG(E4, "error", (E8) => {
                            E5["cleanup"](), (E5["_readyState"] = "closed"), this["emitReserved"]("error", E8), E3 ? E3(E8) : E5["maybeReconnectOnOpen"]();
                        });
                    if (!0x1 !== this["_timeout"]) {
                        const E8 = this["_timeout"];
                        0x0 === E8 && E6();
                        const E9 = this["setTimeoutFn"](() => {
                            E6(), E4["close"](), E4["emit"]("error", new Error("timeout"));
                        }, E8);
                        this["opts"]["autoUnref"] && E9["unref"](),
                            this["subs"]["push"](function () {
                                clearTimeout(E9);
                            });
                    }
                    return this["subs"]["push"](E6), this["subs"]["push"](E7), this;
                }
                ["connect"](E3) {
                    return this["open"](E3);
                }
                ["onopen"]() {
                    this["cleanup"](), (this["_readyState"] = "open"), this["emitReserved"]("open");
                    const E3 = this["engine"];
                    this["subs"]["push"](
                        rG(E3, "ping", this["onping"]["bind"](this)),
                        rG(E3, "data", this["ondata"]["bind"](this)),
                        rG(E3, "error", this["onerror"]["bind"](this)),
                        rG(E3, "close", this["onclose"]["bind"](this)),
                        rG(this["decoder"], "decoded", this["ondecoded"]["bind"](this))
                    );
                }
                ["onping"]() {
                    this["emitReserved"]("ping");
                }
                ["ondata"](E3) {
                    this["decoder"]["add"](E3);
                }
                ["ondecoded"](E3) {
                    this["emitReserved"]("packet", E3);
                }
                ["onerror"](E3) {
                    this["emitReserved"]("error", E3);
                }
                ["socket"](E3, E4) {
                    let E5 = this["nsps"][E3];
                    return E5 || ((E5 = new rQ(this, E3, E4)), (this["nsps"][E3] = E5)), E5;
                }
                ["_destroy"](E3) {
                    const E4 = Object["keys"](this["nsps"]);
                    for (const E5 of E4) {
                        if (this["nsps"][E5]["active"]) return;
                    }
                    this["_close"]();
                }
                ["_packet"](E3) {
                    const E4 = this["encoder"]["encode"](E3);
                    for (let E5 = 0x0; E5 < E4["length"]; E5++) this["engine"]["write"](E4[E5], E3["options"]);
                }
                ["cleanup"]() {
                    this["subs"]["forEach"]((E3) => E3()), (this["subs"]["length"] = 0x0), this["decoder"]["destroy"]();
                }
                ["_close"]() {
                    (this["skipReconnect"] = !0x0), (this["_reconnecting"] = !0x1), this["onclose"]("forced\x20close"), this["engine"] && this["engine"]["close"]();
                }
                ["disconnect"]() {
                    return this["_close"]();
                }
                ["onclose"](E3) {
                    this["cleanup"](), this["backoff"]["reset"](), (this["_readyState"] = "closed"), this["emitReserved"]("close", E3), this["_reconnection"] && !this["skipReconnect"] && this["reconnect"]();
                }
                ["reconnect"]() {
                    if (this["_reconnecting"] || this["skipReconnect"]) return this;
                    const E3 = this;
                    if (this["backoff"]["attempts"] >= this["_reconnectionAttempts"]) this["backoff"]["reset"](), this["emitReserved"]("reconnect_failed"), (this["_reconnecting"] = !0x1);
                    else {
                        const E4 = this["backoff"]["duration"]();
                        this["_reconnecting"] = !0x0;
                        const E5 = this["setTimeoutFn"](() => {
                            E3["skipReconnect"] ||
                                (this["emitReserved"]("reconnect_attempt", E3["backoff"]["attempts"]),
                                E3["skipReconnect"] ||
                                    E3["open"]((E6) => {
                                        E6 ? ((E3["_reconnecting"] = !0x1), E3["reconnect"](), this["emitReserved"]("reconnect_error", E6)) : E3["onreconnect"]();
                                    }));
                        }, E4);
                        this["opts"]["autoUnref"] && E5["unref"](),
                            this["subs"]["push"](function () {
                                clearTimeout(E5);
                            });
                    }
                }
                ["onreconnect"]() {
                    const E3 = this["backoff"]["attempts"];
                    (this["_reconnecting"] = !0x1), this["backoff"]["reset"](), this["emitReserved"]("reconnect", E3);
                }
            }
            const E1 = {};
            function E2(E3, E4) {
                "object" == typeof E3 && ((E4 = E3), (E3 = void 0x0));
                const E5 = (function (EE, ER = "", ET) {
                        let EC = EE;
                        (ET = ET || ("undefined" != typeof location && location)),
                            null == EE && (EE = ET["protocol"] + "//" + ET["host"]),
                            "string" == typeof EE &&
                                ("/" === EE["charAt"](0x0) && (EE = "/" === EE["charAt"](0x1) ? ET["protocol"] + EE : ET["host"] + EE),
                                /^(https?|wss?):\/\//["test"](EE) || (EE = void 0x0 !== ET ? ET["protocol"] + "//" + EE : "https://" + EE),
                                (EC = r4(EE))),
                            EC["port"] || (/^(http|ws)$/["test"](EC["protocol"]) ? (EC["port"] = "80") : /^(http|ws)s$/["test"](EC["protocol"]) && (EC["port"] = "443")),
                            (EC["path"] = EC["path"] || "/");
                        const Ed = -0x1 !== EC["host"]["indexOf"](":") ? "[" + EC["host"] + "]" : EC["host"];
                        return (EC["id"] = EC["protocol"] + "://" + Ed + ":" + EC["port"] + ER), (EC["href"] = EC["protocol"] + "://" + Ed + (ET && ET["port"] === EC["port"] ? "" : ":" + EC["port"])), EC;
                    })(E3, (E4 = E4 || {})["path"] || "/socket.io"),
                    E6 = E5["source"],
                    E7 = E5["id"],
                    E8 = E5["path"],
                    E9 = E1[E7] && E8 in E1[E7]["nsps"];
                let Er;
                return (
                    E4["forceNew"] || E4["force\x20new\x20connection"] || !0x1 === E4["multiplex"] || E9 ? (Er = new E0(E6, E4)) : (E1[E7] || (E1[E7] = new E0(E6, E4)), (Er = E1[E7])),
                    E5["query"] && !E4["query"] && (E4["query"] = E5["queryKey"]),
                    Er["socket"](E5["path"], E4)
                );
            }
            Object["assign"](E2, { Manager: E0, Socket: rQ, io: E2, connect: E2 });
        },
    },
]);
